# 测试体系

## 本章概览

在这一章中，我们将了解：

- NeoKV 的两层测试体系：C++ 单元测试 + Go 集成测试
- C++ 单元测试：GTest 框架、测试内容、运行方式
- Go 集成测试：测试基础设施、Standalone 服务器管理、测试模式
- 如何为新功能添加测试

**关键文件**：
- `test/` — C++ 单元测试（GTest）
- `tests/gocase/` — Go 集成测试
- `tests/gocase/util/` — 测试基础设施（server.go、tcp_client.go 等）

## 1. 两层测试体系

```
┌─────────────────────────────────────────────────────┐
│  C++ 单元测试 (GTest)                                │
│                                                      │
│  测试对象：编码/解码、Slot 计算、Protobuf 消息、      │
│           Raft 集成（单进程）                         │
│  运行方式：编译后直接执行二进制                        │
│  速度：快（秒级）                                    │
│  依赖：无外部依赖                                    │
├─────────────────────────────────────────────────────┤
│  Go 集成测试 (go-redis)                              │
│                                                      │
│  测试对象：完整的 Redis 命令行为                      │
│  运行方式：启动 neo_redis_standalone，通过 Redis      │
│           客户端发送命令并验证结果                     │
│  速度：中等（每个 suite 数秒）                        │
│  依赖：Go 1.24、neo_redis_standalone 二进制           │
└─────────────────────────────────────────────────────┘
```

## 2. C++ 单元测试

### 2.1 测试文件

| 测试 | 文件 | 测试内容 |
|------|------|---------|
| `test_redis_slot` | `test/test_redis_slot.cpp` | CRC16 计算、Hash Tag 提取、Slot 映射 |
| `test_redis_codec` | `test/test_redis_codec.cpp` | Key/Value 编解码、TTL 过期、前缀构建 |
| `test_redis_raft` | `test/test_redis_raft.cpp` | Protobuf 消息、RedisCmd 枚举、路由 Pattern、Key 编码边界情况（约 610 行） |
| `test_redis_read_index` | `test/test_redis_read_index.cpp` | 完整集成：启动 RocksDB + Raft + Redis，测试 SET/GET 通过 Raft，Follower ReadIndex（约 495 行） |

### 2.2 构建与运行

```bash
# 构建（需要 -DWITH_TESTS=ON）
mkdir -p build && cd build
cmake -DWITH_TESTS=ON ..
make -j$(nproc)

# 运行所有测试
make test

# 运行单个测试
./output/bin/test_redis_slot
./output/bin/test_redis_codec
./output/bin/test_redis_raft
./output/bin/test_redis_read_index
```

### 2.3 测试示例

```cpp
// test/test_redis_slot.cpp — Slot 计算测试
TEST(RedisSlotTest, BasicSlot) {
    // 验证与 Redis 官方实现一致
    EXPECT_EQ(redis_slot("foo"), 12182);
    EXPECT_EQ(redis_slot("bar"), 5061);
}

TEST(RedisSlotTest, HashTag) {
    // {user} 是 hash tag，只用 "user" 计算 slot
    EXPECT_EQ(redis_slot("{user}:name"), redis_slot("{user}:age"));
    // 空 hash tag 不生效
    EXPECT_NE(redis_slot("{}:name"), redis_slot("{}:age"));
}
```

## 3. Go 集成测试

Go 集成测试是 NeoKV 的主要测试手段，覆盖了所有 98 个 Redis 命令的行为验证。

### 3.1 测试基础设施

```
tests/gocase/
├── util/
│   ├── server.go       # NeoKVServer：启动/停止 standalone 服务器
│   ├── tcp_client.go   # 原始 RESP 协议客户端
│   ├── assertions.go   # 自定义断言（BetweenValues 等）
│   ├── flags.go        # 命令行参数（-binPath, -workspace）
│   └── random.go       # 随机数据生成
└── unit/
    ├── ping/           # PING 测试
    ├── key/            # EXISTS/TYPE/UNLINK/DEL 测试
    ├── expire/         # EXPIRE/TTL 相关测试
    └── type/
        ├── strings/    # String 命令测试（含数值操作）
        ├── hash/       # Hash 命令测试
        ├── set/        # Set 命令测试
        ├── list/       # List 命令测试
        └── zset/       # ZSet 命令测试
```

### 3.2 server.go：服务器管理

`NeoKVServer` 封装了 `neo_redis_standalone` 的启动和停止：

```go
// tests/gocase/util/server.go
type NeoKVServer struct {
    cmd     *exec.Cmd
    host    string
    port    int
    binPath string
    dataDir string
}

func StartServer(t testing.TB, binPath, workspace string) *NeoKVServer {
    // 1. 选择空闲端口
    port := findFreePort()

    // 2. 创建数据目录
    dataDir := filepath.Join(workspace, fmt.Sprintf("neokv_%d", port))

    // 3. 启动进程
    cmd := exec.Command(binPath,
        "--redis_port", strconv.Itoa(port),
        "--data_dir", dataDir)
    stdout, _ := cmd.StdoutPipe()
    cmd.Start()

    // 4. 等待 "NEOKV_READY" 标记
    scanner := bufio.NewScanner(stdout)
    for scanner.Scan() {
        if strings.Contains(scanner.Text(), "NEOKV_READY") {
            break
        }
    }

    // 5. 用 PING 验证服务可用
    client := redis.NewClient(&redis.Options{Addr: fmt.Sprintf(":%d", port)})
    require.NoError(t, client.Ping(ctx).Err())

    return &NeoKVServer{cmd: cmd, host: "127.0.0.1", port: port}
}

func (s *NeoKVServer) Close(t testing.TB) {
    s.cmd.Process.Signal(syscall.SIGTERM)
    s.cmd.Wait()
}
```

每个测试 suite 启动一个独立的 `neo_redis_standalone` 实例，测试完成后关闭。这保证了测试之间的隔离性。

### 3.3 测试模式

Go 测试使用 `go-redis/v9` 客户端库，测试模式非常直观：

```go
// tests/gocase/unit/type/hash/hash_test.go
func TestHash(t *testing.T) {
    srv := util.StartServer(t, flagBinPath, flagWorkspace)
    defer srv.Close(t)

    client := srv.NewClient()
    defer client.Close()
    ctx := context.Background()

    t.Run("HSET and HGET", func(t *testing.T) {
        // 设置
        n, err := client.HSet(ctx, "myhash", "field1", "value1").Result()
        require.NoError(t, err)
        require.Equal(t, int64(1), n)  // 新增 1 个 field

        // 读取
        val, err := client.HGet(ctx, "myhash", "field1").Result()
        require.NoError(t, err)
        require.Equal(t, "value1", val)

        // 不存在的 field
        _, err = client.HGet(ctx, "myhash", "nonexist").Result()
        require.Equal(t, redis.Nil, err)
    })

    t.Run("HGETALL", func(t *testing.T) {
        client.HSet(ctx, "myhash2", "a", "1", "b", "2", "c", "3")

        result, err := client.HGetAll(ctx, "myhash2").Result()
        require.NoError(t, err)
        require.Equal(t, map[string]string{"a": "1", "b": "2", "c": "3"}, result)
    })
}
```

### 3.4 tcp_client.go：协议级测试

对于需要测试原始 RESP 协议行为的场景，`TcpClient` 提供了低级别的接口：

```go
// tests/gocase/util/tcp_client.go
type TcpClient struct {
    conn   net.Conn
    reader *bufio.Reader
}

func (c *TcpClient) WriteArgs(args ...string) error {
    // 编码为 RESP 格式并发送
    buf := fmt.Sprintf("*%d\r\n", len(args))
    for _, arg := range args {
        buf += fmt.Sprintf("$%d\r\n%s\r\n", len(arg), arg)
    }
    _, err := c.conn.Write([]byte(buf))
    return err
}

func (c *TcpClient) ReadLine() (string, error) {
    return c.reader.ReadString('\n')
}
```

### 3.5 运行测试

```bash
cd tests/gocase && mkdir -p workspace

# 运行所有测试
go test -count=1 ./unit/... \
  -args \
  -binPath=/home/ubuntu/NeoKV/output/bin/neo_redis_standalone \
  -workspace=/home/ubuntu/NeoKV/tests/gocase/workspace

# 运行单个 suite（带详细输出）
go test -count=1 -v ./unit/type/hash/... \
  -args \
  -binPath=/home/ubuntu/NeoKV/output/bin/neo_redis_standalone \
  -workspace=/home/ubuntu/NeoKV/tests/gocase/workspace

# 如果 go 不在 PATH 中
/home/ubuntu/go/pkg/mod/golang.org/toolchain@v0.0.1-go1.24.13.linux-amd64/bin/go \
  test -count=1 ./unit/... -args -binPath=... -workspace=...
```

## 4. 如何添加测试

### 4.1 添加 C++ 单元测试

1. 在 `test/` 目录创建 `test_xxx.cpp`
2. 使用 GTest 框架编写测试
3. 在 `CMakeLists.txt` 中注册测试目标

### 4.2 添加 Go 集成测试

1. 在 `tests/gocase/unit/` 下创建目录和 `xxx_test.go`
2. 使用 `util.StartServer()` 启动服务器
3. 使用 `go-redis` 客户端发送命令并验证

示例：为新命令 SCAN 添加测试：

```go
// tests/gocase/unit/scan/scan_test.go
package scan

import (
    "context"
    "testing"
    "github.com/redis/go-redis/v9"
    "github.com/stretchr/testify/require"
    "tests/gocase/util"
)

var (
    flagBinPath  = util.BinPath()
    flagWorkspace = util.Workspace()
)

func TestScan(t *testing.T) {
    srv := util.StartServer(t, flagBinPath, flagWorkspace)
    defer srv.Close(t)

    client := srv.NewClient()
    defer client.Close()
    ctx := context.Background()

    t.Run("basic scan", func(t *testing.T) {
        // 准备数据
        for i := 0; i < 100; i++ {
            client.Set(ctx, fmt.Sprintf("key:%d", i), "value", 0)
        }

        // 扫描
        var allKeys []string
        var cursor uint64
        for {
            keys, nextCursor, err := client.Scan(ctx, cursor, "*", 10).Result()
            require.NoError(t, err)
            allKeys = append(allKeys, keys...)
            cursor = nextCursor
            if cursor == 0 { break }
        }

        require.Equal(t, 100, len(allKeys))
    })
}
```

## 5. 测试覆盖

| 测试 Suite | 覆盖命令 |
|-----------|---------|
| `ping` | PING |
| `key` | EXISTS, TYPE, UNLINK, DEL |
| `expire` | EXPIRE, PEXPIRE, EXPIREAT, PEXPIREAT, TTL, PTTL, PERSIST |
| `strings` | SET, GET, MSET, MGET, SETNX, SETEX, PSETEX, GETSET, GETDEL, GETEX, APPEND, GETRANGE, SETRANGE, STRLEN |
| `string_numeric` | INCR, DECR, INCRBY, DECRBY, INCRBYFLOAT |
| `hash` | 全部 15 个 Hash 命令 |
| `set` | 全部 17 个 Set 命令 |
| `list` | 全部 14 个 List 命令 |
| `zset` | 全部 17 个 ZSet 命令 |

## 检验你的理解

- 为什么 Go 集成测试每个 suite 启动独立的 `neo_redis_standalone` 实例？共享一个实例有什么风险？
- `neo_redis_standalone` 使用单副本 Raft。这意味着测试覆盖不到哪些场景？
- 如果你要测试 MOVED 重定向行为，需要什么样的测试环境？Go 集成测试能覆盖吗？
- `fill_cache = false` 在 TTL Cleaner 中使用。如果要测试这个行为，应该怎么设计测试用例？

---

> 文档到此结束。如果你按照推荐的学习路线阅读到这里，你已经对 NeoKV 的完整架构有了深入的理解。
>
> 附录：[命令参考](../appendix-命令参考.md) — 98 个已实现命令的完整列表。
