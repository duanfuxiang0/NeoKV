# 路由与集群

## 本章概览

在这一章中，我们将了解：

- CRC16 Slot 计算：Redis Cluster 的哈希槽算法
- Hash Tag：`{tag}` 语法如何让多个 key 落在同一个 slot
- SlotTable：O(1) 的 slot 到 Region 映射
- RedisKeyPattern：每个命令的 key 位置定义
- CROSSSLOT 校验：多 key 命令的 slot 一致性检查
- MOVED 重定向：兼容 Redis Cluster 客户端
- CLUSTER 命令：SLOTS/NODES/INFO/KEYSLOT/MYID

**关键文件**：
- `include/redis/redis_router.h` — RedisRouter 单例、SlotTable、RedisKeyPattern
- `src/redis/redis_router.cpp` — 路由实现（约 500 行）
- `include/redis/redis_service.h` — `redis_crc16()`、`redis_slot()`

## 1. Slot 计算

NeoKV 兼容 Redis Cluster 的 16384 slot 哈希方案。每个 key 通过 CRC16 算法映射到一个 slot：

```cpp
// include/redis/redis_service.h
uint16_t redis_slot(const std::string& key) {
    const std::string tag = extract_hash_tag(key);
    return redis_crc16(tag) & 0x3FFF;  // mod 16384
}
```

### 1.1 CRC16 算法

NeoKV 使用与 Redis 完全相同的 CRC16-CCITT 实现，保证 slot 计算结果一致：

```cpp
uint16_t redis_crc16(const std::string& key) {
    uint16_t crc = 0;
    for (char c : key) {
        crc = (crc << 8) ^ crc16_table[(crc >> 8) ^ (uint8_t)c];
    }
    return crc;
}
```

### 1.2 Hash Tag

Hash Tag 是 Redis Cluster 的一个重要特性——通过 `{tag}` 语法让多个 key 映射到同一个 slot：

```
redis> CLUSTER KEYSLOT {user}:name    → 5474
redis> CLUSTER KEYSLOT {user}:age     → 5474
redis> CLUSTER KEYSLOT {user}:email   → 5474
```

提取规则：如果 key 中包含 `{...}`（第一个 `{` 和第一个 `}`），则只用花括号内的部分计算 slot：

```cpp
std::string extract_hash_tag(const std::string& key) {
    auto start = key.find('{');
    if (start == std::string::npos) return key;

    auto end = key.find('}', start + 1);
    if (end == std::string::npos || end == start + 1) return key;  // 空 tag

    return key.substr(start + 1, end - start - 1);
}
```

Hash Tag 让 MSET/MGET/DEL 等多 key 命令可以正常工作——只要所有 key 使用相同的 hash tag，它们就在同一个 slot。

## 2. SlotTable

`SlotTable` 是一个 16384 项的数组，提供 O(1) 的 slot 到 Region 映射：

```cpp
// include/redis/redis_router.h
struct SlotEntry {
    SmartRegion region;     // 负责该 slot 的 Region
    int64_t region_id;      // Region ID
};

struct SlotTable {
    std::array<SlotEntry, 16384> slots;
};
```

### 2.1 查找

```cpp
SmartRegion RedisRouter::find_region_by_slot(uint16_t slot) {
    auto table = _slot_table.load();  // 原子读取当前 SlotTable
    if (table && table->slots[slot].region) {
        return table->slots[slot].region;
    }

    // 快速路径未命中，走慢路径：线性扫描所有 Region
    return find_region_by_slot_slow(slot);
}
```

快速路径是数组下标访问，O(1)。慢路径在 SlotTable 未就绪或 Region 变更时触发，会自动重建 SlotTable。

### 2.2 重建

SlotTable 在以下时机重建：

```cpp
void RedisRouter::rebuild_slot_table() {
    auto new_table = std::make_shared<SlotTable>();

    // 遍历所有 Region，填充 slot 映射
    Store::get_instance()->traverse_regions([&](SmartRegion region) {
        auto region_info = region->get_region_info();
        uint16_t start_slot = decode_start_slot(region_info.start_key());
        uint16_t end_slot = decode_end_slot(region_info.end_key());

        for (uint16_t s = start_slot; s <= end_slot; s++) {
            new_table->slots[s] = {region, region->get_region_id()};
        }
    });

    // 原子替换
    _slot_table.store(new_table);
}
```

触发时机：
- Store 启动加载 Region 后
- `Store::set_region()` / `Store::erase_region()` 时（Region 新增/删除/Split）
- 慢路径查找未命中时（自动重建）

SlotTable 是不可变的——每次重建都创建新的 table，然后原子替换指针。这避免了读写锁。

## 3. RedisKeyPattern

不同的 Redis 命令，key 参数的位置不同。NeoKV 通过 `RedisKeyPattern` 表定义每个命令的 key 位置：

```cpp
// src/redis/redis_router.cpp
struct RedisKeyPattern {
    int first_key_index;  // 第一个 key 参数的位置（从 1 开始）
    int last_key_index;   // 最后一个 key 参数的位置（-1 表示倒数第一个）
    int key_step;         // key 之间的步长
};

static const std::map<std::string, RedisKeyPattern> kKeyPatterns = {
    // 单 key 命令
    {"get",        {1, 1, 1}},   // GET key
    {"set",        {1, 1, 1}},   // SET key value ...
    {"hset",       {1, 1, 1}},   // HSET key field value ...
    {"zadd",       {1, 1, 1}},   // ZADD key score member ...

    // 多 key 命令
    {"mget",       {1, -1, 1}},  // MGET key1 key2 key3 ...
    {"mset",       {1, -1, 2}},  // MSET key1 val1 key2 val2 ... (步长 2)
    {"del",        {1, -1, 1}},  // DEL key1 key2 key3 ...

    // 集合运算
    {"sinter",     {1, -1, 1}},  // SINTER key1 key2 ...
    {"sunionstore",{1, -1, 1}},  // SUNIONSTORE dest key1 key2 ...

    // 无 key 命令
    {"ping",       {0, 0, 0}},
    {"echo",       {0, 0, 0}},
    {"cluster",    {0, 0, 0}},
    {"flushdb",    {0, 0, 0}},
};
```

### 3.1 Key 提取

根据 pattern 从命令参数中提取所有 key：

```cpp
std::vector<std::string> extract_keys(const std::string& cmd,
                                       const std::vector<std::string>& args) {
    auto it = kKeyPatterns.find(cmd);
    if (it == kKeyPatterns.end() || it->second.first_key_index == 0) {
        return {};  // 无 key 命令
    }

    auto& pattern = it->second;
    int last = pattern.last_key_index;
    if (last < 0) last = args.size() + last;  // -1 → 最后一个参数

    std::vector<std::string> keys;
    for (int i = pattern.first_key_index; i <= last; i += pattern.key_step) {
        keys.push_back(args[i]);
    }
    return keys;
}
```

## 4. CROSSSLOT 校验

多 key 命令要求所有 key 在同一个 slot。如果不满足，返回 CROSSSLOT 错误：

```
redis> MSET name Alice age 30
(error) CROSSSLOT Keys in request don't hash to the same slot

redis> MSET {u}:name Alice {u}:age 30
OK
```

校验逻辑在 `check_route()` 中：

```cpp
RedisRouteResult check_route(const std::vector<std::string>& keys) {
    if (keys.empty()) return {nullptr, OK};

    uint16_t slot = redis_slot(keys[0]);
    for (size_t i = 1; i < keys.size(); i++) {
        if (redis_slot(keys[i]) != slot) {
            return {nullptr, CROSSSLOT};
        }
    }
    return find_region_by_slot(slot);
}
```

## 5. MOVED 重定向

当请求到达非 Leader 节点时，NeoKV 返回 MOVED 重定向：

```
Client → Follower: SET key value
Follower → Client: -MOVED 5474 10.0.0.1:16379
Client → Leader:   SET key value
Leader → Client:   +OK
```

MOVED 响应格式：`-MOVED <slot> <leader_ip>:<leader_redis_port>`

```cpp
// 写命令：在 write_through_raft() 中检测
if (response.errcode() == pb::NOT_LEADER) {
    auto addr = region->get_leader_redis_addr();
    output->FormatError("MOVED %d %s", slot, addr.c_str());
}

// 读命令：在 check_read_consistency() 中检测
if (!region->is_leader() && !FLAGS_use_read_index) {
    auto addr = region->get_leader_redis_addr();
    output->FormatError("MOVED %d %s", slot, addr.c_str());
}
```

Leader 地址通过 `redis_advertise_ip` 和 `redis_advertise_port` 配置。如果未配置，自动检测本机 IP。

## 6. CLUSTER 命令

NeoKV 实现了 Redis Cluster 协议的核心子命令：

### 6.1 CLUSTER KEYSLOT

```
redis> CLUSTER KEYSLOT mykey
(integer) 14687
```

直接调用 `redis_slot()` 计算。

### 6.2 CLUSTER INFO

返回集群状态信息：

```
redis> CLUSTER INFO
cluster_enabled:1
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_known_nodes:3
cluster_size:1
```

### 6.3 CLUSTER SLOTS

返回 slot 范围与节点的映射关系：

```
redis> CLUSTER SLOTS
1) 1) (integer) 0
   2) (integer) 5460
   3) 1) "10.0.0.1"
      2) (integer) 16379
      3) "node-id-1"
2) 1) (integer) 5461
   2) (integer) 10922
   ...
```

遍历所有 Region，将连续的 slot 范围合并输出。

### 6.4 CLUSTER NODES

返回 Redis Cluster 格式的节点列表：

```
redis> CLUSTER NODES
node-id-1 10.0.0.1:16379@16380 myself,master - 0 0 1 connected 0-5460
node-id-2 10.0.0.2:16379@16380 master - 0 0 2 connected 5461-10922
```

### 6.5 CLUSTER MYID

返回当前节点的 ID。

## 7. 代码导读

| 文件 | 内容 |
|------|------|
| `include/redis/redis_router.h` | RedisRouter 单例、SlotTable 结构、RedisKeyPattern |
| `src/redis/redis_router.cpp` | CRC16、hash tag 提取、slot 查找、SlotTable 重建、CROSSSLOT 校验 |
| `include/redis/redis_service.h` | `redis_crc16()`、`redis_slot()` 公共函数 |
| `include/redis/redis_common.h` | `REDIS_SLOT_COUNT = 16384` |

## 检验你的理解

- Hash Tag `{tag}` 的设计目的是什么？如果没有 Hash Tag，MSET 命令在 NeoKV 中还能用吗？
- SlotTable 使用原子指针替换而非读写锁。这种设计在什么场景下比读写锁更好？有什么缺点？
- MOVED 重定向依赖于 Leader 地址的准确性。如果 Leader 刚刚切换，旧 Leader 返回的 MOVED 地址可能指向自己，会发生什么？
- `RedisKeyPattern` 中 MSET 的步长是 2（`{1, -1, 2}`），为什么？如果步长设错了会有什么后果？
- NeoKV 的 CLUSTER SLOTS 输出与 Redis Cluster 的格式兼容。这意味着什么？哪些 Redis 客户端可以直接连接 NeoKV？

---

> 下一章：[15-过期与 TTL](./15-过期与TTL.md) — 我们将了解 NeoKV 的三层过期机制。
