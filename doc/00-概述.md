# NeoKV 概述

## 项目定位

NeoKV 是一个基于 **Braft（Multi-Raft）+ RocksDB** 的分布式强一致 KV 存储，对外提供 **Redis 兼容协议（RESP）**。你可以直接用 `redis-cli` 或任何 Redis SDK 连接它。

这是一个面向**教学**的项目，核心目标是探索 **Multi-Raft 分布式架构**的工程实践。我们并非从零开始，代码参考了 BaikalDB, Apache Kvrocks, Pika

这让我们可以专注于两个核心问题：

1. **如何用 Multi-Raft 实现强一致的分布式存储？**
2. **如何在 KV(rocksdb) 基础上高效地实现 Redis 的丰富数据结构？**

> **注意**：NeoKV 是学习项目，不适用于生产环境。

## 2. 系统架构

### 2.1 进程模型

NeoKV 由两类进程组成：

```
┌────────────────────────────────────────────────┐
│             neoMeta (Cluster)                  │
│                                                │
│  ┌───────────┐ ┌───────────┐ ┌───────────┐     │
│  │ MetaNode1 │ │ MetaNode2 │ │ MetaNode3 │     │
│  └───────────┘ └───────────┘ └───────────┘     │
│ Raft HA / Region Scheduling / Schema / TSO     │
└───────────────────────┬────────────────────────┘
                        │ Heartbeat + Scheduling
        ┌───────────────┼───────────────┐
        ▼               ▼               ▼
┌──────────────┐ ┌──────────────┐ ┌──────────────┐
│   neoStore1  │ │   neoStore2  │ │   neoStore3  │
│              │ │              │ │              │
│ ┌──────────┐ │ │ ┌──────────┐ │ │ ┌──────────┐ │
│ │ Region 1 │ │ │ │ Region 1 │ │ │ │ Region 1 │ │
│ │ (Leader) │◄┼─┼─┤(Follower)│ │ │ │(Follower)│ │
│ ├──────────┤ │ │ ├──────────┤ │ │ ├──────────┤ │
│ │ Region 2 │ │ │ │ Region 2 │ │ │ │ Region 2 │ │
│ │(Follower)│ │ │ │ (Leader) │ │ │ │(Follower)│ │
│ └──────────┘ │ │ └──────────┘ │ │ └──────────┘ │
│   RocksDB    │ │   RocksDB    │ │   RocksDB    │
│  brpc + Redis│ │  brpc + Redis│ │  brpc + Redis│
└──────────────┘ └──────────────┘ └──────────────┘
```

| 进程 | 入口文件 | 职责 |
|------|---------|------|
| **neoMeta** | `src/meta_server/main.cpp` | 集群元数据管理：Region 分配与调度、Schema 管理、TSO 时间戳服务。自身通过 Raft 实现高可用 |
| **neoStore** | `src/store/main.cpp` | 数据服务节点：承载多个 Region（每个是一个独立的 Raft 组），对外暴露两个端口 |

每个 neoStore 节点有两个端口：

- **brpc 端口**（`--store_port`）：内部 Raft 通信和 Store 间 RPC
- **Redis 端口**（`--redis_port`，默认 16379）：运行 `brpc::RedisService`，对外提供 RESP 协议

此外，我们还提供了一个单进程测试模式：

- **neo_redis_standalone**（`src/redis/neo_redis_standalone.cpp`）：内嵌 RocksDB + 单副本 Raft Region，无需 MetaServer，用于本地开发和集成测试

### 2.2 核心概念

在深入之前，先了解几个贯穿全文的核心概念：

- **Region**：数据分片的基本单位。每个 Region 管理一段连续的 Redis Slot 范围（0-16383），是一个独立的 Raft 组。Region 可以自动分裂（Split）和合并（Merge）。

- **Slot**：Redis Cluster 的哈希槽。每个 Redis key 通过 CRC16 算法映射到 0-16383 中的一个 slot，slot 再映射到 Region。

- **Column Family（CF）**：RocksDB 中逻辑隔离的 KV 命名空间。NeoKV 使用 8 个 CF 分别存储 Raft 日志、数据、元信息等。

- **Raft 共识**：所有写操作必须经过 Raft 共识（多数节点确认）才能提交，保证强一致性。读操作可以直接读本地 RocksDB（Leader）或通过 ReadIndex 协议保证一致性（Follower）。

### 2.3 请求链路

一个 Redis 命令从客户端到最终执行，经历以下路径：

```
Redis Client (redis-cli / SDK)
    │  RESP 协议
    ▼
brpc::RedisService (neoStore 进程, port 16379)
    │  brpc 框架完成命令解析
    ▼
CommandHandler (GetCommandHandler / SetCommandHandler / ...)
    │
    ├── 读路径
    │   RedisRouter::route() → 定位 Region
    │       │
    │       ├─ Leader: 直接本地读 RocksDB
    │       ├─ Follower (ReadIndex): 向 Leader 确认 committed
    │       │   index，等待本地 apply 追上后读取
    │       └─ Follower (无 ReadIndex): 返回 MOVED 重定向
    │
    └── 写路径
        RedisRouter::route() → 定位 Region
            │
            ▼
        构建 RedisWriteRequest (protobuf)
            │
            ▼
        braft::Node::apply(task) ── Raft 共识（多数节点确认）
            │
            ▼
        Region::on_apply() → apply_redis_write()
            │
            ▼
        RocksDB WriteBatch (原子写入)
```

关键设计：**写入必须经过 Raft 共识**，这是 NeoKV 与 Kvrocks 等系统的本质区别。Kvrocks 直接写 RocksDB，通过异步主从复制保证可用性；NeoKV 的每一次写入都经过多数节点确认，保证强一致性。

### 2.4 与其他系统的对比

| 维度 | Redis Cluster | Kvrocks | Pika | NeoKV |
|------|--------------|---------|------|-------|
| 存储 | 内存 | RocksDB（单机） | RocksDB（单机） | RocksDB（分布式） |
| 复制 | 异步主从 | 异步 Binlog 复制 | 异步 Binlog 复制 | Raft 强一致 |
| 分片 | 16384 slot，手动迁移 | Centralized Cluster（兼容 Redis Cluster 协议） | Codis 集群 | Region 自动分裂/合并 |
| 一致性 | 最终一致 | 最终一致 | 最终一致 | 强一致（线性一致） |
| 定位 | 生产级缓存 | 生产级持久化 Redis | 生产级持久化 Redis | 教学项目 |

## 3. 已实现功能

### 3.1 Redis 命令（98 个）

| 类型 | 数量 | 命令 |
|------|------|------|
| String | 35 | GET, SET, DEL, MGET, MSET, TTL, PTTL, EXISTS, STRLEN, TYPE, SETNX, SETEX, PSETEX, EXPIRE, PEXPIRE, EXPIREAT, PEXPIREAT, PERSIST, UNLINK, FLUSHDB, FLUSHALL, PING, ECHO, CLUSTER, INCR, DECR, INCRBY, DECRBY, INCRBYFLOAT, APPEND, GETRANGE, SETRANGE, GETSET, GETDEL, GETEX |
| Hash | 15 | HSET, HGET, HDEL, HMSET, HMGET, HGETALL, HKEYS, HVALS, HLEN, HEXISTS, HSETNX, HINCRBY, HINCRBYFLOAT, HRANDFIELD, HSCAN |
| Set | 17 | SADD, SREM, SISMEMBER, SMEMBERS, SCARD, SPOP, SRANDMEMBER, SMISMEMBER, SSCAN, SINTER, SUNION, SDIFF, SINTERCARD, SMOVE, SINTERSTORE, SUNIONSTORE, SDIFFSTORE |
| List | 14 | LPUSH, RPUSH, LPOP, RPOP, LLEN, LINDEX, LRANGE, LPOS, LSET, LINSERT, LREM, LTRIM, LMOVE, LMPOP |
| ZSet | 17 | ZADD, ZREM, ZSCORE, ZRANK, ZREVRANK, ZCARD, ZCOUNT, ZRANGE, ZRANGEBYSCORE, ZREVRANGE, ZREVRANGEBYSCORE, ZINCRBY, ZRANGEBYLEX, ZLEXCOUNT, ZPOPMIN, ZPOPMAX, ZSCAN |

### 3.2 分布式特性

- Multi-Raft 共识，每个 Region 独立的 Raft 组
- Region 自动分裂与合并
- Follower ReadIndex 强一致读
- MOVED 重定向（兼容 Redis Cluster 协议）
- CLUSTER SLOTS / NODES / INFO / KEYSLOT / MYID
- 后台 TTL 清理

## 4. 项目结构

```
NeoKV/
├── src/
│   ├── common/           # 公共工具：Key 编码、Schema 缓存、RPC 客户端
│   ├── engine/           # 存储引擎：RocksWrapper、QoS、Compaction Filter
│   ├── meta_server/      # MetaServer：集群管理、Region 调度、TSO
│   ├── raft/             # Raft 定制层：自定义 Log/Meta Storage、Snapshot Adaptor
│   ├── raft_meta/        # MetaServer 的 Raft 回调实现
│   ├── raft_store/       # Store 的 Raft 回调实现
│   ├── redis/            # Redis 协议层（NeoKV 核心新增）
│   │   ├── redis_service.cpp       # 命令处理器（98 个命令的 Handler）
│   │   ├── redis_router.cpp        # Slot 路由（CRC16、CROSSSLOT、MOVED）
│   │   ├── redis_codec.cpp         # Phase 1 Key/Value 编码
│   │   ├── redis_metadata.cpp      # Phase 2 Metadata 编码（移植自 Kvrocks）
│   │   ├── region_redis.cpp        # Raft apply 逻辑（所有写命令的执行）
│   │   ├── redis_ttl_cleaner.cpp   # TTL 后台清理
│   │   └── neo_redis_standalone.cpp # 单进程测试模式入口
│   └── store/            # Store 节点：Region 管理、Raft 状态机
├── include/              # 头文件（与 src/ 镜像结构）
├── proto/                # Protobuf 定义（Raft 消息、Store RPC、Redis 命令）
├── test/                 # C++ 单元测试（GTest）
├── tests/gocase/         # Go 集成测试（基于 go-redis）
├── conf/                 # 配置文件
├── cmake/                # CMake 模块
└── doc/                  # 文档（你正在阅读的内容）
```

## 5. 构建与快速上手

### 5.1 构建

```bash
mkdir -p build && cd build
cmake -DWITH_TESTS=ON ..
make -j$(nproc)
```

构建产物在 `build/output/bin/` 目录下。

### 5.2 启动 Standalone 模式

```bash
./build/output/bin/neo_redis_standalone --redis_port=16379 --data_dir=/tmp/neokv_standalone
```

### 5.3 验证

```bash
redis-cli -p 16379 PING          # → PONG
redis-cli -p 16379 SET hello world
redis-cli -p 16379 GET hello     # → "world"
redis-cli -p 16379 HSET user:1 name "Alice" age 30
redis-cli -p 16379 HGETALL user:1
```

### 5.4 运行测试

```bash
# C++ 单元测试
cd build && make test

# Go 集成测试
cd tests/gocase && mkdir -p workspace
go test -count=1 ./unit/... \
  -args \
  -binPath=$(pwd)/../../build/output/bin/neo_redis_standalone \
  -workspace=$(pwd)/workspace
```

## 6. 学习路线

我们建议按以下顺序阅读文档：

### 路线一：完整学习（推荐）

1. **Part 1 — Multi-Raft 分布式架构**：从 Raft 共识算法开始，理解 braft 框架的使用与定制，深入 Region 状态机和集群管理。这是 NeoKV 的核心。
2. **Part 2 — 存储引擎**：理解 RocksDB 的关键特性，以及 NeoKV 如何组织 8 个 Column Family、设计 Key 编码、实现 Redis 数据结构的存储。
3. **Part 3 — Redis 数据结构**：逐一了解 String、Hash、Set、List、ZSet 五种数据类型在 RocksDB 上的编码与实现。
4. **Part 4 — Redis 协议层**：理解 RESP 协议接入、命令路由、TTL 过期机制。
5. **Part 5 — 测试与运维**：了解测试体系，学习如何验证和扩展功能。

### 路线二：专注分布式

00-概述 → 01-Raft 共识算法 → 02-braft 实践 → 03-Multi-Raft 与 Region → 04-MetaServer 与集群管理

### 路线三：专注存储

00-概述 → 05-RocksDB 基础 → 06-存储架构设计 → 07-Redis 存储编码 → Part 3 任意章节
