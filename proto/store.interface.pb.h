// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: store.interface.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_store_2einterface_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_store_2einterface_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "raft.pb.h"
#include "plan.pb.h"
#include "optype.pb.h"
#include "statistics.pb.h"
#include "meta.interface.pb.h"
#include "binlog.pb.h"
#include "column.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_store_2einterface_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_store_2einterface_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[39]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_store_2einterface_2eproto;
namespace baikaldb {
namespace pb {
class AnalyzeInfo;
struct AnalyzeInfoDefaultTypeInternal;
extern AnalyzeInfoDefaultTypeInternal _AnalyzeInfo_default_instance_;
class BackUpReq;
struct BackUpReqDefaultTypeInternal;
extern BackUpReqDefaultTypeInternal _BackUpReq_default_instance_;
class BackUpRes;
struct BackUpResDefaultTypeInternal;
extern BackUpResDefaultTypeInternal _BackUpRes_default_instance_;
class BackupRequest;
struct BackupRequestDefaultTypeInternal;
extern BackupRequestDefaultTypeInternal _BackupRequest_default_instance_;
class BackupResponse;
struct BackupResponseDefaultTypeInternal;
extern BackupResponseDefaultTypeInternal _BackupResponse_default_instance_;
class BatchRegionStoreReq;
struct BatchRegionStoreReqDefaultTypeInternal;
extern BatchRegionStoreReqDefaultTypeInternal _BatchRegionStoreReq_default_instance_;
class BatchRegionStoreRes;
struct BatchRegionStoreResDefaultTypeInternal;
extern BatchRegionStoreResDefaultTypeInternal _BatchRegionStoreRes_default_instance_;
class BatchStoreReq;
struct BatchStoreReqDefaultTypeInternal;
extern BatchStoreReqDefaultTypeInternal _BatchStoreReq_default_instance_;
class BatchStoreRes;
struct BatchStoreResDefaultTypeInternal;
extern BatchStoreResDefaultTypeInternal _BatchStoreRes_default_instance_;
class BinlogDesc;
struct BinlogDescDefaultTypeInternal;
extern BinlogDescDefaultTypeInternal _BinlogDesc_default_instance_;
class BinlogQueryInfo;
struct BinlogQueryInfoDefaultTypeInternal;
extern BinlogQueryInfoDefaultTypeInternal _BinlogQueryInfo_default_instance_;
class CachePlan;
struct CachePlanDefaultTypeInternal;
extern CachePlanDefaultTypeInternal _CachePlan_default_instance_;
class ColumnRegionInfo;
struct ColumnRegionInfoDefaultTypeInternal;
extern ColumnRegionInfoDefaultTypeInternal _ColumnRegionInfo_default_instance_;
class CompactionFileRequest;
struct CompactionFileRequestDefaultTypeInternal;
extern CompactionFileRequestDefaultTypeInternal _CompactionFileRequest_default_instance_;
class CompactionFileResponse;
struct CompactionFileResponseDefaultTypeInternal;
extern CompactionFileResponseDefaultTypeInternal _CompactionFileResponse_default_instance_;
class ExtraReq;
struct ExtraReqDefaultTypeInternal;
extern ExtraReqDefaultTypeInternal _ExtraReq_default_instance_;
class ExtraRes;
struct ExtraResDefaultTypeInternal;
extern ExtraResDefaultTypeInternal _ExtraRes_default_instance_;
class GetAppliedIndex;
struct GetAppliedIndexDefaultTypeInternal;
extern GetAppliedIndexDefaultTypeInternal _GetAppliedIndex_default_instance_;
class HealthCheck;
struct HealthCheckDefaultTypeInternal;
extern HealthCheckDefaultTypeInternal _HealthCheck_default_instance_;
class IndexRecords;
struct IndexRecordsDefaultTypeInternal;
extern IndexRecordsDefaultTypeInternal _IndexRecords_default_instance_;
class InitRegion;
struct InitRegionDefaultTypeInternal;
extern InitRegionDefaultTypeInternal _InitRegion_default_instance_;
class KvOp;
struct KvOpDefaultTypeInternal;
extern KvOpDefaultTypeInternal _KvOp_default_instance_;
class OlapRegionIndexInfo;
struct OlapRegionIndexInfoDefaultTypeInternal;
extern OlapRegionIndexInfoDefaultTypeInternal _OlapRegionIndexInfo_default_instance_;
class OlapRegionInfo;
struct OlapRegionInfoDefaultTypeInternal;
extern OlapRegionInfoDefaultTypeInternal _OlapRegionInfo_default_instance_;
class RedisKv;
struct RedisKvDefaultTypeInternal;
extern RedisKvDefaultTypeInternal _RedisKv_default_instance_;
class RedisWriteRequest;
struct RedisWriteRequestDefaultTypeInternal;
extern RedisWriteRequestDefaultTypeInternal _RedisWriteRequest_default_instance_;
class RegionIds;
struct RegionIdsDefaultTypeInternal;
extern RegionIdsDefaultTypeInternal _RegionIds_default_instance_;
class RegionIndexs;
struct RegionIndexsDefaultTypeInternal;
extern RegionIndexsDefaultTypeInternal _RegionIndexs_default_instance_;
class RegionLeader;
struct RegionLeaderDefaultTypeInternal;
extern RegionLeaderDefaultTypeInternal _RegionLeader_default_instance_;
class RegionOfflineBinlogInfo;
struct RegionOfflineBinlogInfoDefaultTypeInternal;
extern RegionOfflineBinlogInfoDefaultTypeInternal _RegionOfflineBinlogInfo_default_instance_;
class RegionRaftStat;
struct RegionRaftStatDefaultTypeInternal;
extern RegionRaftStatDefaultTypeInternal _RegionRaftStat_default_instance_;
class RemoveRegion;
struct RemoveRegionDefaultTypeInternal;
extern RemoveRegionDefaultTypeInternal _RemoveRegion_default_instance_;
class RocksStatisticReq;
struct RocksStatisticReqDefaultTypeInternal;
extern RocksStatisticReqDefaultTypeInternal _RocksStatisticReq_default_instance_;
class RocksStatisticRes;
struct RocksStatisticResDefaultTypeInternal;
extern RocksStatisticResDefaultTypeInternal _RocksStatisticRes_default_instance_;
class RowValue;
struct RowValueDefaultTypeInternal;
extern RowValueDefaultTypeInternal _RowValue_default_instance_;
class StoreReq;
struct StoreReqDefaultTypeInternal;
extern StoreReqDefaultTypeInternal _StoreReq_default_instance_;
class StoreRes;
struct StoreResDefaultTypeInternal;
extern StoreResDefaultTypeInternal _StoreRes_default_instance_;
class TransactionInfo;
struct TransactionInfoDefaultTypeInternal;
extern TransactionInfoDefaultTypeInternal _TransactionInfo_default_instance_;
class UseridCount;
struct UseridCountDefaultTypeInternal;
extern UseridCountDefaultTypeInternal _UseridCount_default_instance_;
}  // namespace pb
}  // namespace baikaldb
PROTOBUF_NAMESPACE_OPEN
template<> ::baikaldb::pb::AnalyzeInfo* Arena::CreateMaybeMessage<::baikaldb::pb::AnalyzeInfo>(Arena*);
template<> ::baikaldb::pb::BackUpReq* Arena::CreateMaybeMessage<::baikaldb::pb::BackUpReq>(Arena*);
template<> ::baikaldb::pb::BackUpRes* Arena::CreateMaybeMessage<::baikaldb::pb::BackUpRes>(Arena*);
template<> ::baikaldb::pb::BackupRequest* Arena::CreateMaybeMessage<::baikaldb::pb::BackupRequest>(Arena*);
template<> ::baikaldb::pb::BackupResponse* Arena::CreateMaybeMessage<::baikaldb::pb::BackupResponse>(Arena*);
template<> ::baikaldb::pb::BatchRegionStoreReq* Arena::CreateMaybeMessage<::baikaldb::pb::BatchRegionStoreReq>(Arena*);
template<> ::baikaldb::pb::BatchRegionStoreRes* Arena::CreateMaybeMessage<::baikaldb::pb::BatchRegionStoreRes>(Arena*);
template<> ::baikaldb::pb::BatchStoreReq* Arena::CreateMaybeMessage<::baikaldb::pb::BatchStoreReq>(Arena*);
template<> ::baikaldb::pb::BatchStoreRes* Arena::CreateMaybeMessage<::baikaldb::pb::BatchStoreRes>(Arena*);
template<> ::baikaldb::pb::BinlogDesc* Arena::CreateMaybeMessage<::baikaldb::pb::BinlogDesc>(Arena*);
template<> ::baikaldb::pb::BinlogQueryInfo* Arena::CreateMaybeMessage<::baikaldb::pb::BinlogQueryInfo>(Arena*);
template<> ::baikaldb::pb::CachePlan* Arena::CreateMaybeMessage<::baikaldb::pb::CachePlan>(Arena*);
template<> ::baikaldb::pb::ColumnRegionInfo* Arena::CreateMaybeMessage<::baikaldb::pb::ColumnRegionInfo>(Arena*);
template<> ::baikaldb::pb::CompactionFileRequest* Arena::CreateMaybeMessage<::baikaldb::pb::CompactionFileRequest>(Arena*);
template<> ::baikaldb::pb::CompactionFileResponse* Arena::CreateMaybeMessage<::baikaldb::pb::CompactionFileResponse>(Arena*);
template<> ::baikaldb::pb::ExtraReq* Arena::CreateMaybeMessage<::baikaldb::pb::ExtraReq>(Arena*);
template<> ::baikaldb::pb::ExtraRes* Arena::CreateMaybeMessage<::baikaldb::pb::ExtraRes>(Arena*);
template<> ::baikaldb::pb::GetAppliedIndex* Arena::CreateMaybeMessage<::baikaldb::pb::GetAppliedIndex>(Arena*);
template<> ::baikaldb::pb::HealthCheck* Arena::CreateMaybeMessage<::baikaldb::pb::HealthCheck>(Arena*);
template<> ::baikaldb::pb::IndexRecords* Arena::CreateMaybeMessage<::baikaldb::pb::IndexRecords>(Arena*);
template<> ::baikaldb::pb::InitRegion* Arena::CreateMaybeMessage<::baikaldb::pb::InitRegion>(Arena*);
template<> ::baikaldb::pb::KvOp* Arena::CreateMaybeMessage<::baikaldb::pb::KvOp>(Arena*);
template<> ::baikaldb::pb::OlapRegionIndexInfo* Arena::CreateMaybeMessage<::baikaldb::pb::OlapRegionIndexInfo>(Arena*);
template<> ::baikaldb::pb::OlapRegionInfo* Arena::CreateMaybeMessage<::baikaldb::pb::OlapRegionInfo>(Arena*);
template<> ::baikaldb::pb::RedisKv* Arena::CreateMaybeMessage<::baikaldb::pb::RedisKv>(Arena*);
template<> ::baikaldb::pb::RedisWriteRequest* Arena::CreateMaybeMessage<::baikaldb::pb::RedisWriteRequest>(Arena*);
template<> ::baikaldb::pb::RegionIds* Arena::CreateMaybeMessage<::baikaldb::pb::RegionIds>(Arena*);
template<> ::baikaldb::pb::RegionIndexs* Arena::CreateMaybeMessage<::baikaldb::pb::RegionIndexs>(Arena*);
template<> ::baikaldb::pb::RegionLeader* Arena::CreateMaybeMessage<::baikaldb::pb::RegionLeader>(Arena*);
template<> ::baikaldb::pb::RegionOfflineBinlogInfo* Arena::CreateMaybeMessage<::baikaldb::pb::RegionOfflineBinlogInfo>(Arena*);
template<> ::baikaldb::pb::RegionRaftStat* Arena::CreateMaybeMessage<::baikaldb::pb::RegionRaftStat>(Arena*);
template<> ::baikaldb::pb::RemoveRegion* Arena::CreateMaybeMessage<::baikaldb::pb::RemoveRegion>(Arena*);
template<> ::baikaldb::pb::RocksStatisticReq* Arena::CreateMaybeMessage<::baikaldb::pb::RocksStatisticReq>(Arena*);
template<> ::baikaldb::pb::RocksStatisticRes* Arena::CreateMaybeMessage<::baikaldb::pb::RocksStatisticRes>(Arena*);
template<> ::baikaldb::pb::RowValue* Arena::CreateMaybeMessage<::baikaldb::pb::RowValue>(Arena*);
template<> ::baikaldb::pb::StoreReq* Arena::CreateMaybeMessage<::baikaldb::pb::StoreReq>(Arena*);
template<> ::baikaldb::pb::StoreRes* Arena::CreateMaybeMessage<::baikaldb::pb::StoreRes>(Arena*);
template<> ::baikaldb::pb::TransactionInfo* Arena::CreateMaybeMessage<::baikaldb::pb::TransactionInfo>(Arena*);
template<> ::baikaldb::pb::UseridCount* Arena::CreateMaybeMessage<::baikaldb::pb::UseridCount>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace baikaldb {
namespace pb {

enum RedisCmd : int {
  REDIS_SET = 0,
  REDIS_DEL = 1,
  REDIS_EXPIRE = 2,
  REDIS_EXPIREAT = 3,
  REDIS_MSET = 4
};
bool RedisCmd_IsValid(int value);
constexpr RedisCmd RedisCmd_MIN = REDIS_SET;
constexpr RedisCmd RedisCmd_MAX = REDIS_MSET;
constexpr int RedisCmd_ARRAYSIZE = RedisCmd_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RedisCmd_descriptor();
template<typename T>
inline const std::string& RedisCmd_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RedisCmd>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RedisCmd_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RedisCmd_descriptor(), enum_t_value);
}
inline bool RedisCmd_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RedisCmd* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RedisCmd>(
    RedisCmd_descriptor(), name, value);
}
enum TxnState : int {
  TXN_UNKEOWN = 0,
  TXN_BEGINED = 1,
  TXN_PREPARED = 2,
  TXN_COMMITTED = 3,
  TXN_ROLLBACKED = 4
};
bool TxnState_IsValid(int value);
constexpr TxnState TxnState_MIN = TXN_UNKEOWN;
constexpr TxnState TxnState_MAX = TXN_ROLLBACKED;
constexpr int TxnState_ARRAYSIZE = TxnState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TxnState_descriptor();
template<typename T>
inline const std::string& TxnState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TxnState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TxnState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TxnState_descriptor(), enum_t_value);
}
inline bool TxnState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TxnState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TxnState>(
    TxnState_descriptor(), name, value);
}
enum StatisticType : int {
  ST_HISTOGRAM = 0,
  ST_CMSKETCH = 1,
  ST_HYPERLOGLOG = 2,
  ST_CLEAR = 3
};
bool StatisticType_IsValid(int value);
constexpr StatisticType StatisticType_MIN = ST_HISTOGRAM;
constexpr StatisticType StatisticType_MAX = ST_CLEAR;
constexpr int StatisticType_ARRAYSIZE = StatisticType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatisticType_descriptor();
template<typename T>
inline const std::string& StatisticType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatisticType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatisticType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatisticType_descriptor(), enum_t_value);
}
inline bool StatisticType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StatisticType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatisticType>(
    StatisticType_descriptor(), name, value);
}
enum ExecuteType : int {
  EXEC_ROW = 0,
  EXEC_ARROW_ACERO = 1,
  EXEC_ARROW_ACERO_PREFER_RETURN_ARROW_DATA = 2
};
bool ExecuteType_IsValid(int value);
constexpr ExecuteType ExecuteType_MIN = EXEC_ROW;
constexpr ExecuteType ExecuteType_MAX = EXEC_ARROW_ACERO_PREFER_RETURN_ARROW_DATA;
constexpr int ExecuteType_ARRAYSIZE = ExecuteType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExecuteType_descriptor();
template<typename T>
inline const std::string& ExecuteType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExecuteType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExecuteType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExecuteType_descriptor(), enum_t_value);
}
inline bool ExecuteType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExecuteType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExecuteType>(
    ExecuteType_descriptor(), name, value);
}
enum BackupOp : int {
  BACKUP_DOWNLOAD = 0,
  BACKUP_UPLOAD = 1,
  BACKUP_QUERY_PEERS = 2,
  BACKUP_QUERY_STREAMING = 3
};
bool BackupOp_IsValid(int value);
constexpr BackupOp BackupOp_MIN = BACKUP_DOWNLOAD;
constexpr BackupOp BackupOp_MAX = BACKUP_QUERY_STREAMING;
constexpr int BackupOp_ARRAYSIZE = BackupOp_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BackupOp_descriptor();
template<typename T>
inline const std::string& BackupOp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BackupOp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BackupOp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BackupOp_descriptor(), enum_t_value);
}
inline bool BackupOp_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BackupOp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BackupOp>(
    BackupOp_descriptor(), name, value);
}
enum OlapRegionStat : int {
  OLAP_ACTIVE = 0,
  OLAP_IMMUTABLE = 1,
  OLAP_FLUSHED = 2,
  OLAP_TRUNCATED = 3
};
bool OlapRegionStat_IsValid(int value);
constexpr OlapRegionStat OlapRegionStat_MIN = OLAP_ACTIVE;
constexpr OlapRegionStat OlapRegionStat_MAX = OLAP_TRUNCATED;
constexpr int OlapRegionStat_ARRAYSIZE = OlapRegionStat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OlapRegionStat_descriptor();
template<typename T>
inline const std::string& OlapRegionStat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OlapRegionStat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OlapRegionStat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OlapRegionStat_descriptor(), enum_t_value);
}
inline bool OlapRegionStat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OlapRegionStat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OlapRegionStat>(
    OlapRegionStat_descriptor(), name, value);
}
enum CompactionOpType : int {
  OP_READ = 1,
  OP_WRITE = 2,
  OP_DELETE_PATH = 3,
  OP_READ_DIR = 4,
  OP_PATH_EXISTS = 5,
  OP_CREATE_DIR = 6,
  OP_GET_FILE_INFO_LIST = 7
};
bool CompactionOpType_IsValid(int value);
constexpr CompactionOpType CompactionOpType_MIN = OP_READ;
constexpr CompactionOpType CompactionOpType_MAX = OP_GET_FILE_INFO_LIST;
constexpr int CompactionOpType_ARRAYSIZE = CompactionOpType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompactionOpType_descriptor();
template<typename T>
inline const std::string& CompactionOpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompactionOpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompactionOpType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompactionOpType_descriptor(), enum_t_value);
}
inline bool CompactionOpType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompactionOpType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompactionOpType>(
    CompactionOpType_descriptor(), name, value);
}
// ===================================================================

class KvOp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.KvOp) */ {
 public:
  inline KvOp() : KvOp(nullptr) {}
  ~KvOp() override;
  explicit constexpr KvOp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KvOp(const KvOp& from);
  KvOp(KvOp&& from) noexcept
    : KvOp() {
    *this = ::std::move(from);
  }

  inline KvOp& operator=(const KvOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline KvOp& operator=(KvOp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KvOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const KvOp* internal_default_instance() {
    return reinterpret_cast<const KvOp*>(
               &_KvOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(KvOp& a, KvOp& b) {
    a.Swap(&b);
  }
  inline void Swap(KvOp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KvOp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KvOp* New() const final {
    return new KvOp();
  }

  KvOp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KvOp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KvOp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KvOp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KvOp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.KvOp";
  }
  protected:
  explicit KvOp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kValueFieldNumber = 3,
    kOpTypeFieldNumber = 1,
    kIsPrimaryKeyFieldNumber = 5,
    kTtlTimestampUsFieldNumber = 4,
  };
  // optional bytes key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional bytes value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // required .baikaldb.pb.OpType op_type = 1;
  bool has_op_type() const;
  private:
  bool _internal_has_op_type() const;
  public:
  void clear_op_type();
  ::baikaldb::pb::OpType op_type() const;
  void set_op_type(::baikaldb::pb::OpType value);
  private:
  ::baikaldb::pb::OpType _internal_op_type() const;
  void _internal_set_op_type(::baikaldb::pb::OpType value);
  public:

  // optional bool is_primary_key = 5;
  bool has_is_primary_key() const;
  private:
  bool _internal_has_is_primary_key() const;
  public:
  void clear_is_primary_key();
  bool is_primary_key() const;
  void set_is_primary_key(bool value);
  private:
  bool _internal_is_primary_key() const;
  void _internal_set_is_primary_key(bool value);
  public:

  // optional int64 ttl_timestamp_us = 4;
  bool has_ttl_timestamp_us() const;
  private:
  bool _internal_has_ttl_timestamp_us() const;
  public:
  void clear_ttl_timestamp_us();
  ::PROTOBUF_NAMESPACE_ID::int64 ttl_timestamp_us() const;
  void set_ttl_timestamp_us(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ttl_timestamp_us() const;
  void _internal_set_ttl_timestamp_us(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.KvOp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  int op_type_;
  bool is_primary_key_;
  ::PROTOBUF_NAMESPACE_ID::int64 ttl_timestamp_us_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RedisKv final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RedisKv) */ {
 public:
  inline RedisKv() : RedisKv(nullptr) {}
  ~RedisKv() override;
  explicit constexpr RedisKv(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedisKv(const RedisKv& from);
  RedisKv(RedisKv&& from) noexcept
    : RedisKv() {
    *this = ::std::move(from);
  }

  inline RedisKv& operator=(const RedisKv& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedisKv& operator=(RedisKv&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedisKv& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedisKv* internal_default_instance() {
    return reinterpret_cast<const RedisKv*>(
               &_RedisKv_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RedisKv& a, RedisKv& b) {
    a.Swap(&b);
  }
  inline void Swap(RedisKv* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedisKv* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RedisKv* New() const final {
    return new RedisKv();
  }

  RedisKv* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RedisKv>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedisKv& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RedisKv& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedisKv* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RedisKv";
  }
  protected:
  explicit RedisKv(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kExpireMsFieldNumber = 3,
  };
  // optional bytes key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional bytes value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional int64 expire_ms = 3;
  bool has_expire_ms() const;
  private:
  bool _internal_has_expire_ms() const;
  public:
  void clear_expire_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 expire_ms() const;
  void set_expire_ms(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_expire_ms() const;
  void _internal_set_expire_ms(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RedisKv)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::int64 expire_ms_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RedisWriteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RedisWriteRequest) */ {
 public:
  inline RedisWriteRequest() : RedisWriteRequest(nullptr) {}
  ~RedisWriteRequest() override;
  explicit constexpr RedisWriteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RedisWriteRequest(const RedisWriteRequest& from);
  RedisWriteRequest(RedisWriteRequest&& from) noexcept
    : RedisWriteRequest() {
    *this = ::std::move(from);
  }

  inline RedisWriteRequest& operator=(const RedisWriteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedisWriteRequest& operator=(RedisWriteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RedisWriteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RedisWriteRequest* internal_default_instance() {
    return reinterpret_cast<const RedisWriteRequest*>(
               &_RedisWriteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RedisWriteRequest& a, RedisWriteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RedisWriteRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedisWriteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RedisWriteRequest* New() const final {
    return new RedisWriteRequest();
  }

  RedisWriteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RedisWriteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RedisWriteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RedisWriteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedisWriteRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RedisWriteRequest";
  }
  protected:
  explicit RedisWriteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvsFieldNumber = 2,
    kCmdFieldNumber = 1,
    kSlotFieldNumber = 3,
  };
  // repeated .baikaldb.pb.RedisKv kvs = 2;
  int kvs_size() const;
  private:
  int _internal_kvs_size() const;
  public:
  void clear_kvs();
  ::baikaldb::pb::RedisKv* mutable_kvs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RedisKv >*
      mutable_kvs();
  private:
  const ::baikaldb::pb::RedisKv& _internal_kvs(int index) const;
  ::baikaldb::pb::RedisKv* _internal_add_kvs();
  public:
  const ::baikaldb::pb::RedisKv& kvs(int index) const;
  ::baikaldb::pb::RedisKv* add_kvs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RedisKv >&
      kvs() const;

  // optional .baikaldb.pb.RedisCmd cmd = 1;
  bool has_cmd() const;
  private:
  bool _internal_has_cmd() const;
  public:
  void clear_cmd();
  ::baikaldb::pb::RedisCmd cmd() const;
  void set_cmd(::baikaldb::pb::RedisCmd value);
  private:
  ::baikaldb::pb::RedisCmd _internal_cmd() const;
  void _internal_set_cmd(::baikaldb::pb::RedisCmd value);
  public:

  // optional uint32 slot = 3;
  bool has_slot() const;
  private:
  bool _internal_has_slot() const;
  public:
  void clear_slot();
  ::PROTOBUF_NAMESPACE_ID::uint32 slot() const;
  void set_slot(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_slot() const;
  void _internal_set_slot(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RedisWriteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RedisKv > kvs_;
  int cmd_;
  ::PROTOBUF_NAMESPACE_ID::uint32 slot_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class CachePlan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.CachePlan) */ {
 public:
  inline CachePlan() : CachePlan(nullptr) {}
  ~CachePlan() override;
  explicit constexpr CachePlan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CachePlan(const CachePlan& from);
  CachePlan(CachePlan&& from) noexcept
    : CachePlan() {
    *this = ::std::move(from);
  }

  inline CachePlan& operator=(const CachePlan& from) {
    CopyFrom(from);
    return *this;
  }
  inline CachePlan& operator=(CachePlan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CachePlan& default_instance() {
    return *internal_default_instance();
  }
  static inline const CachePlan* internal_default_instance() {
    return reinterpret_cast<const CachePlan*>(
               &_CachePlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CachePlan& a, CachePlan& b) {
    a.Swap(&b);
  }
  inline void Swap(CachePlan* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CachePlan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CachePlan* New() const final {
    return new CachePlan();
  }

  CachePlan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CachePlan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CachePlan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CachePlan& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CachePlan* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.CachePlan";
  }
  protected:
  explicit CachePlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTuplesFieldNumber = 4,
    kRegionsFieldNumber = 5,
    kKvOpsFieldNumber = 6,
    kPlanFieldNumber = 3,
    kOpTypeFieldNumber = 1,
    kSeqIdFieldNumber = 2,
  };
  // repeated .baikaldb.pb.TupleDescriptor tuples = 4;
  int tuples_size() const;
  private:
  int _internal_tuples_size() const;
  public:
  void clear_tuples();
  ::baikaldb::pb::TupleDescriptor* mutable_tuples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TupleDescriptor >*
      mutable_tuples();
  private:
  const ::baikaldb::pb::TupleDescriptor& _internal_tuples(int index) const;
  ::baikaldb::pb::TupleDescriptor* _internal_add_tuples();
  public:
  const ::baikaldb::pb::TupleDescriptor& tuples(int index) const;
  ::baikaldb::pb::TupleDescriptor* add_tuples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TupleDescriptor >&
      tuples() const;

  // repeated .baikaldb.pb.RegionInfo regions = 5;
  int regions_size() const;
  private:
  int _internal_regions_size() const;
  public:
  void clear_regions();
  ::baikaldb::pb::RegionInfo* mutable_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >*
      mutable_regions();
  private:
  const ::baikaldb::pb::RegionInfo& _internal_regions(int index) const;
  ::baikaldb::pb::RegionInfo* _internal_add_regions();
  public:
  const ::baikaldb::pb::RegionInfo& regions(int index) const;
  ::baikaldb::pb::RegionInfo* add_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >&
      regions() const;

  // repeated .baikaldb.pb.KvOp kv_ops = 6;
  int kv_ops_size() const;
  private:
  int _internal_kv_ops_size() const;
  public:
  void clear_kv_ops();
  ::baikaldb::pb::KvOp* mutable_kv_ops(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::KvOp >*
      mutable_kv_ops();
  private:
  const ::baikaldb::pb::KvOp& _internal_kv_ops(int index) const;
  ::baikaldb::pb::KvOp* _internal_add_kv_ops();
  public:
  const ::baikaldb::pb::KvOp& kv_ops(int index) const;
  ::baikaldb::pb::KvOp* add_kv_ops();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::KvOp >&
      kv_ops() const;

  // required .baikaldb.pb.Plan plan = 3;
  bool has_plan() const;
  private:
  bool _internal_has_plan() const;
  public:
  void clear_plan();
  const ::baikaldb::pb::Plan& plan() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::Plan* release_plan();
  ::baikaldb::pb::Plan* mutable_plan();
  void set_allocated_plan(::baikaldb::pb::Plan* plan);
  private:
  const ::baikaldb::pb::Plan& _internal_plan() const;
  ::baikaldb::pb::Plan* _internal_mutable_plan();
  public:
  void unsafe_arena_set_allocated_plan(
      ::baikaldb::pb::Plan* plan);
  ::baikaldb::pb::Plan* unsafe_arena_release_plan();

  // required .baikaldb.pb.OpType op_type = 1;
  bool has_op_type() const;
  private:
  bool _internal_has_op_type() const;
  public:
  void clear_op_type();
  ::baikaldb::pb::OpType op_type() const;
  void set_op_type(::baikaldb::pb::OpType value);
  private:
  ::baikaldb::pb::OpType _internal_op_type() const;
  void _internal_set_op_type(::baikaldb::pb::OpType value);
  public:

  // required int32 seq_id = 2;
  bool has_seq_id() const;
  private:
  bool _internal_has_seq_id() const;
  public:
  void clear_seq_id();
  ::PROTOBUF_NAMESPACE_ID::int32 seq_id() const;
  void set_seq_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_seq_id() const;
  void _internal_set_seq_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.CachePlan)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TupleDescriptor > tuples_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo > regions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::KvOp > kv_ops_;
  ::baikaldb::pb::Plan* plan_;
  int op_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 seq_id_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class TransactionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TransactionInfo) */ {
 public:
  inline TransactionInfo() : TransactionInfo(nullptr) {}
  ~TransactionInfo() override;
  explicit constexpr TransactionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionInfo(const TransactionInfo& from);
  TransactionInfo(TransactionInfo&& from) noexcept
    : TransactionInfo() {
    *this = ::std::move(from);
  }

  inline TransactionInfo& operator=(const TransactionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionInfo& operator=(TransactionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionInfo* internal_default_instance() {
    return reinterpret_cast<const TransactionInfo*>(
               &_TransactionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TransactionInfo& a, TransactionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionInfo* New() const final {
    return new TransactionInfo();
  }

  TransactionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TransactionInfo";
  }
  protected:
  explicit TransactionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNeedRollbackSeqFieldNumber = 5,
    kCachePlansFieldNumber = 6,
    kTxnIdFieldNumber = 1,
    kSeqIdFieldNumber = 2,
    kStartSeqIdFieldNumber = 3,
    kNumRowsFieldNumber = 7,
    kPrimaryRegionIdFieldNumber = 9,
    kTxnStateFieldNumber = 10,
    kOptimize1PcFieldNumber = 4,
    kAutocommitFieldNumber = 8,
    kOpenBinlogFieldNumber = 14,
    kFromStoreFieldNumber = 15,
    kLiveTimeFieldNumber = 11,
    kStartTsFieldNumber = 12,
    kCommitTsFieldNumber = 13,
    kTxnTimeoutFieldNumber = 16,
    kNeedUpdatePrimaryTimestampFieldNumber = 17,
  };
  // repeated int32 need_rollback_seq = 5;
  int need_rollback_seq_size() const;
  private:
  int _internal_need_rollback_seq_size() const;
  public:
  void clear_need_rollback_seq();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_need_rollback_seq(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_need_rollback_seq() const;
  void _internal_add_need_rollback_seq(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_need_rollback_seq();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 need_rollback_seq(int index) const;
  void set_need_rollback_seq(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_need_rollback_seq(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      need_rollback_seq() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_need_rollback_seq();

  // repeated .baikaldb.pb.CachePlan cache_plans = 6;
  int cache_plans_size() const;
  private:
  int _internal_cache_plans_size() const;
  public:
  void clear_cache_plans();
  ::baikaldb::pb::CachePlan* mutable_cache_plans(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CachePlan >*
      mutable_cache_plans();
  private:
  const ::baikaldb::pb::CachePlan& _internal_cache_plans(int index) const;
  ::baikaldb::pb::CachePlan* _internal_add_cache_plans();
  public:
  const ::baikaldb::pb::CachePlan& cache_plans(int index) const;
  ::baikaldb::pb::CachePlan* add_cache_plans();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CachePlan >&
      cache_plans() const;

  // required uint64 txn_id = 1;
  bool has_txn_id() const;
  private:
  bool _internal_has_txn_id() const;
  public:
  void clear_txn_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 txn_id() const;
  void set_txn_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_txn_id() const;
  void _internal_set_txn_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required int32 seq_id = 2;
  bool has_seq_id() const;
  private:
  bool _internal_has_seq_id() const;
  public:
  void clear_seq_id();
  ::PROTOBUF_NAMESPACE_ID::int32 seq_id() const;
  void set_seq_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_seq_id() const;
  void _internal_set_seq_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 start_seq_id = 3;
  bool has_start_seq_id() const;
  private:
  bool _internal_has_start_seq_id() const;
  public:
  void clear_start_seq_id();
  ::PROTOBUF_NAMESPACE_ID::int32 start_seq_id() const;
  void set_start_seq_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start_seq_id() const;
  void _internal_set_start_seq_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int64 num_rows = 7;
  bool has_num_rows() const;
  private:
  bool _internal_has_num_rows() const;
  public:
  void clear_num_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 num_rows() const;
  void set_num_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_num_rows() const;
  void _internal_set_num_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 primary_region_id = 9;
  bool has_primary_region_id() const;
  private:
  bool _internal_has_primary_region_id() const;
  public:
  void clear_primary_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 primary_region_id() const;
  void set_primary_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_primary_region_id() const;
  void _internal_set_primary_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.TxnState txn_state = 10;
  bool has_txn_state() const;
  private:
  bool _internal_has_txn_state() const;
  public:
  void clear_txn_state();
  ::baikaldb::pb::TxnState txn_state() const;
  void set_txn_state(::baikaldb::pb::TxnState value);
  private:
  ::baikaldb::pb::TxnState _internal_txn_state() const;
  void _internal_set_txn_state(::baikaldb::pb::TxnState value);
  public:

  // optional bool optimize_1pc = 4;
  bool has_optimize_1pc() const;
  private:
  bool _internal_has_optimize_1pc() const;
  public:
  void clear_optimize_1pc();
  bool optimize_1pc() const;
  void set_optimize_1pc(bool value);
  private:
  bool _internal_optimize_1pc() const;
  void _internal_set_optimize_1pc(bool value);
  public:

  // optional bool autocommit = 8;
  bool has_autocommit() const;
  private:
  bool _internal_has_autocommit() const;
  public:
  void clear_autocommit();
  bool autocommit() const;
  void set_autocommit(bool value);
  private:
  bool _internal_autocommit() const;
  void _internal_set_autocommit(bool value);
  public:

  // optional bool open_binlog = 14;
  bool has_open_binlog() const;
  private:
  bool _internal_has_open_binlog() const;
  public:
  void clear_open_binlog();
  bool open_binlog() const;
  void set_open_binlog(bool value);
  private:
  bool _internal_open_binlog() const;
  void _internal_set_open_binlog(bool value);
  public:

  // optional bool from_store = 15;
  bool has_from_store() const;
  private:
  bool _internal_has_from_store() const;
  public:
  void clear_from_store();
  bool from_store() const;
  void set_from_store(bool value);
  private:
  bool _internal_from_store() const;
  void _internal_set_from_store(bool value);
  public:

  // optional int64 live_time = 11;
  bool has_live_time() const;
  private:
  bool _internal_has_live_time() const;
  public:
  void clear_live_time();
  ::PROTOBUF_NAMESPACE_ID::int64 live_time() const;
  void set_live_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_live_time() const;
  void _internal_set_live_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 start_ts = 12;
  bool has_start_ts() const;
  private:
  bool _internal_has_start_ts() const;
  public:
  void clear_start_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 start_ts() const;
  void set_start_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start_ts() const;
  void _internal_set_start_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 commit_ts = 13;
  bool has_commit_ts() const;
  private:
  bool _internal_has_commit_ts() const;
  public:
  void clear_commit_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 commit_ts() const;
  void set_commit_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_commit_ts() const;
  void _internal_set_commit_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 txn_timeout = 16;
  bool has_txn_timeout() const;
  private:
  bool _internal_has_txn_timeout() const;
  public:
  void clear_txn_timeout();
  ::PROTOBUF_NAMESPACE_ID::int64 txn_timeout() const;
  void set_txn_timeout(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_txn_timeout() const;
  void _internal_set_txn_timeout(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool need_update_primary_timestamp = 17;
  bool has_need_update_primary_timestamp() const;
  private:
  bool _internal_has_need_update_primary_timestamp() const;
  public:
  void clear_need_update_primary_timestamp();
  bool need_update_primary_timestamp() const;
  void set_need_update_primary_timestamp(bool value);
  private:
  bool _internal_need_update_primary_timestamp() const;
  void _internal_set_need_update_primary_timestamp(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TransactionInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > need_rollback_seq_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CachePlan > cache_plans_;
  ::PROTOBUF_NAMESPACE_ID::uint64 txn_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 seq_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_seq_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_rows_;
  ::PROTOBUF_NAMESPACE_ID::int64 primary_region_id_;
  int txn_state_;
  bool optimize_1pc_;
  bool autocommit_;
  bool open_binlog_;
  bool from_store_;
  ::PROTOBUF_NAMESPACE_ID::int64 live_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 commit_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 txn_timeout_;
  bool need_update_primary_timestamp_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class AnalyzeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.AnalyzeInfo) */ {
 public:
  inline AnalyzeInfo() : AnalyzeInfo(nullptr) {}
  ~AnalyzeInfo() override;
  explicit constexpr AnalyzeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnalyzeInfo(const AnalyzeInfo& from);
  AnalyzeInfo(AnalyzeInfo&& from) noexcept
    : AnalyzeInfo() {
    *this = ::std::move(from);
  }

  inline AnalyzeInfo& operator=(const AnalyzeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalyzeInfo& operator=(AnalyzeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalyzeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnalyzeInfo* internal_default_instance() {
    return reinterpret_cast<const AnalyzeInfo*>(
               &_AnalyzeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AnalyzeInfo& a, AnalyzeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AnalyzeInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalyzeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnalyzeInfo* New() const final {
    return new AnalyzeInfo();
  }

  AnalyzeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnalyzeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnalyzeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AnalyzeInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalyzeInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.AnalyzeInfo";
  }
  protected:
  explicit AnalyzeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatisticsTypesFieldNumber = 5,
    kDepthFieldNumber = 1,
    kWidthFieldNumber = 2,
    kTableRowsFieldNumber = 4,
    kSampleRowsFieldNumber = 3,
  };
  // repeated .baikaldb.pb.StatisticType statistics_types = 5;
  int statistics_types_size() const;
  private:
  int _internal_statistics_types_size() const;
  public:
  void clear_statistics_types();
  private:
  ::baikaldb::pb::StatisticType _internal_statistics_types(int index) const;
  void _internal_add_statistics_types(::baikaldb::pb::StatisticType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_statistics_types();
  public:
  ::baikaldb::pb::StatisticType statistics_types(int index) const;
  void set_statistics_types(int index, ::baikaldb::pb::StatisticType value);
  void add_statistics_types(::baikaldb::pb::StatisticType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& statistics_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_statistics_types();

  // optional int32 depth = 1;
  bool has_depth() const;
  private:
  bool _internal_has_depth() const;
  public:
  void clear_depth();
  ::PROTOBUF_NAMESPACE_ID::int32 depth() const;
  void set_depth(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_depth() const;
  void _internal_set_depth(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 width = 2;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int64 table_rows = 4;
  bool has_table_rows() const;
  private:
  bool _internal_has_table_rows() const;
  public:
  void clear_table_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 table_rows() const;
  void set_table_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_rows() const;
  void _internal_set_table_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 sample_rows = 3;
  bool has_sample_rows() const;
  private:
  bool _internal_has_sample_rows() const;
  public:
  void clear_sample_rows();
  ::PROTOBUF_NAMESPACE_ID::int32 sample_rows() const;
  void set_sample_rows(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sample_rows() const;
  void _internal_set_sample_rows(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.AnalyzeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> statistics_types_;
  ::PROTOBUF_NAMESPACE_ID::int32 depth_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_rows_;
  ::PROTOBUF_NAMESPACE_ID::int32 sample_rows_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BinlogDesc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BinlogDesc) */ {
 public:
  inline BinlogDesc() : BinlogDesc(nullptr) {}
  ~BinlogDesc() override;
  explicit constexpr BinlogDesc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinlogDesc(const BinlogDesc& from);
  BinlogDesc(BinlogDesc&& from) noexcept
    : BinlogDesc() {
    *this = ::std::move(from);
  }

  inline BinlogDesc& operator=(const BinlogDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinlogDesc& operator=(BinlogDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinlogDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinlogDesc* internal_default_instance() {
    return reinterpret_cast<const BinlogDesc*>(
               &_BinlogDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BinlogDesc& a, BinlogDesc& b) {
    a.Swap(&b);
  }
  inline void Swap(BinlogDesc* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinlogDesc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinlogDesc* New() const final {
    return new BinlogDesc();
  }

  BinlogDesc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinlogDesc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinlogDesc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BinlogDesc& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinlogDesc* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BinlogDesc";
  }
  protected:
  explicit BinlogDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbTablesFieldNumber = 10,
    kSignsFieldNumber = 11,
    kTxnIdsFieldNumber = 12,
    kUserNameFieldNumber = 8,
    kUserIpFieldNumber = 9,
    kBinlogTsFieldNumber = 1,
    kTxnIdFieldNumber = 2,
    kStartTsFieldNumber = 3,
    kPrimaryRegionIdFieldNumber = 4,
    kReadBinlogCntFieldNumber = 6,
    kBinlogRowCntFieldNumber = 7,
    kFlashBackReadFieldNumber = 13,
    kReadOfflineBinlogFieldNumber = 14,
  };
  // repeated bytes db_tables = 10;
  int db_tables_size() const;
  private:
  int _internal_db_tables_size() const;
  public:
  void clear_db_tables();
  const std::string& db_tables(int index) const;
  std::string* mutable_db_tables(int index);
  void set_db_tables(int index, const std::string& value);
  void set_db_tables(int index, std::string&& value);
  void set_db_tables(int index, const char* value);
  void set_db_tables(int index, const void* value, size_t size);
  std::string* add_db_tables();
  void add_db_tables(const std::string& value);
  void add_db_tables(std::string&& value);
  void add_db_tables(const char* value);
  void add_db_tables(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& db_tables() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_db_tables();
  private:
  const std::string& _internal_db_tables(int index) const;
  std::string* _internal_add_db_tables();
  public:

  // repeated uint64 signs = 11;
  int signs_size() const;
  private:
  int _internal_signs_size() const;
  public:
  void clear_signs();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_signs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_signs() const;
  void _internal_add_signs(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_signs();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 signs(int index) const;
  void set_signs(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_signs(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      signs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_signs();

  // repeated int64 txn_ids = 12;
  int txn_ids_size() const;
  private:
  int _internal_txn_ids_size() const;
  public:
  void clear_txn_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_txn_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_txn_ids() const;
  void _internal_add_txn_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_txn_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 txn_ids(int index) const;
  void set_txn_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_txn_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      txn_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_txn_ids();

  // optional bytes user_name = 8;
  bool has_user_name() const;
  private:
  bool _internal_has_user_name() const;
  public:
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // optional bytes user_ip = 9;
  bool has_user_ip() const;
  private:
  bool _internal_has_user_ip() const;
  public:
  void clear_user_ip();
  const std::string& user_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_ip();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_ip();
  void set_allocated_user_ip(std::string* user_ip);
  private:
  const std::string& _internal_user_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_ip(const std::string& value);
  std::string* _internal_mutable_user_ip();
  public:

  // required int64 binlog_ts = 1;
  bool has_binlog_ts() const;
  private:
  bool _internal_has_binlog_ts() const;
  public:
  void clear_binlog_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 binlog_ts() const;
  void set_binlog_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_binlog_ts() const;
  void _internal_set_binlog_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 txn_id = 2;
  bool has_txn_id() const;
  private:
  bool _internal_has_txn_id() const;
  public:
  void clear_txn_id();
  ::PROTOBUF_NAMESPACE_ID::int64 txn_id() const;
  void set_txn_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_txn_id() const;
  void _internal_set_txn_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 start_ts = 3;
  bool has_start_ts() const;
  private:
  bool _internal_has_start_ts() const;
  public:
  void clear_start_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 start_ts() const;
  void set_start_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start_ts() const;
  void _internal_set_start_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 primary_region_id = 4;
  bool has_primary_region_id() const;
  private:
  bool _internal_has_primary_region_id() const;
  public:
  void clear_primary_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 primary_region_id() const;
  void set_primary_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_primary_region_id() const;
  void _internal_set_primary_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 read_binlog_cnt = 6;
  bool has_read_binlog_cnt() const;
  private:
  bool _internal_has_read_binlog_cnt() const;
  public:
  void clear_read_binlog_cnt();
  ::PROTOBUF_NAMESPACE_ID::int64 read_binlog_cnt() const;
  void set_read_binlog_cnt(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_read_binlog_cnt() const;
  void _internal_set_read_binlog_cnt(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 binlog_row_cnt = 7;
  bool has_binlog_row_cnt() const;
  private:
  bool _internal_has_binlog_row_cnt() const;
  public:
  void clear_binlog_row_cnt();
  ::PROTOBUF_NAMESPACE_ID::int64 binlog_row_cnt() const;
  void set_binlog_row_cnt(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_binlog_row_cnt() const;
  void _internal_set_binlog_row_cnt(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool flash_back_read = 13;
  bool has_flash_back_read() const;
  private:
  bool _internal_has_flash_back_read() const;
  public:
  void clear_flash_back_read();
  bool flash_back_read() const;
  void set_flash_back_read(bool value);
  private:
  bool _internal_flash_back_read() const;
  void _internal_set_flash_back_read(bool value);
  public:

  // optional bool read_offline_binlog = 14;
  bool has_read_offline_binlog() const;
  private:
  bool _internal_has_read_offline_binlog() const;
  public:
  void clear_read_offline_binlog();
  bool read_offline_binlog() const;
  void set_read_offline_binlog(bool value);
  private:
  bool _internal_read_offline_binlog() const;
  void _internal_set_read_offline_binlog(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BinlogDesc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> db_tables_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > signs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > txn_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_ip_;
  ::PROTOBUF_NAMESPACE_ID::int64 binlog_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 txn_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 primary_region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 read_binlog_cnt_;
  ::PROTOBUF_NAMESPACE_ID::int64 binlog_row_cnt_;
  bool flash_back_read_;
  bool read_offline_binlog_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BatchStoreReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BatchStoreReq) */ {
 public:
  inline BatchStoreReq() : BatchStoreReq(nullptr) {}
  ~BatchStoreReq() override;
  explicit constexpr BatchStoreReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchStoreReq(const BatchStoreReq& from);
  BatchStoreReq(BatchStoreReq&& from) noexcept
    : BatchStoreReq() {
    *this = ::std::move(from);
  }

  inline BatchStoreReq& operator=(const BatchStoreReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchStoreReq& operator=(BatchStoreReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchStoreReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchStoreReq* internal_default_instance() {
    return reinterpret_cast<const BatchStoreReq*>(
               &_BatchStoreReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BatchStoreReq& a, BatchStoreReq& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchStoreReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchStoreReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatchStoreReq* New() const final {
    return new BatchStoreReq();
  }

  BatchStoreReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatchStoreReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchStoreReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatchStoreReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchStoreReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BatchStoreReq";
  }
  protected:
  explicit BatchStoreReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestLensFieldNumber = 2,
    kRegionIdFieldNumber = 1,
    kResendStartPosFieldNumber = 3,
  };
  // repeated int64 request_lens = 2;
  int request_lens_size() const;
  private:
  int _internal_request_lens_size() const;
  public:
  void clear_request_lens();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_request_lens(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_request_lens() const;
  void _internal_add_request_lens(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_request_lens();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 request_lens(int index) const;
  void set_request_lens(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_request_lens(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      request_lens() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_request_lens();

  // required int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 resend_start_pos = 3;
  bool has_resend_start_pos() const;
  private:
  bool _internal_has_resend_start_pos() const;
  public:
  void clear_resend_start_pos();
  ::PROTOBUF_NAMESPACE_ID::int64 resend_start_pos() const;
  void set_resend_start_pos(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_resend_start_pos() const;
  void _internal_set_resend_start_pos(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BatchStoreReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > request_lens_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 resend_start_pos_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BatchStoreRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BatchStoreRes) */ {
 public:
  inline BatchStoreRes() : BatchStoreRes(nullptr) {}
  ~BatchStoreRes() override;
  explicit constexpr BatchStoreRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchStoreRes(const BatchStoreRes& from);
  BatchStoreRes(BatchStoreRes&& from) noexcept
    : BatchStoreRes() {
    *this = ::std::move(from);
  }

  inline BatchStoreRes& operator=(const BatchStoreRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchStoreRes& operator=(BatchStoreRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchStoreRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchStoreRes* internal_default_instance() {
    return reinterpret_cast<const BatchStoreRes*>(
               &_BatchStoreRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BatchStoreRes& a, BatchStoreRes& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchStoreRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchStoreRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatchStoreRes* New() const final {
    return new BatchStoreRes();
  }

  BatchStoreRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatchStoreRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchStoreRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatchStoreRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchStoreRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BatchStoreRes";
  }
  protected:
  explicit BatchStoreRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrmsgFieldNumber = 2,
    kLeaderFieldNumber = 3,
    kSuccessCntFieldNumber = 4,
    kAppliedIndexFieldNumber = 5,
    kBraftAppliedIndexFieldNumber = 6,
    kDmlLatencyFieldNumber = 7,
    kErrcodeFieldNumber = 1,
  };
  // optional bytes errmsg = 2;
  bool has_errmsg() const;
  private:
  bool _internal_has_errmsg() const;
  public:
  void clear_errmsg();
  const std::string& errmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errmsg();
  PROTOBUF_MUST_USE_RESULT std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // optional string leader = 3;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // optional int64 success_cnt = 4;
  bool has_success_cnt() const;
  private:
  bool _internal_has_success_cnt() const;
  public:
  void clear_success_cnt();
  ::PROTOBUF_NAMESPACE_ID::int64 success_cnt() const;
  void set_success_cnt(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_success_cnt() const;
  void _internal_set_success_cnt(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 applied_index = 5;
  bool has_applied_index() const;
  private:
  bool _internal_has_applied_index() const;
  public:
  void clear_applied_index();
  ::PROTOBUF_NAMESPACE_ID::int64 applied_index() const;
  void set_applied_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_applied_index() const;
  void _internal_set_applied_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 braft_applied_index = 6;
  bool has_braft_applied_index() const;
  private:
  bool _internal_has_braft_applied_index() const;
  public:
  void clear_braft_applied_index();
  ::PROTOBUF_NAMESPACE_ID::int64 braft_applied_index() const;
  void set_braft_applied_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_braft_applied_index() const;
  void _internal_set_braft_applied_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 dml_latency = 7;
  bool has_dml_latency() const;
  private:
  bool _internal_has_dml_latency() const;
  public:
  void clear_dml_latency();
  ::PROTOBUF_NAMESPACE_ID::int64 dml_latency() const;
  void set_dml_latency(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_dml_latency() const;
  void _internal_set_dml_latency(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required .baikaldb.pb.ErrCode errcode = 1;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::ErrCode errcode() const;
  void set_errcode(::baikaldb::pb::ErrCode value);
  private:
  ::baikaldb::pb::ErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::ErrCode value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BatchStoreRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  ::PROTOBUF_NAMESPACE_ID::int64 success_cnt_;
  ::PROTOBUF_NAMESPACE_ID::int64 applied_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 braft_applied_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 dml_latency_;
  int errcode_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RegionIndexs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RegionIndexs) */ {
 public:
  inline RegionIndexs() : RegionIndexs(nullptr) {}
  ~RegionIndexs() override;
  explicit constexpr RegionIndexs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionIndexs(const RegionIndexs& from);
  RegionIndexs(RegionIndexs&& from) noexcept
    : RegionIndexs() {
    *this = ::std::move(from);
  }

  inline RegionIndexs& operator=(const RegionIndexs& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionIndexs& operator=(RegionIndexs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionIndexs& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionIndexs* internal_default_instance() {
    return reinterpret_cast<const RegionIndexs*>(
               &_RegionIndexs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RegionIndexs& a, RegionIndexs& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionIndexs* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionIndexs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionIndexs* New() const final {
    return new RegionIndexs();
  }

  RegionIndexs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionIndexs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionIndexs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegionIndexs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionIndexs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RegionIndexs";
  }
  protected:
  explicit RegionIndexs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExternalFullPathFieldNumber = 8,
    kOlapIndexInfoListFieldNumber = 12,
    kStatusFieldNumber = 4,
    kResourceTagFieldNumber = 5,
    kColumnInfoFieldNumber = 11,
    kRegionIdFieldNumber = 1,
    kVersionFieldNumber = 2,
    kApplyIndexFieldNumber = 3,
    kTableIdFieldNumber = 6,
    kOlapStateFieldNumber = 7,
    kPathDiffFieldNumber = 9,
    kRegionSizeFieldNumber = 10,
  };
  // repeated string external_full_path = 8;
  int external_full_path_size() const;
  private:
  int _internal_external_full_path_size() const;
  public:
  void clear_external_full_path();
  const std::string& external_full_path(int index) const;
  std::string* mutable_external_full_path(int index);
  void set_external_full_path(int index, const std::string& value);
  void set_external_full_path(int index, std::string&& value);
  void set_external_full_path(int index, const char* value);
  void set_external_full_path(int index, const char* value, size_t size);
  std::string* add_external_full_path();
  void add_external_full_path(const std::string& value);
  void add_external_full_path(std::string&& value);
  void add_external_full_path(const char* value);
  void add_external_full_path(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& external_full_path() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_external_full_path();
  private:
  const std::string& _internal_external_full_path(int index) const;
  std::string* _internal_add_external_full_path();
  public:

  // repeated .baikaldb.pb.OlapRegionIndexInfo olap_index_info_list = 12;
  int olap_index_info_list_size() const;
  private:
  int _internal_olap_index_info_list_size() const;
  public:
  void clear_olap_index_info_list();
  ::baikaldb::pb::OlapRegionIndexInfo* mutable_olap_index_info_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::OlapRegionIndexInfo >*
      mutable_olap_index_info_list();
  private:
  const ::baikaldb::pb::OlapRegionIndexInfo& _internal_olap_index_info_list(int index) const;
  ::baikaldb::pb::OlapRegionIndexInfo* _internal_add_olap_index_info_list();
  public:
  const ::baikaldb::pb::OlapRegionIndexInfo& olap_index_info_list(int index) const;
  ::baikaldb::pb::OlapRegionIndexInfo* add_olap_index_info_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::OlapRegionIndexInfo >&
      olap_index_info_list() const;

  // optional string status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional string resource_tag = 5;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional string column_info = 11;
  bool has_column_info() const;
  private:
  bool _internal_has_column_info() const;
  public:
  void clear_column_info();
  const std::string& column_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_info();
  PROTOBUF_MUST_USE_RESULT std::string* release_column_info();
  void set_allocated_column_info(std::string* column_info);
  private:
  const std::string& _internal_column_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_info(const std::string& value);
  std::string* _internal_mutable_column_info();
  public:

  // optional int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 apply_index = 3;
  bool has_apply_index() const;
  private:
  bool _internal_has_apply_index() const;
  public:
  void clear_apply_index();
  ::PROTOBUF_NAMESPACE_ID::int64 apply_index() const;
  void set_apply_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_apply_index() const;
  void _internal_set_apply_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 table_id = 6;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.OlapRegionStat olap_state = 7;
  bool has_olap_state() const;
  private:
  bool _internal_has_olap_state() const;
  public:
  void clear_olap_state();
  ::baikaldb::pb::OlapRegionStat olap_state() const;
  void set_olap_state(::baikaldb::pb::OlapRegionStat value);
  private:
  ::baikaldb::pb::OlapRegionStat _internal_olap_state() const;
  void _internal_set_olap_state(::baikaldb::pb::OlapRegionStat value);
  public:

  // optional bool path_diff = 9;
  bool has_path_diff() const;
  private:
  bool _internal_has_path_diff() const;
  public:
  void clear_path_diff();
  bool path_diff() const;
  void set_path_diff(bool value);
  private:
  bool _internal_path_diff() const;
  void _internal_set_path_diff(bool value);
  public:

  // optional int64 region_size = 10;
  bool has_region_size() const;
  private:
  bool _internal_has_region_size() const;
  public:
  void clear_region_size();
  ::PROTOBUF_NAMESPACE_ID::int64 region_size() const;
  void set_region_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_size() const;
  void _internal_set_region_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RegionIndexs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> external_full_path_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::OlapRegionIndexInfo > olap_index_info_list_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_info_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  ::PROTOBUF_NAMESPACE_ID::int64 apply_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  int olap_state_;
  bool path_diff_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_size_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class ColumnRegionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ColumnRegionInfo) */ {
 public:
  inline ColumnRegionInfo() : ColumnRegionInfo(nullptr) {}
  ~ColumnRegionInfo() override;
  explicit constexpr ColumnRegionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnRegionInfo(const ColumnRegionInfo& from);
  ColumnRegionInfo(ColumnRegionInfo&& from) noexcept
    : ColumnRegionInfo() {
    *this = ::std::move(from);
  }

  inline ColumnRegionInfo& operator=(const ColumnRegionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnRegionInfo& operator=(ColumnRegionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnRegionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnRegionInfo* internal_default_instance() {
    return reinterpret_cast<const ColumnRegionInfo*>(
               &_ColumnRegionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ColumnRegionInfo& a, ColumnRegionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnRegionInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnRegionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColumnRegionInfo* New() const final {
    return new ColumnRegionInfo();
  }

  ColumnRegionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColumnRegionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnRegionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ColumnRegionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnRegionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ColumnRegionInfo";
  }
  protected:
  explicit ColumnRegionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnFilesFieldNumber = 1,
  };
  // optional .baikaldb.pb.RegionColumnFiles column_files = 1;
  bool has_column_files() const;
  private:
  bool _internal_has_column_files() const;
  public:
  void clear_column_files();
  const ::baikaldb::pb::RegionColumnFiles& column_files() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionColumnFiles* release_column_files();
  ::baikaldb::pb::RegionColumnFiles* mutable_column_files();
  void set_allocated_column_files(::baikaldb::pb::RegionColumnFiles* column_files);
  private:
  const ::baikaldb::pb::RegionColumnFiles& _internal_column_files() const;
  ::baikaldb::pb::RegionColumnFiles* _internal_mutable_column_files();
  public:
  void unsafe_arena_set_allocated_column_files(
      ::baikaldb::pb::RegionColumnFiles* column_files);
  ::baikaldb::pb::RegionColumnFiles* unsafe_arena_release_column_files();

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ColumnRegionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::RegionColumnFiles* column_files_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class UseridCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.UseridCount) */ {
 public:
  inline UseridCount() : UseridCount(nullptr) {}
  ~UseridCount() override;
  explicit constexpr UseridCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UseridCount(const UseridCount& from);
  UseridCount(UseridCount&& from) noexcept
    : UseridCount() {
    *this = ::std::move(from);
  }

  inline UseridCount& operator=(const UseridCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseridCount& operator=(UseridCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UseridCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseridCount* internal_default_instance() {
    return reinterpret_cast<const UseridCount*>(
               &_UseridCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UseridCount& a, UseridCount& b) {
    a.Swap(&b);
  }
  inline void Swap(UseridCount* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseridCount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UseridCount* New() const final {
    return new UseridCount();
  }

  UseridCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UseridCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UseridCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UseridCount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UseridCount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.UseridCount";
  }
  protected:
  explicit UseridCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseridFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // optional int64 userid = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  ::PROTOBUF_NAMESPACE_ID::int64 userid() const;
  void set_userid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_userid() const;
  void _internal_set_userid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 count = 2;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int64 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.UseridCount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 userid_;
  ::PROTOBUF_NAMESPACE_ID::int64 count_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class ExtraReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ExtraReq) */ {
 public:
  inline ExtraReq() : ExtraReq(nullptr) {}
  ~ExtraReq() override;
  explicit constexpr ExtraReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtraReq(const ExtraReq& from);
  ExtraReq(ExtraReq&& from) noexcept
    : ExtraReq() {
    *this = ::std::move(from);
  }

  inline ExtraReq& operator=(const ExtraReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtraReq& operator=(ExtraReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExtraReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtraReq* internal_default_instance() {
    return reinterpret_cast<const ExtraReq*>(
               &_ExtraReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ExtraReq& a, ExtraReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtraReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtraReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExtraReq* New() const final {
    return new ExtraReq();
  }

  ExtraReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExtraReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExtraReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExtraReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExtraReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ExtraReq";
  }
  protected:
  explicit ExtraReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOlapInfoFieldNumber = 3,
    kOfflineBinlogInfoFieldNumber = 4,
    kColumnInfoFieldNumber = 6,
    kSignLatencyFieldNumber = 2,
    kWattStatsVersionFieldNumber = 5,
    kUseReadIdxFieldNumber = 1,
  };
  // optional .baikaldb.pb.OlapRegionInfo olap_info = 3;
  bool has_olap_info() const;
  private:
  bool _internal_has_olap_info() const;
  public:
  void clear_olap_info();
  const ::baikaldb::pb::OlapRegionInfo& olap_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::OlapRegionInfo* release_olap_info();
  ::baikaldb::pb::OlapRegionInfo* mutable_olap_info();
  void set_allocated_olap_info(::baikaldb::pb::OlapRegionInfo* olap_info);
  private:
  const ::baikaldb::pb::OlapRegionInfo& _internal_olap_info() const;
  ::baikaldb::pb::OlapRegionInfo* _internal_mutable_olap_info();
  public:
  void unsafe_arena_set_allocated_olap_info(
      ::baikaldb::pb::OlapRegionInfo* olap_info);
  ::baikaldb::pb::OlapRegionInfo* unsafe_arena_release_olap_info();

  // optional .baikaldb.pb.RegionOfflineBinlogInfo offline_binlog_info = 4;
  bool has_offline_binlog_info() const;
  private:
  bool _internal_has_offline_binlog_info() const;
  public:
  void clear_offline_binlog_info();
  const ::baikaldb::pb::RegionOfflineBinlogInfo& offline_binlog_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionOfflineBinlogInfo* release_offline_binlog_info();
  ::baikaldb::pb::RegionOfflineBinlogInfo* mutable_offline_binlog_info();
  void set_allocated_offline_binlog_info(::baikaldb::pb::RegionOfflineBinlogInfo* offline_binlog_info);
  private:
  const ::baikaldb::pb::RegionOfflineBinlogInfo& _internal_offline_binlog_info() const;
  ::baikaldb::pb::RegionOfflineBinlogInfo* _internal_mutable_offline_binlog_info();
  public:
  void unsafe_arena_set_allocated_offline_binlog_info(
      ::baikaldb::pb::RegionOfflineBinlogInfo* offline_binlog_info);
  ::baikaldb::pb::RegionOfflineBinlogInfo* unsafe_arena_release_offline_binlog_info();

  // optional .baikaldb.pb.ColumnRegionInfo column_info = 6;
  bool has_column_info() const;
  private:
  bool _internal_has_column_info() const;
  public:
  void clear_column_info();
  const ::baikaldb::pb::ColumnRegionInfo& column_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::ColumnRegionInfo* release_column_info();
  ::baikaldb::pb::ColumnRegionInfo* mutable_column_info();
  void set_allocated_column_info(::baikaldb::pb::ColumnRegionInfo* column_info);
  private:
  const ::baikaldb::pb::ColumnRegionInfo& _internal_column_info() const;
  ::baikaldb::pb::ColumnRegionInfo* _internal_mutable_column_info();
  public:
  void unsafe_arena_set_allocated_column_info(
      ::baikaldb::pb::ColumnRegionInfo* column_info);
  ::baikaldb::pb::ColumnRegionInfo* unsafe_arena_release_column_info();

  // optional int64 sign_latency = 2;
  bool has_sign_latency() const;
  private:
  bool _internal_has_sign_latency() const;
  public:
  void clear_sign_latency();
  ::PROTOBUF_NAMESPACE_ID::int64 sign_latency() const;
  void set_sign_latency(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_sign_latency() const;
  void _internal_set_sign_latency(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint64 watt_stats_version = 5;
  bool has_watt_stats_version() const;
  private:
  bool _internal_has_watt_stats_version() const;
  public:
  void clear_watt_stats_version();
  ::PROTOBUF_NAMESPACE_ID::uint64 watt_stats_version() const;
  void set_watt_stats_version(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_watt_stats_version() const;
  void _internal_set_watt_stats_version(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool use_read_idx = 1;
  bool has_use_read_idx() const;
  private:
  bool _internal_has_use_read_idx() const;
  public:
  void clear_use_read_idx();
  bool use_read_idx() const;
  void set_use_read_idx(bool value);
  private:
  bool _internal_use_read_idx() const;
  void _internal_set_use_read_idx(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ExtraReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::OlapRegionInfo* olap_info_;
  ::baikaldb::pb::RegionOfflineBinlogInfo* offline_binlog_info_;
  ::baikaldb::pb::ColumnRegionInfo* column_info_;
  ::PROTOBUF_NAMESPACE_ID::int64 sign_latency_;
  ::PROTOBUF_NAMESPACE_ID::uint64 watt_stats_version_;
  bool use_read_idx_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class ExtraRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ExtraRes) */ {
 public:
  inline ExtraRes() : ExtraRes(nullptr) {}
  ~ExtraRes() override;
  explicit constexpr ExtraRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtraRes(const ExtraRes& from);
  ExtraRes(ExtraRes&& from) noexcept
    : ExtraRes() {
    *this = ::std::move(from);
  }

  inline ExtraRes& operator=(const ExtraRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtraRes& operator=(ExtraRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExtraRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtraRes* internal_default_instance() {
    return reinterpret_cast<const ExtraRes*>(
               &_ExtraRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ExtraRes& a, ExtraRes& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtraRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtraRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExtraRes* New() const final {
    return new ExtraRes();
  }

  ExtraRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExtraRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExtraRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExtraRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExtraRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ExtraRes";
  }
  protected:
  explicit ExtraRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfosFieldNumber = 1,
    kAfsFullNamesFieldNumber = 6,
    kUseridCountFieldNumber = 9,
    kVectorizedRowsFieldNumber = 3,
    kVectorizedSchemaFieldNumber = 4,
    kOfflineBinlogInfoFieldNumber = 2,
    kWaitCostFieldNumber = 5,
    kGetAfsPathSuccFieldNumber = 7,
    kQueryKeypointSuccFieldNumber = 8,
  };
  // repeated .baikaldb.pb.RegionIndexs infos = 1;
  int infos_size() const;
  private:
  int _internal_infos_size() const;
  public:
  void clear_infos();
  ::baikaldb::pb::RegionIndexs* mutable_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionIndexs >*
      mutable_infos();
  private:
  const ::baikaldb::pb::RegionIndexs& _internal_infos(int index) const;
  ::baikaldb::pb::RegionIndexs* _internal_add_infos();
  public:
  const ::baikaldb::pb::RegionIndexs& infos(int index) const;
  ::baikaldb::pb::RegionIndexs* add_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionIndexs >&
      infos() const;

  // repeated bytes afs_full_names = 6;
  int afs_full_names_size() const;
  private:
  int _internal_afs_full_names_size() const;
  public:
  void clear_afs_full_names();
  const std::string& afs_full_names(int index) const;
  std::string* mutable_afs_full_names(int index);
  void set_afs_full_names(int index, const std::string& value);
  void set_afs_full_names(int index, std::string&& value);
  void set_afs_full_names(int index, const char* value);
  void set_afs_full_names(int index, const void* value, size_t size);
  std::string* add_afs_full_names();
  void add_afs_full_names(const std::string& value);
  void add_afs_full_names(std::string&& value);
  void add_afs_full_names(const char* value);
  void add_afs_full_names(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& afs_full_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_afs_full_names();
  private:
  const std::string& _internal_afs_full_names(int index) const;
  std::string* _internal_add_afs_full_names();
  public:

  // repeated .baikaldb.pb.UseridCount userid_count = 9;
  int userid_count_size() const;
  private:
  int _internal_userid_count_size() const;
  public:
  void clear_userid_count();
  ::baikaldb::pb::UseridCount* mutable_userid_count(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::UseridCount >*
      mutable_userid_count();
  private:
  const ::baikaldb::pb::UseridCount& _internal_userid_count(int index) const;
  ::baikaldb::pb::UseridCount* _internal_add_userid_count();
  public:
  const ::baikaldb::pb::UseridCount& userid_count(int index) const;
  ::baikaldb::pb::UseridCount* add_userid_count();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::UseridCount >&
      userid_count() const;

  // optional bytes vectorized_rows = 3;
  bool has_vectorized_rows() const;
  private:
  bool _internal_has_vectorized_rows() const;
  public:
  void clear_vectorized_rows();
  const std::string& vectorized_rows() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vectorized_rows(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vectorized_rows();
  PROTOBUF_MUST_USE_RESULT std::string* release_vectorized_rows();
  void set_allocated_vectorized_rows(std::string* vectorized_rows);
  private:
  const std::string& _internal_vectorized_rows() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vectorized_rows(const std::string& value);
  std::string* _internal_mutable_vectorized_rows();
  public:

  // optional bytes vectorized_schema = 4;
  bool has_vectorized_schema() const;
  private:
  bool _internal_has_vectorized_schema() const;
  public:
  void clear_vectorized_schema();
  const std::string& vectorized_schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vectorized_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vectorized_schema();
  PROTOBUF_MUST_USE_RESULT std::string* release_vectorized_schema();
  void set_allocated_vectorized_schema(std::string* vectorized_schema);
  private:
  const std::string& _internal_vectorized_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vectorized_schema(const std::string& value);
  std::string* _internal_mutable_vectorized_schema();
  public:

  // optional .baikaldb.pb.RegionOfflineBinlogInfo offline_binlog_info = 2;
  bool has_offline_binlog_info() const;
  private:
  bool _internal_has_offline_binlog_info() const;
  public:
  void clear_offline_binlog_info();
  const ::baikaldb::pb::RegionOfflineBinlogInfo& offline_binlog_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionOfflineBinlogInfo* release_offline_binlog_info();
  ::baikaldb::pb::RegionOfflineBinlogInfo* mutable_offline_binlog_info();
  void set_allocated_offline_binlog_info(::baikaldb::pb::RegionOfflineBinlogInfo* offline_binlog_info);
  private:
  const ::baikaldb::pb::RegionOfflineBinlogInfo& _internal_offline_binlog_info() const;
  ::baikaldb::pb::RegionOfflineBinlogInfo* _internal_mutable_offline_binlog_info();
  public:
  void unsafe_arena_set_allocated_offline_binlog_info(
      ::baikaldb::pb::RegionOfflineBinlogInfo* offline_binlog_info);
  ::baikaldb::pb::RegionOfflineBinlogInfo* unsafe_arena_release_offline_binlog_info();

  // optional int64 wait_cost = 5;
  bool has_wait_cost() const;
  private:
  bool _internal_has_wait_cost() const;
  public:
  void clear_wait_cost();
  ::PROTOBUF_NAMESPACE_ID::int64 wait_cost() const;
  void set_wait_cost(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_wait_cost() const;
  void _internal_set_wait_cost(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool get_afs_path_succ = 7;
  bool has_get_afs_path_succ() const;
  private:
  bool _internal_has_get_afs_path_succ() const;
  public:
  void clear_get_afs_path_succ();
  bool get_afs_path_succ() const;
  void set_get_afs_path_succ(bool value);
  private:
  bool _internal_get_afs_path_succ() const;
  void _internal_set_get_afs_path_succ(bool value);
  public:

  // optional bool query_keypoint_succ = 8;
  bool has_query_keypoint_succ() const;
  private:
  bool _internal_has_query_keypoint_succ() const;
  public:
  void clear_query_keypoint_succ();
  bool query_keypoint_succ() const;
  void set_query_keypoint_succ(bool value);
  private:
  bool _internal_query_keypoint_succ() const;
  void _internal_set_query_keypoint_succ(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ExtraRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionIndexs > infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> afs_full_names_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::UseridCount > userid_count_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vectorized_rows_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vectorized_schema_;
  ::baikaldb::pb::RegionOfflineBinlogInfo* offline_binlog_info_;
  ::PROTOBUF_NAMESPACE_ID::int64 wait_cost_;
  bool get_afs_path_succ_;
  bool query_keypoint_succ_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class StoreReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.StoreReq) */ {
 public:
  inline StoreReq() : StoreReq(nullptr) {}
  ~StoreReq() override;
  explicit constexpr StoreReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreReq(const StoreReq& from);
  StoreReq(StoreReq&& from) noexcept
    : StoreReq() {
    *this = ::std::move(from);
  }

  inline StoreReq& operator=(const StoreReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreReq& operator=(StoreReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreReq* internal_default_instance() {
    return reinterpret_cast<const StoreReq*>(
               &_StoreReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(StoreReq& a, StoreReq& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StoreReq* New() const final {
    return new StoreReq();
  }

  StoreReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StoreReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.StoreReq";
  }
  protected:
  explicit StoreReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTuplesFieldNumber = 2,
    kTxnInfosFieldNumber = 6,
    kKvOpsFieldNumber = 21,
    kRollbackTxnIdsFieldNumber = 24,
    kCommitTxnIdsFieldNumber = 25,
    kMultiNewRegionInfosFieldNumber = 29,
    kStartKeyFieldNumber = 9,
    kEndKeyFieldNumber = 10,
    kPlanFieldNumber = 5,
    kNewRegionInfoFieldNumber = 16,
    kDdlworkInfoFieldNumber = 19,
    kAnalyzeInfoFieldNumber = 23,
    kBinlogDescFieldNumber = 26,
    kBinlogFieldNumber = 27,
    kExtraReqFieldNumber = 30,
    kRedisReqFieldNumber = 34,
    kRegionIdFieldNumber = 3,
    kRegionVersionFieldNumber = 4,
    kLogIdFieldNumber = 7,
    kSplitTermFieldNumber = 11,
    kSplitEndIndexFieldNumber = 12,
    kReduceNumLinesFieldNumber = 13,
    kOpTypeFieldNumber = 1,
    kForceFieldNumber = 14,
    kNotCheckRegionFieldNumber = 15,
    kSelectWithoutLeaderFieldNumber = 17,
    kIsTraceFieldNumber = 22,
    kDbConnIdFieldNumber = 18,
    kNumIncreaseRowsFieldNumber = 20,
    kSqlSignFieldNumber = 28,
    kExecuteTypeFieldNumber = 31,
    kIsRollupBaseFieldNumber = 32,
    kSqlExecTimeoutFieldNumber = 33,
  };
  // repeated .baikaldb.pb.TupleDescriptor tuples = 2;
  int tuples_size() const;
  private:
  int _internal_tuples_size() const;
  public:
  void clear_tuples();
  ::baikaldb::pb::TupleDescriptor* mutable_tuples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TupleDescriptor >*
      mutable_tuples();
  private:
  const ::baikaldb::pb::TupleDescriptor& _internal_tuples(int index) const;
  ::baikaldb::pb::TupleDescriptor* _internal_add_tuples();
  public:
  const ::baikaldb::pb::TupleDescriptor& tuples(int index) const;
  ::baikaldb::pb::TupleDescriptor* add_tuples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TupleDescriptor >&
      tuples() const;

  // repeated .baikaldb.pb.TransactionInfo txn_infos = 6;
  int txn_infos_size() const;
  private:
  int _internal_txn_infos_size() const;
  public:
  void clear_txn_infos();
  ::baikaldb::pb::TransactionInfo* mutable_txn_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TransactionInfo >*
      mutable_txn_infos();
  private:
  const ::baikaldb::pb::TransactionInfo& _internal_txn_infos(int index) const;
  ::baikaldb::pb::TransactionInfo* _internal_add_txn_infos();
  public:
  const ::baikaldb::pb::TransactionInfo& txn_infos(int index) const;
  ::baikaldb::pb::TransactionInfo* add_txn_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TransactionInfo >&
      txn_infos() const;

  // repeated .baikaldb.pb.KvOp kv_ops = 21;
  int kv_ops_size() const;
  private:
  int _internal_kv_ops_size() const;
  public:
  void clear_kv_ops();
  ::baikaldb::pb::KvOp* mutable_kv_ops(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::KvOp >*
      mutable_kv_ops();
  private:
  const ::baikaldb::pb::KvOp& _internal_kv_ops(int index) const;
  ::baikaldb::pb::KvOp* _internal_add_kv_ops();
  public:
  const ::baikaldb::pb::KvOp& kv_ops(int index) const;
  ::baikaldb::pb::KvOp* add_kv_ops();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::KvOp >&
      kv_ops() const;

  // repeated uint64 rollback_txn_ids = 24;
  int rollback_txn_ids_size() const;
  private:
  int _internal_rollback_txn_ids_size() const;
  public:
  void clear_rollback_txn_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_rollback_txn_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_rollback_txn_ids() const;
  void _internal_add_rollback_txn_ids(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_rollback_txn_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 rollback_txn_ids(int index) const;
  void set_rollback_txn_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_rollback_txn_ids(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      rollback_txn_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_rollback_txn_ids();

  // repeated uint64 commit_txn_ids = 25;
  int commit_txn_ids_size() const;
  private:
  int _internal_commit_txn_ids_size() const;
  public:
  void clear_commit_txn_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_commit_txn_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      _internal_commit_txn_ids() const;
  void _internal_add_commit_txn_ids(::PROTOBUF_NAMESPACE_ID::uint64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      _internal_mutable_commit_txn_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint64 commit_txn_ids(int index) const;
  void set_commit_txn_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_commit_txn_ids(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      commit_txn_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_commit_txn_ids();

  // repeated .baikaldb.pb.RegionInfo multi_new_region_infos = 29;
  int multi_new_region_infos_size() const;
  private:
  int _internal_multi_new_region_infos_size() const;
  public:
  void clear_multi_new_region_infos();
  ::baikaldb::pb::RegionInfo* mutable_multi_new_region_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >*
      mutable_multi_new_region_infos();
  private:
  const ::baikaldb::pb::RegionInfo& _internal_multi_new_region_infos(int index) const;
  ::baikaldb::pb::RegionInfo* _internal_add_multi_new_region_infos();
  public:
  const ::baikaldb::pb::RegionInfo& multi_new_region_infos(int index) const;
  ::baikaldb::pb::RegionInfo* add_multi_new_region_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >&
      multi_new_region_infos() const;

  // optional bytes start_key = 9;
  bool has_start_key() const;
  private:
  bool _internal_has_start_key() const;
  public:
  void clear_start_key();
  const std::string& start_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_start_key();
  void set_allocated_start_key(std::string* start_key);
  private:
  const std::string& _internal_start_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_key(const std::string& value);
  std::string* _internal_mutable_start_key();
  public:

  // optional bytes end_key = 10;
  bool has_end_key() const;
  private:
  bool _internal_has_end_key() const;
  public:
  void clear_end_key();
  const std::string& end_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_end_key();
  void set_allocated_end_key(std::string* end_key);
  private:
  const std::string& _internal_end_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_key(const std::string& value);
  std::string* _internal_mutable_end_key();
  public:

  // optional .baikaldb.pb.Plan plan = 5;
  bool has_plan() const;
  private:
  bool _internal_has_plan() const;
  public:
  void clear_plan();
  const ::baikaldb::pb::Plan& plan() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::Plan* release_plan();
  ::baikaldb::pb::Plan* mutable_plan();
  void set_allocated_plan(::baikaldb::pb::Plan* plan);
  private:
  const ::baikaldb::pb::Plan& _internal_plan() const;
  ::baikaldb::pb::Plan* _internal_mutable_plan();
  public:
  void unsafe_arena_set_allocated_plan(
      ::baikaldb::pb::Plan* plan);
  ::baikaldb::pb::Plan* unsafe_arena_release_plan();

  // optional .baikaldb.pb.RegionInfo new_region_info = 16;
  bool has_new_region_info() const;
  private:
  bool _internal_has_new_region_info() const;
  public:
  void clear_new_region_info();
  const ::baikaldb::pb::RegionInfo& new_region_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionInfo* release_new_region_info();
  ::baikaldb::pb::RegionInfo* mutable_new_region_info();
  void set_allocated_new_region_info(::baikaldb::pb::RegionInfo* new_region_info);
  private:
  const ::baikaldb::pb::RegionInfo& _internal_new_region_info() const;
  ::baikaldb::pb::RegionInfo* _internal_mutable_new_region_info();
  public:
  void unsafe_arena_set_allocated_new_region_info(
      ::baikaldb::pb::RegionInfo* new_region_info);
  ::baikaldb::pb::RegionInfo* unsafe_arena_release_new_region_info();

  // optional .baikaldb.pb.DdlWorkInfo ddlwork_info = 19;
  bool has_ddlwork_info() const;
  private:
  bool _internal_has_ddlwork_info() const;
  public:
  void clear_ddlwork_info();
  const ::baikaldb::pb::DdlWorkInfo& ddlwork_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::DdlWorkInfo* release_ddlwork_info();
  ::baikaldb::pb::DdlWorkInfo* mutable_ddlwork_info();
  void set_allocated_ddlwork_info(::baikaldb::pb::DdlWorkInfo* ddlwork_info);
  private:
  const ::baikaldb::pb::DdlWorkInfo& _internal_ddlwork_info() const;
  ::baikaldb::pb::DdlWorkInfo* _internal_mutable_ddlwork_info();
  public:
  void unsafe_arena_set_allocated_ddlwork_info(
      ::baikaldb::pb::DdlWorkInfo* ddlwork_info);
  ::baikaldb::pb::DdlWorkInfo* unsafe_arena_release_ddlwork_info();

  // optional .baikaldb.pb.AnalyzeInfo analyze_info = 23;
  bool has_analyze_info() const;
  private:
  bool _internal_has_analyze_info() const;
  public:
  void clear_analyze_info();
  const ::baikaldb::pb::AnalyzeInfo& analyze_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::AnalyzeInfo* release_analyze_info();
  ::baikaldb::pb::AnalyzeInfo* mutable_analyze_info();
  void set_allocated_analyze_info(::baikaldb::pb::AnalyzeInfo* analyze_info);
  private:
  const ::baikaldb::pb::AnalyzeInfo& _internal_analyze_info() const;
  ::baikaldb::pb::AnalyzeInfo* _internal_mutable_analyze_info();
  public:
  void unsafe_arena_set_allocated_analyze_info(
      ::baikaldb::pb::AnalyzeInfo* analyze_info);
  ::baikaldb::pb::AnalyzeInfo* unsafe_arena_release_analyze_info();

  // optional .baikaldb.pb.BinlogDesc binlog_desc = 26;
  bool has_binlog_desc() const;
  private:
  bool _internal_has_binlog_desc() const;
  public:
  void clear_binlog_desc();
  const ::baikaldb::pb::BinlogDesc& binlog_desc() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::BinlogDesc* release_binlog_desc();
  ::baikaldb::pb::BinlogDesc* mutable_binlog_desc();
  void set_allocated_binlog_desc(::baikaldb::pb::BinlogDesc* binlog_desc);
  private:
  const ::baikaldb::pb::BinlogDesc& _internal_binlog_desc() const;
  ::baikaldb::pb::BinlogDesc* _internal_mutable_binlog_desc();
  public:
  void unsafe_arena_set_allocated_binlog_desc(
      ::baikaldb::pb::BinlogDesc* binlog_desc);
  ::baikaldb::pb::BinlogDesc* unsafe_arena_release_binlog_desc();

  // optional .baikaldb.pb.Binlog binlog = 27;
  bool has_binlog() const;
  private:
  bool _internal_has_binlog() const;
  public:
  void clear_binlog();
  const ::baikaldb::pb::Binlog& binlog() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::Binlog* release_binlog();
  ::baikaldb::pb::Binlog* mutable_binlog();
  void set_allocated_binlog(::baikaldb::pb::Binlog* binlog);
  private:
  const ::baikaldb::pb::Binlog& _internal_binlog() const;
  ::baikaldb::pb::Binlog* _internal_mutable_binlog();
  public:
  void unsafe_arena_set_allocated_binlog(
      ::baikaldb::pb::Binlog* binlog);
  ::baikaldb::pb::Binlog* unsafe_arena_release_binlog();

  // optional .baikaldb.pb.ExtraReq extra_req = 30;
  bool has_extra_req() const;
  private:
  bool _internal_has_extra_req() const;
  public:
  void clear_extra_req();
  const ::baikaldb::pb::ExtraReq& extra_req() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::ExtraReq* release_extra_req();
  ::baikaldb::pb::ExtraReq* mutable_extra_req();
  void set_allocated_extra_req(::baikaldb::pb::ExtraReq* extra_req);
  private:
  const ::baikaldb::pb::ExtraReq& _internal_extra_req() const;
  ::baikaldb::pb::ExtraReq* _internal_mutable_extra_req();
  public:
  void unsafe_arena_set_allocated_extra_req(
      ::baikaldb::pb::ExtraReq* extra_req);
  ::baikaldb::pb::ExtraReq* unsafe_arena_release_extra_req();

  // optional .baikaldb.pb.RedisWriteRequest redis_req = 34;
  bool has_redis_req() const;
  private:
  bool _internal_has_redis_req() const;
  public:
  void clear_redis_req();
  const ::baikaldb::pb::RedisWriteRequest& redis_req() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RedisWriteRequest* release_redis_req();
  ::baikaldb::pb::RedisWriteRequest* mutable_redis_req();
  void set_allocated_redis_req(::baikaldb::pb::RedisWriteRequest* redis_req);
  private:
  const ::baikaldb::pb::RedisWriteRequest& _internal_redis_req() const;
  ::baikaldb::pb::RedisWriteRequest* _internal_mutable_redis_req();
  public:
  void unsafe_arena_set_allocated_redis_req(
      ::baikaldb::pb::RedisWriteRequest* redis_req);
  ::baikaldb::pb::RedisWriteRequest* unsafe_arena_release_redis_req();

  // required int64 region_id = 3;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 region_version = 4;
  bool has_region_version() const;
  private:
  bool _internal_has_region_version() const;
  public:
  void clear_region_version();
  ::PROTOBUF_NAMESPACE_ID::int64 region_version() const;
  void set_region_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_version() const;
  void _internal_set_region_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional fixed64 log_id = 7;
  bool has_log_id() const;
  private:
  bool _internal_has_log_id() const;
  public:
  void clear_log_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 log_id() const;
  void set_log_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_log_id() const;
  void _internal_set_log_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int64 split_term = 11;
  bool has_split_term() const;
  private:
  bool _internal_has_split_term() const;
  public:
  void clear_split_term();
  ::PROTOBUF_NAMESPACE_ID::int64 split_term() const;
  void set_split_term(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_split_term() const;
  void _internal_set_split_term(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 split_end_index = 12;
  bool has_split_end_index() const;
  private:
  bool _internal_has_split_end_index() const;
  public:
  void clear_split_end_index();
  ::PROTOBUF_NAMESPACE_ID::int64 split_end_index() const;
  void set_split_end_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_split_end_index() const;
  void _internal_set_split_end_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 reduce_num_lines = 13;
  bool has_reduce_num_lines() const;
  private:
  bool _internal_has_reduce_num_lines() const;
  public:
  void clear_reduce_num_lines();
  ::PROTOBUF_NAMESPACE_ID::int64 reduce_num_lines() const;
  void set_reduce_num_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_reduce_num_lines() const;
  void _internal_set_reduce_num_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required .baikaldb.pb.OpType op_type = 1;
  bool has_op_type() const;
  private:
  bool _internal_has_op_type() const;
  public:
  void clear_op_type();
  ::baikaldb::pb::OpType op_type() const;
  void set_op_type(::baikaldb::pb::OpType value);
  private:
  ::baikaldb::pb::OpType _internal_op_type() const;
  void _internal_set_op_type(::baikaldb::pb::OpType value);
  public:

  // optional bool force = 14;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // optional bool not_check_region = 15;
  bool has_not_check_region() const;
  private:
  bool _internal_has_not_check_region() const;
  public:
  void clear_not_check_region();
  bool not_check_region() const;
  void set_not_check_region(bool value);
  private:
  bool _internal_not_check_region() const;
  void _internal_set_not_check_region(bool value);
  public:

  // optional bool select_without_leader = 17;
  bool has_select_without_leader() const;
  private:
  bool _internal_has_select_without_leader() const;
  public:
  void clear_select_without_leader();
  bool select_without_leader() const;
  void set_select_without_leader(bool value);
  private:
  bool _internal_select_without_leader() const;
  void _internal_set_select_without_leader(bool value);
  public:

  // optional bool is_trace = 22;
  bool has_is_trace() const;
  private:
  bool _internal_has_is_trace() const;
  public:
  void clear_is_trace();
  bool is_trace() const;
  void set_is_trace(bool value);
  private:
  bool _internal_is_trace() const;
  void _internal_set_is_trace(bool value);
  public:

  // optional fixed64 db_conn_id = 18;
  bool has_db_conn_id() const;
  private:
  bool _internal_has_db_conn_id() const;
  public:
  void clear_db_conn_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 db_conn_id() const;
  void set_db_conn_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_db_conn_id() const;
  void _internal_set_db_conn_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int64 num_increase_rows = 20;
  bool has_num_increase_rows() const;
  private:
  bool _internal_has_num_increase_rows() const;
  public:
  void clear_num_increase_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 num_increase_rows() const;
  void set_num_increase_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_num_increase_rows() const;
  void _internal_set_num_increase_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint64 sql_sign = 28;
  bool has_sql_sign() const;
  private:
  bool _internal_has_sql_sign() const;
  public:
  void clear_sql_sign();
  ::PROTOBUF_NAMESPACE_ID::uint64 sql_sign() const;
  void set_sql_sign(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sql_sign() const;
  void _internal_set_sql_sign(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .baikaldb.pb.ExecuteType execute_type = 31;
  bool has_execute_type() const;
  private:
  bool _internal_has_execute_type() const;
  public:
  void clear_execute_type();
  ::baikaldb::pb::ExecuteType execute_type() const;
  void set_execute_type(::baikaldb::pb::ExecuteType value);
  private:
  ::baikaldb::pb::ExecuteType _internal_execute_type() const;
  void _internal_set_execute_type(::baikaldb::pb::ExecuteType value);
  public:

  // optional bool is_rollup_base = 32;
  bool has_is_rollup_base() const;
  private:
  bool _internal_has_is_rollup_base() const;
  public:
  void clear_is_rollup_base();
  bool is_rollup_base() const;
  void set_is_rollup_base(bool value);
  private:
  bool _internal_is_rollup_base() const;
  void _internal_set_is_rollup_base(bool value);
  public:

  // optional int64 sql_exec_timeout = 33;
  bool has_sql_exec_timeout() const;
  private:
  bool _internal_has_sql_exec_timeout() const;
  public:
  void clear_sql_exec_timeout();
  ::PROTOBUF_NAMESPACE_ID::int64 sql_exec_timeout() const;
  void set_sql_exec_timeout(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_sql_exec_timeout() const;
  void _internal_set_sql_exec_timeout(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.StoreReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TupleDescriptor > tuples_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TransactionInfo > txn_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::KvOp > kv_ops_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > rollback_txn_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > commit_txn_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo > multi_new_region_infos_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_key_;
  ::baikaldb::pb::Plan* plan_;
  ::baikaldb::pb::RegionInfo* new_region_info_;
  ::baikaldb::pb::DdlWorkInfo* ddlwork_info_;
  ::baikaldb::pb::AnalyzeInfo* analyze_info_;
  ::baikaldb::pb::BinlogDesc* binlog_desc_;
  ::baikaldb::pb::Binlog* binlog_;
  ::baikaldb::pb::ExtraReq* extra_req_;
  ::baikaldb::pb::RedisWriteRequest* redis_req_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_version_;
  ::PROTOBUF_NAMESPACE_ID::uint64 log_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 split_term_;
  ::PROTOBUF_NAMESPACE_ID::int64 split_end_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 reduce_num_lines_;
  int op_type_;
  bool force_;
  bool not_check_region_;
  bool select_without_leader_;
  bool is_trace_;
  ::PROTOBUF_NAMESPACE_ID::uint64 db_conn_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_increase_rows_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sql_sign_;
  int execute_type_;
  bool is_rollup_base_;
  ::PROTOBUF_NAMESPACE_ID::int64 sql_exec_timeout_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RowValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RowValue) */ {
 public:
  inline RowValue() : RowValue(nullptr) {}
  ~RowValue() override;
  explicit constexpr RowValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RowValue(const RowValue& from);
  RowValue(RowValue&& from) noexcept
    : RowValue() {
    *this = ::std::move(from);
  }

  inline RowValue& operator=(const RowValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline RowValue& operator=(RowValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RowValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const RowValue* internal_default_instance() {
    return reinterpret_cast<const RowValue*>(
               &_RowValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RowValue& a, RowValue& b) {
    a.Swap(&b);
  }
  inline void Swap(RowValue* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RowValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RowValue* New() const final {
    return new RowValue();
  }

  RowValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RowValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RowValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RowValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RowValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RowValue";
  }
  protected:
  explicit RowValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTupleValuesFieldNumber = 1,
  };
  // repeated bytes tuple_values = 1;
  int tuple_values_size() const;
  private:
  int _internal_tuple_values_size() const;
  public:
  void clear_tuple_values();
  const std::string& tuple_values(int index) const;
  std::string* mutable_tuple_values(int index);
  void set_tuple_values(int index, const std::string& value);
  void set_tuple_values(int index, std::string&& value);
  void set_tuple_values(int index, const char* value);
  void set_tuple_values(int index, const void* value, size_t size);
  std::string* add_tuple_values();
  void add_tuple_values(const std::string& value);
  void add_tuple_values(std::string&& value);
  void add_tuple_values(const char* value);
  void add_tuple_values(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tuple_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tuple_values();
  private:
  const std::string& _internal_tuple_values(int index) const;
  std::string* _internal_add_tuple_values();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RowValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tuple_values_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RegionLeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RegionLeader) */ {
 public:
  inline RegionLeader() : RegionLeader(nullptr) {}
  ~RegionLeader() override;
  explicit constexpr RegionLeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionLeader(const RegionLeader& from);
  RegionLeader(RegionLeader&& from) noexcept
    : RegionLeader() {
    *this = ::std::move(from);
  }

  inline RegionLeader& operator=(const RegionLeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionLeader& operator=(RegionLeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionLeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionLeader* internal_default_instance() {
    return reinterpret_cast<const RegionLeader*>(
               &_RegionLeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RegionLeader& a, RegionLeader& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionLeader* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionLeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionLeader* New() const final {
    return new RegionLeader();
  }

  RegionLeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionLeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionLeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegionLeader& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionLeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RegionLeader";
  }
  protected:
  explicit RegionLeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaderFieldNumber = 2,
    kRegionIdFieldNumber = 1,
  };
  // required string leader = 2;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // required int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RegionLeader)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class IndexRecords final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.IndexRecords) */ {
 public:
  inline IndexRecords() : IndexRecords(nullptr) {}
  ~IndexRecords() override;
  explicit constexpr IndexRecords(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexRecords(const IndexRecords& from);
  IndexRecords(IndexRecords&& from) noexcept
    : IndexRecords() {
    *this = ::std::move(from);
  }

  inline IndexRecords& operator=(const IndexRecords& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexRecords& operator=(IndexRecords&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexRecords& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexRecords* internal_default_instance() {
    return reinterpret_cast<const IndexRecords*>(
               &_IndexRecords_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(IndexRecords& a, IndexRecords& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexRecords* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexRecords* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IndexRecords* New() const final {
    return new IndexRecords();
  }

  IndexRecords* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IndexRecords>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexRecords& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IndexRecords& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexRecords* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.IndexRecords";
  }
  protected:
  explicit IndexRecords(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordsFieldNumber = 2,
    kOldRecordsFieldNumber = 3,
    kIndexIdFieldNumber = 1,
    kLocalIndexBinlogFieldNumber = 4,
  };
  // repeated bytes records = 2;
  int records_size() const;
  private:
  int _internal_records_size() const;
  public:
  void clear_records();
  const std::string& records(int index) const;
  std::string* mutable_records(int index);
  void set_records(int index, const std::string& value);
  void set_records(int index, std::string&& value);
  void set_records(int index, const char* value);
  void set_records(int index, const void* value, size_t size);
  std::string* add_records();
  void add_records(const std::string& value);
  void add_records(std::string&& value);
  void add_records(const char* value);
  void add_records(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& records() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_records();
  private:
  const std::string& _internal_records(int index) const;
  std::string* _internal_add_records();
  public:

  // repeated bytes old_records = 3;
  int old_records_size() const;
  private:
  int _internal_old_records_size() const;
  public:
  void clear_old_records();
  const std::string& old_records(int index) const;
  std::string* mutable_old_records(int index);
  void set_old_records(int index, const std::string& value);
  void set_old_records(int index, std::string&& value);
  void set_old_records(int index, const char* value);
  void set_old_records(int index, const void* value, size_t size);
  std::string* add_old_records();
  void add_old_records(const std::string& value);
  void add_old_records(std::string&& value);
  void add_old_records(const char* value);
  void add_old_records(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& old_records() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_old_records();
  private:
  const std::string& _internal_old_records(int index) const;
  std::string* _internal_add_old_records();
  public:

  // required int64 index_id = 1;
  bool has_index_id() const;
  private:
  bool _internal_has_index_id() const;
  public:
  void clear_index_id();
  ::PROTOBUF_NAMESPACE_ID::int64 index_id() const;
  void set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_index_id() const;
  void _internal_set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool local_index_binlog = 4;
  bool has_local_index_binlog() const;
  private:
  bool _internal_has_local_index_binlog() const;
  public:
  void clear_local_index_binlog();
  bool local_index_binlog() const;
  void set_local_index_binlog(bool value);
  private:
  bool _internal_local_index_binlog() const;
  void _internal_set_local_index_binlog(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.IndexRecords)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> records_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> old_records_;
  ::PROTOBUF_NAMESPACE_ID::int64 index_id_;
  bool local_index_binlog_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RegionRaftStat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RegionRaftStat) */ {
 public:
  inline RegionRaftStat() : RegionRaftStat(nullptr) {}
  ~RegionRaftStat() override;
  explicit constexpr RegionRaftStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionRaftStat(const RegionRaftStat& from);
  RegionRaftStat(RegionRaftStat&& from) noexcept
    : RegionRaftStat() {
    *this = ::std::move(from);
  }

  inline RegionRaftStat& operator=(const RegionRaftStat& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionRaftStat& operator=(RegionRaftStat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionRaftStat& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionRaftStat* internal_default_instance() {
    return reinterpret_cast<const RegionRaftStat*>(
               &_RegionRaftStat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RegionRaftStat& a, RegionRaftStat& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionRaftStat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionRaftStat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionRaftStat* New() const final {
    return new RegionRaftStat();
  }

  RegionRaftStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionRaftStat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionRaftStat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegionRaftStat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionRaftStat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RegionRaftStat";
  }
  protected:
  explicit RegionRaftStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppliedIndexFieldNumber = 1,
    kSnapshotDataSizeFieldNumber = 2,
    kSnapshotMetaSizeFieldNumber = 3,
    kSnapshotIndexFieldNumber = 4,
    kDmlLatencyFieldNumber = 5,
  };
  // optional int64 applied_index = 1;
  bool has_applied_index() const;
  private:
  bool _internal_has_applied_index() const;
  public:
  void clear_applied_index();
  ::PROTOBUF_NAMESPACE_ID::int64 applied_index() const;
  void set_applied_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_applied_index() const;
  void _internal_set_applied_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint64 snapshot_data_size = 2;
  bool has_snapshot_data_size() const;
  private:
  bool _internal_has_snapshot_data_size() const;
  public:
  void clear_snapshot_data_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 snapshot_data_size() const;
  void set_snapshot_data_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_snapshot_data_size() const;
  void _internal_set_snapshot_data_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 snapshot_meta_size = 3;
  bool has_snapshot_meta_size() const;
  private:
  bool _internal_has_snapshot_meta_size() const;
  public:
  void clear_snapshot_meta_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 snapshot_meta_size() const;
  void set_snapshot_meta_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_snapshot_meta_size() const;
  void _internal_set_snapshot_meta_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int64 snapshot_index = 4;
  bool has_snapshot_index() const;
  private:
  bool _internal_has_snapshot_index() const;
  public:
  void clear_snapshot_index();
  ::PROTOBUF_NAMESPACE_ID::int64 snapshot_index() const;
  void set_snapshot_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_snapshot_index() const;
  void _internal_set_snapshot_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 dml_latency = 5;
  bool has_dml_latency() const;
  private:
  bool _internal_has_dml_latency() const;
  public:
  void clear_dml_latency();
  ::PROTOBUF_NAMESPACE_ID::int64 dml_latency() const;
  void set_dml_latency(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_dml_latency() const;
  void _internal_set_dml_latency(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RegionRaftStat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 applied_index_;
  ::PROTOBUF_NAMESPACE_ID::uint64 snapshot_data_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 snapshot_meta_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 snapshot_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 dml_latency_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RocksStatisticReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RocksStatisticReq) */ {
 public:
  inline RocksStatisticReq() : RocksStatisticReq(nullptr) {}
  ~RocksStatisticReq() override;
  explicit constexpr RocksStatisticReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RocksStatisticReq(const RocksStatisticReq& from);
  RocksStatisticReq(RocksStatisticReq&& from) noexcept
    : RocksStatisticReq() {
    *this = ::std::move(from);
  }

  inline RocksStatisticReq& operator=(const RocksStatisticReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RocksStatisticReq& operator=(RocksStatisticReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RocksStatisticReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RocksStatisticReq* internal_default_instance() {
    return reinterpret_cast<const RocksStatisticReq*>(
               &_RocksStatisticReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RocksStatisticReq& a, RocksStatisticReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RocksStatisticReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RocksStatisticReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RocksStatisticReq* New() const final {
    return new RocksStatisticReq();
  }

  RocksStatisticReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RocksStatisticReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RocksStatisticReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RocksStatisticReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RocksStatisticReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RocksStatisticReq";
  }
  protected:
  explicit RocksStatisticReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 1,
  };
  // repeated bytes keys = 1;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RocksStatisticReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RocksStatisticRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RocksStatisticRes) */ {
 public:
  inline RocksStatisticRes() : RocksStatisticRes(nullptr) {}
  ~RocksStatisticRes() override;
  explicit constexpr RocksStatisticRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RocksStatisticRes(const RocksStatisticRes& from);
  RocksStatisticRes(RocksStatisticRes&& from) noexcept
    : RocksStatisticRes() {
    *this = ::std::move(from);
  }

  inline RocksStatisticRes& operator=(const RocksStatisticRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline RocksStatisticRes& operator=(RocksStatisticRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RocksStatisticRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const RocksStatisticRes* internal_default_instance() {
    return reinterpret_cast<const RocksStatisticRes*>(
               &_RocksStatisticRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RocksStatisticRes& a, RocksStatisticRes& b) {
    a.Swap(&b);
  }
  inline void Swap(RocksStatisticRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RocksStatisticRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RocksStatisticRes* New() const final {
    return new RocksStatisticRes();
  }

  RocksStatisticRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RocksStatisticRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RocksStatisticRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RocksStatisticRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RocksStatisticRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RocksStatisticRes";
  }
  protected:
  explicit RocksStatisticRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 4,
    kValueFieldNumber = 5,
    kLevel0SstNumFieldNumber = 2,
    kCompactionDataSizeFieldNumber = 3,
    kErrcodeFieldNumber = 1,
  };
  // repeated bytes key = 4;
  int key_size() const;
  private:
  int _internal_key_size() const;
  public:
  void clear_key();
  const std::string& key(int index) const;
  std::string* mutable_key(int index);
  void set_key(int index, const std::string& value);
  void set_key(int index, std::string&& value);
  void set_key(int index, const char* value);
  void set_key(int index, const void* value, size_t size);
  std::string* add_key();
  void add_key(const std::string& value);
  void add_key(std::string&& value);
  void add_key(const char* value);
  void add_key(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& key() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_key();
  private:
  const std::string& _internal_key(int index) const;
  std::string* _internal_add_key();
  public:

  // repeated bytes value = 5;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  const std::string& value(int index) const;
  std::string* mutable_value(int index);
  void set_value(int index, const std::string& value);
  void set_value(int index, std::string&& value);
  void set_value(int index, const char* value);
  void set_value(int index, const void* value, size_t size);
  std::string* add_value();
  void add_value(const std::string& value);
  void add_value(std::string&& value);
  void add_value(const char* value);
  void add_value(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_value();
  private:
  const std::string& _internal_value(int index) const;
  std::string* _internal_add_value();
  public:

  // optional uint64 level0_sst_num = 2;
  bool has_level0_sst_num() const;
  private:
  bool _internal_has_level0_sst_num() const;
  public:
  void clear_level0_sst_num();
  ::PROTOBUF_NAMESPACE_ID::uint64 level0_sst_num() const;
  void set_level0_sst_num(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_level0_sst_num() const;
  void _internal_set_level0_sst_num(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 compaction_data_size = 3;
  bool has_compaction_data_size() const;
  private:
  bool _internal_has_compaction_data_size() const;
  public:
  void clear_compaction_data_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 compaction_data_size() const;
  void set_compaction_data_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_compaction_data_size() const;
  void _internal_set_compaction_data_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required .baikaldb.pb.ErrCode errcode = 1;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::ErrCode errcode() const;
  void set_errcode(::baikaldb::pb::ErrCode value);
  private:
  ::baikaldb::pb::ErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::ErrCode value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RocksStatisticRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> key_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> value_;
  ::PROTOBUF_NAMESPACE_ID::uint64 level0_sst_num_;
  ::PROTOBUF_NAMESPACE_ID::uint64 compaction_data_size_;
  int errcode_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BinlogQueryInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BinlogQueryInfo) */ {
 public:
  inline BinlogQueryInfo() : BinlogQueryInfo(nullptr) {}
  ~BinlogQueryInfo() override;
  explicit constexpr BinlogQueryInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinlogQueryInfo(const BinlogQueryInfo& from);
  BinlogQueryInfo(BinlogQueryInfo&& from) noexcept
    : BinlogQueryInfo() {
    *this = ::std::move(from);
  }

  inline BinlogQueryInfo& operator=(const BinlogQueryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinlogQueryInfo& operator=(BinlogQueryInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinlogQueryInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinlogQueryInfo* internal_default_instance() {
    return reinterpret_cast<const BinlogQueryInfo*>(
               &_BinlogQueryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(BinlogQueryInfo& a, BinlogQueryInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BinlogQueryInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinlogQueryInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinlogQueryInfo* New() const final {
    return new BinlogQueryInfo();
  }

  BinlogQueryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinlogQueryInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinlogQueryInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BinlogQueryInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinlogQueryInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BinlogQueryInfo";
  }
  protected:
  explicit BinlogQueryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIpFieldNumber = 7,
    kRegionIdFieldNumber = 1,
    kOldestTsFieldNumber = 2,
    kCheckPointTsFieldNumber = 3,
    kRegionOldestTsFieldNumber = 4,
    kBinlogCfOldestTsFieldNumber = 5,
    kDataCfOldestTsFieldNumber = 6,
  };
  // optional string region_ip = 7;
  bool has_region_ip() const;
  private:
  bool _internal_has_region_ip() const;
  public:
  void clear_region_ip();
  const std::string& region_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region_ip();
  PROTOBUF_MUST_USE_RESULT std::string* release_region_ip();
  void set_allocated_region_ip(std::string* region_ip);
  private:
  const std::string& _internal_region_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region_ip(const std::string& value);
  std::string* _internal_mutable_region_ip();
  public:

  // optional int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 oldest_ts = 2;
  bool has_oldest_ts() const;
  private:
  bool _internal_has_oldest_ts() const;
  public:
  void clear_oldest_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 oldest_ts() const;
  void set_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_oldest_ts() const;
  void _internal_set_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 check_point_ts = 3;
  bool has_check_point_ts() const;
  private:
  bool _internal_has_check_point_ts() const;
  public:
  void clear_check_point_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 check_point_ts() const;
  void set_check_point_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_check_point_ts() const;
  void _internal_set_check_point_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_oldest_ts = 4;
  bool has_region_oldest_ts() const;
  private:
  bool _internal_has_region_oldest_ts() const;
  public:
  void clear_region_oldest_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 region_oldest_ts() const;
  void set_region_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_oldest_ts() const;
  void _internal_set_region_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 binlog_cf_oldest_ts = 5;
  bool has_binlog_cf_oldest_ts() const;
  private:
  bool _internal_has_binlog_cf_oldest_ts() const;
  public:
  void clear_binlog_cf_oldest_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 binlog_cf_oldest_ts() const;
  void set_binlog_cf_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_binlog_cf_oldest_ts() const;
  void _internal_set_binlog_cf_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 data_cf_oldest_ts = 6;
  bool has_data_cf_oldest_ts() const;
  private:
  bool _internal_has_data_cf_oldest_ts() const;
  public:
  void clear_data_cf_oldest_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 data_cf_oldest_ts() const;
  void set_data_cf_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_data_cf_oldest_ts() const;
  void _internal_set_data_cf_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BinlogQueryInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_ip_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 oldest_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 check_point_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_oldest_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 binlog_cf_oldest_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 data_cf_oldest_ts_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class StoreRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.StoreRes) */ {
 public:
  inline StoreRes() : StoreRes(nullptr) {}
  ~StoreRes() override;
  explicit constexpr StoreRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreRes(const StoreRes& from);
  StoreRes(StoreRes&& from) noexcept
    : StoreRes() {
    *this = ::std::move(from);
  }

  inline StoreRes& operator=(const StoreRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreRes& operator=(StoreRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreRes* internal_default_instance() {
    return reinterpret_cast<const StoreRes*>(
               &_StoreRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(StoreRes& a, StoreRes& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StoreRes* New() const final {
    return new StoreRes();
  }

  StoreRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StoreRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.StoreRes";
  }
  protected:
  explicit StoreRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTupleIdsFieldNumber = 4,
    kRowValuesFieldNumber = 5,
    kRegionsFieldNumber = 7,
    kTxnInfosFieldNumber = 10,
    kRegionLeadersFieldNumber = 13,
    kRecordsFieldNumber = 15,
    kBinlogsFieldNumber = 19,
    kCommitTsFieldNumber = 20,
    kTtlTimestampFieldNumber = 24,
    kErrmsgFieldNumber = 2,
    kLeaderFieldNumber = 3,
    kCmsketchFieldNumber = 17,
    kRegionRaftStatFieldNumber = 23,
    kExtraResFieldNumber = 25,
    kBinlogInfoFieldNumber = 26,
    kHllFieldNumber = 30,
    kErrcodeFieldNumber = 1,
    kLastSeqIdFieldNumber = 9,
    kAffectedRowsFieldNumber = 6,
    kAppliedIndexFieldNumber = 8,
    kRegionCountFieldNumber = 12,
    kMysqlErrcodeFieldNumber = 11,
    kIsMergeFieldNumber = 14,
    kScanRowsFieldNumber = 16,
    kFilterRowsFieldNumber = 18,
    kLastInsertIdFieldNumber = 22,
    kRegionStatusFieldNumber = 21,
    kExecuteTypeFieldNumber = 27,
    kReadDiskSizeFieldNumber = 28,
    kOrigRegionIdFieldNumber = 29,
  };
  // repeated int32 tuple_ids = 4;
  int tuple_ids_size() const;
  private:
  int _internal_tuple_ids_size() const;
  public:
  void clear_tuple_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tuple_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_tuple_ids() const;
  void _internal_add_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_tuple_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 tuple_ids(int index) const;
  void set_tuple_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      tuple_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_tuple_ids();

  // repeated .baikaldb.pb.RowValue row_values = 5;
  int row_values_size() const;
  private:
  int _internal_row_values_size() const;
  public:
  void clear_row_values();
  ::baikaldb::pb::RowValue* mutable_row_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RowValue >*
      mutable_row_values();
  private:
  const ::baikaldb::pb::RowValue& _internal_row_values(int index) const;
  ::baikaldb::pb::RowValue* _internal_add_row_values();
  public:
  const ::baikaldb::pb::RowValue& row_values(int index) const;
  ::baikaldb::pb::RowValue* add_row_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RowValue >&
      row_values() const;

  // repeated .baikaldb.pb.RegionInfo regions = 7;
  int regions_size() const;
  private:
  int _internal_regions_size() const;
  public:
  void clear_regions();
  ::baikaldb::pb::RegionInfo* mutable_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >*
      mutable_regions();
  private:
  const ::baikaldb::pb::RegionInfo& _internal_regions(int index) const;
  ::baikaldb::pb::RegionInfo* _internal_add_regions();
  public:
  const ::baikaldb::pb::RegionInfo& regions(int index) const;
  ::baikaldb::pb::RegionInfo* add_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >&
      regions() const;

  // repeated .baikaldb.pb.TransactionInfo txn_infos = 10;
  int txn_infos_size() const;
  private:
  int _internal_txn_infos_size() const;
  public:
  void clear_txn_infos();
  ::baikaldb::pb::TransactionInfo* mutable_txn_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TransactionInfo >*
      mutable_txn_infos();
  private:
  const ::baikaldb::pb::TransactionInfo& _internal_txn_infos(int index) const;
  ::baikaldb::pb::TransactionInfo* _internal_add_txn_infos();
  public:
  const ::baikaldb::pb::TransactionInfo& txn_infos(int index) const;
  ::baikaldb::pb::TransactionInfo* add_txn_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TransactionInfo >&
      txn_infos() const;

  // repeated .baikaldb.pb.RegionLeader region_leaders = 13;
  int region_leaders_size() const;
  private:
  int _internal_region_leaders_size() const;
  public:
  void clear_region_leaders();
  ::baikaldb::pb::RegionLeader* mutable_region_leaders(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionLeader >*
      mutable_region_leaders();
  private:
  const ::baikaldb::pb::RegionLeader& _internal_region_leaders(int index) const;
  ::baikaldb::pb::RegionLeader* _internal_add_region_leaders();
  public:
  const ::baikaldb::pb::RegionLeader& region_leaders(int index) const;
  ::baikaldb::pb::RegionLeader* add_region_leaders();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionLeader >&
      region_leaders() const;

  // repeated .baikaldb.pb.IndexRecords records = 15;
  int records_size() const;
  private:
  int _internal_records_size() const;
  public:
  void clear_records();
  ::baikaldb::pb::IndexRecords* mutable_records(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::IndexRecords >*
      mutable_records();
  private:
  const ::baikaldb::pb::IndexRecords& _internal_records(int index) const;
  ::baikaldb::pb::IndexRecords* _internal_add_records();
  public:
  const ::baikaldb::pb::IndexRecords& records(int index) const;
  ::baikaldb::pb::IndexRecords* add_records();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::IndexRecords >&
      records() const;

  // repeated bytes binlogs = 19;
  int binlogs_size() const;
  private:
  int _internal_binlogs_size() const;
  public:
  void clear_binlogs();
  const std::string& binlogs(int index) const;
  std::string* mutable_binlogs(int index);
  void set_binlogs(int index, const std::string& value);
  void set_binlogs(int index, std::string&& value);
  void set_binlogs(int index, const char* value);
  void set_binlogs(int index, const void* value, size_t size);
  std::string* add_binlogs();
  void add_binlogs(const std::string& value);
  void add_binlogs(std::string&& value);
  void add_binlogs(const char* value);
  void add_binlogs(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& binlogs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_binlogs();
  private:
  const std::string& _internal_binlogs(int index) const;
  std::string* _internal_add_binlogs();
  public:

  // repeated int64 commit_ts = 20;
  int commit_ts_size() const;
  private:
  int _internal_commit_ts_size() const;
  public:
  void clear_commit_ts();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_commit_ts(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_commit_ts() const;
  void _internal_add_commit_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_commit_ts();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 commit_ts(int index) const;
  void set_commit_ts(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_commit_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      commit_ts() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_commit_ts();

  // repeated int64 ttl_timestamp = 24;
  int ttl_timestamp_size() const;
  private:
  int _internal_ttl_timestamp_size() const;
  public:
  void clear_ttl_timestamp();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ttl_timestamp(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_ttl_timestamp() const;
  void _internal_add_ttl_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_ttl_timestamp();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 ttl_timestamp(int index) const;
  void set_ttl_timestamp(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_ttl_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      ttl_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_ttl_timestamp();

  // optional bytes errmsg = 2;
  bool has_errmsg() const;
  private:
  bool _internal_has_errmsg() const;
  public:
  void clear_errmsg();
  const std::string& errmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errmsg();
  PROTOBUF_MUST_USE_RESULT std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // optional string leader = 3;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // optional .baikaldb.pb.CMsketch cmsketch = 17;
  bool has_cmsketch() const;
  private:
  bool _internal_has_cmsketch() const;
  public:
  void clear_cmsketch();
  const ::baikaldb::pb::CMsketch& cmsketch() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::CMsketch* release_cmsketch();
  ::baikaldb::pb::CMsketch* mutable_cmsketch();
  void set_allocated_cmsketch(::baikaldb::pb::CMsketch* cmsketch);
  private:
  const ::baikaldb::pb::CMsketch& _internal_cmsketch() const;
  ::baikaldb::pb::CMsketch* _internal_mutable_cmsketch();
  public:
  void unsafe_arena_set_allocated_cmsketch(
      ::baikaldb::pb::CMsketch* cmsketch);
  ::baikaldb::pb::CMsketch* unsafe_arena_release_cmsketch();

  // optional .baikaldb.pb.RegionRaftStat region_raft_stat = 23;
  bool has_region_raft_stat() const;
  private:
  bool _internal_has_region_raft_stat() const;
  public:
  void clear_region_raft_stat();
  const ::baikaldb::pb::RegionRaftStat& region_raft_stat() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionRaftStat* release_region_raft_stat();
  ::baikaldb::pb::RegionRaftStat* mutable_region_raft_stat();
  void set_allocated_region_raft_stat(::baikaldb::pb::RegionRaftStat* region_raft_stat);
  private:
  const ::baikaldb::pb::RegionRaftStat& _internal_region_raft_stat() const;
  ::baikaldb::pb::RegionRaftStat* _internal_mutable_region_raft_stat();
  public:
  void unsafe_arena_set_allocated_region_raft_stat(
      ::baikaldb::pb::RegionRaftStat* region_raft_stat);
  ::baikaldb::pb::RegionRaftStat* unsafe_arena_release_region_raft_stat();

  // optional .baikaldb.pb.ExtraRes extra_res = 25;
  bool has_extra_res() const;
  private:
  bool _internal_has_extra_res() const;
  public:
  void clear_extra_res();
  const ::baikaldb::pb::ExtraRes& extra_res() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::ExtraRes* release_extra_res();
  ::baikaldb::pb::ExtraRes* mutable_extra_res();
  void set_allocated_extra_res(::baikaldb::pb::ExtraRes* extra_res);
  private:
  const ::baikaldb::pb::ExtraRes& _internal_extra_res() const;
  ::baikaldb::pb::ExtraRes* _internal_mutable_extra_res();
  public:
  void unsafe_arena_set_allocated_extra_res(
      ::baikaldb::pb::ExtraRes* extra_res);
  ::baikaldb::pb::ExtraRes* unsafe_arena_release_extra_res();

  // optional .baikaldb.pb.BinlogQueryInfo binlog_info = 26;
  bool has_binlog_info() const;
  private:
  bool _internal_has_binlog_info() const;
  public:
  void clear_binlog_info();
  const ::baikaldb::pb::BinlogQueryInfo& binlog_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::BinlogQueryInfo* release_binlog_info();
  ::baikaldb::pb::BinlogQueryInfo* mutable_binlog_info();
  void set_allocated_binlog_info(::baikaldb::pb::BinlogQueryInfo* binlog_info);
  private:
  const ::baikaldb::pb::BinlogQueryInfo& _internal_binlog_info() const;
  ::baikaldb::pb::BinlogQueryInfo* _internal_mutable_binlog_info();
  public:
  void unsafe_arena_set_allocated_binlog_info(
      ::baikaldb::pb::BinlogQueryInfo* binlog_info);
  ::baikaldb::pb::BinlogQueryInfo* unsafe_arena_release_binlog_info();

  // optional .baikaldb.pb.HyperLogLog hll = 30;
  bool has_hll() const;
  private:
  bool _internal_has_hll() const;
  public:
  void clear_hll();
  const ::baikaldb::pb::HyperLogLog& hll() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::HyperLogLog* release_hll();
  ::baikaldb::pb::HyperLogLog* mutable_hll();
  void set_allocated_hll(::baikaldb::pb::HyperLogLog* hll);
  private:
  const ::baikaldb::pb::HyperLogLog& _internal_hll() const;
  ::baikaldb::pb::HyperLogLog* _internal_mutable_hll();
  public:
  void unsafe_arena_set_allocated_hll(
      ::baikaldb::pb::HyperLogLog* hll);
  ::baikaldb::pb::HyperLogLog* unsafe_arena_release_hll();

  // required .baikaldb.pb.ErrCode errcode = 1;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::ErrCode errcode() const;
  void set_errcode(::baikaldb::pb::ErrCode value);
  private:
  ::baikaldb::pb::ErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::ErrCode value);
  public:

  // optional int32 last_seq_id = 9;
  bool has_last_seq_id() const;
  private:
  bool _internal_has_last_seq_id() const;
  public:
  void clear_last_seq_id();
  ::PROTOBUF_NAMESPACE_ID::int32 last_seq_id() const;
  void set_last_seq_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_last_seq_id() const;
  void _internal_set_last_seq_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int64 affected_rows = 6;
  bool has_affected_rows() const;
  private:
  bool _internal_has_affected_rows() const;
  public:
  void clear_affected_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 affected_rows() const;
  void set_affected_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_affected_rows() const;
  void _internal_set_affected_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 applied_index = 8;
  bool has_applied_index() const;
  private:
  bool _internal_has_applied_index() const;
  public:
  void clear_applied_index();
  ::PROTOBUF_NAMESPACE_ID::int64 applied_index() const;
  void set_applied_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_applied_index() const;
  void _internal_set_applied_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_count = 12;
  bool has_region_count() const;
  private:
  bool _internal_has_region_count() const;
  public:
  void clear_region_count();
  ::PROTOBUF_NAMESPACE_ID::int64 region_count() const;
  void set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_count() const;
  void _internal_set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 mysql_errcode = 11;
  bool has_mysql_errcode() const;
  private:
  bool _internal_has_mysql_errcode() const;
  public:
  void clear_mysql_errcode();
  ::PROTOBUF_NAMESPACE_ID::int32 mysql_errcode() const;
  void set_mysql_errcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_mysql_errcode() const;
  void _internal_set_mysql_errcode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool is_merge = 14;
  bool has_is_merge() const;
  private:
  bool _internal_has_is_merge() const;
  public:
  void clear_is_merge();
  bool is_merge() const;
  void set_is_merge(bool value);
  private:
  bool _internal_is_merge() const;
  void _internal_set_is_merge(bool value);
  public:

  // optional int64 scan_rows = 16;
  bool has_scan_rows() const;
  private:
  bool _internal_has_scan_rows() const;
  public:
  void clear_scan_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 scan_rows() const;
  void set_scan_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_scan_rows() const;
  void _internal_set_scan_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 filter_rows = 18;
  bool has_filter_rows() const;
  private:
  bool _internal_has_filter_rows() const;
  public:
  void clear_filter_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 filter_rows() const;
  void set_filter_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_filter_rows() const;
  void _internal_set_filter_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 last_insert_id = 22;
  bool has_last_insert_id() const;
  private:
  bool _internal_has_last_insert_id() const;
  public:
  void clear_last_insert_id();
  ::PROTOBUF_NAMESPACE_ID::int64 last_insert_id() const;
  void set_last_insert_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_last_insert_id() const;
  void _internal_set_last_insert_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.PeerStatus region_status = 21;
  bool has_region_status() const;
  private:
  bool _internal_has_region_status() const;
  public:
  void clear_region_status();
  ::baikaldb::pb::PeerStatus region_status() const;
  void set_region_status(::baikaldb::pb::PeerStatus value);
  private:
  ::baikaldb::pb::PeerStatus _internal_region_status() const;
  void _internal_set_region_status(::baikaldb::pb::PeerStatus value);
  public:

  // optional .baikaldb.pb.ExecuteType execute_type = 27;
  bool has_execute_type() const;
  private:
  bool _internal_has_execute_type() const;
  public:
  void clear_execute_type();
  ::baikaldb::pb::ExecuteType execute_type() const;
  void set_execute_type(::baikaldb::pb::ExecuteType value);
  private:
  ::baikaldb::pb::ExecuteType _internal_execute_type() const;
  void _internal_set_execute_type(::baikaldb::pb::ExecuteType value);
  public:

  // optional int64 read_disk_size = 28;
  bool has_read_disk_size() const;
  private:
  bool _internal_has_read_disk_size() const;
  public:
  void clear_read_disk_size();
  ::PROTOBUF_NAMESPACE_ID::int64 read_disk_size() const;
  void set_read_disk_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_read_disk_size() const;
  void _internal_set_read_disk_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 orig_region_id = 29;
  bool has_orig_region_id() const;
  private:
  bool _internal_has_orig_region_id() const;
  public:
  void clear_orig_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 orig_region_id() const;
  void set_orig_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_orig_region_id() const;
  void _internal_set_orig_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.StoreRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > tuple_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RowValue > row_values_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo > regions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TransactionInfo > txn_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionLeader > region_leaders_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::IndexRecords > records_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> binlogs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > commit_ts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > ttl_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  ::baikaldb::pb::CMsketch* cmsketch_;
  ::baikaldb::pb::RegionRaftStat* region_raft_stat_;
  ::baikaldb::pb::ExtraRes* extra_res_;
  ::baikaldb::pb::BinlogQueryInfo* binlog_info_;
  ::baikaldb::pb::HyperLogLog* hll_;
  int errcode_;
  ::PROTOBUF_NAMESPACE_ID::int32 last_seq_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 affected_rows_;
  ::PROTOBUF_NAMESPACE_ID::int64 applied_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 mysql_errcode_;
  bool is_merge_;
  ::PROTOBUF_NAMESPACE_ID::int64 scan_rows_;
  ::PROTOBUF_NAMESPACE_ID::int64 filter_rows_;
  ::PROTOBUF_NAMESPACE_ID::int64 last_insert_id_;
  int region_status_;
  int execute_type_;
  ::PROTOBUF_NAMESPACE_ID::int64 read_disk_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 orig_region_id_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BatchRegionStoreReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BatchRegionStoreReq) */ {
 public:
  inline BatchRegionStoreReq() : BatchRegionStoreReq(nullptr) {}
  ~BatchRegionStoreReq() override;
  explicit constexpr BatchRegionStoreReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchRegionStoreReq(const BatchRegionStoreReq& from);
  BatchRegionStoreReq(BatchRegionStoreReq&& from) noexcept
    : BatchRegionStoreReq() {
    *this = ::std::move(from);
  }

  inline BatchRegionStoreReq& operator=(const BatchRegionStoreReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchRegionStoreReq& operator=(BatchRegionStoreReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchRegionStoreReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchRegionStoreReq* internal_default_instance() {
    return reinterpret_cast<const BatchRegionStoreReq*>(
               &_BatchRegionStoreReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(BatchRegionStoreReq& a, BatchRegionStoreReq& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchRegionStoreReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchRegionStoreReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatchRegionStoreReq* New() const final {
    return new BatchRegionStoreReq();
  }

  BatchRegionStoreReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatchRegionStoreReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchRegionStoreReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatchRegionStoreReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchRegionStoreReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BatchRegionStoreReq";
  }
  protected:
  explicit BatchRegionStoreReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreReqFieldNumber = 1,
    kPlanFieldNumber = 3,
    kLimitSingleStoreConcurrencyFieldNumber = 2,
  };
  // repeated .baikaldb.pb.StoreReq store_req = 1;
  int store_req_size() const;
  private:
  int _internal_store_req_size() const;
  public:
  void clear_store_req();
  ::baikaldb::pb::StoreReq* mutable_store_req(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::StoreReq >*
      mutable_store_req();
  private:
  const ::baikaldb::pb::StoreReq& _internal_store_req(int index) const;
  ::baikaldb::pb::StoreReq* _internal_add_store_req();
  public:
  const ::baikaldb::pb::StoreReq& store_req(int index) const;
  ::baikaldb::pb::StoreReq* add_store_req();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::StoreReq >&
      store_req() const;

  // repeated .baikaldb.pb.Plan plan = 3;
  int plan_size() const;
  private:
  int _internal_plan_size() const;
  public:
  void clear_plan();
  ::baikaldb::pb::Plan* mutable_plan(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Plan >*
      mutable_plan();
  private:
  const ::baikaldb::pb::Plan& _internal_plan(int index) const;
  ::baikaldb::pb::Plan* _internal_add_plan();
  public:
  const ::baikaldb::pb::Plan& plan(int index) const;
  ::baikaldb::pb::Plan* add_plan();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Plan >&
      plan() const;

  // required int64 limit_single_store_concurrency = 2;
  bool has_limit_single_store_concurrency() const;
  private:
  bool _internal_has_limit_single_store_concurrency() const;
  public:
  void clear_limit_single_store_concurrency();
  ::PROTOBUF_NAMESPACE_ID::int64 limit_single_store_concurrency() const;
  void set_limit_single_store_concurrency(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_limit_single_store_concurrency() const;
  void _internal_set_limit_single_store_concurrency(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BatchRegionStoreReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::StoreReq > store_req_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Plan > plan_;
  ::PROTOBUF_NAMESPACE_ID::int64 limit_single_store_concurrency_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BatchRegionStoreRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BatchRegionStoreRes) */ {
 public:
  inline BatchRegionStoreRes() : BatchRegionStoreRes(nullptr) {}
  ~BatchRegionStoreRes() override;
  explicit constexpr BatchRegionStoreRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchRegionStoreRes(const BatchRegionStoreRes& from);
  BatchRegionStoreRes(BatchRegionStoreRes&& from) noexcept
    : BatchRegionStoreRes() {
    *this = ::std::move(from);
  }

  inline BatchRegionStoreRes& operator=(const BatchRegionStoreRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchRegionStoreRes& operator=(BatchRegionStoreRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchRegionStoreRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchRegionStoreRes* internal_default_instance() {
    return reinterpret_cast<const BatchRegionStoreRes*>(
               &_BatchRegionStoreRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(BatchRegionStoreRes& a, BatchRegionStoreRes& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchRegionStoreRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchRegionStoreRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatchRegionStoreRes* New() const final {
    return new BatchRegionStoreRes();
  }

  BatchRegionStoreRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatchRegionStoreRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchRegionStoreRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatchRegionStoreRes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchRegionStoreRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BatchRegionStoreRes";
  }
  protected:
  explicit BatchRegionStoreRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreResFieldNumber = 1,
  };
  // repeated .baikaldb.pb.StoreRes store_res = 1;
  int store_res_size() const;
  private:
  int _internal_store_res_size() const;
  public:
  void clear_store_res();
  ::baikaldb::pb::StoreRes* mutable_store_res(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::StoreRes >*
      mutable_store_res();
  private:
  const ::baikaldb::pb::StoreRes& _internal_store_res(int index) const;
  ::baikaldb::pb::StoreRes* _internal_add_store_res();
  public:
  const ::baikaldb::pb::StoreRes& store_res(int index) const;
  ::baikaldb::pb::StoreRes* add_store_res();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::StoreRes >&
      store_res() const;

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BatchRegionStoreRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::StoreRes > store_res_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class InitRegion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.InitRegion) */ {
 public:
  inline InitRegion() : InitRegion(nullptr) {}
  ~InitRegion() override;
  explicit constexpr InitRegion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitRegion(const InitRegion& from);
  InitRegion(InitRegion&& from) noexcept
    : InitRegion() {
    *this = ::std::move(from);
  }

  inline InitRegion& operator=(const InitRegion& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitRegion& operator=(InitRegion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitRegion& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitRegion* internal_default_instance() {
    return reinterpret_cast<const InitRegion*>(
               &_InitRegion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(InitRegion& a, InitRegion& b) {
    a.Swap(&b);
  }
  inline void Swap(InitRegion* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitRegion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InitRegion* New() const final {
    return new InitRegion();
  }

  InitRegion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InitRegion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitRegion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InitRegion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitRegion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.InitRegion";
  }
  protected:
  explicit InitRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionInfoFieldNumber = 1,
    kSchemaInfoFieldNumber = 2,
    kSnapshotTimesFieldNumber = 4,
    kIsSplitFieldNumber = 3,
    kIsLearnerFieldNumber = 5,
  };
  // required .baikaldb.pb.RegionInfo region_info = 1;
  bool has_region_info() const;
  private:
  bool _internal_has_region_info() const;
  public:
  void clear_region_info();
  const ::baikaldb::pb::RegionInfo& region_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionInfo* release_region_info();
  ::baikaldb::pb::RegionInfo* mutable_region_info();
  void set_allocated_region_info(::baikaldb::pb::RegionInfo* region_info);
  private:
  const ::baikaldb::pb::RegionInfo& _internal_region_info() const;
  ::baikaldb::pb::RegionInfo* _internal_mutable_region_info();
  public:
  void unsafe_arena_set_allocated_region_info(
      ::baikaldb::pb::RegionInfo* region_info);
  ::baikaldb::pb::RegionInfo* unsafe_arena_release_region_info();

  // optional .baikaldb.pb.SchemaInfo schema_info = 2;
  bool has_schema_info() const;
  private:
  bool _internal_has_schema_info() const;
  public:
  void clear_schema_info();
  const ::baikaldb::pb::SchemaInfo& schema_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::SchemaInfo* release_schema_info();
  ::baikaldb::pb::SchemaInfo* mutable_schema_info();
  void set_allocated_schema_info(::baikaldb::pb::SchemaInfo* schema_info);
  private:
  const ::baikaldb::pb::SchemaInfo& _internal_schema_info() const;
  ::baikaldb::pb::SchemaInfo* _internal_mutable_schema_info();
  public:
  void unsafe_arena_set_allocated_schema_info(
      ::baikaldb::pb::SchemaInfo* schema_info);
  ::baikaldb::pb::SchemaInfo* unsafe_arena_release_schema_info();

  // optional int32 snapshot_times = 4;
  bool has_snapshot_times() const;
  private:
  bool _internal_has_snapshot_times() const;
  public:
  void clear_snapshot_times();
  ::PROTOBUF_NAMESPACE_ID::int32 snapshot_times() const;
  void set_snapshot_times(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_snapshot_times() const;
  void _internal_set_snapshot_times(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool is_split = 3;
  bool has_is_split() const;
  private:
  bool _internal_has_is_split() const;
  public:
  void clear_is_split();
  bool is_split() const;
  void set_is_split(bool value);
  private:
  bool _internal_is_split() const;
  void _internal_set_is_split(bool value);
  public:

  // optional bool is_learner = 5;
  bool has_is_learner() const;
  private:
  bool _internal_has_is_learner() const;
  public:
  void clear_is_learner();
  bool is_learner() const;
  void set_is_learner(bool value);
  private:
  bool _internal_is_learner() const;
  void _internal_set_is_learner(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.InitRegion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::RegionInfo* region_info_;
  ::baikaldb::pb::SchemaInfo* schema_info_;
  ::PROTOBUF_NAMESPACE_ID::int32 snapshot_times_;
  bool is_split_;
  bool is_learner_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class GetAppliedIndex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.GetAppliedIndex) */ {
 public:
  inline GetAppliedIndex() : GetAppliedIndex(nullptr) {}
  ~GetAppliedIndex() override;
  explicit constexpr GetAppliedIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAppliedIndex(const GetAppliedIndex& from);
  GetAppliedIndex(GetAppliedIndex&& from) noexcept
    : GetAppliedIndex() {
    *this = ::std::move(from);
  }

  inline GetAppliedIndex& operator=(const GetAppliedIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAppliedIndex& operator=(GetAppliedIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAppliedIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAppliedIndex* internal_default_instance() {
    return reinterpret_cast<const GetAppliedIndex*>(
               &_GetAppliedIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetAppliedIndex& a, GetAppliedIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAppliedIndex* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAppliedIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetAppliedIndex* New() const final {
    return new GetAppliedIndex();
  }

  GetAppliedIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAppliedIndex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAppliedIndex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAppliedIndex& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAppliedIndex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.GetAppliedIndex";
  }
  protected:
  explicit GetAppliedIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
    kUseReadIdxFieldNumber = 2,
    kUseRaftLogIndexFieldNumber = 3,
  };
  // required int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool use_read_idx = 2;
  bool has_use_read_idx() const;
  private:
  bool _internal_has_use_read_idx() const;
  public:
  void clear_use_read_idx();
  bool use_read_idx() const;
  void set_use_read_idx(bool value);
  private:
  bool _internal_use_read_idx() const;
  void _internal_set_use_read_idx(bool value);
  public:

  // optional bool use_raft_log_index = 3;
  bool has_use_raft_log_index() const;
  private:
  bool _internal_has_use_raft_log_index() const;
  public:
  void clear_use_raft_log_index();
  bool use_raft_log_index() const;
  void set_use_raft_log_index(bool value);
  private:
  bool _internal_use_raft_log_index() const;
  void _internal_set_use_raft_log_index(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.GetAppliedIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  bool use_read_idx_;
  bool use_raft_log_index_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RemoveRegion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RemoveRegion) */ {
 public:
  inline RemoveRegion() : RemoveRegion(nullptr) {}
  ~RemoveRegion() override;
  explicit constexpr RemoveRegion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveRegion(const RemoveRegion& from);
  RemoveRegion(RemoveRegion&& from) noexcept
    : RemoveRegion() {
    *this = ::std::move(from);
  }

  inline RemoveRegion& operator=(const RemoveRegion& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveRegion& operator=(RemoveRegion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveRegion& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveRegion* internal_default_instance() {
    return reinterpret_cast<const RemoveRegion*>(
               &_RemoveRegion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(RemoveRegion& a, RemoveRegion& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveRegion* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveRegion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoveRegion* New() const final {
    return new RemoveRegion();
  }

  RemoveRegion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoveRegion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveRegion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoveRegion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveRegion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RemoveRegion";
  }
  protected:
  explicit RemoveRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
    kForceFieldNumber = 2,
    kNeedDelayDropFieldNumber = 3,
  };
  // required int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool force = 2;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // optional bool need_delay_drop = 3;
  bool has_need_delay_drop() const;
  private:
  bool _internal_has_need_delay_drop() const;
  public:
  void clear_need_delay_drop();
  bool need_delay_drop() const;
  void set_need_delay_drop(bool value);
  private:
  bool _internal_need_delay_drop() const;
  void _internal_set_need_delay_drop(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RemoveRegion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  bool force_;
  bool need_delay_drop_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RegionIds final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RegionIds) */ {
 public:
  inline RegionIds() : RegionIds(nullptr) {}
  ~RegionIds() override;
  explicit constexpr RegionIds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionIds(const RegionIds& from);
  RegionIds(RegionIds&& from) noexcept
    : RegionIds() {
    *this = ::std::move(from);
  }

  inline RegionIds& operator=(const RegionIds& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionIds& operator=(RegionIds&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionIds& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionIds* internal_default_instance() {
    return reinterpret_cast<const RegionIds*>(
               &_RegionIds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(RegionIds& a, RegionIds& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionIds* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionIds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionIds* New() const final {
    return new RegionIds();
  }

  RegionIds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionIds>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionIds& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegionIds& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionIds* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RegionIds";
  }
  protected:
  explicit RegionIds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdsFieldNumber = 1,
    kUseridsFieldNumber = 8,
    kTableIdFieldNumber = 3,
    kCompactTypeFieldNumber = 4,
    kCompactRaftLogFieldNumber = 2,
    kClearAllTxnsFieldNumber = 5,
    kQueryApplyIndexFieldNumber = 7,
    kQueryAllAfsFileFieldNumber = 9,
    kTxnTimeoutFieldNumber = 6,
    kQueryOlapKeypointFieldNumber = 10,
  };
  // repeated int64 region_ids = 1;
  int region_ids_size() const;
  private:
  int _internal_region_ids_size() const;
  public:
  void clear_region_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_region_ids() const;
  void _internal_add_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_region_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 region_ids(int index) const;
  void set_region_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      region_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_region_ids();

  // repeated int64 userids = 8;
  int userids_size() const;
  private:
  int _internal_userids_size() const;
  public:
  void clear_userids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_userids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_userids() const;
  void _internal_add_userids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_userids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 userids(int index) const;
  void set_userids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_userids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      userids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_userids();

  // optional int64 table_id = 3;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 compact_type = 4;
  bool has_compact_type() const;
  private:
  bool _internal_has_compact_type() const;
  public:
  void clear_compact_type();
  ::PROTOBUF_NAMESPACE_ID::int32 compact_type() const;
  void set_compact_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_compact_type() const;
  void _internal_set_compact_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool compact_raft_log = 2;
  bool has_compact_raft_log() const;
  private:
  bool _internal_has_compact_raft_log() const;
  public:
  void clear_compact_raft_log();
  bool compact_raft_log() const;
  void set_compact_raft_log(bool value);
  private:
  bool _internal_compact_raft_log() const;
  void _internal_set_compact_raft_log(bool value);
  public:

  // optional bool clear_all_txns = 5;
  bool has_clear_all_txns() const;
  private:
  bool _internal_has_clear_all_txns() const;
  public:
  void clear_clear_all_txns();
  bool clear_all_txns() const;
  void set_clear_all_txns(bool value);
  private:
  bool _internal_clear_all_txns() const;
  void _internal_set_clear_all_txns(bool value);
  public:

  // optional bool query_apply_index = 7;
  bool has_query_apply_index() const;
  private:
  bool _internal_has_query_apply_index() const;
  public:
  void clear_query_apply_index();
  bool query_apply_index() const;
  void set_query_apply_index(bool value);
  private:
  bool _internal_query_apply_index() const;
  void _internal_set_query_apply_index(bool value);
  public:

  // optional bool query_all_afs_file = 9;
  bool has_query_all_afs_file() const;
  private:
  bool _internal_has_query_all_afs_file() const;
  public:
  void clear_query_all_afs_file();
  bool query_all_afs_file() const;
  void set_query_all_afs_file(bool value);
  private:
  bool _internal_query_all_afs_file() const;
  void _internal_set_query_all_afs_file(bool value);
  public:

  // optional int64 txn_timeout = 6;
  bool has_txn_timeout() const;
  private:
  bool _internal_has_txn_timeout() const;
  public:
  void clear_txn_timeout();
  ::PROTOBUF_NAMESPACE_ID::int64 txn_timeout() const;
  void set_txn_timeout(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_txn_timeout() const;
  void _internal_set_txn_timeout(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool query_olap_keypoint = 10;
  bool has_query_olap_keypoint() const;
  private:
  bool _internal_has_query_olap_keypoint() const;
  public:
  void clear_query_olap_keypoint();
  bool query_olap_keypoint() const;
  void set_query_olap_keypoint(bool value);
  private:
  bool _internal_query_olap_keypoint() const;
  void _internal_set_query_olap_keypoint(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RegionIds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > region_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > userids_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 compact_type_;
  bool compact_raft_log_;
  bool clear_all_txns_;
  bool query_apply_index_;
  bool query_all_afs_file_;
  ::PROTOBUF_NAMESPACE_ID::int64 txn_timeout_;
  bool query_olap_keypoint_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BackUpReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:baikaldb.pb.BackUpReq) */ {
 public:
  inline BackUpReq() : BackUpReq(nullptr) {}
  explicit constexpr BackUpReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BackUpReq(const BackUpReq& from);
  BackUpReq(BackUpReq&& from) noexcept
    : BackUpReq() {
    *this = ::std::move(from);
  }

  inline BackUpReq& operator=(const BackUpReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackUpReq& operator=(BackUpReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BackUpReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const BackUpReq* internal_default_instance() {
    return reinterpret_cast<const BackUpReq*>(
               &_BackUpReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(BackUpReq& a, BackUpReq& b) {
    a.Swap(&b);
  }
  inline void Swap(BackUpReq* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackUpReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BackUpReq* New() const final {
    return new BackUpReq();
  }

  BackUpReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BackUpReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BackUpReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BackUpReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BackUpReq";
  }
  protected:
  explicit BackUpReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BackUpReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BackUpRes final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:baikaldb.pb.BackUpRes) */ {
 public:
  inline BackUpRes() : BackUpRes(nullptr) {}
  explicit constexpr BackUpRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BackUpRes(const BackUpRes& from);
  BackUpRes(BackUpRes&& from) noexcept
    : BackUpRes() {
    *this = ::std::move(from);
  }

  inline BackUpRes& operator=(const BackUpRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackUpRes& operator=(BackUpRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BackUpRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const BackUpRes* internal_default_instance() {
    return reinterpret_cast<const BackUpRes*>(
               &_BackUpRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(BackUpRes& a, BackUpRes& b) {
    a.Swap(&b);
  }
  inline void Swap(BackUpRes* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackUpRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BackUpRes* New() const final {
    return new BackUpRes();
  }

  BackUpRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BackUpRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BackUpRes& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BackUpRes& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BackUpRes";
  }
  protected:
  explicit BackUpRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BackUpRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BackupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BackupRequest) */ {
 public:
  inline BackupRequest() : BackupRequest(nullptr) {}
  ~BackupRequest() override;
  explicit constexpr BackupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BackupRequest(const BackupRequest& from);
  BackupRequest(BackupRequest&& from) noexcept
    : BackupRequest() {
    *this = ::std::move(from);
  }

  inline BackupRequest& operator=(const BackupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackupRequest& operator=(BackupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BackupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BackupRequest* internal_default_instance() {
    return reinterpret_cast<const BackupRequest*>(
               &_BackupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(BackupRequest& a, BackupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BackupRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BackupRequest* New() const final {
    return new BackupRequest();
  }

  BackupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BackupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BackupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BackupRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BackupRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BackupRequest";
  }
  protected:
  explicit BackupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
    kLogIndexFieldNumber = 2,
    kBackupOpFieldNumber = 3,
    kIngestStoreLatestSstFieldNumber = 4,
    kDataSstToProcessSizeFieldNumber = 5,
    kRowSizeFieldNumber = 6,
    kStreamingIdFieldNumber = 7,
  };
  // required int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 log_index = 2;
  bool has_log_index() const;
  private:
  bool _internal_has_log_index() const;
  public:
  void clear_log_index();
  ::PROTOBUF_NAMESPACE_ID::int64 log_index() const;
  void set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_log_index() const;
  void _internal_set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.BackupOp backup_op = 3;
  bool has_backup_op() const;
  private:
  bool _internal_has_backup_op() const;
  public:
  void clear_backup_op();
  ::baikaldb::pb::BackupOp backup_op() const;
  void set_backup_op(::baikaldb::pb::BackupOp value);
  private:
  ::baikaldb::pb::BackupOp _internal_backup_op() const;
  void _internal_set_backup_op(::baikaldb::pb::BackupOp value);
  public:

  // optional bool ingest_store_latest_sst = 4;
  bool has_ingest_store_latest_sst() const;
  private:
  bool _internal_has_ingest_store_latest_sst() const;
  public:
  void clear_ingest_store_latest_sst();
  bool ingest_store_latest_sst() const;
  void set_ingest_store_latest_sst(bool value);
  private:
  bool _internal_ingest_store_latest_sst() const;
  void _internal_set_ingest_store_latest_sst(bool value);
  public:

  // optional int64 data_sst_to_process_size = 5;
  bool has_data_sst_to_process_size() const;
  private:
  bool _internal_has_data_sst_to_process_size() const;
  public:
  void clear_data_sst_to_process_size();
  ::PROTOBUF_NAMESPACE_ID::int64 data_sst_to_process_size() const;
  void set_data_sst_to_process_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_data_sst_to_process_size() const;
  void _internal_set_data_sst_to_process_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 row_size = 6;
  bool has_row_size() const;
  private:
  bool _internal_has_row_size() const;
  public:
  void clear_row_size();
  ::PROTOBUF_NAMESPACE_ID::int64 row_size() const;
  void set_row_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_row_size() const;
  void _internal_set_row_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint64 streaming_id = 7;
  bool has_streaming_id() const;
  private:
  bool _internal_has_streaming_id() const;
  public:
  void clear_streaming_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 streaming_id() const;
  void set_streaming_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_streaming_id() const;
  void _internal_set_streaming_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BackupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 log_index_;
  int backup_op_;
  bool ingest_store_latest_sst_;
  ::PROTOBUF_NAMESPACE_ID::int64 data_sst_to_process_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 row_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 streaming_id_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BackupResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BackupResponse) */ {
 public:
  inline BackupResponse() : BackupResponse(nullptr) {}
  ~BackupResponse() override;
  explicit constexpr BackupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BackupResponse(const BackupResponse& from);
  BackupResponse(BackupResponse&& from) noexcept
    : BackupResponse() {
    *this = ::std::move(from);
  }

  inline BackupResponse& operator=(const BackupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackupResponse& operator=(BackupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BackupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BackupResponse* internal_default_instance() {
    return reinterpret_cast<const BackupResponse*>(
               &_BackupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(BackupResponse& a, BackupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BackupResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BackupResponse* New() const final {
    return new BackupResponse();
  }

  BackupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BackupResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BackupResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BackupResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BackupResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BackupResponse";
  }
  protected:
  explicit BackupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 4,
    kUnstableFollowersFieldNumber = 5,
    kLeaderFieldNumber = 3,
    kLogIndexFieldNumber = 1,
    kErrcodeFieldNumber = 2,
    kStreamingStateFieldNumber = 7,
    kStreamingIdFieldNumber = 6,
  };
  // repeated string peers = 4;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  const std::string& peers(int index) const;
  std::string* mutable_peers(int index);
  void set_peers(int index, const std::string& value);
  void set_peers(int index, std::string&& value);
  void set_peers(int index, const char* value);
  void set_peers(int index, const char* value, size_t size);
  std::string* add_peers();
  void add_peers(const std::string& value);
  void add_peers(std::string&& value);
  void add_peers(const char* value);
  void add_peers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& peers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_peers();
  private:
  const std::string& _internal_peers(int index) const;
  std::string* _internal_add_peers();
  public:

  // repeated string unstable_followers = 5;
  int unstable_followers_size() const;
  private:
  int _internal_unstable_followers_size() const;
  public:
  void clear_unstable_followers();
  const std::string& unstable_followers(int index) const;
  std::string* mutable_unstable_followers(int index);
  void set_unstable_followers(int index, const std::string& value);
  void set_unstable_followers(int index, std::string&& value);
  void set_unstable_followers(int index, const char* value);
  void set_unstable_followers(int index, const char* value, size_t size);
  std::string* add_unstable_followers();
  void add_unstable_followers(const std::string& value);
  void add_unstable_followers(std::string&& value);
  void add_unstable_followers(const char* value);
  void add_unstable_followers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& unstable_followers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_unstable_followers();
  private:
  const std::string& _internal_unstable_followers(int index) const;
  std::string* _internal_add_unstable_followers();
  public:

  // optional string leader = 3;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // optional int64 log_index = 1;
  bool has_log_index() const;
  private:
  bool _internal_has_log_index() const;
  public:
  void clear_log_index();
  ::PROTOBUF_NAMESPACE_ID::int64 log_index() const;
  void set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_log_index() const;
  void _internal_set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.ErrCode errcode = 2;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::ErrCode errcode() const;
  void set_errcode(::baikaldb::pb::ErrCode value);
  private:
  ::baikaldb::pb::ErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::ErrCode value);
  public:

  // optional .baikaldb.pb.StreamState streaming_state = 7;
  bool has_streaming_state() const;
  private:
  bool _internal_has_streaming_state() const;
  public:
  void clear_streaming_state();
  ::baikaldb::pb::StreamState streaming_state() const;
  void set_streaming_state(::baikaldb::pb::StreamState value);
  private:
  ::baikaldb::pb::StreamState _internal_streaming_state() const;
  void _internal_set_streaming_state(::baikaldb::pb::StreamState value);
  public:

  // optional uint64 streaming_id = 6;
  bool has_streaming_id() const;
  private:
  bool _internal_has_streaming_id() const;
  public:
  void clear_streaming_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 streaming_id() const;
  void set_streaming_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_streaming_id() const;
  void _internal_set_streaming_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BackupResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> peers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> unstable_followers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  ::PROTOBUF_NAMESPACE_ID::int64 log_index_;
  int errcode_;
  int streaming_state_;
  ::PROTOBUF_NAMESPACE_ID::uint64 streaming_id_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class HealthCheck final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:baikaldb.pb.HealthCheck) */ {
 public:
  inline HealthCheck() : HealthCheck(nullptr) {}
  explicit constexpr HealthCheck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HealthCheck(const HealthCheck& from);
  HealthCheck(HealthCheck&& from) noexcept
    : HealthCheck() {
    *this = ::std::move(from);
  }

  inline HealthCheck& operator=(const HealthCheck& from) {
    CopyFrom(from);
    return *this;
  }
  inline HealthCheck& operator=(HealthCheck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HealthCheck& default_instance() {
    return *internal_default_instance();
  }
  static inline const HealthCheck* internal_default_instance() {
    return reinterpret_cast<const HealthCheck*>(
               &_HealthCheck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(HealthCheck& a, HealthCheck& b) {
    a.Swap(&b);
  }
  inline void Swap(HealthCheck* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HealthCheck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HealthCheck* New() const final {
    return new HealthCheck();
  }

  HealthCheck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HealthCheck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HealthCheck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HealthCheck& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.HealthCheck";
  }
  protected:
  explicit HealthCheck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:baikaldb.pb.HealthCheck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class OlapRegionIndexInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.OlapRegionIndexInfo) */ {
 public:
  inline OlapRegionIndexInfo() : OlapRegionIndexInfo(nullptr) {}
  ~OlapRegionIndexInfo() override;
  explicit constexpr OlapRegionIndexInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OlapRegionIndexInfo(const OlapRegionIndexInfo& from);
  OlapRegionIndexInfo(OlapRegionIndexInfo&& from) noexcept
    : OlapRegionIndexInfo() {
    *this = ::std::move(from);
  }

  inline OlapRegionIndexInfo& operator=(const OlapRegionIndexInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OlapRegionIndexInfo& operator=(OlapRegionIndexInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OlapRegionIndexInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OlapRegionIndexInfo* internal_default_instance() {
    return reinterpret_cast<const OlapRegionIndexInfo*>(
               &_OlapRegionIndexInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(OlapRegionIndexInfo& a, OlapRegionIndexInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OlapRegionIndexInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OlapRegionIndexInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OlapRegionIndexInfo* New() const final {
    return new OlapRegionIndexInfo();
  }

  OlapRegionIndexInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OlapRegionIndexInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OlapRegionIndexInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OlapRegionIndexInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OlapRegionIndexInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.OlapRegionIndexInfo";
  }
  protected:
  explicit OlapRegionIndexInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExternalPathFieldNumber = 2,
    kIndexIdFieldNumber = 1,
    kStateFieldNumber = 3,
  };
  // repeated string external_path = 2;
  int external_path_size() const;
  private:
  int _internal_external_path_size() const;
  public:
  void clear_external_path();
  const std::string& external_path(int index) const;
  std::string* mutable_external_path(int index);
  void set_external_path(int index, const std::string& value);
  void set_external_path(int index, std::string&& value);
  void set_external_path(int index, const char* value);
  void set_external_path(int index, const char* value, size_t size);
  std::string* add_external_path();
  void add_external_path(const std::string& value);
  void add_external_path(std::string&& value);
  void add_external_path(const char* value);
  void add_external_path(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& external_path() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_external_path();
  private:
  const std::string& _internal_external_path(int index) const;
  std::string* _internal_add_external_path();
  public:

  // required int64 index_id = 1;
  bool has_index_id() const;
  private:
  bool _internal_has_index_id() const;
  public:
  void clear_index_id();
  ::PROTOBUF_NAMESPACE_ID::int64 index_id() const;
  void set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_index_id() const;
  void _internal_set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.OlapRegionStat state = 3;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::baikaldb::pb::OlapRegionStat state() const;
  void set_state(::baikaldb::pb::OlapRegionStat value);
  private:
  ::baikaldb::pb::OlapRegionStat _internal_state() const;
  void _internal_set_state(::baikaldb::pb::OlapRegionStat value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.OlapRegionIndexInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> external_path_;
  ::PROTOBUF_NAMESPACE_ID::int64 index_id_;
  int state_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class OlapRegionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.OlapRegionInfo) */ {
 public:
  inline OlapRegionInfo() : OlapRegionInfo(nullptr) {}
  ~OlapRegionInfo() override;
  explicit constexpr OlapRegionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OlapRegionInfo(const OlapRegionInfo& from);
  OlapRegionInfo(OlapRegionInfo&& from) noexcept
    : OlapRegionInfo() {
    *this = ::std::move(from);
  }

  inline OlapRegionInfo& operator=(const OlapRegionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OlapRegionInfo& operator=(OlapRegionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OlapRegionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OlapRegionInfo* internal_default_instance() {
    return reinterpret_cast<const OlapRegionInfo*>(
               &_OlapRegionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(OlapRegionInfo& a, OlapRegionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OlapRegionInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OlapRegionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OlapRegionInfo* New() const final {
    return new OlapRegionInfo();
  }

  OlapRegionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OlapRegionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OlapRegionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OlapRegionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OlapRegionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.OlapRegionInfo";
  }
  protected:
  explicit OlapRegionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExternalFullPathFieldNumber = 3,
    kOlapIndexInfoListFieldNumber = 4,
    kNewOlapIndexInfoFieldNumber = 5,
    kStateTimeFieldNumber = 2,
    kStateFieldNumber = 1,
  };
  // repeated string external_full_path = 3;
  int external_full_path_size() const;
  private:
  int _internal_external_full_path_size() const;
  public:
  void clear_external_full_path();
  const std::string& external_full_path(int index) const;
  std::string* mutable_external_full_path(int index);
  void set_external_full_path(int index, const std::string& value);
  void set_external_full_path(int index, std::string&& value);
  void set_external_full_path(int index, const char* value);
  void set_external_full_path(int index, const char* value, size_t size);
  std::string* add_external_full_path();
  void add_external_full_path(const std::string& value);
  void add_external_full_path(std::string&& value);
  void add_external_full_path(const char* value);
  void add_external_full_path(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& external_full_path() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_external_full_path();
  private:
  const std::string& _internal_external_full_path(int index) const;
  std::string* _internal_add_external_full_path();
  public:

  // repeated .baikaldb.pb.OlapRegionIndexInfo olap_index_info_list = 4;
  int olap_index_info_list_size() const;
  private:
  int _internal_olap_index_info_list_size() const;
  public:
  void clear_olap_index_info_list();
  ::baikaldb::pb::OlapRegionIndexInfo* mutable_olap_index_info_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::OlapRegionIndexInfo >*
      mutable_olap_index_info_list();
  private:
  const ::baikaldb::pb::OlapRegionIndexInfo& _internal_olap_index_info_list(int index) const;
  ::baikaldb::pb::OlapRegionIndexInfo* _internal_add_olap_index_info_list();
  public:
  const ::baikaldb::pb::OlapRegionIndexInfo& olap_index_info_list(int index) const;
  ::baikaldb::pb::OlapRegionIndexInfo* add_olap_index_info_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::OlapRegionIndexInfo >&
      olap_index_info_list() const;

  // optional .baikaldb.pb.OlapRegionIndexInfo new_olap_index_info = 5;
  bool has_new_olap_index_info() const;
  private:
  bool _internal_has_new_olap_index_info() const;
  public:
  void clear_new_olap_index_info();
  const ::baikaldb::pb::OlapRegionIndexInfo& new_olap_index_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::OlapRegionIndexInfo* release_new_olap_index_info();
  ::baikaldb::pb::OlapRegionIndexInfo* mutable_new_olap_index_info();
  void set_allocated_new_olap_index_info(::baikaldb::pb::OlapRegionIndexInfo* new_olap_index_info);
  private:
  const ::baikaldb::pb::OlapRegionIndexInfo& _internal_new_olap_index_info() const;
  ::baikaldb::pb::OlapRegionIndexInfo* _internal_mutable_new_olap_index_info();
  public:
  void unsafe_arena_set_allocated_new_olap_index_info(
      ::baikaldb::pb::OlapRegionIndexInfo* new_olap_index_info);
  ::baikaldb::pb::OlapRegionIndexInfo* unsafe_arena_release_new_olap_index_info();

  // optional uint64 state_time = 2;
  bool has_state_time() const;
  private:
  bool _internal_has_state_time() const;
  public:
  void clear_state_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 state_time() const;
  void set_state_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_state_time() const;
  void _internal_set_state_time(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required .baikaldb.pb.OlapRegionStat state = 1 [default = OLAP_ACTIVE];
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::baikaldb::pb::OlapRegionStat state() const;
  void set_state(::baikaldb::pb::OlapRegionStat value);
  private:
  ::baikaldb::pb::OlapRegionStat _internal_state() const;
  void _internal_set_state(::baikaldb::pb::OlapRegionStat value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.OlapRegionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> external_full_path_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::OlapRegionIndexInfo > olap_index_info_list_;
  ::baikaldb::pb::OlapRegionIndexInfo* new_olap_index_info_;
  ::PROTOBUF_NAMESPACE_ID::uint64 state_time_;
  int state_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RegionOfflineBinlogInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RegionOfflineBinlogInfo) */ {
 public:
  inline RegionOfflineBinlogInfo() : RegionOfflineBinlogInfo(nullptr) {}
  ~RegionOfflineBinlogInfo() override;
  explicit constexpr RegionOfflineBinlogInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionOfflineBinlogInfo(const RegionOfflineBinlogInfo& from);
  RegionOfflineBinlogInfo(RegionOfflineBinlogInfo&& from) noexcept
    : RegionOfflineBinlogInfo() {
    *this = ::std::move(from);
  }

  inline RegionOfflineBinlogInfo& operator=(const RegionOfflineBinlogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionOfflineBinlogInfo& operator=(RegionOfflineBinlogInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionOfflineBinlogInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionOfflineBinlogInfo* internal_default_instance() {
    return reinterpret_cast<const RegionOfflineBinlogInfo*>(
               &_RegionOfflineBinlogInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(RegionOfflineBinlogInfo& a, RegionOfflineBinlogInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionOfflineBinlogInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionOfflineBinlogInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionOfflineBinlogInfo* New() const final {
    return new RegionOfflineBinlogInfo();
  }

  RegionOfflineBinlogInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionOfflineBinlogInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionOfflineBinlogInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegionOfflineBinlogInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionOfflineBinlogInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RegionOfflineBinlogInfo";
  }
  protected:
  explicit RegionOfflineBinlogInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExternalFullPathFieldNumber = 5,
    kOldestTsFieldNumber = 1,
    kNewestTsFieldNumber = 2,
    kTaskStartTsFieldNumber = 3,
    kTaskEndTsFieldNumber = 4,
  };
  // repeated string external_full_path = 5;
  int external_full_path_size() const;
  private:
  int _internal_external_full_path_size() const;
  public:
  void clear_external_full_path();
  const std::string& external_full_path(int index) const;
  std::string* mutable_external_full_path(int index);
  void set_external_full_path(int index, const std::string& value);
  void set_external_full_path(int index, std::string&& value);
  void set_external_full_path(int index, const char* value);
  void set_external_full_path(int index, const char* value, size_t size);
  std::string* add_external_full_path();
  void add_external_full_path(const std::string& value);
  void add_external_full_path(std::string&& value);
  void add_external_full_path(const char* value);
  void add_external_full_path(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& external_full_path() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_external_full_path();
  private:
  const std::string& _internal_external_full_path(int index) const;
  std::string* _internal_add_external_full_path();
  public:

  // required int64 oldest_ts = 1;
  bool has_oldest_ts() const;
  private:
  bool _internal_has_oldest_ts() const;
  public:
  void clear_oldest_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 oldest_ts() const;
  void set_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_oldest_ts() const;
  void _internal_set_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 newest_ts = 2;
  bool has_newest_ts() const;
  private:
  bool _internal_has_newest_ts() const;
  public:
  void clear_newest_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 newest_ts() const;
  void set_newest_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_newest_ts() const;
  void _internal_set_newest_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 task_start_ts = 3;
  bool has_task_start_ts() const;
  private:
  bool _internal_has_task_start_ts() const;
  public:
  void clear_task_start_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 task_start_ts() const;
  void set_task_start_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_task_start_ts() const;
  void _internal_set_task_start_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 task_end_ts = 4;
  bool has_task_end_ts() const;
  private:
  bool _internal_has_task_end_ts() const;
  public:
  void clear_task_end_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 task_end_ts() const;
  void set_task_end_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_task_end_ts() const;
  void _internal_set_task_end_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RegionOfflineBinlogInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> external_full_path_;
  ::PROTOBUF_NAMESPACE_ID::int64 oldest_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 newest_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 task_start_ts_;
  ::PROTOBUF_NAMESPACE_ID::int64 task_end_ts_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class CompactionFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.CompactionFileRequest) */ {
 public:
  inline CompactionFileRequest() : CompactionFileRequest(nullptr) {}
  ~CompactionFileRequest() override;
  explicit constexpr CompactionFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompactionFileRequest(const CompactionFileRequest& from);
  CompactionFileRequest(CompactionFileRequest&& from) noexcept
    : CompactionFileRequest() {
    *this = ::std::move(from);
  }

  inline CompactionFileRequest& operator=(const CompactionFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompactionFileRequest& operator=(CompactionFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompactionFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompactionFileRequest* internal_default_instance() {
    return reinterpret_cast<const CompactionFileRequest*>(
               &_CompactionFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(CompactionFileRequest& a, CompactionFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CompactionFileRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompactionFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CompactionFileRequest* New() const final {
    return new CompactionFileRequest();
  }

  CompactionFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CompactionFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompactionFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CompactionFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompactionFileRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.CompactionFileRequest";
  }
  protected:
  explicit CompactionFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteCompactionIdFieldNumber = 2,
    kFileNameFieldNumber = 3,
    kDataFieldNumber = 6,
    kOffsetFieldNumber = 4,
    kCountFieldNumber = 5,
    kRecursiveFieldNumber = 7,
    kOpTypeFieldNumber = 1,
  };
  // required string remote_compaction_id = 2;
  bool has_remote_compaction_id() const;
  private:
  bool _internal_has_remote_compaction_id() const;
  public:
  void clear_remote_compaction_id();
  const std::string& remote_compaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_compaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_compaction_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_remote_compaction_id();
  void set_allocated_remote_compaction_id(std::string* remote_compaction_id);
  private:
  const std::string& _internal_remote_compaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_compaction_id(const std::string& value);
  std::string* _internal_mutable_remote_compaction_id();
  public:

  // optional string file_name = 3;
  bool has_file_name() const;
  private:
  bool _internal_has_file_name() const;
  public:
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // optional bytes data = 6;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional uint64 offset = 4;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::uint64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint32 count = 5;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool recursive = 7;
  bool has_recursive() const;
  private:
  bool _internal_has_recursive() const;
  public:
  void clear_recursive();
  bool recursive() const;
  void set_recursive(bool value);
  private:
  bool _internal_recursive() const;
  void _internal_set_recursive(bool value);
  public:

  // required .baikaldb.pb.CompactionOpType op_type = 1;
  bool has_op_type() const;
  private:
  bool _internal_has_op_type() const;
  public:
  void clear_op_type();
  ::baikaldb::pb::CompactionOpType op_type() const;
  void set_op_type(::baikaldb::pb::CompactionOpType value);
  private:
  ::baikaldb::pb::CompactionOpType _internal_op_type() const;
  void _internal_set_op_type(::baikaldb::pb::CompactionOpType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.CompactionFileRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_compaction_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::uint64 offset_;
  ::PROTOBUF_NAMESPACE_ID::uint32 count_;
  bool recursive_;
  int op_type_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// -------------------------------------------------------------------

class CompactionFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.CompactionFileResponse) */ {
 public:
  inline CompactionFileResponse() : CompactionFileResponse(nullptr) {}
  ~CompactionFileResponse() override;
  explicit constexpr CompactionFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompactionFileResponse(const CompactionFileResponse& from);
  CompactionFileResponse(CompactionFileResponse&& from) noexcept
    : CompactionFileResponse() {
    *this = ::std::move(from);
  }

  inline CompactionFileResponse& operator=(const CompactionFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompactionFileResponse& operator=(CompactionFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompactionFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompactionFileResponse* internal_default_instance() {
    return reinterpret_cast<const CompactionFileResponse*>(
               &_CompactionFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(CompactionFileResponse& a, CompactionFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CompactionFileResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompactionFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CompactionFileResponse* New() const final {
    return new CompactionFileResponse();
  }

  CompactionFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CompactionFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompactionFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CompactionFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompactionFileResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.CompactionFileResponse";
  }
  protected:
  explicit CompactionFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileInfoFieldNumber = 3,
    kDataFieldNumber = 2,
    kErrcodeFieldNumber = 1,
  };
  // repeated .baikaldb.pb.CompactionFileInfo file_info = 3;
  int file_info_size() const;
  private:
  int _internal_file_info_size() const;
  public:
  void clear_file_info();
  ::baikaldb::pb::CompactionFileInfo* mutable_file_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CompactionFileInfo >*
      mutable_file_info();
  private:
  const ::baikaldb::pb::CompactionFileInfo& _internal_file_info(int index) const;
  ::baikaldb::pb::CompactionFileInfo* _internal_add_file_info();
  public:
  const ::baikaldb::pb::CompactionFileInfo& file_info(int index) const;
  ::baikaldb::pb::CompactionFileInfo* add_file_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CompactionFileInfo >&
      file_info() const;

  // optional bytes data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // required .baikaldb.pb.ErrCode errcode = 1;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::ErrCode errcode() const;
  void set_errcode(::baikaldb::pb::ErrCode value);
  private:
  ::baikaldb::pb::ErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::ErrCode value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.CompactionFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CompactionFileInfo > file_info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int errcode_;
  friend struct ::TableStruct_store_2einterface_2eproto;
};
// ===================================================================

class StoreService_Stub;

class StoreService : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline StoreService() {};
 public:
  virtual ~StoreService();

  typedef StoreService_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void init_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::InitRegion* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  virtual void region_raft_control(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RaftControlRequest* request,
                       ::baikaldb::pb::RaftControlResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void health_check(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::HealthCheck* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  virtual void async_apply_log_entry(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::BatchStoreReq* request,
                       ::baikaldb::pb::BatchStoreRes* response,
                       ::google::protobuf::Closure* done);
  virtual void query(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::StoreReq* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  virtual void query_batch(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::BatchRegionStoreReq* request,
                       ::baikaldb::pb::BatchRegionStoreRes* response,
                       ::google::protobuf::Closure* done);
  virtual void query_binlog(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::StoreReq* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  virtual void remove_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RemoveRegion* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  virtual void add_peer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::AddPeer* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  virtual void get_applied_index(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::GetAppliedIndex* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  virtual void compact_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RegionIds* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  virtual void snapshot_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RegionIds* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  virtual void restore_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RegionIds* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  virtual void manual_split_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RegionIds* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  virtual void query_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RegionIds* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  virtual void query_illegal_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RegionIds* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  virtual void backup_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::BackUpReq* request,
                       ::baikaldb::pb::BackUpRes* response,
                       ::google::protobuf::Closure* done);
  virtual void backup(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::BackupRequest* request,
                       ::baikaldb::pb::BackupResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void get_rocks_statistic(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RocksStatisticReq* request,
                       ::baikaldb::pb::RocksStatisticRes* response,
                       ::google::protobuf::Closure* done);
  virtual void manual_link_external_sst(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RegionIds* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  virtual void query_file_system(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::CompactionFileRequest* request,
                       ::baikaldb::pb::CompactionFileResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(StoreService);
};

class StoreService_Stub : public StoreService {
 public:
  StoreService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  StoreService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~StoreService_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements StoreService ------------------------------------------

  void init_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::InitRegion* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  void region_raft_control(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RaftControlRequest* request,
                       ::baikaldb::pb::RaftControlResponse* response,
                       ::google::protobuf::Closure* done);
  void health_check(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::HealthCheck* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  void async_apply_log_entry(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::BatchStoreReq* request,
                       ::baikaldb::pb::BatchStoreRes* response,
                       ::google::protobuf::Closure* done);
  void query(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::StoreReq* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  void query_batch(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::BatchRegionStoreReq* request,
                       ::baikaldb::pb::BatchRegionStoreRes* response,
                       ::google::protobuf::Closure* done);
  void query_binlog(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::StoreReq* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  void remove_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RemoveRegion* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  void add_peer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::AddPeer* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  void get_applied_index(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::GetAppliedIndex* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  void compact_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RegionIds* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  void snapshot_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RegionIds* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  void restore_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RegionIds* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  void manual_split_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RegionIds* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  void query_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RegionIds* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  void query_illegal_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RegionIds* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  void backup_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::BackUpReq* request,
                       ::baikaldb::pb::BackUpRes* response,
                       ::google::protobuf::Closure* done);
  void backup(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::BackupRequest* request,
                       ::baikaldb::pb::BackupResponse* response,
                       ::google::protobuf::Closure* done);
  void get_rocks_statistic(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RocksStatisticReq* request,
                       ::baikaldb::pb::RocksStatisticRes* response,
                       ::google::protobuf::Closure* done);
  void manual_link_external_sst(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RegionIds* request,
                       ::baikaldb::pb::StoreRes* response,
                       ::google::protobuf::Closure* done);
  void query_file_system(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::CompactionFileRequest* request,
                       ::baikaldb::pb::CompactionFileResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(StoreService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// KvOp

// required .baikaldb.pb.OpType op_type = 1;
inline bool KvOp::_internal_has_op_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KvOp::has_op_type() const {
  return _internal_has_op_type();
}
inline void KvOp::clear_op_type() {
  op_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::baikaldb::pb::OpType KvOp::_internal_op_type() const {
  return static_cast< ::baikaldb::pb::OpType >(op_type_);
}
inline ::baikaldb::pb::OpType KvOp::op_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.KvOp.op_type)
  return _internal_op_type();
}
inline void KvOp::_internal_set_op_type(::baikaldb::pb::OpType value) {
  assert(::baikaldb::pb::OpType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  op_type_ = value;
}
inline void KvOp::set_op_type(::baikaldb::pb::OpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.KvOp.op_type)
}

// optional bytes key = 2;
inline bool KvOp::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KvOp::has_key() const {
  return _internal_has_key();
}
inline void KvOp::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KvOp::key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.KvOp.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KvOp::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.KvOp.key)
}
inline std::string* KvOp::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.KvOp.key)
  return _s;
}
inline const std::string& KvOp::_internal_key() const {
  return key_.Get();
}
inline void KvOp::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KvOp::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KvOp::release_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.KvOp.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KvOp::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.KvOp.key)
}

// optional bytes value = 3;
inline bool KvOp::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KvOp::has_value() const {
  return _internal_has_value();
}
inline void KvOp::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KvOp::value() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.KvOp.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KvOp::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.KvOp.value)
}
inline std::string* KvOp::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.KvOp.value)
  return _s;
}
inline const std::string& KvOp::_internal_value() const {
  return value_.Get();
}
inline void KvOp::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KvOp::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KvOp::release_value() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.KvOp.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KvOp::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.KvOp.value)
}

// optional int64 ttl_timestamp_us = 4;
inline bool KvOp::_internal_has_ttl_timestamp_us() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool KvOp::has_ttl_timestamp_us() const {
  return _internal_has_ttl_timestamp_us();
}
inline void KvOp::clear_ttl_timestamp_us() {
  ttl_timestamp_us_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 KvOp::_internal_ttl_timestamp_us() const {
  return ttl_timestamp_us_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 KvOp::ttl_timestamp_us() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.KvOp.ttl_timestamp_us)
  return _internal_ttl_timestamp_us();
}
inline void KvOp::_internal_set_ttl_timestamp_us(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  ttl_timestamp_us_ = value;
}
inline void KvOp::set_ttl_timestamp_us(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_ttl_timestamp_us(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.KvOp.ttl_timestamp_us)
}

// optional bool is_primary_key = 5;
inline bool KvOp::_internal_has_is_primary_key() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool KvOp::has_is_primary_key() const {
  return _internal_has_is_primary_key();
}
inline void KvOp::clear_is_primary_key() {
  is_primary_key_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool KvOp::_internal_is_primary_key() const {
  return is_primary_key_;
}
inline bool KvOp::is_primary_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.KvOp.is_primary_key)
  return _internal_is_primary_key();
}
inline void KvOp::_internal_set_is_primary_key(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_primary_key_ = value;
}
inline void KvOp::set_is_primary_key(bool value) {
  _internal_set_is_primary_key(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.KvOp.is_primary_key)
}

// -------------------------------------------------------------------

// RedisKv

// optional bytes key = 1;
inline bool RedisKv::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RedisKv::has_key() const {
  return _internal_has_key();
}
inline void RedisKv::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RedisKv::key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RedisKv.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RedisKv::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RedisKv.key)
}
inline std::string* RedisKv::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RedisKv.key)
  return _s;
}
inline const std::string& RedisKv::_internal_key() const {
  return key_.Get();
}
inline void RedisKv::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RedisKv::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RedisKv::release_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RedisKv.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RedisKv::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RedisKv.key)
}

// optional bytes value = 2;
inline bool RedisKv::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RedisKv::has_value() const {
  return _internal_has_value();
}
inline void RedisKv::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RedisKv::value() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RedisKv.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RedisKv::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RedisKv.value)
}
inline std::string* RedisKv::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RedisKv.value)
  return _s;
}
inline const std::string& RedisKv::_internal_value() const {
  return value_.Get();
}
inline void RedisKv::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RedisKv::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RedisKv::release_value() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RedisKv.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RedisKv::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RedisKv.value)
}

// optional int64 expire_ms = 3;
inline bool RedisKv::_internal_has_expire_ms() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RedisKv::has_expire_ms() const {
  return _internal_has_expire_ms();
}
inline void RedisKv::clear_expire_ms() {
  expire_ms_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RedisKv::_internal_expire_ms() const {
  return expire_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RedisKv::expire_ms() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RedisKv.expire_ms)
  return _internal_expire_ms();
}
inline void RedisKv::_internal_set_expire_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  expire_ms_ = value;
}
inline void RedisKv::set_expire_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_expire_ms(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RedisKv.expire_ms)
}

// -------------------------------------------------------------------

// RedisWriteRequest

// optional .baikaldb.pb.RedisCmd cmd = 1;
inline bool RedisWriteRequest::_internal_has_cmd() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RedisWriteRequest::has_cmd() const {
  return _internal_has_cmd();
}
inline void RedisWriteRequest::clear_cmd() {
  cmd_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::baikaldb::pb::RedisCmd RedisWriteRequest::_internal_cmd() const {
  return static_cast< ::baikaldb::pb::RedisCmd >(cmd_);
}
inline ::baikaldb::pb::RedisCmd RedisWriteRequest::cmd() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RedisWriteRequest.cmd)
  return _internal_cmd();
}
inline void RedisWriteRequest::_internal_set_cmd(::baikaldb::pb::RedisCmd value) {
  assert(::baikaldb::pb::RedisCmd_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  cmd_ = value;
}
inline void RedisWriteRequest::set_cmd(::baikaldb::pb::RedisCmd value) {
  _internal_set_cmd(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RedisWriteRequest.cmd)
}

// repeated .baikaldb.pb.RedisKv kvs = 2;
inline int RedisWriteRequest::_internal_kvs_size() const {
  return kvs_.size();
}
inline int RedisWriteRequest::kvs_size() const {
  return _internal_kvs_size();
}
inline void RedisWriteRequest::clear_kvs() {
  kvs_.Clear();
}
inline ::baikaldb::pb::RedisKv* RedisWriteRequest::mutable_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RedisWriteRequest.kvs)
  return kvs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RedisKv >*
RedisWriteRequest::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RedisWriteRequest.kvs)
  return &kvs_;
}
inline const ::baikaldb::pb::RedisKv& RedisWriteRequest::_internal_kvs(int index) const {
  return kvs_.Get(index);
}
inline const ::baikaldb::pb::RedisKv& RedisWriteRequest::kvs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RedisWriteRequest.kvs)
  return _internal_kvs(index);
}
inline ::baikaldb::pb::RedisKv* RedisWriteRequest::_internal_add_kvs() {
  return kvs_.Add();
}
inline ::baikaldb::pb::RedisKv* RedisWriteRequest::add_kvs() {
  ::baikaldb::pb::RedisKv* _add = _internal_add_kvs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.RedisWriteRequest.kvs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RedisKv >&
RedisWriteRequest::kvs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RedisWriteRequest.kvs)
  return kvs_;
}

// optional uint32 slot = 3;
inline bool RedisWriteRequest::_internal_has_slot() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RedisWriteRequest::has_slot() const {
  return _internal_has_slot();
}
inline void RedisWriteRequest::clear_slot() {
  slot_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RedisWriteRequest::_internal_slot() const {
  return slot_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RedisWriteRequest::slot() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RedisWriteRequest.slot)
  return _internal_slot();
}
inline void RedisWriteRequest::_internal_set_slot(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  slot_ = value;
}
inline void RedisWriteRequest::set_slot(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_slot(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RedisWriteRequest.slot)
}

// -------------------------------------------------------------------

// CachePlan

// required .baikaldb.pb.OpType op_type = 1;
inline bool CachePlan::_internal_has_op_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CachePlan::has_op_type() const {
  return _internal_has_op_type();
}
inline void CachePlan::clear_op_type() {
  op_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::baikaldb::pb::OpType CachePlan::_internal_op_type() const {
  return static_cast< ::baikaldb::pb::OpType >(op_type_);
}
inline ::baikaldb::pb::OpType CachePlan::op_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CachePlan.op_type)
  return _internal_op_type();
}
inline void CachePlan::_internal_set_op_type(::baikaldb::pb::OpType value) {
  assert(::baikaldb::pb::OpType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  op_type_ = value;
}
inline void CachePlan::set_op_type(::baikaldb::pb::OpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CachePlan.op_type)
}

// required int32 seq_id = 2;
inline bool CachePlan::_internal_has_seq_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CachePlan::has_seq_id() const {
  return _internal_has_seq_id();
}
inline void CachePlan::clear_seq_id() {
  seq_id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CachePlan::_internal_seq_id() const {
  return seq_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CachePlan::seq_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CachePlan.seq_id)
  return _internal_seq_id();
}
inline void CachePlan::_internal_set_seq_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  seq_id_ = value;
}
inline void CachePlan::set_seq_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_seq_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CachePlan.seq_id)
}

// required .baikaldb.pb.Plan plan = 3;
inline bool CachePlan::_internal_has_plan() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || plan_ != nullptr);
  return value;
}
inline bool CachePlan::has_plan() const {
  return _internal_has_plan();
}
inline const ::baikaldb::pb::Plan& CachePlan::_internal_plan() const {
  const ::baikaldb::pb::Plan* p = plan_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::Plan&>(
      ::baikaldb::pb::_Plan_default_instance_);
}
inline const ::baikaldb::pb::Plan& CachePlan::plan() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CachePlan.plan)
  return _internal_plan();
}
inline void CachePlan::unsafe_arena_set_allocated_plan(
    ::baikaldb::pb::Plan* plan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(plan_);
  }
  plan_ = plan;
  if (plan) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.CachePlan.plan)
}
inline ::baikaldb::pb::Plan* CachePlan::release_plan() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::Plan* temp = plan_;
  plan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::Plan* CachePlan::unsafe_arena_release_plan() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.CachePlan.plan)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::Plan* temp = plan_;
  plan_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::Plan* CachePlan::_internal_mutable_plan() {
  _has_bits_[0] |= 0x00000001u;
  if (plan_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::Plan>(GetArenaForAllocation());
    plan_ = p;
  }
  return plan_;
}
inline ::baikaldb::pb::Plan* CachePlan::mutable_plan() {
  ::baikaldb::pb::Plan* _msg = _internal_mutable_plan();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.CachePlan.plan)
  return _msg;
}
inline void CachePlan::set_allocated_plan(::baikaldb::pb::Plan* plan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(plan_);
  }
  if (plan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(plan));
    if (message_arena != submessage_arena) {
      plan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, plan, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  plan_ = plan;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.CachePlan.plan)
}

// repeated .baikaldb.pb.TupleDescriptor tuples = 4;
inline int CachePlan::_internal_tuples_size() const {
  return tuples_.size();
}
inline int CachePlan::tuples_size() const {
  return _internal_tuples_size();
}
inline ::baikaldb::pb::TupleDescriptor* CachePlan::mutable_tuples(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.CachePlan.tuples)
  return tuples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TupleDescriptor >*
CachePlan::mutable_tuples() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.CachePlan.tuples)
  return &tuples_;
}
inline const ::baikaldb::pb::TupleDescriptor& CachePlan::_internal_tuples(int index) const {
  return tuples_.Get(index);
}
inline const ::baikaldb::pb::TupleDescriptor& CachePlan::tuples(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CachePlan.tuples)
  return _internal_tuples(index);
}
inline ::baikaldb::pb::TupleDescriptor* CachePlan::_internal_add_tuples() {
  return tuples_.Add();
}
inline ::baikaldb::pb::TupleDescriptor* CachePlan::add_tuples() {
  ::baikaldb::pb::TupleDescriptor* _add = _internal_add_tuples();
  // @@protoc_insertion_point(field_add:baikaldb.pb.CachePlan.tuples)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TupleDescriptor >&
CachePlan::tuples() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.CachePlan.tuples)
  return tuples_;
}

// repeated .baikaldb.pb.RegionInfo regions = 5;
inline int CachePlan::_internal_regions_size() const {
  return regions_.size();
}
inline int CachePlan::regions_size() const {
  return _internal_regions_size();
}
inline ::baikaldb::pb::RegionInfo* CachePlan::mutable_regions(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.CachePlan.regions)
  return regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >*
CachePlan::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.CachePlan.regions)
  return &regions_;
}
inline const ::baikaldb::pb::RegionInfo& CachePlan::_internal_regions(int index) const {
  return regions_.Get(index);
}
inline const ::baikaldb::pb::RegionInfo& CachePlan::regions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CachePlan.regions)
  return _internal_regions(index);
}
inline ::baikaldb::pb::RegionInfo* CachePlan::_internal_add_regions() {
  return regions_.Add();
}
inline ::baikaldb::pb::RegionInfo* CachePlan::add_regions() {
  ::baikaldb::pb::RegionInfo* _add = _internal_add_regions();
  // @@protoc_insertion_point(field_add:baikaldb.pb.CachePlan.regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >&
CachePlan::regions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.CachePlan.regions)
  return regions_;
}

// repeated .baikaldb.pb.KvOp kv_ops = 6;
inline int CachePlan::_internal_kv_ops_size() const {
  return kv_ops_.size();
}
inline int CachePlan::kv_ops_size() const {
  return _internal_kv_ops_size();
}
inline void CachePlan::clear_kv_ops() {
  kv_ops_.Clear();
}
inline ::baikaldb::pb::KvOp* CachePlan::mutable_kv_ops(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.CachePlan.kv_ops)
  return kv_ops_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::KvOp >*
CachePlan::mutable_kv_ops() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.CachePlan.kv_ops)
  return &kv_ops_;
}
inline const ::baikaldb::pb::KvOp& CachePlan::_internal_kv_ops(int index) const {
  return kv_ops_.Get(index);
}
inline const ::baikaldb::pb::KvOp& CachePlan::kv_ops(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CachePlan.kv_ops)
  return _internal_kv_ops(index);
}
inline ::baikaldb::pb::KvOp* CachePlan::_internal_add_kv_ops() {
  return kv_ops_.Add();
}
inline ::baikaldb::pb::KvOp* CachePlan::add_kv_ops() {
  ::baikaldb::pb::KvOp* _add = _internal_add_kv_ops();
  // @@protoc_insertion_point(field_add:baikaldb.pb.CachePlan.kv_ops)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::KvOp >&
CachePlan::kv_ops() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.CachePlan.kv_ops)
  return kv_ops_;
}

// -------------------------------------------------------------------

// TransactionInfo

// required uint64 txn_id = 1;
inline bool TransactionInfo::_internal_has_txn_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TransactionInfo::has_txn_id() const {
  return _internal_has_txn_id();
}
inline void TransactionInfo::clear_txn_id() {
  txn_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TransactionInfo::_internal_txn_id() const {
  return txn_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TransactionInfo::txn_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.txn_id)
  return _internal_txn_id();
}
inline void TransactionInfo::_internal_set_txn_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  txn_id_ = value;
}
inline void TransactionInfo::set_txn_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_txn_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionInfo.txn_id)
}

// required int32 seq_id = 2;
inline bool TransactionInfo::_internal_has_seq_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TransactionInfo::has_seq_id() const {
  return _internal_has_seq_id();
}
inline void TransactionInfo::clear_seq_id() {
  seq_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TransactionInfo::_internal_seq_id() const {
  return seq_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TransactionInfo::seq_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.seq_id)
  return _internal_seq_id();
}
inline void TransactionInfo::_internal_set_seq_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  seq_id_ = value;
}
inline void TransactionInfo::set_seq_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_seq_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionInfo.seq_id)
}

// optional int32 start_seq_id = 3;
inline bool TransactionInfo::_internal_has_start_seq_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TransactionInfo::has_start_seq_id() const {
  return _internal_has_start_seq_id();
}
inline void TransactionInfo::clear_start_seq_id() {
  start_seq_id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TransactionInfo::_internal_start_seq_id() const {
  return start_seq_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TransactionInfo::start_seq_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.start_seq_id)
  return _internal_start_seq_id();
}
inline void TransactionInfo::_internal_set_start_seq_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  start_seq_id_ = value;
}
inline void TransactionInfo::set_start_seq_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start_seq_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionInfo.start_seq_id)
}

// optional bool optimize_1pc = 4;
inline bool TransactionInfo::_internal_has_optimize_1pc() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TransactionInfo::has_optimize_1pc() const {
  return _internal_has_optimize_1pc();
}
inline void TransactionInfo::clear_optimize_1pc() {
  optimize_1pc_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool TransactionInfo::_internal_optimize_1pc() const {
  return optimize_1pc_;
}
inline bool TransactionInfo::optimize_1pc() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.optimize_1pc)
  return _internal_optimize_1pc();
}
inline void TransactionInfo::_internal_set_optimize_1pc(bool value) {
  _has_bits_[0] |= 0x00000040u;
  optimize_1pc_ = value;
}
inline void TransactionInfo::set_optimize_1pc(bool value) {
  _internal_set_optimize_1pc(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionInfo.optimize_1pc)
}

// repeated int32 need_rollback_seq = 5;
inline int TransactionInfo::_internal_need_rollback_seq_size() const {
  return need_rollback_seq_.size();
}
inline int TransactionInfo::need_rollback_seq_size() const {
  return _internal_need_rollback_seq_size();
}
inline void TransactionInfo::clear_need_rollback_seq() {
  need_rollback_seq_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TransactionInfo::_internal_need_rollback_seq(int index) const {
  return need_rollback_seq_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TransactionInfo::need_rollback_seq(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.need_rollback_seq)
  return _internal_need_rollback_seq(index);
}
inline void TransactionInfo::set_need_rollback_seq(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  need_rollback_seq_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionInfo.need_rollback_seq)
}
inline void TransactionInfo::_internal_add_need_rollback_seq(::PROTOBUF_NAMESPACE_ID::int32 value) {
  need_rollback_seq_.Add(value);
}
inline void TransactionInfo::add_need_rollback_seq(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_need_rollback_seq(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.TransactionInfo.need_rollback_seq)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TransactionInfo::_internal_need_rollback_seq() const {
  return need_rollback_seq_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TransactionInfo::need_rollback_seq() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.TransactionInfo.need_rollback_seq)
  return _internal_need_rollback_seq();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TransactionInfo::_internal_mutable_need_rollback_seq() {
  return &need_rollback_seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TransactionInfo::mutable_need_rollback_seq() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.TransactionInfo.need_rollback_seq)
  return _internal_mutable_need_rollback_seq();
}

// repeated .baikaldb.pb.CachePlan cache_plans = 6;
inline int TransactionInfo::_internal_cache_plans_size() const {
  return cache_plans_.size();
}
inline int TransactionInfo::cache_plans_size() const {
  return _internal_cache_plans_size();
}
inline void TransactionInfo::clear_cache_plans() {
  cache_plans_.Clear();
}
inline ::baikaldb::pb::CachePlan* TransactionInfo::mutable_cache_plans(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TransactionInfo.cache_plans)
  return cache_plans_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CachePlan >*
TransactionInfo::mutable_cache_plans() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.TransactionInfo.cache_plans)
  return &cache_plans_;
}
inline const ::baikaldb::pb::CachePlan& TransactionInfo::_internal_cache_plans(int index) const {
  return cache_plans_.Get(index);
}
inline const ::baikaldb::pb::CachePlan& TransactionInfo::cache_plans(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.cache_plans)
  return _internal_cache_plans(index);
}
inline ::baikaldb::pb::CachePlan* TransactionInfo::_internal_add_cache_plans() {
  return cache_plans_.Add();
}
inline ::baikaldb::pb::CachePlan* TransactionInfo::add_cache_plans() {
  ::baikaldb::pb::CachePlan* _add = _internal_add_cache_plans();
  // @@protoc_insertion_point(field_add:baikaldb.pb.TransactionInfo.cache_plans)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CachePlan >&
TransactionInfo::cache_plans() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.TransactionInfo.cache_plans)
  return cache_plans_;
}

// optional int64 num_rows = 7;
inline bool TransactionInfo::_internal_has_num_rows() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TransactionInfo::has_num_rows() const {
  return _internal_has_num_rows();
}
inline void TransactionInfo::clear_num_rows() {
  num_rows_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionInfo::_internal_num_rows() const {
  return num_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionInfo::num_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.num_rows)
  return _internal_num_rows();
}
inline void TransactionInfo::_internal_set_num_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  num_rows_ = value;
}
inline void TransactionInfo::set_num_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_num_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionInfo.num_rows)
}

// optional bool autocommit = 8;
inline bool TransactionInfo::_internal_has_autocommit() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TransactionInfo::has_autocommit() const {
  return _internal_has_autocommit();
}
inline void TransactionInfo::clear_autocommit() {
  autocommit_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool TransactionInfo::_internal_autocommit() const {
  return autocommit_;
}
inline bool TransactionInfo::autocommit() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.autocommit)
  return _internal_autocommit();
}
inline void TransactionInfo::_internal_set_autocommit(bool value) {
  _has_bits_[0] |= 0x00000080u;
  autocommit_ = value;
}
inline void TransactionInfo::set_autocommit(bool value) {
  _internal_set_autocommit(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionInfo.autocommit)
}

// optional int64 primary_region_id = 9;
inline bool TransactionInfo::_internal_has_primary_region_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TransactionInfo::has_primary_region_id() const {
  return _internal_has_primary_region_id();
}
inline void TransactionInfo::clear_primary_region_id() {
  primary_region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionInfo::_internal_primary_region_id() const {
  return primary_region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionInfo::primary_region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.primary_region_id)
  return _internal_primary_region_id();
}
inline void TransactionInfo::_internal_set_primary_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  primary_region_id_ = value;
}
inline void TransactionInfo::set_primary_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_primary_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionInfo.primary_region_id)
}

// optional .baikaldb.pb.TxnState txn_state = 10;
inline bool TransactionInfo::_internal_has_txn_state() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TransactionInfo::has_txn_state() const {
  return _internal_has_txn_state();
}
inline void TransactionInfo::clear_txn_state() {
  txn_state_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::baikaldb::pb::TxnState TransactionInfo::_internal_txn_state() const {
  return static_cast< ::baikaldb::pb::TxnState >(txn_state_);
}
inline ::baikaldb::pb::TxnState TransactionInfo::txn_state() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.txn_state)
  return _internal_txn_state();
}
inline void TransactionInfo::_internal_set_txn_state(::baikaldb::pb::TxnState value) {
  assert(::baikaldb::pb::TxnState_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  txn_state_ = value;
}
inline void TransactionInfo::set_txn_state(::baikaldb::pb::TxnState value) {
  _internal_set_txn_state(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionInfo.txn_state)
}

// optional int64 live_time = 11;
inline bool TransactionInfo::_internal_has_live_time() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TransactionInfo::has_live_time() const {
  return _internal_has_live_time();
}
inline void TransactionInfo::clear_live_time() {
  live_time_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionInfo::_internal_live_time() const {
  return live_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionInfo::live_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.live_time)
  return _internal_live_time();
}
inline void TransactionInfo::_internal_set_live_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  live_time_ = value;
}
inline void TransactionInfo::set_live_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_live_time(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionInfo.live_time)
}

// optional int64 start_ts = 12;
inline bool TransactionInfo::_internal_has_start_ts() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TransactionInfo::has_start_ts() const {
  return _internal_has_start_ts();
}
inline void TransactionInfo::clear_start_ts() {
  start_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionInfo::_internal_start_ts() const {
  return start_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionInfo::start_ts() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.start_ts)
  return _internal_start_ts();
}
inline void TransactionInfo::_internal_set_start_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  start_ts_ = value;
}
inline void TransactionInfo::set_start_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start_ts(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionInfo.start_ts)
}

// optional int64 commit_ts = 13;
inline bool TransactionInfo::_internal_has_commit_ts() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TransactionInfo::has_commit_ts() const {
  return _internal_has_commit_ts();
}
inline void TransactionInfo::clear_commit_ts() {
  commit_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionInfo::_internal_commit_ts() const {
  return commit_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionInfo::commit_ts() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.commit_ts)
  return _internal_commit_ts();
}
inline void TransactionInfo::_internal_set_commit_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00001000u;
  commit_ts_ = value;
}
inline void TransactionInfo::set_commit_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_commit_ts(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionInfo.commit_ts)
}

// optional bool open_binlog = 14;
inline bool TransactionInfo::_internal_has_open_binlog() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TransactionInfo::has_open_binlog() const {
  return _internal_has_open_binlog();
}
inline void TransactionInfo::clear_open_binlog() {
  open_binlog_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool TransactionInfo::_internal_open_binlog() const {
  return open_binlog_;
}
inline bool TransactionInfo::open_binlog() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.open_binlog)
  return _internal_open_binlog();
}
inline void TransactionInfo::_internal_set_open_binlog(bool value) {
  _has_bits_[0] |= 0x00000100u;
  open_binlog_ = value;
}
inline void TransactionInfo::set_open_binlog(bool value) {
  _internal_set_open_binlog(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionInfo.open_binlog)
}

// optional bool from_store = 15;
inline bool TransactionInfo::_internal_has_from_store() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TransactionInfo::has_from_store() const {
  return _internal_has_from_store();
}
inline void TransactionInfo::clear_from_store() {
  from_store_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool TransactionInfo::_internal_from_store() const {
  return from_store_;
}
inline bool TransactionInfo::from_store() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.from_store)
  return _internal_from_store();
}
inline void TransactionInfo::_internal_set_from_store(bool value) {
  _has_bits_[0] |= 0x00000200u;
  from_store_ = value;
}
inline void TransactionInfo::set_from_store(bool value) {
  _internal_set_from_store(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionInfo.from_store)
}

// optional int64 txn_timeout = 16;
inline bool TransactionInfo::_internal_has_txn_timeout() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool TransactionInfo::has_txn_timeout() const {
  return _internal_has_txn_timeout();
}
inline void TransactionInfo::clear_txn_timeout() {
  txn_timeout_ = int64_t{0};
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionInfo::_internal_txn_timeout() const {
  return txn_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionInfo::txn_timeout() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.txn_timeout)
  return _internal_txn_timeout();
}
inline void TransactionInfo::_internal_set_txn_timeout(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00002000u;
  txn_timeout_ = value;
}
inline void TransactionInfo::set_txn_timeout(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_txn_timeout(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionInfo.txn_timeout)
}

// optional bool need_update_primary_timestamp = 17;
inline bool TransactionInfo::_internal_has_need_update_primary_timestamp() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool TransactionInfo::has_need_update_primary_timestamp() const {
  return _internal_has_need_update_primary_timestamp();
}
inline void TransactionInfo::clear_need_update_primary_timestamp() {
  need_update_primary_timestamp_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool TransactionInfo::_internal_need_update_primary_timestamp() const {
  return need_update_primary_timestamp_;
}
inline bool TransactionInfo::need_update_primary_timestamp() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionInfo.need_update_primary_timestamp)
  return _internal_need_update_primary_timestamp();
}
inline void TransactionInfo::_internal_set_need_update_primary_timestamp(bool value) {
  _has_bits_[0] |= 0x00004000u;
  need_update_primary_timestamp_ = value;
}
inline void TransactionInfo::set_need_update_primary_timestamp(bool value) {
  _internal_set_need_update_primary_timestamp(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionInfo.need_update_primary_timestamp)
}

// -------------------------------------------------------------------

// AnalyzeInfo

// optional int32 depth = 1;
inline bool AnalyzeInfo::_internal_has_depth() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AnalyzeInfo::has_depth() const {
  return _internal_has_depth();
}
inline void AnalyzeInfo::clear_depth() {
  depth_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AnalyzeInfo::_internal_depth() const {
  return depth_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AnalyzeInfo::depth() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AnalyzeInfo.depth)
  return _internal_depth();
}
inline void AnalyzeInfo::_internal_set_depth(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  depth_ = value;
}
inline void AnalyzeInfo::set_depth(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AnalyzeInfo.depth)
}

// optional int32 width = 2;
inline bool AnalyzeInfo::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AnalyzeInfo::has_width() const {
  return _internal_has_width();
}
inline void AnalyzeInfo::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AnalyzeInfo::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AnalyzeInfo::width() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AnalyzeInfo.width)
  return _internal_width();
}
inline void AnalyzeInfo::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  width_ = value;
}
inline void AnalyzeInfo::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AnalyzeInfo.width)
}

// optional int32 sample_rows = 3;
inline bool AnalyzeInfo::_internal_has_sample_rows() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AnalyzeInfo::has_sample_rows() const {
  return _internal_has_sample_rows();
}
inline void AnalyzeInfo::clear_sample_rows() {
  sample_rows_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AnalyzeInfo::_internal_sample_rows() const {
  return sample_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AnalyzeInfo::sample_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AnalyzeInfo.sample_rows)
  return _internal_sample_rows();
}
inline void AnalyzeInfo::_internal_set_sample_rows(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  sample_rows_ = value;
}
inline void AnalyzeInfo::set_sample_rows(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sample_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AnalyzeInfo.sample_rows)
}

// optional int64 table_rows = 4;
inline bool AnalyzeInfo::_internal_has_table_rows() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AnalyzeInfo::has_table_rows() const {
  return _internal_has_table_rows();
}
inline void AnalyzeInfo::clear_table_rows() {
  table_rows_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AnalyzeInfo::_internal_table_rows() const {
  return table_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AnalyzeInfo::table_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AnalyzeInfo.table_rows)
  return _internal_table_rows();
}
inline void AnalyzeInfo::_internal_set_table_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  table_rows_ = value;
}
inline void AnalyzeInfo::set_table_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AnalyzeInfo.table_rows)
}

// repeated .baikaldb.pb.StatisticType statistics_types = 5;
inline int AnalyzeInfo::_internal_statistics_types_size() const {
  return statistics_types_.size();
}
inline int AnalyzeInfo::statistics_types_size() const {
  return _internal_statistics_types_size();
}
inline void AnalyzeInfo::clear_statistics_types() {
  statistics_types_.Clear();
}
inline ::baikaldb::pb::StatisticType AnalyzeInfo::_internal_statistics_types(int index) const {
  return static_cast< ::baikaldb::pb::StatisticType >(statistics_types_.Get(index));
}
inline ::baikaldb::pb::StatisticType AnalyzeInfo::statistics_types(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AnalyzeInfo.statistics_types)
  return _internal_statistics_types(index);
}
inline void AnalyzeInfo::set_statistics_types(int index, ::baikaldb::pb::StatisticType value) {
  assert(::baikaldb::pb::StatisticType_IsValid(value));
  statistics_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AnalyzeInfo.statistics_types)
}
inline void AnalyzeInfo::_internal_add_statistics_types(::baikaldb::pb::StatisticType value) {
  assert(::baikaldb::pb::StatisticType_IsValid(value));
  statistics_types_.Add(value);
}
inline void AnalyzeInfo::add_statistics_types(::baikaldb::pb::StatisticType value) {
  _internal_add_statistics_types(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.AnalyzeInfo.statistics_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
AnalyzeInfo::statistics_types() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.AnalyzeInfo.statistics_types)
  return statistics_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
AnalyzeInfo::_internal_mutable_statistics_types() {
  return &statistics_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
AnalyzeInfo::mutable_statistics_types() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.AnalyzeInfo.statistics_types)
  return _internal_mutable_statistics_types();
}

// -------------------------------------------------------------------

// BinlogDesc

// required int64 binlog_ts = 1;
inline bool BinlogDesc::_internal_has_binlog_ts() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BinlogDesc::has_binlog_ts() const {
  return _internal_has_binlog_ts();
}
inline void BinlogDesc::clear_binlog_ts() {
  binlog_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogDesc::_internal_binlog_ts() const {
  return binlog_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogDesc::binlog_ts() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogDesc.binlog_ts)
  return _internal_binlog_ts();
}
inline void BinlogDesc::_internal_set_binlog_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  binlog_ts_ = value;
}
inline void BinlogDesc::set_binlog_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_binlog_ts(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogDesc.binlog_ts)
}

// optional int64 txn_id = 2;
inline bool BinlogDesc::_internal_has_txn_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BinlogDesc::has_txn_id() const {
  return _internal_has_txn_id();
}
inline void BinlogDesc::clear_txn_id() {
  txn_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogDesc::_internal_txn_id() const {
  return txn_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogDesc::txn_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogDesc.txn_id)
  return _internal_txn_id();
}
inline void BinlogDesc::_internal_set_txn_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  txn_id_ = value;
}
inline void BinlogDesc::set_txn_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_txn_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogDesc.txn_id)
}

// optional int64 start_ts = 3;
inline bool BinlogDesc::_internal_has_start_ts() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BinlogDesc::has_start_ts() const {
  return _internal_has_start_ts();
}
inline void BinlogDesc::clear_start_ts() {
  start_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogDesc::_internal_start_ts() const {
  return start_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogDesc::start_ts() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogDesc.start_ts)
  return _internal_start_ts();
}
inline void BinlogDesc::_internal_set_start_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  start_ts_ = value;
}
inline void BinlogDesc::set_start_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start_ts(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogDesc.start_ts)
}

// optional int64 primary_region_id = 4;
inline bool BinlogDesc::_internal_has_primary_region_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BinlogDesc::has_primary_region_id() const {
  return _internal_has_primary_region_id();
}
inline void BinlogDesc::clear_primary_region_id() {
  primary_region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogDesc::_internal_primary_region_id() const {
  return primary_region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogDesc::primary_region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogDesc.primary_region_id)
  return _internal_primary_region_id();
}
inline void BinlogDesc::_internal_set_primary_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  primary_region_id_ = value;
}
inline void BinlogDesc::set_primary_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_primary_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogDesc.primary_region_id)
}

// optional int64 read_binlog_cnt = 6;
inline bool BinlogDesc::_internal_has_read_binlog_cnt() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BinlogDesc::has_read_binlog_cnt() const {
  return _internal_has_read_binlog_cnt();
}
inline void BinlogDesc::clear_read_binlog_cnt() {
  read_binlog_cnt_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogDesc::_internal_read_binlog_cnt() const {
  return read_binlog_cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogDesc::read_binlog_cnt() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogDesc.read_binlog_cnt)
  return _internal_read_binlog_cnt();
}
inline void BinlogDesc::_internal_set_read_binlog_cnt(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  read_binlog_cnt_ = value;
}
inline void BinlogDesc::set_read_binlog_cnt(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_read_binlog_cnt(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogDesc.read_binlog_cnt)
}

// optional int64 binlog_row_cnt = 7;
inline bool BinlogDesc::_internal_has_binlog_row_cnt() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool BinlogDesc::has_binlog_row_cnt() const {
  return _internal_has_binlog_row_cnt();
}
inline void BinlogDesc::clear_binlog_row_cnt() {
  binlog_row_cnt_ = int64_t{0};
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogDesc::_internal_binlog_row_cnt() const {
  return binlog_row_cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogDesc::binlog_row_cnt() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogDesc.binlog_row_cnt)
  return _internal_binlog_row_cnt();
}
inline void BinlogDesc::_internal_set_binlog_row_cnt(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  binlog_row_cnt_ = value;
}
inline void BinlogDesc::set_binlog_row_cnt(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_binlog_row_cnt(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogDesc.binlog_row_cnt)
}

// optional bytes user_name = 8;
inline bool BinlogDesc::_internal_has_user_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BinlogDesc::has_user_name() const {
  return _internal_has_user_name();
}
inline void BinlogDesc::clear_user_name() {
  user_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BinlogDesc::user_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogDesc.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinlogDesc::set_user_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogDesc.user_name)
}
inline std::string* BinlogDesc::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BinlogDesc.user_name)
  return _s;
}
inline const std::string& BinlogDesc::_internal_user_name() const {
  return user_name_.Get();
}
inline void BinlogDesc::_internal_set_user_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BinlogDesc::_internal_mutable_user_name() {
  _has_bits_[0] |= 0x00000001u;
  return user_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BinlogDesc::release_user_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BinlogDesc.user_name)
  if (!_internal_has_user_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return user_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BinlogDesc::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BinlogDesc.user_name)
}

// optional bytes user_ip = 9;
inline bool BinlogDesc::_internal_has_user_ip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BinlogDesc::has_user_ip() const {
  return _internal_has_user_ip();
}
inline void BinlogDesc::clear_user_ip() {
  user_ip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BinlogDesc::user_ip() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogDesc.user_ip)
  return _internal_user_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinlogDesc::set_user_ip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 user_ip_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogDesc.user_ip)
}
inline std::string* BinlogDesc::mutable_user_ip() {
  std::string* _s = _internal_mutable_user_ip();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BinlogDesc.user_ip)
  return _s;
}
inline const std::string& BinlogDesc::_internal_user_ip() const {
  return user_ip_.Get();
}
inline void BinlogDesc::_internal_set_user_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  user_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BinlogDesc::_internal_mutable_user_ip() {
  _has_bits_[0] |= 0x00000002u;
  return user_ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BinlogDesc::release_user_ip() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BinlogDesc.user_ip)
  if (!_internal_has_user_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return user_ip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BinlogDesc::set_allocated_user_ip(std::string* user_ip) {
  if (user_ip != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  user_ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_ip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BinlogDesc.user_ip)
}

// repeated bytes db_tables = 10;
inline int BinlogDesc::_internal_db_tables_size() const {
  return db_tables_.size();
}
inline int BinlogDesc::db_tables_size() const {
  return _internal_db_tables_size();
}
inline void BinlogDesc::clear_db_tables() {
  db_tables_.Clear();
}
inline std::string* BinlogDesc::add_db_tables() {
  std::string* _s = _internal_add_db_tables();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.BinlogDesc.db_tables)
  return _s;
}
inline const std::string& BinlogDesc::_internal_db_tables(int index) const {
  return db_tables_.Get(index);
}
inline const std::string& BinlogDesc::db_tables(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogDesc.db_tables)
  return _internal_db_tables(index);
}
inline std::string* BinlogDesc::mutable_db_tables(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BinlogDesc.db_tables)
  return db_tables_.Mutable(index);
}
inline void BinlogDesc::set_db_tables(int index, const std::string& value) {
  db_tables_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogDesc.db_tables)
}
inline void BinlogDesc::set_db_tables(int index, std::string&& value) {
  db_tables_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogDesc.db_tables)
}
inline void BinlogDesc::set_db_tables(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  db_tables_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.BinlogDesc.db_tables)
}
inline void BinlogDesc::set_db_tables(int index, const void* value, size_t size) {
  db_tables_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.BinlogDesc.db_tables)
}
inline std::string* BinlogDesc::_internal_add_db_tables() {
  return db_tables_.Add();
}
inline void BinlogDesc::add_db_tables(const std::string& value) {
  db_tables_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.BinlogDesc.db_tables)
}
inline void BinlogDesc::add_db_tables(std::string&& value) {
  db_tables_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.BinlogDesc.db_tables)
}
inline void BinlogDesc::add_db_tables(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  db_tables_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.BinlogDesc.db_tables)
}
inline void BinlogDesc::add_db_tables(const void* value, size_t size) {
  db_tables_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.BinlogDesc.db_tables)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BinlogDesc::db_tables() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BinlogDesc.db_tables)
  return db_tables_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BinlogDesc::mutable_db_tables() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BinlogDesc.db_tables)
  return &db_tables_;
}

// repeated uint64 signs = 11;
inline int BinlogDesc::_internal_signs_size() const {
  return signs_.size();
}
inline int BinlogDesc::signs_size() const {
  return _internal_signs_size();
}
inline void BinlogDesc::clear_signs() {
  signs_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BinlogDesc::_internal_signs(int index) const {
  return signs_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BinlogDesc::signs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogDesc.signs)
  return _internal_signs(index);
}
inline void BinlogDesc::set_signs(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  signs_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogDesc.signs)
}
inline void BinlogDesc::_internal_add_signs(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  signs_.Add(value);
}
inline void BinlogDesc::add_signs(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_signs(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.BinlogDesc.signs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
BinlogDesc::_internal_signs() const {
  return signs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
BinlogDesc::signs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BinlogDesc.signs)
  return _internal_signs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
BinlogDesc::_internal_mutable_signs() {
  return &signs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
BinlogDesc::mutable_signs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BinlogDesc.signs)
  return _internal_mutable_signs();
}

// repeated int64 txn_ids = 12;
inline int BinlogDesc::_internal_txn_ids_size() const {
  return txn_ids_.size();
}
inline int BinlogDesc::txn_ids_size() const {
  return _internal_txn_ids_size();
}
inline void BinlogDesc::clear_txn_ids() {
  txn_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogDesc::_internal_txn_ids(int index) const {
  return txn_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogDesc::txn_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogDesc.txn_ids)
  return _internal_txn_ids(index);
}
inline void BinlogDesc::set_txn_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  txn_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogDesc.txn_ids)
}
inline void BinlogDesc::_internal_add_txn_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  txn_ids_.Add(value);
}
inline void BinlogDesc::add_txn_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_txn_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.BinlogDesc.txn_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
BinlogDesc::_internal_txn_ids() const {
  return txn_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
BinlogDesc::txn_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BinlogDesc.txn_ids)
  return _internal_txn_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
BinlogDesc::_internal_mutable_txn_ids() {
  return &txn_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
BinlogDesc::mutable_txn_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BinlogDesc.txn_ids)
  return _internal_mutable_txn_ids();
}

// optional bool flash_back_read = 13;
inline bool BinlogDesc::_internal_has_flash_back_read() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool BinlogDesc::has_flash_back_read() const {
  return _internal_has_flash_back_read();
}
inline void BinlogDesc::clear_flash_back_read() {
  flash_back_read_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool BinlogDesc::_internal_flash_back_read() const {
  return flash_back_read_;
}
inline bool BinlogDesc::flash_back_read() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogDesc.flash_back_read)
  return _internal_flash_back_read();
}
inline void BinlogDesc::_internal_set_flash_back_read(bool value) {
  _has_bits_[0] |= 0x00000100u;
  flash_back_read_ = value;
}
inline void BinlogDesc::set_flash_back_read(bool value) {
  _internal_set_flash_back_read(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogDesc.flash_back_read)
}

// optional bool read_offline_binlog = 14;
inline bool BinlogDesc::_internal_has_read_offline_binlog() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool BinlogDesc::has_read_offline_binlog() const {
  return _internal_has_read_offline_binlog();
}
inline void BinlogDesc::clear_read_offline_binlog() {
  read_offline_binlog_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool BinlogDesc::_internal_read_offline_binlog() const {
  return read_offline_binlog_;
}
inline bool BinlogDesc::read_offline_binlog() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogDesc.read_offline_binlog)
  return _internal_read_offline_binlog();
}
inline void BinlogDesc::_internal_set_read_offline_binlog(bool value) {
  _has_bits_[0] |= 0x00000200u;
  read_offline_binlog_ = value;
}
inline void BinlogDesc::set_read_offline_binlog(bool value) {
  _internal_set_read_offline_binlog(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogDesc.read_offline_binlog)
}

// -------------------------------------------------------------------

// BatchStoreReq

// required int64 region_id = 1;
inline bool BatchStoreReq::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BatchStoreReq::has_region_id() const {
  return _internal_has_region_id();
}
inline void BatchStoreReq::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatchStoreReq::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatchStoreReq::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BatchStoreReq.region_id)
  return _internal_region_id();
}
inline void BatchStoreReq::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  region_id_ = value;
}
inline void BatchStoreReq::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BatchStoreReq.region_id)
}

// repeated int64 request_lens = 2;
inline int BatchStoreReq::_internal_request_lens_size() const {
  return request_lens_.size();
}
inline int BatchStoreReq::request_lens_size() const {
  return _internal_request_lens_size();
}
inline void BatchStoreReq::clear_request_lens() {
  request_lens_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatchStoreReq::_internal_request_lens(int index) const {
  return request_lens_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatchStoreReq::request_lens(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BatchStoreReq.request_lens)
  return _internal_request_lens(index);
}
inline void BatchStoreReq::set_request_lens(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  request_lens_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BatchStoreReq.request_lens)
}
inline void BatchStoreReq::_internal_add_request_lens(::PROTOBUF_NAMESPACE_ID::int64 value) {
  request_lens_.Add(value);
}
inline void BatchStoreReq::add_request_lens(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_request_lens(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.BatchStoreReq.request_lens)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
BatchStoreReq::_internal_request_lens() const {
  return request_lens_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
BatchStoreReq::request_lens() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BatchStoreReq.request_lens)
  return _internal_request_lens();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
BatchStoreReq::_internal_mutable_request_lens() {
  return &request_lens_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
BatchStoreReq::mutable_request_lens() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BatchStoreReq.request_lens)
  return _internal_mutable_request_lens();
}

// optional int64 resend_start_pos = 3;
inline bool BatchStoreReq::_internal_has_resend_start_pos() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BatchStoreReq::has_resend_start_pos() const {
  return _internal_has_resend_start_pos();
}
inline void BatchStoreReq::clear_resend_start_pos() {
  resend_start_pos_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatchStoreReq::_internal_resend_start_pos() const {
  return resend_start_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatchStoreReq::resend_start_pos() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BatchStoreReq.resend_start_pos)
  return _internal_resend_start_pos();
}
inline void BatchStoreReq::_internal_set_resend_start_pos(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  resend_start_pos_ = value;
}
inline void BatchStoreReq::set_resend_start_pos(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_resend_start_pos(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BatchStoreReq.resend_start_pos)
}

// -------------------------------------------------------------------

// BatchStoreRes

// required .baikaldb.pb.ErrCode errcode = 1;
inline bool BatchStoreRes::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BatchStoreRes::has_errcode() const {
  return _internal_has_errcode();
}
inline void BatchStoreRes::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::baikaldb::pb::ErrCode BatchStoreRes::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::ErrCode >(errcode_);
}
inline ::baikaldb::pb::ErrCode BatchStoreRes::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BatchStoreRes.errcode)
  return _internal_errcode();
}
inline void BatchStoreRes::_internal_set_errcode(::baikaldb::pb::ErrCode value) {
  assert(::baikaldb::pb::ErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  errcode_ = value;
}
inline void BatchStoreRes::set_errcode(::baikaldb::pb::ErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BatchStoreRes.errcode)
}

// optional bytes errmsg = 2;
inline bool BatchStoreRes::_internal_has_errmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BatchStoreRes::has_errmsg() const {
  return _internal_has_errmsg();
}
inline void BatchStoreRes::clear_errmsg() {
  errmsg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BatchStoreRes::errmsg() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BatchStoreRes.errmsg)
  return _internal_errmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatchStoreRes::set_errmsg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 errmsg_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BatchStoreRes.errmsg)
}
inline std::string* BatchStoreRes::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BatchStoreRes.errmsg)
  return _s;
}
inline const std::string& BatchStoreRes::_internal_errmsg() const {
  return errmsg_.Get();
}
inline void BatchStoreRes::_internal_set_errmsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BatchStoreRes::_internal_mutable_errmsg() {
  _has_bits_[0] |= 0x00000001u;
  return errmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BatchStoreRes::release_errmsg() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BatchStoreRes.errmsg)
  if (!_internal_has_errmsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return errmsg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BatchStoreRes::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BatchStoreRes.errmsg)
}

// optional string leader = 3;
inline bool BatchStoreRes::_internal_has_leader() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BatchStoreRes::has_leader() const {
  return _internal_has_leader();
}
inline void BatchStoreRes::clear_leader() {
  leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BatchStoreRes::leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BatchStoreRes.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BatchStoreRes::set_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BatchStoreRes.leader)
}
inline std::string* BatchStoreRes::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BatchStoreRes.leader)
  return _s;
}
inline const std::string& BatchStoreRes::_internal_leader() const {
  return leader_.Get();
}
inline void BatchStoreRes::_internal_set_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BatchStoreRes::_internal_mutable_leader() {
  _has_bits_[0] |= 0x00000002u;
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BatchStoreRes::release_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BatchStoreRes.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BatchStoreRes::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BatchStoreRes.leader)
}

// optional int64 success_cnt = 4;
inline bool BatchStoreRes::_internal_has_success_cnt() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BatchStoreRes::has_success_cnt() const {
  return _internal_has_success_cnt();
}
inline void BatchStoreRes::clear_success_cnt() {
  success_cnt_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatchStoreRes::_internal_success_cnt() const {
  return success_cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatchStoreRes::success_cnt() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BatchStoreRes.success_cnt)
  return _internal_success_cnt();
}
inline void BatchStoreRes::_internal_set_success_cnt(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  success_cnt_ = value;
}
inline void BatchStoreRes::set_success_cnt(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_success_cnt(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BatchStoreRes.success_cnt)
}

// optional int64 applied_index = 5;
inline bool BatchStoreRes::_internal_has_applied_index() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BatchStoreRes::has_applied_index() const {
  return _internal_has_applied_index();
}
inline void BatchStoreRes::clear_applied_index() {
  applied_index_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatchStoreRes::_internal_applied_index() const {
  return applied_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatchStoreRes::applied_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BatchStoreRes.applied_index)
  return _internal_applied_index();
}
inline void BatchStoreRes::_internal_set_applied_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  applied_index_ = value;
}
inline void BatchStoreRes::set_applied_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_applied_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BatchStoreRes.applied_index)
}

// optional int64 braft_applied_index = 6;
inline bool BatchStoreRes::_internal_has_braft_applied_index() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BatchStoreRes::has_braft_applied_index() const {
  return _internal_has_braft_applied_index();
}
inline void BatchStoreRes::clear_braft_applied_index() {
  braft_applied_index_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatchStoreRes::_internal_braft_applied_index() const {
  return braft_applied_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatchStoreRes::braft_applied_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BatchStoreRes.braft_applied_index)
  return _internal_braft_applied_index();
}
inline void BatchStoreRes::_internal_set_braft_applied_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  braft_applied_index_ = value;
}
inline void BatchStoreRes::set_braft_applied_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_braft_applied_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BatchStoreRes.braft_applied_index)
}

// optional int64 dml_latency = 7;
inline bool BatchStoreRes::_internal_has_dml_latency() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BatchStoreRes::has_dml_latency() const {
  return _internal_has_dml_latency();
}
inline void BatchStoreRes::clear_dml_latency() {
  dml_latency_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatchStoreRes::_internal_dml_latency() const {
  return dml_latency_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatchStoreRes::dml_latency() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BatchStoreRes.dml_latency)
  return _internal_dml_latency();
}
inline void BatchStoreRes::_internal_set_dml_latency(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  dml_latency_ = value;
}
inline void BatchStoreRes::set_dml_latency(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_dml_latency(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BatchStoreRes.dml_latency)
}

// -------------------------------------------------------------------

// RegionIndexs

// optional int64 region_id = 1;
inline bool RegionIndexs::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RegionIndexs::has_region_id() const {
  return _internal_has_region_id();
}
inline void RegionIndexs::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIndexs::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIndexs::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIndexs.region_id)
  return _internal_region_id();
}
inline void RegionIndexs::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  region_id_ = value;
}
inline void RegionIndexs::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIndexs.region_id)
}

// optional int64 version = 2;
inline bool RegionIndexs::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RegionIndexs::has_version() const {
  return _internal_has_version();
}
inline void RegionIndexs::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIndexs::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIndexs::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIndexs.version)
  return _internal_version();
}
inline void RegionIndexs::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  version_ = value;
}
inline void RegionIndexs::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIndexs.version)
}

// optional int64 apply_index = 3;
inline bool RegionIndexs::_internal_has_apply_index() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RegionIndexs::has_apply_index() const {
  return _internal_has_apply_index();
}
inline void RegionIndexs::clear_apply_index() {
  apply_index_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIndexs::_internal_apply_index() const {
  return apply_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIndexs::apply_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIndexs.apply_index)
  return _internal_apply_index();
}
inline void RegionIndexs::_internal_set_apply_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  apply_index_ = value;
}
inline void RegionIndexs::set_apply_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_apply_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIndexs.apply_index)
}

// optional string status = 4;
inline bool RegionIndexs::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegionIndexs::has_status() const {
  return _internal_has_status();
}
inline void RegionIndexs::clear_status() {
  status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionIndexs::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIndexs.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionIndexs::set_status(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIndexs.status)
}
inline std::string* RegionIndexs::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionIndexs.status)
  return _s;
}
inline const std::string& RegionIndexs::_internal_status() const {
  return status_.Get();
}
inline void RegionIndexs::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionIndexs::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionIndexs::release_status() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionIndexs.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionIndexs::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionIndexs.status)
}

// optional string resource_tag = 5;
inline bool RegionIndexs::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionIndexs::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void RegionIndexs::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RegionIndexs::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIndexs.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionIndexs::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIndexs.resource_tag)
}
inline std::string* RegionIndexs::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionIndexs.resource_tag)
  return _s;
}
inline const std::string& RegionIndexs::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void RegionIndexs::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionIndexs::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000002u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionIndexs::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionIndexs.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionIndexs::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionIndexs.resource_tag)
}

// optional int64 table_id = 6;
inline bool RegionIndexs::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RegionIndexs::has_table_id() const {
  return _internal_has_table_id();
}
inline void RegionIndexs::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIndexs::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIndexs::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIndexs.table_id)
  return _internal_table_id();
}
inline void RegionIndexs::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  table_id_ = value;
}
inline void RegionIndexs::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIndexs.table_id)
}

// optional .baikaldb.pb.OlapRegionStat olap_state = 7;
inline bool RegionIndexs::_internal_has_olap_state() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool RegionIndexs::has_olap_state() const {
  return _internal_has_olap_state();
}
inline void RegionIndexs::clear_olap_state() {
  olap_state_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::baikaldb::pb::OlapRegionStat RegionIndexs::_internal_olap_state() const {
  return static_cast< ::baikaldb::pb::OlapRegionStat >(olap_state_);
}
inline ::baikaldb::pb::OlapRegionStat RegionIndexs::olap_state() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIndexs.olap_state)
  return _internal_olap_state();
}
inline void RegionIndexs::_internal_set_olap_state(::baikaldb::pb::OlapRegionStat value) {
  assert(::baikaldb::pb::OlapRegionStat_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  olap_state_ = value;
}
inline void RegionIndexs::set_olap_state(::baikaldb::pb::OlapRegionStat value) {
  _internal_set_olap_state(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIndexs.olap_state)
}

// repeated string external_full_path = 8;
inline int RegionIndexs::_internal_external_full_path_size() const {
  return external_full_path_.size();
}
inline int RegionIndexs::external_full_path_size() const {
  return _internal_external_full_path_size();
}
inline void RegionIndexs::clear_external_full_path() {
  external_full_path_.Clear();
}
inline std::string* RegionIndexs::add_external_full_path() {
  std::string* _s = _internal_add_external_full_path();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.RegionIndexs.external_full_path)
  return _s;
}
inline const std::string& RegionIndexs::_internal_external_full_path(int index) const {
  return external_full_path_.Get(index);
}
inline const std::string& RegionIndexs::external_full_path(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIndexs.external_full_path)
  return _internal_external_full_path(index);
}
inline std::string* RegionIndexs::mutable_external_full_path(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionIndexs.external_full_path)
  return external_full_path_.Mutable(index);
}
inline void RegionIndexs::set_external_full_path(int index, const std::string& value) {
  external_full_path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIndexs.external_full_path)
}
inline void RegionIndexs::set_external_full_path(int index, std::string&& value) {
  external_full_path_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIndexs.external_full_path)
}
inline void RegionIndexs::set_external_full_path(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  external_full_path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.RegionIndexs.external_full_path)
}
inline void RegionIndexs::set_external_full_path(int index, const char* value, size_t size) {
  external_full_path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.RegionIndexs.external_full_path)
}
inline std::string* RegionIndexs::_internal_add_external_full_path() {
  return external_full_path_.Add();
}
inline void RegionIndexs::add_external_full_path(const std::string& value) {
  external_full_path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionIndexs.external_full_path)
}
inline void RegionIndexs::add_external_full_path(std::string&& value) {
  external_full_path_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionIndexs.external_full_path)
}
inline void RegionIndexs::add_external_full_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  external_full_path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.RegionIndexs.external_full_path)
}
inline void RegionIndexs::add_external_full_path(const char* value, size_t size) {
  external_full_path_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.RegionIndexs.external_full_path)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RegionIndexs::external_full_path() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RegionIndexs.external_full_path)
  return external_full_path_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RegionIndexs::mutable_external_full_path() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RegionIndexs.external_full_path)
  return &external_full_path_;
}

// optional bool path_diff = 9;
inline bool RegionIndexs::_internal_has_path_diff() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool RegionIndexs::has_path_diff() const {
  return _internal_has_path_diff();
}
inline void RegionIndexs::clear_path_diff() {
  path_diff_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool RegionIndexs::_internal_path_diff() const {
  return path_diff_;
}
inline bool RegionIndexs::path_diff() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIndexs.path_diff)
  return _internal_path_diff();
}
inline void RegionIndexs::_internal_set_path_diff(bool value) {
  _has_bits_[0] |= 0x00000100u;
  path_diff_ = value;
}
inline void RegionIndexs::set_path_diff(bool value) {
  _internal_set_path_diff(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIndexs.path_diff)
}

// optional int64 region_size = 10;
inline bool RegionIndexs::_internal_has_region_size() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool RegionIndexs::has_region_size() const {
  return _internal_has_region_size();
}
inline void RegionIndexs::clear_region_size() {
  region_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIndexs::_internal_region_size() const {
  return region_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIndexs::region_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIndexs.region_size)
  return _internal_region_size();
}
inline void RegionIndexs::_internal_set_region_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  region_size_ = value;
}
inline void RegionIndexs::set_region_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIndexs.region_size)
}

// optional string column_info = 11;
inline bool RegionIndexs::_internal_has_column_info() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegionIndexs::has_column_info() const {
  return _internal_has_column_info();
}
inline void RegionIndexs::clear_column_info() {
  column_info_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RegionIndexs::column_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIndexs.column_info)
  return _internal_column_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionIndexs::set_column_info(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 column_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIndexs.column_info)
}
inline std::string* RegionIndexs::mutable_column_info() {
  std::string* _s = _internal_mutable_column_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionIndexs.column_info)
  return _s;
}
inline const std::string& RegionIndexs::_internal_column_info() const {
  return column_info_.Get();
}
inline void RegionIndexs::_internal_set_column_info(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  column_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionIndexs::_internal_mutable_column_info() {
  _has_bits_[0] |= 0x00000004u;
  return column_info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionIndexs::release_column_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionIndexs.column_info)
  if (!_internal_has_column_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return column_info_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionIndexs::set_allocated_column_info(std::string* column_info) {
  if (column_info != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  column_info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), column_info,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionIndexs.column_info)
}

// repeated .baikaldb.pb.OlapRegionIndexInfo olap_index_info_list = 12;
inline int RegionIndexs::_internal_olap_index_info_list_size() const {
  return olap_index_info_list_.size();
}
inline int RegionIndexs::olap_index_info_list_size() const {
  return _internal_olap_index_info_list_size();
}
inline void RegionIndexs::clear_olap_index_info_list() {
  olap_index_info_list_.Clear();
}
inline ::baikaldb::pb::OlapRegionIndexInfo* RegionIndexs::mutable_olap_index_info_list(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionIndexs.olap_index_info_list)
  return olap_index_info_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::OlapRegionIndexInfo >*
RegionIndexs::mutable_olap_index_info_list() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RegionIndexs.olap_index_info_list)
  return &olap_index_info_list_;
}
inline const ::baikaldb::pb::OlapRegionIndexInfo& RegionIndexs::_internal_olap_index_info_list(int index) const {
  return olap_index_info_list_.Get(index);
}
inline const ::baikaldb::pb::OlapRegionIndexInfo& RegionIndexs::olap_index_info_list(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIndexs.olap_index_info_list)
  return _internal_olap_index_info_list(index);
}
inline ::baikaldb::pb::OlapRegionIndexInfo* RegionIndexs::_internal_add_olap_index_info_list() {
  return olap_index_info_list_.Add();
}
inline ::baikaldb::pb::OlapRegionIndexInfo* RegionIndexs::add_olap_index_info_list() {
  ::baikaldb::pb::OlapRegionIndexInfo* _add = _internal_add_olap_index_info_list();
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionIndexs.olap_index_info_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::OlapRegionIndexInfo >&
RegionIndexs::olap_index_info_list() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RegionIndexs.olap_index_info_list)
  return olap_index_info_list_;
}

// -------------------------------------------------------------------

// ColumnRegionInfo

// optional .baikaldb.pb.RegionColumnFiles column_files = 1;
inline bool ColumnRegionInfo::_internal_has_column_files() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || column_files_ != nullptr);
  return value;
}
inline bool ColumnRegionInfo::has_column_files() const {
  return _internal_has_column_files();
}
inline const ::baikaldb::pb::RegionColumnFiles& ColumnRegionInfo::_internal_column_files() const {
  const ::baikaldb::pb::RegionColumnFiles* p = column_files_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionColumnFiles&>(
      ::baikaldb::pb::_RegionColumnFiles_default_instance_);
}
inline const ::baikaldb::pb::RegionColumnFiles& ColumnRegionInfo::column_files() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ColumnRegionInfo.column_files)
  return _internal_column_files();
}
inline void ColumnRegionInfo::unsafe_arena_set_allocated_column_files(
    ::baikaldb::pb::RegionColumnFiles* column_files) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(column_files_);
  }
  column_files_ = column_files;
  if (column_files) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.ColumnRegionInfo.column_files)
}
inline ::baikaldb::pb::RegionColumnFiles* ColumnRegionInfo::release_column_files() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::RegionColumnFiles* temp = column_files_;
  column_files_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionColumnFiles* ColumnRegionInfo::unsafe_arena_release_column_files() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ColumnRegionInfo.column_files)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::RegionColumnFiles* temp = column_files_;
  column_files_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionColumnFiles* ColumnRegionInfo::_internal_mutable_column_files() {
  _has_bits_[0] |= 0x00000001u;
  if (column_files_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionColumnFiles>(GetArenaForAllocation());
    column_files_ = p;
  }
  return column_files_;
}
inline ::baikaldb::pb::RegionColumnFiles* ColumnRegionInfo::mutable_column_files() {
  ::baikaldb::pb::RegionColumnFiles* _msg = _internal_mutable_column_files();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ColumnRegionInfo.column_files)
  return _msg;
}
inline void ColumnRegionInfo::set_allocated_column_files(::baikaldb::pb::RegionColumnFiles* column_files) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(column_files_);
  }
  if (column_files) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(column_files));
    if (message_arena != submessage_arena) {
      column_files = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_files, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  column_files_ = column_files;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ColumnRegionInfo.column_files)
}

// -------------------------------------------------------------------

// UseridCount

// optional int64 userid = 1;
inline bool UseridCount::_internal_has_userid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UseridCount::has_userid() const {
  return _internal_has_userid();
}
inline void UseridCount::clear_userid() {
  userid_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UseridCount::_internal_userid() const {
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UseridCount::userid() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UseridCount.userid)
  return _internal_userid();
}
inline void UseridCount::_internal_set_userid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  userid_ = value;
}
inline void UseridCount::set_userid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UseridCount.userid)
}

// optional int64 count = 2;
inline bool UseridCount::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UseridCount::has_count() const {
  return _internal_has_count();
}
inline void UseridCount::clear_count() {
  count_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UseridCount::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UseridCount::count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UseridCount.count)
  return _internal_count();
}
inline void UseridCount::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  count_ = value;
}
inline void UseridCount::set_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UseridCount.count)
}

// -------------------------------------------------------------------

// ExtraReq

// optional bool use_read_idx = 1;
inline bool ExtraReq::_internal_has_use_read_idx() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExtraReq::has_use_read_idx() const {
  return _internal_has_use_read_idx();
}
inline void ExtraReq::clear_use_read_idx() {
  use_read_idx_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ExtraReq::_internal_use_read_idx() const {
  return use_read_idx_;
}
inline bool ExtraReq::use_read_idx() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExtraReq.use_read_idx)
  return _internal_use_read_idx();
}
inline void ExtraReq::_internal_set_use_read_idx(bool value) {
  _has_bits_[0] |= 0x00000020u;
  use_read_idx_ = value;
}
inline void ExtraReq::set_use_read_idx(bool value) {
  _internal_set_use_read_idx(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExtraReq.use_read_idx)
}

// optional int64 sign_latency = 2;
inline bool ExtraReq::_internal_has_sign_latency() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExtraReq::has_sign_latency() const {
  return _internal_has_sign_latency();
}
inline void ExtraReq::clear_sign_latency() {
  sign_latency_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExtraReq::_internal_sign_latency() const {
  return sign_latency_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExtraReq::sign_latency() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExtraReq.sign_latency)
  return _internal_sign_latency();
}
inline void ExtraReq::_internal_set_sign_latency(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  sign_latency_ = value;
}
inline void ExtraReq::set_sign_latency(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_sign_latency(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExtraReq.sign_latency)
}

// optional .baikaldb.pb.OlapRegionInfo olap_info = 3;
inline bool ExtraReq::_internal_has_olap_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || olap_info_ != nullptr);
  return value;
}
inline bool ExtraReq::has_olap_info() const {
  return _internal_has_olap_info();
}
inline void ExtraReq::clear_olap_info() {
  if (olap_info_ != nullptr) olap_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::OlapRegionInfo& ExtraReq::_internal_olap_info() const {
  const ::baikaldb::pb::OlapRegionInfo* p = olap_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::OlapRegionInfo&>(
      ::baikaldb::pb::_OlapRegionInfo_default_instance_);
}
inline const ::baikaldb::pb::OlapRegionInfo& ExtraReq::olap_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExtraReq.olap_info)
  return _internal_olap_info();
}
inline void ExtraReq::unsafe_arena_set_allocated_olap_info(
    ::baikaldb::pb::OlapRegionInfo* olap_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(olap_info_);
  }
  olap_info_ = olap_info;
  if (olap_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.ExtraReq.olap_info)
}
inline ::baikaldb::pb::OlapRegionInfo* ExtraReq::release_olap_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::OlapRegionInfo* temp = olap_info_;
  olap_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::OlapRegionInfo* ExtraReq::unsafe_arena_release_olap_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ExtraReq.olap_info)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::OlapRegionInfo* temp = olap_info_;
  olap_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::OlapRegionInfo* ExtraReq::_internal_mutable_olap_info() {
  _has_bits_[0] |= 0x00000001u;
  if (olap_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::OlapRegionInfo>(GetArenaForAllocation());
    olap_info_ = p;
  }
  return olap_info_;
}
inline ::baikaldb::pb::OlapRegionInfo* ExtraReq::mutable_olap_info() {
  ::baikaldb::pb::OlapRegionInfo* _msg = _internal_mutable_olap_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExtraReq.olap_info)
  return _msg;
}
inline void ExtraReq::set_allocated_olap_info(::baikaldb::pb::OlapRegionInfo* olap_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete olap_info_;
  }
  if (olap_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::OlapRegionInfo>::GetOwningArena(olap_info);
    if (message_arena != submessage_arena) {
      olap_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, olap_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  olap_info_ = olap_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ExtraReq.olap_info)
}

// optional .baikaldb.pb.RegionOfflineBinlogInfo offline_binlog_info = 4;
inline bool ExtraReq::_internal_has_offline_binlog_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || offline_binlog_info_ != nullptr);
  return value;
}
inline bool ExtraReq::has_offline_binlog_info() const {
  return _internal_has_offline_binlog_info();
}
inline void ExtraReq::clear_offline_binlog_info() {
  if (offline_binlog_info_ != nullptr) offline_binlog_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::baikaldb::pb::RegionOfflineBinlogInfo& ExtraReq::_internal_offline_binlog_info() const {
  const ::baikaldb::pb::RegionOfflineBinlogInfo* p = offline_binlog_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionOfflineBinlogInfo&>(
      ::baikaldb::pb::_RegionOfflineBinlogInfo_default_instance_);
}
inline const ::baikaldb::pb::RegionOfflineBinlogInfo& ExtraReq::offline_binlog_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExtraReq.offline_binlog_info)
  return _internal_offline_binlog_info();
}
inline void ExtraReq::unsafe_arena_set_allocated_offline_binlog_info(
    ::baikaldb::pb::RegionOfflineBinlogInfo* offline_binlog_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(offline_binlog_info_);
  }
  offline_binlog_info_ = offline_binlog_info;
  if (offline_binlog_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.ExtraReq.offline_binlog_info)
}
inline ::baikaldb::pb::RegionOfflineBinlogInfo* ExtraReq::release_offline_binlog_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::RegionOfflineBinlogInfo* temp = offline_binlog_info_;
  offline_binlog_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionOfflineBinlogInfo* ExtraReq::unsafe_arena_release_offline_binlog_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ExtraReq.offline_binlog_info)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::RegionOfflineBinlogInfo* temp = offline_binlog_info_;
  offline_binlog_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionOfflineBinlogInfo* ExtraReq::_internal_mutable_offline_binlog_info() {
  _has_bits_[0] |= 0x00000002u;
  if (offline_binlog_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionOfflineBinlogInfo>(GetArenaForAllocation());
    offline_binlog_info_ = p;
  }
  return offline_binlog_info_;
}
inline ::baikaldb::pb::RegionOfflineBinlogInfo* ExtraReq::mutable_offline_binlog_info() {
  ::baikaldb::pb::RegionOfflineBinlogInfo* _msg = _internal_mutable_offline_binlog_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExtraReq.offline_binlog_info)
  return _msg;
}
inline void ExtraReq::set_allocated_offline_binlog_info(::baikaldb::pb::RegionOfflineBinlogInfo* offline_binlog_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete offline_binlog_info_;
  }
  if (offline_binlog_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::RegionOfflineBinlogInfo>::GetOwningArena(offline_binlog_info);
    if (message_arena != submessage_arena) {
      offline_binlog_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offline_binlog_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  offline_binlog_info_ = offline_binlog_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ExtraReq.offline_binlog_info)
}

// optional uint64 watt_stats_version = 5;
inline bool ExtraReq::_internal_has_watt_stats_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ExtraReq::has_watt_stats_version() const {
  return _internal_has_watt_stats_version();
}
inline void ExtraReq::clear_watt_stats_version() {
  watt_stats_version_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExtraReq::_internal_watt_stats_version() const {
  return watt_stats_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExtraReq::watt_stats_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExtraReq.watt_stats_version)
  return _internal_watt_stats_version();
}
inline void ExtraReq::_internal_set_watt_stats_version(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  watt_stats_version_ = value;
}
inline void ExtraReq::set_watt_stats_version(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_watt_stats_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExtraReq.watt_stats_version)
}

// optional .baikaldb.pb.ColumnRegionInfo column_info = 6;
inline bool ExtraReq::_internal_has_column_info() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || column_info_ != nullptr);
  return value;
}
inline bool ExtraReq::has_column_info() const {
  return _internal_has_column_info();
}
inline void ExtraReq::clear_column_info() {
  if (column_info_ != nullptr) column_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::baikaldb::pb::ColumnRegionInfo& ExtraReq::_internal_column_info() const {
  const ::baikaldb::pb::ColumnRegionInfo* p = column_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::ColumnRegionInfo&>(
      ::baikaldb::pb::_ColumnRegionInfo_default_instance_);
}
inline const ::baikaldb::pb::ColumnRegionInfo& ExtraReq::column_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExtraReq.column_info)
  return _internal_column_info();
}
inline void ExtraReq::unsafe_arena_set_allocated_column_info(
    ::baikaldb::pb::ColumnRegionInfo* column_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(column_info_);
  }
  column_info_ = column_info;
  if (column_info) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.ExtraReq.column_info)
}
inline ::baikaldb::pb::ColumnRegionInfo* ExtraReq::release_column_info() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::ColumnRegionInfo* temp = column_info_;
  column_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::ColumnRegionInfo* ExtraReq::unsafe_arena_release_column_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ExtraReq.column_info)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::ColumnRegionInfo* temp = column_info_;
  column_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::ColumnRegionInfo* ExtraReq::_internal_mutable_column_info() {
  _has_bits_[0] |= 0x00000004u;
  if (column_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::ColumnRegionInfo>(GetArenaForAllocation());
    column_info_ = p;
  }
  return column_info_;
}
inline ::baikaldb::pb::ColumnRegionInfo* ExtraReq::mutable_column_info() {
  ::baikaldb::pb::ColumnRegionInfo* _msg = _internal_mutable_column_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExtraReq.column_info)
  return _msg;
}
inline void ExtraReq::set_allocated_column_info(::baikaldb::pb::ColumnRegionInfo* column_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete column_info_;
  }
  if (column_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::ColumnRegionInfo>::GetOwningArena(column_info);
    if (message_arena != submessage_arena) {
      column_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  column_info_ = column_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ExtraReq.column_info)
}

// -------------------------------------------------------------------

// ExtraRes

// repeated .baikaldb.pb.RegionIndexs infos = 1;
inline int ExtraRes::_internal_infos_size() const {
  return infos_.size();
}
inline int ExtraRes::infos_size() const {
  return _internal_infos_size();
}
inline void ExtraRes::clear_infos() {
  infos_.Clear();
}
inline ::baikaldb::pb::RegionIndexs* ExtraRes::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExtraRes.infos)
  return infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionIndexs >*
ExtraRes::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ExtraRes.infos)
  return &infos_;
}
inline const ::baikaldb::pb::RegionIndexs& ExtraRes::_internal_infos(int index) const {
  return infos_.Get(index);
}
inline const ::baikaldb::pb::RegionIndexs& ExtraRes::infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExtraRes.infos)
  return _internal_infos(index);
}
inline ::baikaldb::pb::RegionIndexs* ExtraRes::_internal_add_infos() {
  return infos_.Add();
}
inline ::baikaldb::pb::RegionIndexs* ExtraRes::add_infos() {
  ::baikaldb::pb::RegionIndexs* _add = _internal_add_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ExtraRes.infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionIndexs >&
ExtraRes::infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ExtraRes.infos)
  return infos_;
}

// optional .baikaldb.pb.RegionOfflineBinlogInfo offline_binlog_info = 2;
inline bool ExtraRes::_internal_has_offline_binlog_info() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || offline_binlog_info_ != nullptr);
  return value;
}
inline bool ExtraRes::has_offline_binlog_info() const {
  return _internal_has_offline_binlog_info();
}
inline void ExtraRes::clear_offline_binlog_info() {
  if (offline_binlog_info_ != nullptr) offline_binlog_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::baikaldb::pb::RegionOfflineBinlogInfo& ExtraRes::_internal_offline_binlog_info() const {
  const ::baikaldb::pb::RegionOfflineBinlogInfo* p = offline_binlog_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionOfflineBinlogInfo&>(
      ::baikaldb::pb::_RegionOfflineBinlogInfo_default_instance_);
}
inline const ::baikaldb::pb::RegionOfflineBinlogInfo& ExtraRes::offline_binlog_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExtraRes.offline_binlog_info)
  return _internal_offline_binlog_info();
}
inline void ExtraRes::unsafe_arena_set_allocated_offline_binlog_info(
    ::baikaldb::pb::RegionOfflineBinlogInfo* offline_binlog_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(offline_binlog_info_);
  }
  offline_binlog_info_ = offline_binlog_info;
  if (offline_binlog_info) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.ExtraRes.offline_binlog_info)
}
inline ::baikaldb::pb::RegionOfflineBinlogInfo* ExtraRes::release_offline_binlog_info() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::RegionOfflineBinlogInfo* temp = offline_binlog_info_;
  offline_binlog_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionOfflineBinlogInfo* ExtraRes::unsafe_arena_release_offline_binlog_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ExtraRes.offline_binlog_info)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::RegionOfflineBinlogInfo* temp = offline_binlog_info_;
  offline_binlog_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionOfflineBinlogInfo* ExtraRes::_internal_mutable_offline_binlog_info() {
  _has_bits_[0] |= 0x00000004u;
  if (offline_binlog_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionOfflineBinlogInfo>(GetArenaForAllocation());
    offline_binlog_info_ = p;
  }
  return offline_binlog_info_;
}
inline ::baikaldb::pb::RegionOfflineBinlogInfo* ExtraRes::mutable_offline_binlog_info() {
  ::baikaldb::pb::RegionOfflineBinlogInfo* _msg = _internal_mutable_offline_binlog_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExtraRes.offline_binlog_info)
  return _msg;
}
inline void ExtraRes::set_allocated_offline_binlog_info(::baikaldb::pb::RegionOfflineBinlogInfo* offline_binlog_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete offline_binlog_info_;
  }
  if (offline_binlog_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::RegionOfflineBinlogInfo>::GetOwningArena(offline_binlog_info);
    if (message_arena != submessage_arena) {
      offline_binlog_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offline_binlog_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  offline_binlog_info_ = offline_binlog_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ExtraRes.offline_binlog_info)
}

// optional bytes vectorized_rows = 3;
inline bool ExtraRes::_internal_has_vectorized_rows() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExtraRes::has_vectorized_rows() const {
  return _internal_has_vectorized_rows();
}
inline void ExtraRes::clear_vectorized_rows() {
  vectorized_rows_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExtraRes::vectorized_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExtraRes.vectorized_rows)
  return _internal_vectorized_rows();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtraRes::set_vectorized_rows(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 vectorized_rows_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExtraRes.vectorized_rows)
}
inline std::string* ExtraRes::mutable_vectorized_rows() {
  std::string* _s = _internal_mutable_vectorized_rows();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExtraRes.vectorized_rows)
  return _s;
}
inline const std::string& ExtraRes::_internal_vectorized_rows() const {
  return vectorized_rows_.Get();
}
inline void ExtraRes::_internal_set_vectorized_rows(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  vectorized_rows_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExtraRes::_internal_mutable_vectorized_rows() {
  _has_bits_[0] |= 0x00000001u;
  return vectorized_rows_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExtraRes::release_vectorized_rows() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ExtraRes.vectorized_rows)
  if (!_internal_has_vectorized_rows()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return vectorized_rows_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExtraRes::set_allocated_vectorized_rows(std::string* vectorized_rows) {
  if (vectorized_rows != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vectorized_rows_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vectorized_rows,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ExtraRes.vectorized_rows)
}

// optional bytes vectorized_schema = 4;
inline bool ExtraRes::_internal_has_vectorized_schema() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExtraRes::has_vectorized_schema() const {
  return _internal_has_vectorized_schema();
}
inline void ExtraRes::clear_vectorized_schema() {
  vectorized_schema_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ExtraRes::vectorized_schema() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExtraRes.vectorized_schema)
  return _internal_vectorized_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtraRes::set_vectorized_schema(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 vectorized_schema_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExtraRes.vectorized_schema)
}
inline std::string* ExtraRes::mutable_vectorized_schema() {
  std::string* _s = _internal_mutable_vectorized_schema();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExtraRes.vectorized_schema)
  return _s;
}
inline const std::string& ExtraRes::_internal_vectorized_schema() const {
  return vectorized_schema_.Get();
}
inline void ExtraRes::_internal_set_vectorized_schema(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  vectorized_schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExtraRes::_internal_mutable_vectorized_schema() {
  _has_bits_[0] |= 0x00000002u;
  return vectorized_schema_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExtraRes::release_vectorized_schema() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ExtraRes.vectorized_schema)
  if (!_internal_has_vectorized_schema()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return vectorized_schema_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExtraRes::set_allocated_vectorized_schema(std::string* vectorized_schema) {
  if (vectorized_schema != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  vectorized_schema_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vectorized_schema,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ExtraRes.vectorized_schema)
}

// optional int64 wait_cost = 5;
inline bool ExtraRes::_internal_has_wait_cost() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExtraRes::has_wait_cost() const {
  return _internal_has_wait_cost();
}
inline void ExtraRes::clear_wait_cost() {
  wait_cost_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExtraRes::_internal_wait_cost() const {
  return wait_cost_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExtraRes::wait_cost() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExtraRes.wait_cost)
  return _internal_wait_cost();
}
inline void ExtraRes::_internal_set_wait_cost(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  wait_cost_ = value;
}
inline void ExtraRes::set_wait_cost(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_wait_cost(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExtraRes.wait_cost)
}

// repeated bytes afs_full_names = 6;
inline int ExtraRes::_internal_afs_full_names_size() const {
  return afs_full_names_.size();
}
inline int ExtraRes::afs_full_names_size() const {
  return _internal_afs_full_names_size();
}
inline void ExtraRes::clear_afs_full_names() {
  afs_full_names_.Clear();
}
inline std::string* ExtraRes::add_afs_full_names() {
  std::string* _s = _internal_add_afs_full_names();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.ExtraRes.afs_full_names)
  return _s;
}
inline const std::string& ExtraRes::_internal_afs_full_names(int index) const {
  return afs_full_names_.Get(index);
}
inline const std::string& ExtraRes::afs_full_names(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExtraRes.afs_full_names)
  return _internal_afs_full_names(index);
}
inline std::string* ExtraRes::mutable_afs_full_names(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExtraRes.afs_full_names)
  return afs_full_names_.Mutable(index);
}
inline void ExtraRes::set_afs_full_names(int index, const std::string& value) {
  afs_full_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExtraRes.afs_full_names)
}
inline void ExtraRes::set_afs_full_names(int index, std::string&& value) {
  afs_full_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExtraRes.afs_full_names)
}
inline void ExtraRes::set_afs_full_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  afs_full_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.ExtraRes.afs_full_names)
}
inline void ExtraRes::set_afs_full_names(int index, const void* value, size_t size) {
  afs_full_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.ExtraRes.afs_full_names)
}
inline std::string* ExtraRes::_internal_add_afs_full_names() {
  return afs_full_names_.Add();
}
inline void ExtraRes::add_afs_full_names(const std::string& value) {
  afs_full_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.ExtraRes.afs_full_names)
}
inline void ExtraRes::add_afs_full_names(std::string&& value) {
  afs_full_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.ExtraRes.afs_full_names)
}
inline void ExtraRes::add_afs_full_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  afs_full_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.ExtraRes.afs_full_names)
}
inline void ExtraRes::add_afs_full_names(const void* value, size_t size) {
  afs_full_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.ExtraRes.afs_full_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExtraRes::afs_full_names() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ExtraRes.afs_full_names)
  return afs_full_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExtraRes::mutable_afs_full_names() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ExtraRes.afs_full_names)
  return &afs_full_names_;
}

// optional bool get_afs_path_succ = 7;
inline bool ExtraRes::_internal_has_get_afs_path_succ() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ExtraRes::has_get_afs_path_succ() const {
  return _internal_has_get_afs_path_succ();
}
inline void ExtraRes::clear_get_afs_path_succ() {
  get_afs_path_succ_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ExtraRes::_internal_get_afs_path_succ() const {
  return get_afs_path_succ_;
}
inline bool ExtraRes::get_afs_path_succ() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExtraRes.get_afs_path_succ)
  return _internal_get_afs_path_succ();
}
inline void ExtraRes::_internal_set_get_afs_path_succ(bool value) {
  _has_bits_[0] |= 0x00000010u;
  get_afs_path_succ_ = value;
}
inline void ExtraRes::set_get_afs_path_succ(bool value) {
  _internal_set_get_afs_path_succ(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExtraRes.get_afs_path_succ)
}

// optional bool query_keypoint_succ = 8;
inline bool ExtraRes::_internal_has_query_keypoint_succ() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExtraRes::has_query_keypoint_succ() const {
  return _internal_has_query_keypoint_succ();
}
inline void ExtraRes::clear_query_keypoint_succ() {
  query_keypoint_succ_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ExtraRes::_internal_query_keypoint_succ() const {
  return query_keypoint_succ_;
}
inline bool ExtraRes::query_keypoint_succ() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExtraRes.query_keypoint_succ)
  return _internal_query_keypoint_succ();
}
inline void ExtraRes::_internal_set_query_keypoint_succ(bool value) {
  _has_bits_[0] |= 0x00000020u;
  query_keypoint_succ_ = value;
}
inline void ExtraRes::set_query_keypoint_succ(bool value) {
  _internal_set_query_keypoint_succ(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExtraRes.query_keypoint_succ)
}

// repeated .baikaldb.pb.UseridCount userid_count = 9;
inline int ExtraRes::_internal_userid_count_size() const {
  return userid_count_.size();
}
inline int ExtraRes::userid_count_size() const {
  return _internal_userid_count_size();
}
inline void ExtraRes::clear_userid_count() {
  userid_count_.Clear();
}
inline ::baikaldb::pb::UseridCount* ExtraRes::mutable_userid_count(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExtraRes.userid_count)
  return userid_count_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::UseridCount >*
ExtraRes::mutable_userid_count() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ExtraRes.userid_count)
  return &userid_count_;
}
inline const ::baikaldb::pb::UseridCount& ExtraRes::_internal_userid_count(int index) const {
  return userid_count_.Get(index);
}
inline const ::baikaldb::pb::UseridCount& ExtraRes::userid_count(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExtraRes.userid_count)
  return _internal_userid_count(index);
}
inline ::baikaldb::pb::UseridCount* ExtraRes::_internal_add_userid_count() {
  return userid_count_.Add();
}
inline ::baikaldb::pb::UseridCount* ExtraRes::add_userid_count() {
  ::baikaldb::pb::UseridCount* _add = _internal_add_userid_count();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ExtraRes.userid_count)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::UseridCount >&
ExtraRes::userid_count() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ExtraRes.userid_count)
  return userid_count_;
}

// -------------------------------------------------------------------

// StoreReq

// required .baikaldb.pb.OpType op_type = 1;
inline bool StoreReq::_internal_has_op_type() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool StoreReq::has_op_type() const {
  return _internal_has_op_type();
}
inline void StoreReq::clear_op_type() {
  op_type_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::baikaldb::pb::OpType StoreReq::_internal_op_type() const {
  return static_cast< ::baikaldb::pb::OpType >(op_type_);
}
inline ::baikaldb::pb::OpType StoreReq::op_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.op_type)
  return _internal_op_type();
}
inline void StoreReq::_internal_set_op_type(::baikaldb::pb::OpType value) {
  assert(::baikaldb::pb::OpType_IsValid(value));
  _has_bits_[0] |= 0x00010000u;
  op_type_ = value;
}
inline void StoreReq::set_op_type(::baikaldb::pb::OpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.op_type)
}

// repeated .baikaldb.pb.TupleDescriptor tuples = 2;
inline int StoreReq::_internal_tuples_size() const {
  return tuples_.size();
}
inline int StoreReq::tuples_size() const {
  return _internal_tuples_size();
}
inline ::baikaldb::pb::TupleDescriptor* StoreReq::mutable_tuples(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreReq.tuples)
  return tuples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TupleDescriptor >*
StoreReq::mutable_tuples() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreReq.tuples)
  return &tuples_;
}
inline const ::baikaldb::pb::TupleDescriptor& StoreReq::_internal_tuples(int index) const {
  return tuples_.Get(index);
}
inline const ::baikaldb::pb::TupleDescriptor& StoreReq::tuples(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.tuples)
  return _internal_tuples(index);
}
inline ::baikaldb::pb::TupleDescriptor* StoreReq::_internal_add_tuples() {
  return tuples_.Add();
}
inline ::baikaldb::pb::TupleDescriptor* StoreReq::add_tuples() {
  ::baikaldb::pb::TupleDescriptor* _add = _internal_add_tuples();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreReq.tuples)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TupleDescriptor >&
StoreReq::tuples() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreReq.tuples)
  return tuples_;
}

// required int64 region_id = 3;
inline bool StoreReq::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool StoreReq::has_region_id() const {
  return _internal_has_region_id();
}
inline void StoreReq::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreReq::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreReq::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.region_id)
  return _internal_region_id();
}
inline void StoreReq::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  region_id_ = value;
}
inline void StoreReq::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.region_id)
}

// required int64 region_version = 4;
inline bool StoreReq::_internal_has_region_version() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool StoreReq::has_region_version() const {
  return _internal_has_region_version();
}
inline void StoreReq::clear_region_version() {
  region_version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreReq::_internal_region_version() const {
  return region_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreReq::region_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.region_version)
  return _internal_region_version();
}
inline void StoreReq::_internal_set_region_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  region_version_ = value;
}
inline void StoreReq::set_region_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.region_version)
}

// optional .baikaldb.pb.Plan plan = 5;
inline bool StoreReq::_internal_has_plan() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || plan_ != nullptr);
  return value;
}
inline bool StoreReq::has_plan() const {
  return _internal_has_plan();
}
inline const ::baikaldb::pb::Plan& StoreReq::_internal_plan() const {
  const ::baikaldb::pb::Plan* p = plan_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::Plan&>(
      ::baikaldb::pb::_Plan_default_instance_);
}
inline const ::baikaldb::pb::Plan& StoreReq::plan() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.plan)
  return _internal_plan();
}
inline void StoreReq::unsafe_arena_set_allocated_plan(
    ::baikaldb::pb::Plan* plan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(plan_);
  }
  plan_ = plan;
  if (plan) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.StoreReq.plan)
}
inline ::baikaldb::pb::Plan* StoreReq::release_plan() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::Plan* temp = plan_;
  plan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::Plan* StoreReq::unsafe_arena_release_plan() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreReq.plan)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::Plan* temp = plan_;
  plan_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::Plan* StoreReq::_internal_mutable_plan() {
  _has_bits_[0] |= 0x00000004u;
  if (plan_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::Plan>(GetArenaForAllocation());
    plan_ = p;
  }
  return plan_;
}
inline ::baikaldb::pb::Plan* StoreReq::mutable_plan() {
  ::baikaldb::pb::Plan* _msg = _internal_mutable_plan();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreReq.plan)
  return _msg;
}
inline void StoreReq::set_allocated_plan(::baikaldb::pb::Plan* plan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(plan_);
  }
  if (plan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(plan));
    if (message_arena != submessage_arena) {
      plan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, plan, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  plan_ = plan;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreReq.plan)
}

// repeated .baikaldb.pb.TransactionInfo txn_infos = 6;
inline int StoreReq::_internal_txn_infos_size() const {
  return txn_infos_.size();
}
inline int StoreReq::txn_infos_size() const {
  return _internal_txn_infos_size();
}
inline void StoreReq::clear_txn_infos() {
  txn_infos_.Clear();
}
inline ::baikaldb::pb::TransactionInfo* StoreReq::mutable_txn_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreReq.txn_infos)
  return txn_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TransactionInfo >*
StoreReq::mutable_txn_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreReq.txn_infos)
  return &txn_infos_;
}
inline const ::baikaldb::pb::TransactionInfo& StoreReq::_internal_txn_infos(int index) const {
  return txn_infos_.Get(index);
}
inline const ::baikaldb::pb::TransactionInfo& StoreReq::txn_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.txn_infos)
  return _internal_txn_infos(index);
}
inline ::baikaldb::pb::TransactionInfo* StoreReq::_internal_add_txn_infos() {
  return txn_infos_.Add();
}
inline ::baikaldb::pb::TransactionInfo* StoreReq::add_txn_infos() {
  ::baikaldb::pb::TransactionInfo* _add = _internal_add_txn_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreReq.txn_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TransactionInfo >&
StoreReq::txn_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreReq.txn_infos)
  return txn_infos_;
}

// optional fixed64 log_id = 7;
inline bool StoreReq::_internal_has_log_id() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool StoreReq::has_log_id() const {
  return _internal_has_log_id();
}
inline void StoreReq::clear_log_id() {
  log_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreReq::_internal_log_id() const {
  return log_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreReq::log_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.log_id)
  return _internal_log_id();
}
inline void StoreReq::_internal_set_log_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00001000u;
  log_id_ = value;
}
inline void StoreReq::set_log_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_log_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.log_id)
}

// optional bytes start_key = 9;
inline bool StoreReq::_internal_has_start_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreReq::has_start_key() const {
  return _internal_has_start_key();
}
inline void StoreReq::clear_start_key() {
  start_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreReq::start_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.start_key)
  return _internal_start_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreReq::set_start_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 start_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.start_key)
}
inline std::string* StoreReq::mutable_start_key() {
  std::string* _s = _internal_mutable_start_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreReq.start_key)
  return _s;
}
inline const std::string& StoreReq::_internal_start_key() const {
  return start_key_.Get();
}
inline void StoreReq::_internal_set_start_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  start_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreReq::_internal_mutable_start_key() {
  _has_bits_[0] |= 0x00000001u;
  return start_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreReq::release_start_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreReq.start_key)
  if (!_internal_has_start_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return start_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StoreReq::set_allocated_start_key(std::string* start_key) {
  if (start_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  start_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreReq.start_key)
}

// optional bytes end_key = 10;
inline bool StoreReq::_internal_has_end_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreReq::has_end_key() const {
  return _internal_has_end_key();
}
inline void StoreReq::clear_end_key() {
  end_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StoreReq::end_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.end_key)
  return _internal_end_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreReq::set_end_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 end_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.end_key)
}
inline std::string* StoreReq::mutable_end_key() {
  std::string* _s = _internal_mutable_end_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreReq.end_key)
  return _s;
}
inline const std::string& StoreReq::_internal_end_key() const {
  return end_key_.Get();
}
inline void StoreReq::_internal_set_end_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  end_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreReq::_internal_mutable_end_key() {
  _has_bits_[0] |= 0x00000002u;
  return end_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreReq::release_end_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreReq.end_key)
  if (!_internal_has_end_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return end_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StoreReq::set_allocated_end_key(std::string* end_key) {
  if (end_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  end_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), end_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreReq.end_key)
}

// optional int64 split_term = 11;
inline bool StoreReq::_internal_has_split_term() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool StoreReq::has_split_term() const {
  return _internal_has_split_term();
}
inline void StoreReq::clear_split_term() {
  split_term_ = int64_t{0};
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreReq::_internal_split_term() const {
  return split_term_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreReq::split_term() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.split_term)
  return _internal_split_term();
}
inline void StoreReq::_internal_set_split_term(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00002000u;
  split_term_ = value;
}
inline void StoreReq::set_split_term(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_split_term(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.split_term)
}

// optional int64 split_end_index = 12;
inline bool StoreReq::_internal_has_split_end_index() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool StoreReq::has_split_end_index() const {
  return _internal_has_split_end_index();
}
inline void StoreReq::clear_split_end_index() {
  split_end_index_ = int64_t{0};
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreReq::_internal_split_end_index() const {
  return split_end_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreReq::split_end_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.split_end_index)
  return _internal_split_end_index();
}
inline void StoreReq::_internal_set_split_end_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00004000u;
  split_end_index_ = value;
}
inline void StoreReq::set_split_end_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_split_end_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.split_end_index)
}

// optional int64 reduce_num_lines = 13;
inline bool StoreReq::_internal_has_reduce_num_lines() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool StoreReq::has_reduce_num_lines() const {
  return _internal_has_reduce_num_lines();
}
inline void StoreReq::clear_reduce_num_lines() {
  reduce_num_lines_ = int64_t{0};
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreReq::_internal_reduce_num_lines() const {
  return reduce_num_lines_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreReq::reduce_num_lines() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.reduce_num_lines)
  return _internal_reduce_num_lines();
}
inline void StoreReq::_internal_set_reduce_num_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00008000u;
  reduce_num_lines_ = value;
}
inline void StoreReq::set_reduce_num_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_reduce_num_lines(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.reduce_num_lines)
}

// optional bool force = 14;
inline bool StoreReq::_internal_has_force() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool StoreReq::has_force() const {
  return _internal_has_force();
}
inline void StoreReq::clear_force() {
  force_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool StoreReq::_internal_force() const {
  return force_;
}
inline bool StoreReq::force() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.force)
  return _internal_force();
}
inline void StoreReq::_internal_set_force(bool value) {
  _has_bits_[0] |= 0x00020000u;
  force_ = value;
}
inline void StoreReq::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.force)
}

// optional bool not_check_region = 15;
inline bool StoreReq::_internal_has_not_check_region() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool StoreReq::has_not_check_region() const {
  return _internal_has_not_check_region();
}
inline void StoreReq::clear_not_check_region() {
  not_check_region_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool StoreReq::_internal_not_check_region() const {
  return not_check_region_;
}
inline bool StoreReq::not_check_region() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.not_check_region)
  return _internal_not_check_region();
}
inline void StoreReq::_internal_set_not_check_region(bool value) {
  _has_bits_[0] |= 0x00040000u;
  not_check_region_ = value;
}
inline void StoreReq::set_not_check_region(bool value) {
  _internal_set_not_check_region(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.not_check_region)
}

// optional .baikaldb.pb.RegionInfo new_region_info = 16;
inline bool StoreReq::_internal_has_new_region_info() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || new_region_info_ != nullptr);
  return value;
}
inline bool StoreReq::has_new_region_info() const {
  return _internal_has_new_region_info();
}
inline const ::baikaldb::pb::RegionInfo& StoreReq::_internal_new_region_info() const {
  const ::baikaldb::pb::RegionInfo* p = new_region_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionInfo&>(
      ::baikaldb::pb::_RegionInfo_default_instance_);
}
inline const ::baikaldb::pb::RegionInfo& StoreReq::new_region_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.new_region_info)
  return _internal_new_region_info();
}
inline void StoreReq::unsafe_arena_set_allocated_new_region_info(
    ::baikaldb::pb::RegionInfo* new_region_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_region_info_);
  }
  new_region_info_ = new_region_info;
  if (new_region_info) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.StoreReq.new_region_info)
}
inline ::baikaldb::pb::RegionInfo* StoreReq::release_new_region_info() {
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::RegionInfo* temp = new_region_info_;
  new_region_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionInfo* StoreReq::unsafe_arena_release_new_region_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreReq.new_region_info)
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::RegionInfo* temp = new_region_info_;
  new_region_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionInfo* StoreReq::_internal_mutable_new_region_info() {
  _has_bits_[0] |= 0x00000008u;
  if (new_region_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionInfo>(GetArenaForAllocation());
    new_region_info_ = p;
  }
  return new_region_info_;
}
inline ::baikaldb::pb::RegionInfo* StoreReq::mutable_new_region_info() {
  ::baikaldb::pb::RegionInfo* _msg = _internal_mutable_new_region_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreReq.new_region_info)
  return _msg;
}
inline void StoreReq::set_allocated_new_region_info(::baikaldb::pb::RegionInfo* new_region_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_region_info_);
  }
  if (new_region_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_region_info));
    if (message_arena != submessage_arena) {
      new_region_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_region_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  new_region_info_ = new_region_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreReq.new_region_info)
}

// optional bool select_without_leader = 17;
inline bool StoreReq::_internal_has_select_without_leader() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool StoreReq::has_select_without_leader() const {
  return _internal_has_select_without_leader();
}
inline void StoreReq::clear_select_without_leader() {
  select_without_leader_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool StoreReq::_internal_select_without_leader() const {
  return select_without_leader_;
}
inline bool StoreReq::select_without_leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.select_without_leader)
  return _internal_select_without_leader();
}
inline void StoreReq::_internal_set_select_without_leader(bool value) {
  _has_bits_[0] |= 0x00080000u;
  select_without_leader_ = value;
}
inline void StoreReq::set_select_without_leader(bool value) {
  _internal_set_select_without_leader(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.select_without_leader)
}

// optional fixed64 db_conn_id = 18;
inline bool StoreReq::_internal_has_db_conn_id() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool StoreReq::has_db_conn_id() const {
  return _internal_has_db_conn_id();
}
inline void StoreReq::clear_db_conn_id() {
  db_conn_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00200000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreReq::_internal_db_conn_id() const {
  return db_conn_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreReq::db_conn_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.db_conn_id)
  return _internal_db_conn_id();
}
inline void StoreReq::_internal_set_db_conn_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00200000u;
  db_conn_id_ = value;
}
inline void StoreReq::set_db_conn_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_db_conn_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.db_conn_id)
}

// optional .baikaldb.pb.DdlWorkInfo ddlwork_info = 19;
inline bool StoreReq::_internal_has_ddlwork_info() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || ddlwork_info_ != nullptr);
  return value;
}
inline bool StoreReq::has_ddlwork_info() const {
  return _internal_has_ddlwork_info();
}
inline const ::baikaldb::pb::DdlWorkInfo& StoreReq::_internal_ddlwork_info() const {
  const ::baikaldb::pb::DdlWorkInfo* p = ddlwork_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::DdlWorkInfo&>(
      ::baikaldb::pb::_DdlWorkInfo_default_instance_);
}
inline const ::baikaldb::pb::DdlWorkInfo& StoreReq::ddlwork_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.ddlwork_info)
  return _internal_ddlwork_info();
}
inline void StoreReq::unsafe_arena_set_allocated_ddlwork_info(
    ::baikaldb::pb::DdlWorkInfo* ddlwork_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ddlwork_info_);
  }
  ddlwork_info_ = ddlwork_info;
  if (ddlwork_info) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.StoreReq.ddlwork_info)
}
inline ::baikaldb::pb::DdlWorkInfo* StoreReq::release_ddlwork_info() {
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::DdlWorkInfo* temp = ddlwork_info_;
  ddlwork_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::DdlWorkInfo* StoreReq::unsafe_arena_release_ddlwork_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreReq.ddlwork_info)
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::DdlWorkInfo* temp = ddlwork_info_;
  ddlwork_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::DdlWorkInfo* StoreReq::_internal_mutable_ddlwork_info() {
  _has_bits_[0] |= 0x00000010u;
  if (ddlwork_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::DdlWorkInfo>(GetArenaForAllocation());
    ddlwork_info_ = p;
  }
  return ddlwork_info_;
}
inline ::baikaldb::pb::DdlWorkInfo* StoreReq::mutable_ddlwork_info() {
  ::baikaldb::pb::DdlWorkInfo* _msg = _internal_mutable_ddlwork_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreReq.ddlwork_info)
  return _msg;
}
inline void StoreReq::set_allocated_ddlwork_info(::baikaldb::pb::DdlWorkInfo* ddlwork_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ddlwork_info_);
  }
  if (ddlwork_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ddlwork_info));
    if (message_arena != submessage_arena) {
      ddlwork_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ddlwork_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  ddlwork_info_ = ddlwork_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreReq.ddlwork_info)
}

// optional int64 num_increase_rows = 20;
inline bool StoreReq::_internal_has_num_increase_rows() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool StoreReq::has_num_increase_rows() const {
  return _internal_has_num_increase_rows();
}
inline void StoreReq::clear_num_increase_rows() {
  num_increase_rows_ = int64_t{0};
  _has_bits_[0] &= ~0x00400000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreReq::_internal_num_increase_rows() const {
  return num_increase_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreReq::num_increase_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.num_increase_rows)
  return _internal_num_increase_rows();
}
inline void StoreReq::_internal_set_num_increase_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00400000u;
  num_increase_rows_ = value;
}
inline void StoreReq::set_num_increase_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_num_increase_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.num_increase_rows)
}

// repeated .baikaldb.pb.KvOp kv_ops = 21;
inline int StoreReq::_internal_kv_ops_size() const {
  return kv_ops_.size();
}
inline int StoreReq::kv_ops_size() const {
  return _internal_kv_ops_size();
}
inline void StoreReq::clear_kv_ops() {
  kv_ops_.Clear();
}
inline ::baikaldb::pb::KvOp* StoreReq::mutable_kv_ops(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreReq.kv_ops)
  return kv_ops_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::KvOp >*
StoreReq::mutable_kv_ops() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreReq.kv_ops)
  return &kv_ops_;
}
inline const ::baikaldb::pb::KvOp& StoreReq::_internal_kv_ops(int index) const {
  return kv_ops_.Get(index);
}
inline const ::baikaldb::pb::KvOp& StoreReq::kv_ops(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.kv_ops)
  return _internal_kv_ops(index);
}
inline ::baikaldb::pb::KvOp* StoreReq::_internal_add_kv_ops() {
  return kv_ops_.Add();
}
inline ::baikaldb::pb::KvOp* StoreReq::add_kv_ops() {
  ::baikaldb::pb::KvOp* _add = _internal_add_kv_ops();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreReq.kv_ops)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::KvOp >&
StoreReq::kv_ops() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreReq.kv_ops)
  return kv_ops_;
}

// optional bool is_trace = 22;
inline bool StoreReq::_internal_has_is_trace() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool StoreReq::has_is_trace() const {
  return _internal_has_is_trace();
}
inline void StoreReq::clear_is_trace() {
  is_trace_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool StoreReq::_internal_is_trace() const {
  return is_trace_;
}
inline bool StoreReq::is_trace() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.is_trace)
  return _internal_is_trace();
}
inline void StoreReq::_internal_set_is_trace(bool value) {
  _has_bits_[0] |= 0x00100000u;
  is_trace_ = value;
}
inline void StoreReq::set_is_trace(bool value) {
  _internal_set_is_trace(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.is_trace)
}

// optional .baikaldb.pb.AnalyzeInfo analyze_info = 23;
inline bool StoreReq::_internal_has_analyze_info() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || analyze_info_ != nullptr);
  return value;
}
inline bool StoreReq::has_analyze_info() const {
  return _internal_has_analyze_info();
}
inline void StoreReq::clear_analyze_info() {
  if (analyze_info_ != nullptr) analyze_info_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::baikaldb::pb::AnalyzeInfo& StoreReq::_internal_analyze_info() const {
  const ::baikaldb::pb::AnalyzeInfo* p = analyze_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::AnalyzeInfo&>(
      ::baikaldb::pb::_AnalyzeInfo_default_instance_);
}
inline const ::baikaldb::pb::AnalyzeInfo& StoreReq::analyze_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.analyze_info)
  return _internal_analyze_info();
}
inline void StoreReq::unsafe_arena_set_allocated_analyze_info(
    ::baikaldb::pb::AnalyzeInfo* analyze_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(analyze_info_);
  }
  analyze_info_ = analyze_info;
  if (analyze_info) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.StoreReq.analyze_info)
}
inline ::baikaldb::pb::AnalyzeInfo* StoreReq::release_analyze_info() {
  _has_bits_[0] &= ~0x00000020u;
  ::baikaldb::pb::AnalyzeInfo* temp = analyze_info_;
  analyze_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::AnalyzeInfo* StoreReq::unsafe_arena_release_analyze_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreReq.analyze_info)
  _has_bits_[0] &= ~0x00000020u;
  ::baikaldb::pb::AnalyzeInfo* temp = analyze_info_;
  analyze_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::AnalyzeInfo* StoreReq::_internal_mutable_analyze_info() {
  _has_bits_[0] |= 0x00000020u;
  if (analyze_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::AnalyzeInfo>(GetArenaForAllocation());
    analyze_info_ = p;
  }
  return analyze_info_;
}
inline ::baikaldb::pb::AnalyzeInfo* StoreReq::mutable_analyze_info() {
  ::baikaldb::pb::AnalyzeInfo* _msg = _internal_mutable_analyze_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreReq.analyze_info)
  return _msg;
}
inline void StoreReq::set_allocated_analyze_info(::baikaldb::pb::AnalyzeInfo* analyze_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete analyze_info_;
  }
  if (analyze_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::AnalyzeInfo>::GetOwningArena(analyze_info);
    if (message_arena != submessage_arena) {
      analyze_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, analyze_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  analyze_info_ = analyze_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreReq.analyze_info)
}

// repeated uint64 rollback_txn_ids = 24;
inline int StoreReq::_internal_rollback_txn_ids_size() const {
  return rollback_txn_ids_.size();
}
inline int StoreReq::rollback_txn_ids_size() const {
  return _internal_rollback_txn_ids_size();
}
inline void StoreReq::clear_rollback_txn_ids() {
  rollback_txn_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreReq::_internal_rollback_txn_ids(int index) const {
  return rollback_txn_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreReq::rollback_txn_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.rollback_txn_ids)
  return _internal_rollback_txn_ids(index);
}
inline void StoreReq::set_rollback_txn_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  rollback_txn_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.rollback_txn_ids)
}
inline void StoreReq::_internal_add_rollback_txn_ids(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  rollback_txn_ids_.Add(value);
}
inline void StoreReq::add_rollback_txn_ids(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_rollback_txn_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreReq.rollback_txn_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
StoreReq::_internal_rollback_txn_ids() const {
  return rollback_txn_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
StoreReq::rollback_txn_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreReq.rollback_txn_ids)
  return _internal_rollback_txn_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
StoreReq::_internal_mutable_rollback_txn_ids() {
  return &rollback_txn_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
StoreReq::mutable_rollback_txn_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreReq.rollback_txn_ids)
  return _internal_mutable_rollback_txn_ids();
}

// repeated uint64 commit_txn_ids = 25;
inline int StoreReq::_internal_commit_txn_ids_size() const {
  return commit_txn_ids_.size();
}
inline int StoreReq::commit_txn_ids_size() const {
  return _internal_commit_txn_ids_size();
}
inline void StoreReq::clear_commit_txn_ids() {
  commit_txn_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreReq::_internal_commit_txn_ids(int index) const {
  return commit_txn_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreReq::commit_txn_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.commit_txn_ids)
  return _internal_commit_txn_ids(index);
}
inline void StoreReq::set_commit_txn_ids(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  commit_txn_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.commit_txn_ids)
}
inline void StoreReq::_internal_add_commit_txn_ids(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  commit_txn_ids_.Add(value);
}
inline void StoreReq::add_commit_txn_ids(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_add_commit_txn_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreReq.commit_txn_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
StoreReq::_internal_commit_txn_ids() const {
  return commit_txn_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
StoreReq::commit_txn_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreReq.commit_txn_ids)
  return _internal_commit_txn_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
StoreReq::_internal_mutable_commit_txn_ids() {
  return &commit_txn_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
StoreReq::mutable_commit_txn_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreReq.commit_txn_ids)
  return _internal_mutable_commit_txn_ids();
}

// optional .baikaldb.pb.BinlogDesc binlog_desc = 26;
inline bool StoreReq::_internal_has_binlog_desc() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || binlog_desc_ != nullptr);
  return value;
}
inline bool StoreReq::has_binlog_desc() const {
  return _internal_has_binlog_desc();
}
inline void StoreReq::clear_binlog_desc() {
  if (binlog_desc_ != nullptr) binlog_desc_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::baikaldb::pb::BinlogDesc& StoreReq::_internal_binlog_desc() const {
  const ::baikaldb::pb::BinlogDesc* p = binlog_desc_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::BinlogDesc&>(
      ::baikaldb::pb::_BinlogDesc_default_instance_);
}
inline const ::baikaldb::pb::BinlogDesc& StoreReq::binlog_desc() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.binlog_desc)
  return _internal_binlog_desc();
}
inline void StoreReq::unsafe_arena_set_allocated_binlog_desc(
    ::baikaldb::pb::BinlogDesc* binlog_desc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(binlog_desc_);
  }
  binlog_desc_ = binlog_desc;
  if (binlog_desc) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.StoreReq.binlog_desc)
}
inline ::baikaldb::pb::BinlogDesc* StoreReq::release_binlog_desc() {
  _has_bits_[0] &= ~0x00000040u;
  ::baikaldb::pb::BinlogDesc* temp = binlog_desc_;
  binlog_desc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::BinlogDesc* StoreReq::unsafe_arena_release_binlog_desc() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreReq.binlog_desc)
  _has_bits_[0] &= ~0x00000040u;
  ::baikaldb::pb::BinlogDesc* temp = binlog_desc_;
  binlog_desc_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::BinlogDesc* StoreReq::_internal_mutable_binlog_desc() {
  _has_bits_[0] |= 0x00000040u;
  if (binlog_desc_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::BinlogDesc>(GetArenaForAllocation());
    binlog_desc_ = p;
  }
  return binlog_desc_;
}
inline ::baikaldb::pb::BinlogDesc* StoreReq::mutable_binlog_desc() {
  ::baikaldb::pb::BinlogDesc* _msg = _internal_mutable_binlog_desc();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreReq.binlog_desc)
  return _msg;
}
inline void StoreReq::set_allocated_binlog_desc(::baikaldb::pb::BinlogDesc* binlog_desc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete binlog_desc_;
  }
  if (binlog_desc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::BinlogDesc>::GetOwningArena(binlog_desc);
    if (message_arena != submessage_arena) {
      binlog_desc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, binlog_desc, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  binlog_desc_ = binlog_desc;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreReq.binlog_desc)
}

// optional .baikaldb.pb.Binlog binlog = 27;
inline bool StoreReq::_internal_has_binlog() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || binlog_ != nullptr);
  return value;
}
inline bool StoreReq::has_binlog() const {
  return _internal_has_binlog();
}
inline const ::baikaldb::pb::Binlog& StoreReq::_internal_binlog() const {
  const ::baikaldb::pb::Binlog* p = binlog_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::Binlog&>(
      ::baikaldb::pb::_Binlog_default_instance_);
}
inline const ::baikaldb::pb::Binlog& StoreReq::binlog() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.binlog)
  return _internal_binlog();
}
inline void StoreReq::unsafe_arena_set_allocated_binlog(
    ::baikaldb::pb::Binlog* binlog) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(binlog_);
  }
  binlog_ = binlog;
  if (binlog) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.StoreReq.binlog)
}
inline ::baikaldb::pb::Binlog* StoreReq::release_binlog() {
  _has_bits_[0] &= ~0x00000080u;
  ::baikaldb::pb::Binlog* temp = binlog_;
  binlog_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::Binlog* StoreReq::unsafe_arena_release_binlog() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreReq.binlog)
  _has_bits_[0] &= ~0x00000080u;
  ::baikaldb::pb::Binlog* temp = binlog_;
  binlog_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::Binlog* StoreReq::_internal_mutable_binlog() {
  _has_bits_[0] |= 0x00000080u;
  if (binlog_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::Binlog>(GetArenaForAllocation());
    binlog_ = p;
  }
  return binlog_;
}
inline ::baikaldb::pb::Binlog* StoreReq::mutable_binlog() {
  ::baikaldb::pb::Binlog* _msg = _internal_mutable_binlog();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreReq.binlog)
  return _msg;
}
inline void StoreReq::set_allocated_binlog(::baikaldb::pb::Binlog* binlog) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(binlog_);
  }
  if (binlog) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(binlog));
    if (message_arena != submessage_arena) {
      binlog = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, binlog, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  binlog_ = binlog;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreReq.binlog)
}

// optional uint64 sql_sign = 28;
inline bool StoreReq::_internal_has_sql_sign() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool StoreReq::has_sql_sign() const {
  return _internal_has_sql_sign();
}
inline void StoreReq::clear_sql_sign() {
  sql_sign_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00800000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreReq::_internal_sql_sign() const {
  return sql_sign_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreReq::sql_sign() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.sql_sign)
  return _internal_sql_sign();
}
inline void StoreReq::_internal_set_sql_sign(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00800000u;
  sql_sign_ = value;
}
inline void StoreReq::set_sql_sign(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_sql_sign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.sql_sign)
}

// repeated .baikaldb.pb.RegionInfo multi_new_region_infos = 29;
inline int StoreReq::_internal_multi_new_region_infos_size() const {
  return multi_new_region_infos_.size();
}
inline int StoreReq::multi_new_region_infos_size() const {
  return _internal_multi_new_region_infos_size();
}
inline ::baikaldb::pb::RegionInfo* StoreReq::mutable_multi_new_region_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreReq.multi_new_region_infos)
  return multi_new_region_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >*
StoreReq::mutable_multi_new_region_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreReq.multi_new_region_infos)
  return &multi_new_region_infos_;
}
inline const ::baikaldb::pb::RegionInfo& StoreReq::_internal_multi_new_region_infos(int index) const {
  return multi_new_region_infos_.Get(index);
}
inline const ::baikaldb::pb::RegionInfo& StoreReq::multi_new_region_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.multi_new_region_infos)
  return _internal_multi_new_region_infos(index);
}
inline ::baikaldb::pb::RegionInfo* StoreReq::_internal_add_multi_new_region_infos() {
  return multi_new_region_infos_.Add();
}
inline ::baikaldb::pb::RegionInfo* StoreReq::add_multi_new_region_infos() {
  ::baikaldb::pb::RegionInfo* _add = _internal_add_multi_new_region_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreReq.multi_new_region_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >&
StoreReq::multi_new_region_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreReq.multi_new_region_infos)
  return multi_new_region_infos_;
}

// optional .baikaldb.pb.ExtraReq extra_req = 30;
inline bool StoreReq::_internal_has_extra_req() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || extra_req_ != nullptr);
  return value;
}
inline bool StoreReq::has_extra_req() const {
  return _internal_has_extra_req();
}
inline void StoreReq::clear_extra_req() {
  if (extra_req_ != nullptr) extra_req_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::baikaldb::pb::ExtraReq& StoreReq::_internal_extra_req() const {
  const ::baikaldb::pb::ExtraReq* p = extra_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::ExtraReq&>(
      ::baikaldb::pb::_ExtraReq_default_instance_);
}
inline const ::baikaldb::pb::ExtraReq& StoreReq::extra_req() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.extra_req)
  return _internal_extra_req();
}
inline void StoreReq::unsafe_arena_set_allocated_extra_req(
    ::baikaldb::pb::ExtraReq* extra_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra_req_);
  }
  extra_req_ = extra_req;
  if (extra_req) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.StoreReq.extra_req)
}
inline ::baikaldb::pb::ExtraReq* StoreReq::release_extra_req() {
  _has_bits_[0] &= ~0x00000100u;
  ::baikaldb::pb::ExtraReq* temp = extra_req_;
  extra_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::ExtraReq* StoreReq::unsafe_arena_release_extra_req() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreReq.extra_req)
  _has_bits_[0] &= ~0x00000100u;
  ::baikaldb::pb::ExtraReq* temp = extra_req_;
  extra_req_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::ExtraReq* StoreReq::_internal_mutable_extra_req() {
  _has_bits_[0] |= 0x00000100u;
  if (extra_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::ExtraReq>(GetArenaForAllocation());
    extra_req_ = p;
  }
  return extra_req_;
}
inline ::baikaldb::pb::ExtraReq* StoreReq::mutable_extra_req() {
  ::baikaldb::pb::ExtraReq* _msg = _internal_mutable_extra_req();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreReq.extra_req)
  return _msg;
}
inline void StoreReq::set_allocated_extra_req(::baikaldb::pb::ExtraReq* extra_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete extra_req_;
  }
  if (extra_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::ExtraReq>::GetOwningArena(extra_req);
    if (message_arena != submessage_arena) {
      extra_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra_req, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  extra_req_ = extra_req;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreReq.extra_req)
}

// optional .baikaldb.pb.ExecuteType execute_type = 31;
inline bool StoreReq::_internal_has_execute_type() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool StoreReq::has_execute_type() const {
  return _internal_has_execute_type();
}
inline void StoreReq::clear_execute_type() {
  execute_type_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::baikaldb::pb::ExecuteType StoreReq::_internal_execute_type() const {
  return static_cast< ::baikaldb::pb::ExecuteType >(execute_type_);
}
inline ::baikaldb::pb::ExecuteType StoreReq::execute_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.execute_type)
  return _internal_execute_type();
}
inline void StoreReq::_internal_set_execute_type(::baikaldb::pb::ExecuteType value) {
  assert(::baikaldb::pb::ExecuteType_IsValid(value));
  _has_bits_[0] |= 0x01000000u;
  execute_type_ = value;
}
inline void StoreReq::set_execute_type(::baikaldb::pb::ExecuteType value) {
  _internal_set_execute_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.execute_type)
}

// optional bool is_rollup_base = 32;
inline bool StoreReq::_internal_has_is_rollup_base() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool StoreReq::has_is_rollup_base() const {
  return _internal_has_is_rollup_base();
}
inline void StoreReq::clear_is_rollup_base() {
  is_rollup_base_ = false;
  _has_bits_[0] &= ~0x02000000u;
}
inline bool StoreReq::_internal_is_rollup_base() const {
  return is_rollup_base_;
}
inline bool StoreReq::is_rollup_base() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.is_rollup_base)
  return _internal_is_rollup_base();
}
inline void StoreReq::_internal_set_is_rollup_base(bool value) {
  _has_bits_[0] |= 0x02000000u;
  is_rollup_base_ = value;
}
inline void StoreReq::set_is_rollup_base(bool value) {
  _internal_set_is_rollup_base(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.is_rollup_base)
}

// optional int64 sql_exec_timeout = 33;
inline bool StoreReq::_internal_has_sql_exec_timeout() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool StoreReq::has_sql_exec_timeout() const {
  return _internal_has_sql_exec_timeout();
}
inline void StoreReq::clear_sql_exec_timeout() {
  sql_exec_timeout_ = int64_t{0};
  _has_bits_[0] &= ~0x04000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreReq::_internal_sql_exec_timeout() const {
  return sql_exec_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreReq::sql_exec_timeout() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.sql_exec_timeout)
  return _internal_sql_exec_timeout();
}
inline void StoreReq::_internal_set_sql_exec_timeout(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x04000000u;
  sql_exec_timeout_ = value;
}
inline void StoreReq::set_sql_exec_timeout(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_sql_exec_timeout(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreReq.sql_exec_timeout)
}

// optional .baikaldb.pb.RedisWriteRequest redis_req = 34;
inline bool StoreReq::_internal_has_redis_req() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || redis_req_ != nullptr);
  return value;
}
inline bool StoreReq::has_redis_req() const {
  return _internal_has_redis_req();
}
inline void StoreReq::clear_redis_req() {
  if (redis_req_ != nullptr) redis_req_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::baikaldb::pb::RedisWriteRequest& StoreReq::_internal_redis_req() const {
  const ::baikaldb::pb::RedisWriteRequest* p = redis_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RedisWriteRequest&>(
      ::baikaldb::pb::_RedisWriteRequest_default_instance_);
}
inline const ::baikaldb::pb::RedisWriteRequest& StoreReq::redis_req() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreReq.redis_req)
  return _internal_redis_req();
}
inline void StoreReq::unsafe_arena_set_allocated_redis_req(
    ::baikaldb::pb::RedisWriteRequest* redis_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(redis_req_);
  }
  redis_req_ = redis_req;
  if (redis_req) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.StoreReq.redis_req)
}
inline ::baikaldb::pb::RedisWriteRequest* StoreReq::release_redis_req() {
  _has_bits_[0] &= ~0x00000200u;
  ::baikaldb::pb::RedisWriteRequest* temp = redis_req_;
  redis_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RedisWriteRequest* StoreReq::unsafe_arena_release_redis_req() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreReq.redis_req)
  _has_bits_[0] &= ~0x00000200u;
  ::baikaldb::pb::RedisWriteRequest* temp = redis_req_;
  redis_req_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RedisWriteRequest* StoreReq::_internal_mutable_redis_req() {
  _has_bits_[0] |= 0x00000200u;
  if (redis_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RedisWriteRequest>(GetArenaForAllocation());
    redis_req_ = p;
  }
  return redis_req_;
}
inline ::baikaldb::pb::RedisWriteRequest* StoreReq::mutable_redis_req() {
  ::baikaldb::pb::RedisWriteRequest* _msg = _internal_mutable_redis_req();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreReq.redis_req)
  return _msg;
}
inline void StoreReq::set_allocated_redis_req(::baikaldb::pb::RedisWriteRequest* redis_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete redis_req_;
  }
  if (redis_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::RedisWriteRequest>::GetOwningArena(redis_req);
    if (message_arena != submessage_arena) {
      redis_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, redis_req, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  redis_req_ = redis_req;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreReq.redis_req)
}

// -------------------------------------------------------------------

// RowValue

// repeated bytes tuple_values = 1;
inline int RowValue::_internal_tuple_values_size() const {
  return tuple_values_.size();
}
inline int RowValue::tuple_values_size() const {
  return _internal_tuple_values_size();
}
inline void RowValue::clear_tuple_values() {
  tuple_values_.Clear();
}
inline std::string* RowValue::add_tuple_values() {
  std::string* _s = _internal_add_tuple_values();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.RowValue.tuple_values)
  return _s;
}
inline const std::string& RowValue::_internal_tuple_values(int index) const {
  return tuple_values_.Get(index);
}
inline const std::string& RowValue::tuple_values(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RowValue.tuple_values)
  return _internal_tuple_values(index);
}
inline std::string* RowValue::mutable_tuple_values(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RowValue.tuple_values)
  return tuple_values_.Mutable(index);
}
inline void RowValue::set_tuple_values(int index, const std::string& value) {
  tuple_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RowValue.tuple_values)
}
inline void RowValue::set_tuple_values(int index, std::string&& value) {
  tuple_values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.RowValue.tuple_values)
}
inline void RowValue::set_tuple_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tuple_values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.RowValue.tuple_values)
}
inline void RowValue::set_tuple_values(int index, const void* value, size_t size) {
  tuple_values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.RowValue.tuple_values)
}
inline std::string* RowValue::_internal_add_tuple_values() {
  return tuple_values_.Add();
}
inline void RowValue::add_tuple_values(const std::string& value) {
  tuple_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.RowValue.tuple_values)
}
inline void RowValue::add_tuple_values(std::string&& value) {
  tuple_values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.RowValue.tuple_values)
}
inline void RowValue::add_tuple_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tuple_values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.RowValue.tuple_values)
}
inline void RowValue::add_tuple_values(const void* value, size_t size) {
  tuple_values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.RowValue.tuple_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RowValue::tuple_values() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RowValue.tuple_values)
  return tuple_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RowValue::mutable_tuple_values() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RowValue.tuple_values)
  return &tuple_values_;
}

// -------------------------------------------------------------------

// RegionLeader

// required int64 region_id = 1;
inline bool RegionLeader::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionLeader::has_region_id() const {
  return _internal_has_region_id();
}
inline void RegionLeader::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionLeader::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionLeader::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionLeader.region_id)
  return _internal_region_id();
}
inline void RegionLeader::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  region_id_ = value;
}
inline void RegionLeader::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionLeader.region_id)
}

// required string leader = 2;
inline bool RegionLeader::_internal_has_leader() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegionLeader::has_leader() const {
  return _internal_has_leader();
}
inline void RegionLeader::clear_leader() {
  leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionLeader::leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionLeader.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionLeader::set_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionLeader.leader)
}
inline std::string* RegionLeader::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionLeader.leader)
  return _s;
}
inline const std::string& RegionLeader::_internal_leader() const {
  return leader_.Get();
}
inline void RegionLeader::_internal_set_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionLeader::_internal_mutable_leader() {
  _has_bits_[0] |= 0x00000001u;
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionLeader::release_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionLeader.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionLeader::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionLeader.leader)
}

// -------------------------------------------------------------------

// IndexRecords

// required int64 index_id = 1;
inline bool IndexRecords::_internal_has_index_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IndexRecords::has_index_id() const {
  return _internal_has_index_id();
}
inline void IndexRecords::clear_index_id() {
  index_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexRecords::_internal_index_id() const {
  return index_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexRecords::index_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexRecords.index_id)
  return _internal_index_id();
}
inline void IndexRecords::_internal_set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  index_id_ = value;
}
inline void IndexRecords::set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_index_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexRecords.index_id)
}

// repeated bytes records = 2;
inline int IndexRecords::_internal_records_size() const {
  return records_.size();
}
inline int IndexRecords::records_size() const {
  return _internal_records_size();
}
inline void IndexRecords::clear_records() {
  records_.Clear();
}
inline std::string* IndexRecords::add_records() {
  std::string* _s = _internal_add_records();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.IndexRecords.records)
  return _s;
}
inline const std::string& IndexRecords::_internal_records(int index) const {
  return records_.Get(index);
}
inline const std::string& IndexRecords::records(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexRecords.records)
  return _internal_records(index);
}
inline std::string* IndexRecords::mutable_records(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.IndexRecords.records)
  return records_.Mutable(index);
}
inline void IndexRecords::set_records(int index, const std::string& value) {
  records_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexRecords.records)
}
inline void IndexRecords::set_records(int index, std::string&& value) {
  records_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexRecords.records)
}
inline void IndexRecords::set_records(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  records_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.IndexRecords.records)
}
inline void IndexRecords::set_records(int index, const void* value, size_t size) {
  records_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.IndexRecords.records)
}
inline std::string* IndexRecords::_internal_add_records() {
  return records_.Add();
}
inline void IndexRecords::add_records(const std::string& value) {
  records_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.IndexRecords.records)
}
inline void IndexRecords::add_records(std::string&& value) {
  records_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.IndexRecords.records)
}
inline void IndexRecords::add_records(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  records_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.IndexRecords.records)
}
inline void IndexRecords::add_records(const void* value, size_t size) {
  records_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.IndexRecords.records)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IndexRecords::records() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.IndexRecords.records)
  return records_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IndexRecords::mutable_records() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.IndexRecords.records)
  return &records_;
}

// repeated bytes old_records = 3;
inline int IndexRecords::_internal_old_records_size() const {
  return old_records_.size();
}
inline int IndexRecords::old_records_size() const {
  return _internal_old_records_size();
}
inline void IndexRecords::clear_old_records() {
  old_records_.Clear();
}
inline std::string* IndexRecords::add_old_records() {
  std::string* _s = _internal_add_old_records();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.IndexRecords.old_records)
  return _s;
}
inline const std::string& IndexRecords::_internal_old_records(int index) const {
  return old_records_.Get(index);
}
inline const std::string& IndexRecords::old_records(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexRecords.old_records)
  return _internal_old_records(index);
}
inline std::string* IndexRecords::mutable_old_records(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.IndexRecords.old_records)
  return old_records_.Mutable(index);
}
inline void IndexRecords::set_old_records(int index, const std::string& value) {
  old_records_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexRecords.old_records)
}
inline void IndexRecords::set_old_records(int index, std::string&& value) {
  old_records_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexRecords.old_records)
}
inline void IndexRecords::set_old_records(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  old_records_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.IndexRecords.old_records)
}
inline void IndexRecords::set_old_records(int index, const void* value, size_t size) {
  old_records_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.IndexRecords.old_records)
}
inline std::string* IndexRecords::_internal_add_old_records() {
  return old_records_.Add();
}
inline void IndexRecords::add_old_records(const std::string& value) {
  old_records_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.IndexRecords.old_records)
}
inline void IndexRecords::add_old_records(std::string&& value) {
  old_records_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.IndexRecords.old_records)
}
inline void IndexRecords::add_old_records(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  old_records_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.IndexRecords.old_records)
}
inline void IndexRecords::add_old_records(const void* value, size_t size) {
  old_records_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.IndexRecords.old_records)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IndexRecords::old_records() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.IndexRecords.old_records)
  return old_records_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IndexRecords::mutable_old_records() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.IndexRecords.old_records)
  return &old_records_;
}

// optional bool local_index_binlog = 4;
inline bool IndexRecords::_internal_has_local_index_binlog() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IndexRecords::has_local_index_binlog() const {
  return _internal_has_local_index_binlog();
}
inline void IndexRecords::clear_local_index_binlog() {
  local_index_binlog_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool IndexRecords::_internal_local_index_binlog() const {
  return local_index_binlog_;
}
inline bool IndexRecords::local_index_binlog() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexRecords.local_index_binlog)
  return _internal_local_index_binlog();
}
inline void IndexRecords::_internal_set_local_index_binlog(bool value) {
  _has_bits_[0] |= 0x00000002u;
  local_index_binlog_ = value;
}
inline void IndexRecords::set_local_index_binlog(bool value) {
  _internal_set_local_index_binlog(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexRecords.local_index_binlog)
}

// -------------------------------------------------------------------

// RegionRaftStat

// optional int64 applied_index = 1;
inline bool RegionRaftStat::_internal_has_applied_index() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegionRaftStat::has_applied_index() const {
  return _internal_has_applied_index();
}
inline void RegionRaftStat::clear_applied_index() {
  applied_index_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionRaftStat::_internal_applied_index() const {
  return applied_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionRaftStat::applied_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionRaftStat.applied_index)
  return _internal_applied_index();
}
inline void RegionRaftStat::_internal_set_applied_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  applied_index_ = value;
}
inline void RegionRaftStat::set_applied_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_applied_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionRaftStat.applied_index)
}

// optional uint64 snapshot_data_size = 2;
inline bool RegionRaftStat::_internal_has_snapshot_data_size() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionRaftStat::has_snapshot_data_size() const {
  return _internal_has_snapshot_data_size();
}
inline void RegionRaftStat::clear_snapshot_data_size() {
  snapshot_data_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionRaftStat::_internal_snapshot_data_size() const {
  return snapshot_data_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionRaftStat::snapshot_data_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionRaftStat.snapshot_data_size)
  return _internal_snapshot_data_size();
}
inline void RegionRaftStat::_internal_set_snapshot_data_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  snapshot_data_size_ = value;
}
inline void RegionRaftStat::set_snapshot_data_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_snapshot_data_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionRaftStat.snapshot_data_size)
}

// optional uint64 snapshot_meta_size = 3;
inline bool RegionRaftStat::_internal_has_snapshot_meta_size() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegionRaftStat::has_snapshot_meta_size() const {
  return _internal_has_snapshot_meta_size();
}
inline void RegionRaftStat::clear_snapshot_meta_size() {
  snapshot_meta_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionRaftStat::_internal_snapshot_meta_size() const {
  return snapshot_meta_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionRaftStat::snapshot_meta_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionRaftStat.snapshot_meta_size)
  return _internal_snapshot_meta_size();
}
inline void RegionRaftStat::_internal_set_snapshot_meta_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  snapshot_meta_size_ = value;
}
inline void RegionRaftStat::set_snapshot_meta_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_snapshot_meta_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionRaftStat.snapshot_meta_size)
}

// optional int64 snapshot_index = 4;
inline bool RegionRaftStat::_internal_has_snapshot_index() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RegionRaftStat::has_snapshot_index() const {
  return _internal_has_snapshot_index();
}
inline void RegionRaftStat::clear_snapshot_index() {
  snapshot_index_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionRaftStat::_internal_snapshot_index() const {
  return snapshot_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionRaftStat::snapshot_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionRaftStat.snapshot_index)
  return _internal_snapshot_index();
}
inline void RegionRaftStat::_internal_set_snapshot_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  snapshot_index_ = value;
}
inline void RegionRaftStat::set_snapshot_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_snapshot_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionRaftStat.snapshot_index)
}

// optional int64 dml_latency = 5;
inline bool RegionRaftStat::_internal_has_dml_latency() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RegionRaftStat::has_dml_latency() const {
  return _internal_has_dml_latency();
}
inline void RegionRaftStat::clear_dml_latency() {
  dml_latency_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionRaftStat::_internal_dml_latency() const {
  return dml_latency_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionRaftStat::dml_latency() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionRaftStat.dml_latency)
  return _internal_dml_latency();
}
inline void RegionRaftStat::_internal_set_dml_latency(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  dml_latency_ = value;
}
inline void RegionRaftStat::set_dml_latency(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_dml_latency(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionRaftStat.dml_latency)
}

// -------------------------------------------------------------------

// RocksStatisticReq

// repeated bytes keys = 1;
inline int RocksStatisticReq::_internal_keys_size() const {
  return keys_.size();
}
inline int RocksStatisticReq::keys_size() const {
  return _internal_keys_size();
}
inline void RocksStatisticReq::clear_keys() {
  keys_.Clear();
}
inline std::string* RocksStatisticReq::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.RocksStatisticReq.keys)
  return _s;
}
inline const std::string& RocksStatisticReq::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const std::string& RocksStatisticReq::keys(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RocksStatisticReq.keys)
  return _internal_keys(index);
}
inline std::string* RocksStatisticReq::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RocksStatisticReq.keys)
  return keys_.Mutable(index);
}
inline void RocksStatisticReq::set_keys(int index, const std::string& value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RocksStatisticReq.keys)
}
inline void RocksStatisticReq::set_keys(int index, std::string&& value) {
  keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.RocksStatisticReq.keys)
}
inline void RocksStatisticReq::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.RocksStatisticReq.keys)
}
inline void RocksStatisticReq::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.RocksStatisticReq.keys)
}
inline std::string* RocksStatisticReq::_internal_add_keys() {
  return keys_.Add();
}
inline void RocksStatisticReq::add_keys(const std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.RocksStatisticReq.keys)
}
inline void RocksStatisticReq::add_keys(std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.RocksStatisticReq.keys)
}
inline void RocksStatisticReq::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.RocksStatisticReq.keys)
}
inline void RocksStatisticReq::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.RocksStatisticReq.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RocksStatisticReq::keys() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RocksStatisticReq.keys)
  return keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RocksStatisticReq::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RocksStatisticReq.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// RocksStatisticRes

// required .baikaldb.pb.ErrCode errcode = 1;
inline bool RocksStatisticRes::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RocksStatisticRes::has_errcode() const {
  return _internal_has_errcode();
}
inline void RocksStatisticRes::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::baikaldb::pb::ErrCode RocksStatisticRes::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::ErrCode >(errcode_);
}
inline ::baikaldb::pb::ErrCode RocksStatisticRes::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RocksStatisticRes.errcode)
  return _internal_errcode();
}
inline void RocksStatisticRes::_internal_set_errcode(::baikaldb::pb::ErrCode value) {
  assert(::baikaldb::pb::ErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  errcode_ = value;
}
inline void RocksStatisticRes::set_errcode(::baikaldb::pb::ErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RocksStatisticRes.errcode)
}

// optional uint64 level0_sst_num = 2;
inline bool RocksStatisticRes::_internal_has_level0_sst_num() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RocksStatisticRes::has_level0_sst_num() const {
  return _internal_has_level0_sst_num();
}
inline void RocksStatisticRes::clear_level0_sst_num() {
  level0_sst_num_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RocksStatisticRes::_internal_level0_sst_num() const {
  return level0_sst_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RocksStatisticRes::level0_sst_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RocksStatisticRes.level0_sst_num)
  return _internal_level0_sst_num();
}
inline void RocksStatisticRes::_internal_set_level0_sst_num(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  level0_sst_num_ = value;
}
inline void RocksStatisticRes::set_level0_sst_num(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_level0_sst_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RocksStatisticRes.level0_sst_num)
}

// optional uint64 compaction_data_size = 3;
inline bool RocksStatisticRes::_internal_has_compaction_data_size() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RocksStatisticRes::has_compaction_data_size() const {
  return _internal_has_compaction_data_size();
}
inline void RocksStatisticRes::clear_compaction_data_size() {
  compaction_data_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RocksStatisticRes::_internal_compaction_data_size() const {
  return compaction_data_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RocksStatisticRes::compaction_data_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RocksStatisticRes.compaction_data_size)
  return _internal_compaction_data_size();
}
inline void RocksStatisticRes::_internal_set_compaction_data_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  compaction_data_size_ = value;
}
inline void RocksStatisticRes::set_compaction_data_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_compaction_data_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RocksStatisticRes.compaction_data_size)
}

// repeated bytes key = 4;
inline int RocksStatisticRes::_internal_key_size() const {
  return key_.size();
}
inline int RocksStatisticRes::key_size() const {
  return _internal_key_size();
}
inline void RocksStatisticRes::clear_key() {
  key_.Clear();
}
inline std::string* RocksStatisticRes::add_key() {
  std::string* _s = _internal_add_key();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.RocksStatisticRes.key)
  return _s;
}
inline const std::string& RocksStatisticRes::_internal_key(int index) const {
  return key_.Get(index);
}
inline const std::string& RocksStatisticRes::key(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RocksStatisticRes.key)
  return _internal_key(index);
}
inline std::string* RocksStatisticRes::mutable_key(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RocksStatisticRes.key)
  return key_.Mutable(index);
}
inline void RocksStatisticRes::set_key(int index, const std::string& value) {
  key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RocksStatisticRes.key)
}
inline void RocksStatisticRes::set_key(int index, std::string&& value) {
  key_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.RocksStatisticRes.key)
}
inline void RocksStatisticRes::set_key(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.RocksStatisticRes.key)
}
inline void RocksStatisticRes::set_key(int index, const void* value, size_t size) {
  key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.RocksStatisticRes.key)
}
inline std::string* RocksStatisticRes::_internal_add_key() {
  return key_.Add();
}
inline void RocksStatisticRes::add_key(const std::string& value) {
  key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.RocksStatisticRes.key)
}
inline void RocksStatisticRes::add_key(std::string&& value) {
  key_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.RocksStatisticRes.key)
}
inline void RocksStatisticRes::add_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.RocksStatisticRes.key)
}
inline void RocksStatisticRes::add_key(const void* value, size_t size) {
  key_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.RocksStatisticRes.key)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RocksStatisticRes::key() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RocksStatisticRes.key)
  return key_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RocksStatisticRes::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RocksStatisticRes.key)
  return &key_;
}

// repeated bytes value = 5;
inline int RocksStatisticRes::_internal_value_size() const {
  return value_.size();
}
inline int RocksStatisticRes::value_size() const {
  return _internal_value_size();
}
inline void RocksStatisticRes::clear_value() {
  value_.Clear();
}
inline std::string* RocksStatisticRes::add_value() {
  std::string* _s = _internal_add_value();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.RocksStatisticRes.value)
  return _s;
}
inline const std::string& RocksStatisticRes::_internal_value(int index) const {
  return value_.Get(index);
}
inline const std::string& RocksStatisticRes::value(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RocksStatisticRes.value)
  return _internal_value(index);
}
inline std::string* RocksStatisticRes::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RocksStatisticRes.value)
  return value_.Mutable(index);
}
inline void RocksStatisticRes::set_value(int index, const std::string& value) {
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RocksStatisticRes.value)
}
inline void RocksStatisticRes::set_value(int index, std::string&& value) {
  value_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.RocksStatisticRes.value)
}
inline void RocksStatisticRes::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.RocksStatisticRes.value)
}
inline void RocksStatisticRes::set_value(int index, const void* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.RocksStatisticRes.value)
}
inline std::string* RocksStatisticRes::_internal_add_value() {
  return value_.Add();
}
inline void RocksStatisticRes::add_value(const std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.RocksStatisticRes.value)
}
inline void RocksStatisticRes::add_value(std::string&& value) {
  value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.RocksStatisticRes.value)
}
inline void RocksStatisticRes::add_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.RocksStatisticRes.value)
}
inline void RocksStatisticRes::add_value(const void* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.RocksStatisticRes.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RocksStatisticRes::value() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RocksStatisticRes.value)
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RocksStatisticRes::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RocksStatisticRes.value)
  return &value_;
}

// -------------------------------------------------------------------

// BinlogQueryInfo

// optional int64 region_id = 1;
inline bool BinlogQueryInfo::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BinlogQueryInfo::has_region_id() const {
  return _internal_has_region_id();
}
inline void BinlogQueryInfo::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogQueryInfo::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogQueryInfo::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogQueryInfo.region_id)
  return _internal_region_id();
}
inline void BinlogQueryInfo::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  region_id_ = value;
}
inline void BinlogQueryInfo::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogQueryInfo.region_id)
}

// optional int64 oldest_ts = 2;
inline bool BinlogQueryInfo::_internal_has_oldest_ts() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BinlogQueryInfo::has_oldest_ts() const {
  return _internal_has_oldest_ts();
}
inline void BinlogQueryInfo::clear_oldest_ts() {
  oldest_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogQueryInfo::_internal_oldest_ts() const {
  return oldest_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogQueryInfo::oldest_ts() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogQueryInfo.oldest_ts)
  return _internal_oldest_ts();
}
inline void BinlogQueryInfo::_internal_set_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  oldest_ts_ = value;
}
inline void BinlogQueryInfo::set_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_oldest_ts(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogQueryInfo.oldest_ts)
}

// optional int64 check_point_ts = 3;
inline bool BinlogQueryInfo::_internal_has_check_point_ts() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BinlogQueryInfo::has_check_point_ts() const {
  return _internal_has_check_point_ts();
}
inline void BinlogQueryInfo::clear_check_point_ts() {
  check_point_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogQueryInfo::_internal_check_point_ts() const {
  return check_point_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogQueryInfo::check_point_ts() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogQueryInfo.check_point_ts)
  return _internal_check_point_ts();
}
inline void BinlogQueryInfo::_internal_set_check_point_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  check_point_ts_ = value;
}
inline void BinlogQueryInfo::set_check_point_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_check_point_ts(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogQueryInfo.check_point_ts)
}

// optional int64 region_oldest_ts = 4;
inline bool BinlogQueryInfo::_internal_has_region_oldest_ts() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BinlogQueryInfo::has_region_oldest_ts() const {
  return _internal_has_region_oldest_ts();
}
inline void BinlogQueryInfo::clear_region_oldest_ts() {
  region_oldest_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogQueryInfo::_internal_region_oldest_ts() const {
  return region_oldest_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogQueryInfo::region_oldest_ts() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogQueryInfo.region_oldest_ts)
  return _internal_region_oldest_ts();
}
inline void BinlogQueryInfo::_internal_set_region_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  region_oldest_ts_ = value;
}
inline void BinlogQueryInfo::set_region_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_oldest_ts(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogQueryInfo.region_oldest_ts)
}

// optional int64 binlog_cf_oldest_ts = 5;
inline bool BinlogQueryInfo::_internal_has_binlog_cf_oldest_ts() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BinlogQueryInfo::has_binlog_cf_oldest_ts() const {
  return _internal_has_binlog_cf_oldest_ts();
}
inline void BinlogQueryInfo::clear_binlog_cf_oldest_ts() {
  binlog_cf_oldest_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogQueryInfo::_internal_binlog_cf_oldest_ts() const {
  return binlog_cf_oldest_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogQueryInfo::binlog_cf_oldest_ts() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogQueryInfo.binlog_cf_oldest_ts)
  return _internal_binlog_cf_oldest_ts();
}
inline void BinlogQueryInfo::_internal_set_binlog_cf_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  binlog_cf_oldest_ts_ = value;
}
inline void BinlogQueryInfo::set_binlog_cf_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_binlog_cf_oldest_ts(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogQueryInfo.binlog_cf_oldest_ts)
}

// optional int64 data_cf_oldest_ts = 6;
inline bool BinlogQueryInfo::_internal_has_data_cf_oldest_ts() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BinlogQueryInfo::has_data_cf_oldest_ts() const {
  return _internal_has_data_cf_oldest_ts();
}
inline void BinlogQueryInfo::clear_data_cf_oldest_ts() {
  data_cf_oldest_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogQueryInfo::_internal_data_cf_oldest_ts() const {
  return data_cf_oldest_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogQueryInfo::data_cf_oldest_ts() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogQueryInfo.data_cf_oldest_ts)
  return _internal_data_cf_oldest_ts();
}
inline void BinlogQueryInfo::_internal_set_data_cf_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  data_cf_oldest_ts_ = value;
}
inline void BinlogQueryInfo::set_data_cf_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_data_cf_oldest_ts(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogQueryInfo.data_cf_oldest_ts)
}

// optional string region_ip = 7;
inline bool BinlogQueryInfo::_internal_has_region_ip() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BinlogQueryInfo::has_region_ip() const {
  return _internal_has_region_ip();
}
inline void BinlogQueryInfo::clear_region_ip() {
  region_ip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BinlogQueryInfo::region_ip() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogQueryInfo.region_ip)
  return _internal_region_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinlogQueryInfo::set_region_ip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 region_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogQueryInfo.region_ip)
}
inline std::string* BinlogQueryInfo::mutable_region_ip() {
  std::string* _s = _internal_mutable_region_ip();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BinlogQueryInfo.region_ip)
  return _s;
}
inline const std::string& BinlogQueryInfo::_internal_region_ip() const {
  return region_ip_.Get();
}
inline void BinlogQueryInfo::_internal_set_region_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  region_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BinlogQueryInfo::_internal_mutable_region_ip() {
  _has_bits_[0] |= 0x00000001u;
  return region_ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BinlogQueryInfo::release_region_ip() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BinlogQueryInfo.region_ip)
  if (!_internal_has_region_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return region_ip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BinlogQueryInfo::set_allocated_region_ip(std::string* region_ip) {
  if (region_ip != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region_ip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BinlogQueryInfo.region_ip)
}

// -------------------------------------------------------------------

// StoreRes

// required .baikaldb.pb.ErrCode errcode = 1;
inline bool StoreRes::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool StoreRes::has_errcode() const {
  return _internal_has_errcode();
}
inline void StoreRes::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::baikaldb::pb::ErrCode StoreRes::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::ErrCode >(errcode_);
}
inline ::baikaldb::pb::ErrCode StoreRes::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.errcode)
  return _internal_errcode();
}
inline void StoreRes::_internal_set_errcode(::baikaldb::pb::ErrCode value) {
  assert(::baikaldb::pb::ErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  errcode_ = value;
}
inline void StoreRes::set_errcode(::baikaldb::pb::ErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.errcode)
}

// optional bytes errmsg = 2;
inline bool StoreRes::_internal_has_errmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreRes::has_errmsg() const {
  return _internal_has_errmsg();
}
inline void StoreRes::clear_errmsg() {
  errmsg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreRes::errmsg() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.errmsg)
  return _internal_errmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreRes::set_errmsg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 errmsg_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.errmsg)
}
inline std::string* StoreRes::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreRes.errmsg)
  return _s;
}
inline const std::string& StoreRes::_internal_errmsg() const {
  return errmsg_.Get();
}
inline void StoreRes::_internal_set_errmsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreRes::_internal_mutable_errmsg() {
  _has_bits_[0] |= 0x00000001u;
  return errmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreRes::release_errmsg() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreRes.errmsg)
  if (!_internal_has_errmsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return errmsg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StoreRes::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreRes.errmsg)
}

// optional string leader = 3;
inline bool StoreRes::_internal_has_leader() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreRes::has_leader() const {
  return _internal_has_leader();
}
inline void StoreRes::clear_leader() {
  leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StoreRes::leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreRes::set_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.leader)
}
inline std::string* StoreRes::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreRes.leader)
  return _s;
}
inline const std::string& StoreRes::_internal_leader() const {
  return leader_.Get();
}
inline void StoreRes::_internal_set_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreRes::_internal_mutable_leader() {
  _has_bits_[0] |= 0x00000002u;
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreRes::release_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreRes.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StoreRes::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreRes.leader)
}

// repeated int32 tuple_ids = 4;
inline int StoreRes::_internal_tuple_ids_size() const {
  return tuple_ids_.size();
}
inline int StoreRes::tuple_ids_size() const {
  return _internal_tuple_ids_size();
}
inline void StoreRes::clear_tuple_ids() {
  tuple_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StoreRes::_internal_tuple_ids(int index) const {
  return tuple_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StoreRes::tuple_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.tuple_ids)
  return _internal_tuple_ids(index);
}
inline void StoreRes::set_tuple_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  tuple_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.tuple_ids)
}
inline void StoreRes::_internal_add_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  tuple_ids_.Add(value);
}
inline void StoreRes::add_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_tuple_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreRes.tuple_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
StoreRes::_internal_tuple_ids() const {
  return tuple_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
StoreRes::tuple_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreRes.tuple_ids)
  return _internal_tuple_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
StoreRes::_internal_mutable_tuple_ids() {
  return &tuple_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
StoreRes::mutable_tuple_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreRes.tuple_ids)
  return _internal_mutable_tuple_ids();
}

// repeated .baikaldb.pb.RowValue row_values = 5;
inline int StoreRes::_internal_row_values_size() const {
  return row_values_.size();
}
inline int StoreRes::row_values_size() const {
  return _internal_row_values_size();
}
inline void StoreRes::clear_row_values() {
  row_values_.Clear();
}
inline ::baikaldb::pb::RowValue* StoreRes::mutable_row_values(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreRes.row_values)
  return row_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RowValue >*
StoreRes::mutable_row_values() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreRes.row_values)
  return &row_values_;
}
inline const ::baikaldb::pb::RowValue& StoreRes::_internal_row_values(int index) const {
  return row_values_.Get(index);
}
inline const ::baikaldb::pb::RowValue& StoreRes::row_values(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.row_values)
  return _internal_row_values(index);
}
inline ::baikaldb::pb::RowValue* StoreRes::_internal_add_row_values() {
  return row_values_.Add();
}
inline ::baikaldb::pb::RowValue* StoreRes::add_row_values() {
  ::baikaldb::pb::RowValue* _add = _internal_add_row_values();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreRes.row_values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RowValue >&
StoreRes::row_values() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreRes.row_values)
  return row_values_;
}

// optional int64 affected_rows = 6;
inline bool StoreRes::_internal_has_affected_rows() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool StoreRes::has_affected_rows() const {
  return _internal_has_affected_rows();
}
inline void StoreRes::clear_affected_rows() {
  affected_rows_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::_internal_affected_rows() const {
  return affected_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::affected_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.affected_rows)
  return _internal_affected_rows();
}
inline void StoreRes::_internal_set_affected_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  affected_rows_ = value;
}
inline void StoreRes::set_affected_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_affected_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.affected_rows)
}

// repeated .baikaldb.pb.RegionInfo regions = 7;
inline int StoreRes::_internal_regions_size() const {
  return regions_.size();
}
inline int StoreRes::regions_size() const {
  return _internal_regions_size();
}
inline ::baikaldb::pb::RegionInfo* StoreRes::mutable_regions(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreRes.regions)
  return regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >*
StoreRes::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreRes.regions)
  return &regions_;
}
inline const ::baikaldb::pb::RegionInfo& StoreRes::_internal_regions(int index) const {
  return regions_.Get(index);
}
inline const ::baikaldb::pb::RegionInfo& StoreRes::regions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.regions)
  return _internal_regions(index);
}
inline ::baikaldb::pb::RegionInfo* StoreRes::_internal_add_regions() {
  return regions_.Add();
}
inline ::baikaldb::pb::RegionInfo* StoreRes::add_regions() {
  ::baikaldb::pb::RegionInfo* _add = _internal_add_regions();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreRes.regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >&
StoreRes::regions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreRes.regions)
  return regions_;
}

// optional int64 applied_index = 8;
inline bool StoreRes::_internal_has_applied_index() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool StoreRes::has_applied_index() const {
  return _internal_has_applied_index();
}
inline void StoreRes::clear_applied_index() {
  applied_index_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::_internal_applied_index() const {
  return applied_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::applied_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.applied_index)
  return _internal_applied_index();
}
inline void StoreRes::_internal_set_applied_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  applied_index_ = value;
}
inline void StoreRes::set_applied_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_applied_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.applied_index)
}

// optional int32 last_seq_id = 9;
inline bool StoreRes::_internal_has_last_seq_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool StoreRes::has_last_seq_id() const {
  return _internal_has_last_seq_id();
}
inline void StoreRes::clear_last_seq_id() {
  last_seq_id_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StoreRes::_internal_last_seq_id() const {
  return last_seq_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StoreRes::last_seq_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.last_seq_id)
  return _internal_last_seq_id();
}
inline void StoreRes::_internal_set_last_seq_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  last_seq_id_ = value;
}
inline void StoreRes::set_last_seq_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_last_seq_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.last_seq_id)
}

// repeated .baikaldb.pb.TransactionInfo txn_infos = 10;
inline int StoreRes::_internal_txn_infos_size() const {
  return txn_infos_.size();
}
inline int StoreRes::txn_infos_size() const {
  return _internal_txn_infos_size();
}
inline void StoreRes::clear_txn_infos() {
  txn_infos_.Clear();
}
inline ::baikaldb::pb::TransactionInfo* StoreRes::mutable_txn_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreRes.txn_infos)
  return txn_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TransactionInfo >*
StoreRes::mutable_txn_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreRes.txn_infos)
  return &txn_infos_;
}
inline const ::baikaldb::pb::TransactionInfo& StoreRes::_internal_txn_infos(int index) const {
  return txn_infos_.Get(index);
}
inline const ::baikaldb::pb::TransactionInfo& StoreRes::txn_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.txn_infos)
  return _internal_txn_infos(index);
}
inline ::baikaldb::pb::TransactionInfo* StoreRes::_internal_add_txn_infos() {
  return txn_infos_.Add();
}
inline ::baikaldb::pb::TransactionInfo* StoreRes::add_txn_infos() {
  ::baikaldb::pb::TransactionInfo* _add = _internal_add_txn_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreRes.txn_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TransactionInfo >&
StoreRes::txn_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreRes.txn_infos)
  return txn_infos_;
}

// optional int32 mysql_errcode = 11;
inline bool StoreRes::_internal_has_mysql_errcode() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool StoreRes::has_mysql_errcode() const {
  return _internal_has_mysql_errcode();
}
inline void StoreRes::clear_mysql_errcode() {
  mysql_errcode_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StoreRes::_internal_mysql_errcode() const {
  return mysql_errcode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StoreRes::mysql_errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.mysql_errcode)
  return _internal_mysql_errcode();
}
inline void StoreRes::_internal_set_mysql_errcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00001000u;
  mysql_errcode_ = value;
}
inline void StoreRes::set_mysql_errcode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_mysql_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.mysql_errcode)
}

// optional int64 region_count = 12;
inline bool StoreRes::_internal_has_region_count() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool StoreRes::has_region_count() const {
  return _internal_has_region_count();
}
inline void StoreRes::clear_region_count() {
  region_count_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::_internal_region_count() const {
  return region_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::region_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.region_count)
  return _internal_region_count();
}
inline void StoreRes::_internal_set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  region_count_ = value;
}
inline void StoreRes::set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.region_count)
}

// repeated .baikaldb.pb.RegionLeader region_leaders = 13;
inline int StoreRes::_internal_region_leaders_size() const {
  return region_leaders_.size();
}
inline int StoreRes::region_leaders_size() const {
  return _internal_region_leaders_size();
}
inline void StoreRes::clear_region_leaders() {
  region_leaders_.Clear();
}
inline ::baikaldb::pb::RegionLeader* StoreRes::mutable_region_leaders(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreRes.region_leaders)
  return region_leaders_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionLeader >*
StoreRes::mutable_region_leaders() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreRes.region_leaders)
  return &region_leaders_;
}
inline const ::baikaldb::pb::RegionLeader& StoreRes::_internal_region_leaders(int index) const {
  return region_leaders_.Get(index);
}
inline const ::baikaldb::pb::RegionLeader& StoreRes::region_leaders(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.region_leaders)
  return _internal_region_leaders(index);
}
inline ::baikaldb::pb::RegionLeader* StoreRes::_internal_add_region_leaders() {
  return region_leaders_.Add();
}
inline ::baikaldb::pb::RegionLeader* StoreRes::add_region_leaders() {
  ::baikaldb::pb::RegionLeader* _add = _internal_add_region_leaders();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreRes.region_leaders)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionLeader >&
StoreRes::region_leaders() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreRes.region_leaders)
  return region_leaders_;
}

// optional bool is_merge = 14;
inline bool StoreRes::_internal_has_is_merge() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool StoreRes::has_is_merge() const {
  return _internal_has_is_merge();
}
inline void StoreRes::clear_is_merge() {
  is_merge_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool StoreRes::_internal_is_merge() const {
  return is_merge_;
}
inline bool StoreRes::is_merge() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.is_merge)
  return _internal_is_merge();
}
inline void StoreRes::_internal_set_is_merge(bool value) {
  _has_bits_[0] |= 0x00002000u;
  is_merge_ = value;
}
inline void StoreRes::set_is_merge(bool value) {
  _internal_set_is_merge(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.is_merge)
}

// repeated .baikaldb.pb.IndexRecords records = 15;
inline int StoreRes::_internal_records_size() const {
  return records_.size();
}
inline int StoreRes::records_size() const {
  return _internal_records_size();
}
inline void StoreRes::clear_records() {
  records_.Clear();
}
inline ::baikaldb::pb::IndexRecords* StoreRes::mutable_records(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreRes.records)
  return records_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::IndexRecords >*
StoreRes::mutable_records() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreRes.records)
  return &records_;
}
inline const ::baikaldb::pb::IndexRecords& StoreRes::_internal_records(int index) const {
  return records_.Get(index);
}
inline const ::baikaldb::pb::IndexRecords& StoreRes::records(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.records)
  return _internal_records(index);
}
inline ::baikaldb::pb::IndexRecords* StoreRes::_internal_add_records() {
  return records_.Add();
}
inline ::baikaldb::pb::IndexRecords* StoreRes::add_records() {
  ::baikaldb::pb::IndexRecords* _add = _internal_add_records();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreRes.records)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::IndexRecords >&
StoreRes::records() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreRes.records)
  return records_;
}

// optional int64 scan_rows = 16;
inline bool StoreRes::_internal_has_scan_rows() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool StoreRes::has_scan_rows() const {
  return _internal_has_scan_rows();
}
inline void StoreRes::clear_scan_rows() {
  scan_rows_ = int64_t{0};
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::_internal_scan_rows() const {
  return scan_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::scan_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.scan_rows)
  return _internal_scan_rows();
}
inline void StoreRes::_internal_set_scan_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00004000u;
  scan_rows_ = value;
}
inline void StoreRes::set_scan_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_scan_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.scan_rows)
}

// optional .baikaldb.pb.CMsketch cmsketch = 17;
inline bool StoreRes::_internal_has_cmsketch() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || cmsketch_ != nullptr);
  return value;
}
inline bool StoreRes::has_cmsketch() const {
  return _internal_has_cmsketch();
}
inline const ::baikaldb::pb::CMsketch& StoreRes::_internal_cmsketch() const {
  const ::baikaldb::pb::CMsketch* p = cmsketch_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::CMsketch&>(
      ::baikaldb::pb::_CMsketch_default_instance_);
}
inline const ::baikaldb::pb::CMsketch& StoreRes::cmsketch() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.cmsketch)
  return _internal_cmsketch();
}
inline void StoreRes::unsafe_arena_set_allocated_cmsketch(
    ::baikaldb::pb::CMsketch* cmsketch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cmsketch_);
  }
  cmsketch_ = cmsketch;
  if (cmsketch) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.StoreRes.cmsketch)
}
inline ::baikaldb::pb::CMsketch* StoreRes::release_cmsketch() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::CMsketch* temp = cmsketch_;
  cmsketch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::CMsketch* StoreRes::unsafe_arena_release_cmsketch() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreRes.cmsketch)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::CMsketch* temp = cmsketch_;
  cmsketch_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::CMsketch* StoreRes::_internal_mutable_cmsketch() {
  _has_bits_[0] |= 0x00000004u;
  if (cmsketch_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::CMsketch>(GetArenaForAllocation());
    cmsketch_ = p;
  }
  return cmsketch_;
}
inline ::baikaldb::pb::CMsketch* StoreRes::mutable_cmsketch() {
  ::baikaldb::pb::CMsketch* _msg = _internal_mutable_cmsketch();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreRes.cmsketch)
  return _msg;
}
inline void StoreRes::set_allocated_cmsketch(::baikaldb::pb::CMsketch* cmsketch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cmsketch_);
  }
  if (cmsketch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cmsketch));
    if (message_arena != submessage_arena) {
      cmsketch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cmsketch, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  cmsketch_ = cmsketch;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreRes.cmsketch)
}

// optional int64 filter_rows = 18;
inline bool StoreRes::_internal_has_filter_rows() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool StoreRes::has_filter_rows() const {
  return _internal_has_filter_rows();
}
inline void StoreRes::clear_filter_rows() {
  filter_rows_ = int64_t{0};
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::_internal_filter_rows() const {
  return filter_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::filter_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.filter_rows)
  return _internal_filter_rows();
}
inline void StoreRes::_internal_set_filter_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00008000u;
  filter_rows_ = value;
}
inline void StoreRes::set_filter_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_filter_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.filter_rows)
}

// repeated bytes binlogs = 19;
inline int StoreRes::_internal_binlogs_size() const {
  return binlogs_.size();
}
inline int StoreRes::binlogs_size() const {
  return _internal_binlogs_size();
}
inline void StoreRes::clear_binlogs() {
  binlogs_.Clear();
}
inline std::string* StoreRes::add_binlogs() {
  std::string* _s = _internal_add_binlogs();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.StoreRes.binlogs)
  return _s;
}
inline const std::string& StoreRes::_internal_binlogs(int index) const {
  return binlogs_.Get(index);
}
inline const std::string& StoreRes::binlogs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.binlogs)
  return _internal_binlogs(index);
}
inline std::string* StoreRes::mutable_binlogs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreRes.binlogs)
  return binlogs_.Mutable(index);
}
inline void StoreRes::set_binlogs(int index, const std::string& value) {
  binlogs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.binlogs)
}
inline void StoreRes::set_binlogs(int index, std::string&& value) {
  binlogs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.binlogs)
}
inline void StoreRes::set_binlogs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  binlogs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.StoreRes.binlogs)
}
inline void StoreRes::set_binlogs(int index, const void* value, size_t size) {
  binlogs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.StoreRes.binlogs)
}
inline std::string* StoreRes::_internal_add_binlogs() {
  return binlogs_.Add();
}
inline void StoreRes::add_binlogs(const std::string& value) {
  binlogs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreRes.binlogs)
}
inline void StoreRes::add_binlogs(std::string&& value) {
  binlogs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreRes.binlogs)
}
inline void StoreRes::add_binlogs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  binlogs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.StoreRes.binlogs)
}
inline void StoreRes::add_binlogs(const void* value, size_t size) {
  binlogs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.StoreRes.binlogs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StoreRes::binlogs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreRes.binlogs)
  return binlogs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StoreRes::mutable_binlogs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreRes.binlogs)
  return &binlogs_;
}

// repeated int64 commit_ts = 20;
inline int StoreRes::_internal_commit_ts_size() const {
  return commit_ts_.size();
}
inline int StoreRes::commit_ts_size() const {
  return _internal_commit_ts_size();
}
inline void StoreRes::clear_commit_ts() {
  commit_ts_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::_internal_commit_ts(int index) const {
  return commit_ts_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::commit_ts(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.commit_ts)
  return _internal_commit_ts(index);
}
inline void StoreRes::set_commit_ts(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  commit_ts_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.commit_ts)
}
inline void StoreRes::_internal_add_commit_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  commit_ts_.Add(value);
}
inline void StoreRes::add_commit_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_commit_ts(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreRes.commit_ts)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
StoreRes::_internal_commit_ts() const {
  return commit_ts_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
StoreRes::commit_ts() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreRes.commit_ts)
  return _internal_commit_ts();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
StoreRes::_internal_mutable_commit_ts() {
  return &commit_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
StoreRes::mutable_commit_ts() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreRes.commit_ts)
  return _internal_mutable_commit_ts();
}

// optional .baikaldb.pb.PeerStatus region_status = 21;
inline bool StoreRes::_internal_has_region_status() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool StoreRes::has_region_status() const {
  return _internal_has_region_status();
}
inline void StoreRes::clear_region_status() {
  region_status_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::baikaldb::pb::PeerStatus StoreRes::_internal_region_status() const {
  return static_cast< ::baikaldb::pb::PeerStatus >(region_status_);
}
inline ::baikaldb::pb::PeerStatus StoreRes::region_status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.region_status)
  return _internal_region_status();
}
inline void StoreRes::_internal_set_region_status(::baikaldb::pb::PeerStatus value) {
  assert(::baikaldb::pb::PeerStatus_IsValid(value));
  _has_bits_[0] |= 0x00020000u;
  region_status_ = value;
}
inline void StoreRes::set_region_status(::baikaldb::pb::PeerStatus value) {
  _internal_set_region_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.region_status)
}

// optional int64 last_insert_id = 22;
inline bool StoreRes::_internal_has_last_insert_id() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool StoreRes::has_last_insert_id() const {
  return _internal_has_last_insert_id();
}
inline void StoreRes::clear_last_insert_id() {
  last_insert_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::_internal_last_insert_id() const {
  return last_insert_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::last_insert_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.last_insert_id)
  return _internal_last_insert_id();
}
inline void StoreRes::_internal_set_last_insert_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00010000u;
  last_insert_id_ = value;
}
inline void StoreRes::set_last_insert_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_last_insert_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.last_insert_id)
}

// optional .baikaldb.pb.RegionRaftStat region_raft_stat = 23;
inline bool StoreRes::_internal_has_region_raft_stat() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || region_raft_stat_ != nullptr);
  return value;
}
inline bool StoreRes::has_region_raft_stat() const {
  return _internal_has_region_raft_stat();
}
inline void StoreRes::clear_region_raft_stat() {
  if (region_raft_stat_ != nullptr) region_raft_stat_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::baikaldb::pb::RegionRaftStat& StoreRes::_internal_region_raft_stat() const {
  const ::baikaldb::pb::RegionRaftStat* p = region_raft_stat_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionRaftStat&>(
      ::baikaldb::pb::_RegionRaftStat_default_instance_);
}
inline const ::baikaldb::pb::RegionRaftStat& StoreRes::region_raft_stat() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.region_raft_stat)
  return _internal_region_raft_stat();
}
inline void StoreRes::unsafe_arena_set_allocated_region_raft_stat(
    ::baikaldb::pb::RegionRaftStat* region_raft_stat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_raft_stat_);
  }
  region_raft_stat_ = region_raft_stat;
  if (region_raft_stat) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.StoreRes.region_raft_stat)
}
inline ::baikaldb::pb::RegionRaftStat* StoreRes::release_region_raft_stat() {
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::RegionRaftStat* temp = region_raft_stat_;
  region_raft_stat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionRaftStat* StoreRes::unsafe_arena_release_region_raft_stat() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreRes.region_raft_stat)
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::RegionRaftStat* temp = region_raft_stat_;
  region_raft_stat_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionRaftStat* StoreRes::_internal_mutable_region_raft_stat() {
  _has_bits_[0] |= 0x00000008u;
  if (region_raft_stat_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionRaftStat>(GetArenaForAllocation());
    region_raft_stat_ = p;
  }
  return region_raft_stat_;
}
inline ::baikaldb::pb::RegionRaftStat* StoreRes::mutable_region_raft_stat() {
  ::baikaldb::pb::RegionRaftStat* _msg = _internal_mutable_region_raft_stat();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreRes.region_raft_stat)
  return _msg;
}
inline void StoreRes::set_allocated_region_raft_stat(::baikaldb::pb::RegionRaftStat* region_raft_stat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete region_raft_stat_;
  }
  if (region_raft_stat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::RegionRaftStat>::GetOwningArena(region_raft_stat);
    if (message_arena != submessage_arena) {
      region_raft_stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_raft_stat, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  region_raft_stat_ = region_raft_stat;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreRes.region_raft_stat)
}

// repeated int64 ttl_timestamp = 24;
inline int StoreRes::_internal_ttl_timestamp_size() const {
  return ttl_timestamp_.size();
}
inline int StoreRes::ttl_timestamp_size() const {
  return _internal_ttl_timestamp_size();
}
inline void StoreRes::clear_ttl_timestamp() {
  ttl_timestamp_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::_internal_ttl_timestamp(int index) const {
  return ttl_timestamp_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::ttl_timestamp(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.ttl_timestamp)
  return _internal_ttl_timestamp(index);
}
inline void StoreRes::set_ttl_timestamp(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  ttl_timestamp_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.ttl_timestamp)
}
inline void StoreRes::_internal_add_ttl_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  ttl_timestamp_.Add(value);
}
inline void StoreRes::add_ttl_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_ttl_timestamp(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreRes.ttl_timestamp)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
StoreRes::_internal_ttl_timestamp() const {
  return ttl_timestamp_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
StoreRes::ttl_timestamp() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreRes.ttl_timestamp)
  return _internal_ttl_timestamp();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
StoreRes::_internal_mutable_ttl_timestamp() {
  return &ttl_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
StoreRes::mutable_ttl_timestamp() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreRes.ttl_timestamp)
  return _internal_mutable_ttl_timestamp();
}

// optional .baikaldb.pb.ExtraRes extra_res = 25;
inline bool StoreRes::_internal_has_extra_res() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || extra_res_ != nullptr);
  return value;
}
inline bool StoreRes::has_extra_res() const {
  return _internal_has_extra_res();
}
inline void StoreRes::clear_extra_res() {
  if (extra_res_ != nullptr) extra_res_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::baikaldb::pb::ExtraRes& StoreRes::_internal_extra_res() const {
  const ::baikaldb::pb::ExtraRes* p = extra_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::ExtraRes&>(
      ::baikaldb::pb::_ExtraRes_default_instance_);
}
inline const ::baikaldb::pb::ExtraRes& StoreRes::extra_res() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.extra_res)
  return _internal_extra_res();
}
inline void StoreRes::unsafe_arena_set_allocated_extra_res(
    ::baikaldb::pb::ExtraRes* extra_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extra_res_);
  }
  extra_res_ = extra_res;
  if (extra_res) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.StoreRes.extra_res)
}
inline ::baikaldb::pb::ExtraRes* StoreRes::release_extra_res() {
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::ExtraRes* temp = extra_res_;
  extra_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::ExtraRes* StoreRes::unsafe_arena_release_extra_res() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreRes.extra_res)
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::ExtraRes* temp = extra_res_;
  extra_res_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::ExtraRes* StoreRes::_internal_mutable_extra_res() {
  _has_bits_[0] |= 0x00000010u;
  if (extra_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::ExtraRes>(GetArenaForAllocation());
    extra_res_ = p;
  }
  return extra_res_;
}
inline ::baikaldb::pb::ExtraRes* StoreRes::mutable_extra_res() {
  ::baikaldb::pb::ExtraRes* _msg = _internal_mutable_extra_res();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreRes.extra_res)
  return _msg;
}
inline void StoreRes::set_allocated_extra_res(::baikaldb::pb::ExtraRes* extra_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete extra_res_;
  }
  if (extra_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::ExtraRes>::GetOwningArena(extra_res);
    if (message_arena != submessage_arena) {
      extra_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra_res, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  extra_res_ = extra_res;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreRes.extra_res)
}

// optional .baikaldb.pb.BinlogQueryInfo binlog_info = 26;
inline bool StoreRes::_internal_has_binlog_info() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || binlog_info_ != nullptr);
  return value;
}
inline bool StoreRes::has_binlog_info() const {
  return _internal_has_binlog_info();
}
inline void StoreRes::clear_binlog_info() {
  if (binlog_info_ != nullptr) binlog_info_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::baikaldb::pb::BinlogQueryInfo& StoreRes::_internal_binlog_info() const {
  const ::baikaldb::pb::BinlogQueryInfo* p = binlog_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::BinlogQueryInfo&>(
      ::baikaldb::pb::_BinlogQueryInfo_default_instance_);
}
inline const ::baikaldb::pb::BinlogQueryInfo& StoreRes::binlog_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.binlog_info)
  return _internal_binlog_info();
}
inline void StoreRes::unsafe_arena_set_allocated_binlog_info(
    ::baikaldb::pb::BinlogQueryInfo* binlog_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(binlog_info_);
  }
  binlog_info_ = binlog_info;
  if (binlog_info) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.StoreRes.binlog_info)
}
inline ::baikaldb::pb::BinlogQueryInfo* StoreRes::release_binlog_info() {
  _has_bits_[0] &= ~0x00000020u;
  ::baikaldb::pb::BinlogQueryInfo* temp = binlog_info_;
  binlog_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::BinlogQueryInfo* StoreRes::unsafe_arena_release_binlog_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreRes.binlog_info)
  _has_bits_[0] &= ~0x00000020u;
  ::baikaldb::pb::BinlogQueryInfo* temp = binlog_info_;
  binlog_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::BinlogQueryInfo* StoreRes::_internal_mutable_binlog_info() {
  _has_bits_[0] |= 0x00000020u;
  if (binlog_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::BinlogQueryInfo>(GetArenaForAllocation());
    binlog_info_ = p;
  }
  return binlog_info_;
}
inline ::baikaldb::pb::BinlogQueryInfo* StoreRes::mutable_binlog_info() {
  ::baikaldb::pb::BinlogQueryInfo* _msg = _internal_mutable_binlog_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreRes.binlog_info)
  return _msg;
}
inline void StoreRes::set_allocated_binlog_info(::baikaldb::pb::BinlogQueryInfo* binlog_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete binlog_info_;
  }
  if (binlog_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::BinlogQueryInfo>::GetOwningArena(binlog_info);
    if (message_arena != submessage_arena) {
      binlog_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, binlog_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  binlog_info_ = binlog_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreRes.binlog_info)
}

// optional .baikaldb.pb.ExecuteType execute_type = 27;
inline bool StoreRes::_internal_has_execute_type() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool StoreRes::has_execute_type() const {
  return _internal_has_execute_type();
}
inline void StoreRes::clear_execute_type() {
  execute_type_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::baikaldb::pb::ExecuteType StoreRes::_internal_execute_type() const {
  return static_cast< ::baikaldb::pb::ExecuteType >(execute_type_);
}
inline ::baikaldb::pb::ExecuteType StoreRes::execute_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.execute_type)
  return _internal_execute_type();
}
inline void StoreRes::_internal_set_execute_type(::baikaldb::pb::ExecuteType value) {
  assert(::baikaldb::pb::ExecuteType_IsValid(value));
  _has_bits_[0] |= 0x00040000u;
  execute_type_ = value;
}
inline void StoreRes::set_execute_type(::baikaldb::pb::ExecuteType value) {
  _internal_set_execute_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.execute_type)
}

// optional int64 read_disk_size = 28;
inline bool StoreRes::_internal_has_read_disk_size() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool StoreRes::has_read_disk_size() const {
  return _internal_has_read_disk_size();
}
inline void StoreRes::clear_read_disk_size() {
  read_disk_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::_internal_read_disk_size() const {
  return read_disk_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::read_disk_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.read_disk_size)
  return _internal_read_disk_size();
}
inline void StoreRes::_internal_set_read_disk_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00080000u;
  read_disk_size_ = value;
}
inline void StoreRes::set_read_disk_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_read_disk_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.read_disk_size)
}

// optional int64 orig_region_id = 29;
inline bool StoreRes::_internal_has_orig_region_id() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool StoreRes::has_orig_region_id() const {
  return _internal_has_orig_region_id();
}
inline void StoreRes::clear_orig_region_id() {
  orig_region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::_internal_orig_region_id() const {
  return orig_region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRes::orig_region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.orig_region_id)
  return _internal_orig_region_id();
}
inline void StoreRes::_internal_set_orig_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00100000u;
  orig_region_id_ = value;
}
inline void StoreRes::set_orig_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_orig_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRes.orig_region_id)
}

// optional .baikaldb.pb.HyperLogLog hll = 30;
inline bool StoreRes::_internal_has_hll() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || hll_ != nullptr);
  return value;
}
inline bool StoreRes::has_hll() const {
  return _internal_has_hll();
}
inline const ::baikaldb::pb::HyperLogLog& StoreRes::_internal_hll() const {
  const ::baikaldb::pb::HyperLogLog* p = hll_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::HyperLogLog&>(
      ::baikaldb::pb::_HyperLogLog_default_instance_);
}
inline const ::baikaldb::pb::HyperLogLog& StoreRes::hll() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRes.hll)
  return _internal_hll();
}
inline void StoreRes::unsafe_arena_set_allocated_hll(
    ::baikaldb::pb::HyperLogLog* hll) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hll_);
  }
  hll_ = hll;
  if (hll) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.StoreRes.hll)
}
inline ::baikaldb::pb::HyperLogLog* StoreRes::release_hll() {
  _has_bits_[0] &= ~0x00000040u;
  ::baikaldb::pb::HyperLogLog* temp = hll_;
  hll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::HyperLogLog* StoreRes::unsafe_arena_release_hll() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreRes.hll)
  _has_bits_[0] &= ~0x00000040u;
  ::baikaldb::pb::HyperLogLog* temp = hll_;
  hll_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::HyperLogLog* StoreRes::_internal_mutable_hll() {
  _has_bits_[0] |= 0x00000040u;
  if (hll_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::HyperLogLog>(GetArenaForAllocation());
    hll_ = p;
  }
  return hll_;
}
inline ::baikaldb::pb::HyperLogLog* StoreRes::mutable_hll() {
  ::baikaldb::pb::HyperLogLog* _msg = _internal_mutable_hll();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreRes.hll)
  return _msg;
}
inline void StoreRes::set_allocated_hll(::baikaldb::pb::HyperLogLog* hll) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hll_);
  }
  if (hll) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hll));
    if (message_arena != submessage_arena) {
      hll = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hll, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  hll_ = hll;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreRes.hll)
}

// -------------------------------------------------------------------

// BatchRegionStoreReq

// repeated .baikaldb.pb.StoreReq store_req = 1;
inline int BatchRegionStoreReq::_internal_store_req_size() const {
  return store_req_.size();
}
inline int BatchRegionStoreReq::store_req_size() const {
  return _internal_store_req_size();
}
inline void BatchRegionStoreReq::clear_store_req() {
  store_req_.Clear();
}
inline ::baikaldb::pb::StoreReq* BatchRegionStoreReq::mutable_store_req(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BatchRegionStoreReq.store_req)
  return store_req_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::StoreReq >*
BatchRegionStoreReq::mutable_store_req() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BatchRegionStoreReq.store_req)
  return &store_req_;
}
inline const ::baikaldb::pb::StoreReq& BatchRegionStoreReq::_internal_store_req(int index) const {
  return store_req_.Get(index);
}
inline const ::baikaldb::pb::StoreReq& BatchRegionStoreReq::store_req(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BatchRegionStoreReq.store_req)
  return _internal_store_req(index);
}
inline ::baikaldb::pb::StoreReq* BatchRegionStoreReq::_internal_add_store_req() {
  return store_req_.Add();
}
inline ::baikaldb::pb::StoreReq* BatchRegionStoreReq::add_store_req() {
  ::baikaldb::pb::StoreReq* _add = _internal_add_store_req();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BatchRegionStoreReq.store_req)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::StoreReq >&
BatchRegionStoreReq::store_req() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BatchRegionStoreReq.store_req)
  return store_req_;
}

// required int64 limit_single_store_concurrency = 2;
inline bool BatchRegionStoreReq::_internal_has_limit_single_store_concurrency() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BatchRegionStoreReq::has_limit_single_store_concurrency() const {
  return _internal_has_limit_single_store_concurrency();
}
inline void BatchRegionStoreReq::clear_limit_single_store_concurrency() {
  limit_single_store_concurrency_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatchRegionStoreReq::_internal_limit_single_store_concurrency() const {
  return limit_single_store_concurrency_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BatchRegionStoreReq::limit_single_store_concurrency() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BatchRegionStoreReq.limit_single_store_concurrency)
  return _internal_limit_single_store_concurrency();
}
inline void BatchRegionStoreReq::_internal_set_limit_single_store_concurrency(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  limit_single_store_concurrency_ = value;
}
inline void BatchRegionStoreReq::set_limit_single_store_concurrency(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_limit_single_store_concurrency(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BatchRegionStoreReq.limit_single_store_concurrency)
}

// repeated .baikaldb.pb.Plan plan = 3;
inline int BatchRegionStoreReq::_internal_plan_size() const {
  return plan_.size();
}
inline int BatchRegionStoreReq::plan_size() const {
  return _internal_plan_size();
}
inline ::baikaldb::pb::Plan* BatchRegionStoreReq::mutable_plan(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BatchRegionStoreReq.plan)
  return plan_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Plan >*
BatchRegionStoreReq::mutable_plan() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BatchRegionStoreReq.plan)
  return &plan_;
}
inline const ::baikaldb::pb::Plan& BatchRegionStoreReq::_internal_plan(int index) const {
  return plan_.Get(index);
}
inline const ::baikaldb::pb::Plan& BatchRegionStoreReq::plan(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BatchRegionStoreReq.plan)
  return _internal_plan(index);
}
inline ::baikaldb::pb::Plan* BatchRegionStoreReq::_internal_add_plan() {
  return plan_.Add();
}
inline ::baikaldb::pb::Plan* BatchRegionStoreReq::add_plan() {
  ::baikaldb::pb::Plan* _add = _internal_add_plan();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BatchRegionStoreReq.plan)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Plan >&
BatchRegionStoreReq::plan() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BatchRegionStoreReq.plan)
  return plan_;
}

// -------------------------------------------------------------------

// BatchRegionStoreRes

// repeated .baikaldb.pb.StoreRes store_res = 1;
inline int BatchRegionStoreRes::_internal_store_res_size() const {
  return store_res_.size();
}
inline int BatchRegionStoreRes::store_res_size() const {
  return _internal_store_res_size();
}
inline void BatchRegionStoreRes::clear_store_res() {
  store_res_.Clear();
}
inline ::baikaldb::pb::StoreRes* BatchRegionStoreRes::mutable_store_res(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BatchRegionStoreRes.store_res)
  return store_res_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::StoreRes >*
BatchRegionStoreRes::mutable_store_res() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BatchRegionStoreRes.store_res)
  return &store_res_;
}
inline const ::baikaldb::pb::StoreRes& BatchRegionStoreRes::_internal_store_res(int index) const {
  return store_res_.Get(index);
}
inline const ::baikaldb::pb::StoreRes& BatchRegionStoreRes::store_res(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BatchRegionStoreRes.store_res)
  return _internal_store_res(index);
}
inline ::baikaldb::pb::StoreRes* BatchRegionStoreRes::_internal_add_store_res() {
  return store_res_.Add();
}
inline ::baikaldb::pb::StoreRes* BatchRegionStoreRes::add_store_res() {
  ::baikaldb::pb::StoreRes* _add = _internal_add_store_res();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BatchRegionStoreRes.store_res)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::StoreRes >&
BatchRegionStoreRes::store_res() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BatchRegionStoreRes.store_res)
  return store_res_;
}

// -------------------------------------------------------------------

// InitRegion

// required .baikaldb.pb.RegionInfo region_info = 1;
inline bool InitRegion::_internal_has_region_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || region_info_ != nullptr);
  return value;
}
inline bool InitRegion::has_region_info() const {
  return _internal_has_region_info();
}
inline const ::baikaldb::pb::RegionInfo& InitRegion::_internal_region_info() const {
  const ::baikaldb::pb::RegionInfo* p = region_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionInfo&>(
      ::baikaldb::pb::_RegionInfo_default_instance_);
}
inline const ::baikaldb::pb::RegionInfo& InitRegion::region_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InitRegion.region_info)
  return _internal_region_info();
}
inline void InitRegion::unsafe_arena_set_allocated_region_info(
    ::baikaldb::pb::RegionInfo* region_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_info_);
  }
  region_info_ = region_info;
  if (region_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.InitRegion.region_info)
}
inline ::baikaldb::pb::RegionInfo* InitRegion::release_region_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::RegionInfo* temp = region_info_;
  region_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionInfo* InitRegion::unsafe_arena_release_region_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.InitRegion.region_info)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::RegionInfo* temp = region_info_;
  region_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionInfo* InitRegion::_internal_mutable_region_info() {
  _has_bits_[0] |= 0x00000001u;
  if (region_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionInfo>(GetArenaForAllocation());
    region_info_ = p;
  }
  return region_info_;
}
inline ::baikaldb::pb::RegionInfo* InitRegion::mutable_region_info() {
  ::baikaldb::pb::RegionInfo* _msg = _internal_mutable_region_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.InitRegion.region_info)
  return _msg;
}
inline void InitRegion::set_allocated_region_info(::baikaldb::pb::RegionInfo* region_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_info_);
  }
  if (region_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_info));
    if (message_arena != submessage_arena) {
      region_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_info_ = region_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.InitRegion.region_info)
}

// optional .baikaldb.pb.SchemaInfo schema_info = 2;
inline bool InitRegion::_internal_has_schema_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || schema_info_ != nullptr);
  return value;
}
inline bool InitRegion::has_schema_info() const {
  return _internal_has_schema_info();
}
inline const ::baikaldb::pb::SchemaInfo& InitRegion::_internal_schema_info() const {
  const ::baikaldb::pb::SchemaInfo* p = schema_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::SchemaInfo&>(
      ::baikaldb::pb::_SchemaInfo_default_instance_);
}
inline const ::baikaldb::pb::SchemaInfo& InitRegion::schema_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InitRegion.schema_info)
  return _internal_schema_info();
}
inline void InitRegion::unsafe_arena_set_allocated_schema_info(
    ::baikaldb::pb::SchemaInfo* schema_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_info_);
  }
  schema_info_ = schema_info;
  if (schema_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.InitRegion.schema_info)
}
inline ::baikaldb::pb::SchemaInfo* InitRegion::release_schema_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::SchemaInfo* temp = schema_info_;
  schema_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::SchemaInfo* InitRegion::unsafe_arena_release_schema_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.InitRegion.schema_info)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::SchemaInfo* temp = schema_info_;
  schema_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::SchemaInfo* InitRegion::_internal_mutable_schema_info() {
  _has_bits_[0] |= 0x00000002u;
  if (schema_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::SchemaInfo>(GetArenaForAllocation());
    schema_info_ = p;
  }
  return schema_info_;
}
inline ::baikaldb::pb::SchemaInfo* InitRegion::mutable_schema_info() {
  ::baikaldb::pb::SchemaInfo* _msg = _internal_mutable_schema_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.InitRegion.schema_info)
  return _msg;
}
inline void InitRegion::set_allocated_schema_info(::baikaldb::pb::SchemaInfo* schema_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_info_);
  }
  if (schema_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_info));
    if (message_arena != submessage_arena) {
      schema_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  schema_info_ = schema_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.InitRegion.schema_info)
}

// optional bool is_split = 3;
inline bool InitRegion::_internal_has_is_split() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InitRegion::has_is_split() const {
  return _internal_has_is_split();
}
inline void InitRegion::clear_is_split() {
  is_split_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool InitRegion::_internal_is_split() const {
  return is_split_;
}
inline bool InitRegion::is_split() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InitRegion.is_split)
  return _internal_is_split();
}
inline void InitRegion::_internal_set_is_split(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_split_ = value;
}
inline void InitRegion::set_is_split(bool value) {
  _internal_set_is_split(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InitRegion.is_split)
}

// optional int32 snapshot_times = 4;
inline bool InitRegion::_internal_has_snapshot_times() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InitRegion::has_snapshot_times() const {
  return _internal_has_snapshot_times();
}
inline void InitRegion::clear_snapshot_times() {
  snapshot_times_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InitRegion::_internal_snapshot_times() const {
  return snapshot_times_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InitRegion::snapshot_times() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InitRegion.snapshot_times)
  return _internal_snapshot_times();
}
inline void InitRegion::_internal_set_snapshot_times(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  snapshot_times_ = value;
}
inline void InitRegion::set_snapshot_times(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_snapshot_times(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InitRegion.snapshot_times)
}

// optional bool is_learner = 5;
inline bool InitRegion::_internal_has_is_learner() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InitRegion::has_is_learner() const {
  return _internal_has_is_learner();
}
inline void InitRegion::clear_is_learner() {
  is_learner_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool InitRegion::_internal_is_learner() const {
  return is_learner_;
}
inline bool InitRegion::is_learner() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InitRegion.is_learner)
  return _internal_is_learner();
}
inline void InitRegion::_internal_set_is_learner(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_learner_ = value;
}
inline void InitRegion::set_is_learner(bool value) {
  _internal_set_is_learner(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InitRegion.is_learner)
}

// -------------------------------------------------------------------

// GetAppliedIndex

// required int64 region_id = 1;
inline bool GetAppliedIndex::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetAppliedIndex::has_region_id() const {
  return _internal_has_region_id();
}
inline void GetAppliedIndex::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetAppliedIndex::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetAppliedIndex::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.GetAppliedIndex.region_id)
  return _internal_region_id();
}
inline void GetAppliedIndex::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  region_id_ = value;
}
inline void GetAppliedIndex::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.GetAppliedIndex.region_id)
}

// optional bool use_read_idx = 2;
inline bool GetAppliedIndex::_internal_has_use_read_idx() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetAppliedIndex::has_use_read_idx() const {
  return _internal_has_use_read_idx();
}
inline void GetAppliedIndex::clear_use_read_idx() {
  use_read_idx_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool GetAppliedIndex::_internal_use_read_idx() const {
  return use_read_idx_;
}
inline bool GetAppliedIndex::use_read_idx() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.GetAppliedIndex.use_read_idx)
  return _internal_use_read_idx();
}
inline void GetAppliedIndex::_internal_set_use_read_idx(bool value) {
  _has_bits_[0] |= 0x00000002u;
  use_read_idx_ = value;
}
inline void GetAppliedIndex::set_use_read_idx(bool value) {
  _internal_set_use_read_idx(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.GetAppliedIndex.use_read_idx)
}

// optional bool use_raft_log_index = 3;
inline bool GetAppliedIndex::_internal_has_use_raft_log_index() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetAppliedIndex::has_use_raft_log_index() const {
  return _internal_has_use_raft_log_index();
}
inline void GetAppliedIndex::clear_use_raft_log_index() {
  use_raft_log_index_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool GetAppliedIndex::_internal_use_raft_log_index() const {
  return use_raft_log_index_;
}
inline bool GetAppliedIndex::use_raft_log_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.GetAppliedIndex.use_raft_log_index)
  return _internal_use_raft_log_index();
}
inline void GetAppliedIndex::_internal_set_use_raft_log_index(bool value) {
  _has_bits_[0] |= 0x00000004u;
  use_raft_log_index_ = value;
}
inline void GetAppliedIndex::set_use_raft_log_index(bool value) {
  _internal_set_use_raft_log_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.GetAppliedIndex.use_raft_log_index)
}

// -------------------------------------------------------------------

// RemoveRegion

// required int64 region_id = 1;
inline bool RemoveRegion::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RemoveRegion::has_region_id() const {
  return _internal_has_region_id();
}
inline void RemoveRegion::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RemoveRegion::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RemoveRegion::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RemoveRegion.region_id)
  return _internal_region_id();
}
inline void RemoveRegion::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  region_id_ = value;
}
inline void RemoveRegion::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RemoveRegion.region_id)
}

// optional bool force = 2;
inline bool RemoveRegion::_internal_has_force() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RemoveRegion::has_force() const {
  return _internal_has_force();
}
inline void RemoveRegion::clear_force() {
  force_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool RemoveRegion::_internal_force() const {
  return force_;
}
inline bool RemoveRegion::force() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RemoveRegion.force)
  return _internal_force();
}
inline void RemoveRegion::_internal_set_force(bool value) {
  _has_bits_[0] |= 0x00000002u;
  force_ = value;
}
inline void RemoveRegion::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RemoveRegion.force)
}

// optional bool need_delay_drop = 3;
inline bool RemoveRegion::_internal_has_need_delay_drop() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RemoveRegion::has_need_delay_drop() const {
  return _internal_has_need_delay_drop();
}
inline void RemoveRegion::clear_need_delay_drop() {
  need_delay_drop_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool RemoveRegion::_internal_need_delay_drop() const {
  return need_delay_drop_;
}
inline bool RemoveRegion::need_delay_drop() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RemoveRegion.need_delay_drop)
  return _internal_need_delay_drop();
}
inline void RemoveRegion::_internal_set_need_delay_drop(bool value) {
  _has_bits_[0] |= 0x00000004u;
  need_delay_drop_ = value;
}
inline void RemoveRegion::set_need_delay_drop(bool value) {
  _internal_set_need_delay_drop(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RemoveRegion.need_delay_drop)
}

// -------------------------------------------------------------------

// RegionIds

// repeated int64 region_ids = 1;
inline int RegionIds::_internal_region_ids_size() const {
  return region_ids_.size();
}
inline int RegionIds::region_ids_size() const {
  return _internal_region_ids_size();
}
inline void RegionIds::clear_region_ids() {
  region_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIds::_internal_region_ids(int index) const {
  return region_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIds::region_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIds.region_ids)
  return _internal_region_ids(index);
}
inline void RegionIds::set_region_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  region_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIds.region_ids)
}
inline void RegionIds::_internal_add_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  region_ids_.Add(value);
}
inline void RegionIds::add_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_region_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionIds.region_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
RegionIds::_internal_region_ids() const {
  return region_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
RegionIds::region_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RegionIds.region_ids)
  return _internal_region_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
RegionIds::_internal_mutable_region_ids() {
  return &region_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
RegionIds::mutable_region_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RegionIds.region_ids)
  return _internal_mutable_region_ids();
}

// optional bool compact_raft_log = 2;
inline bool RegionIds::_internal_has_compact_raft_log() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegionIds::has_compact_raft_log() const {
  return _internal_has_compact_raft_log();
}
inline void RegionIds::clear_compact_raft_log() {
  compact_raft_log_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool RegionIds::_internal_compact_raft_log() const {
  return compact_raft_log_;
}
inline bool RegionIds::compact_raft_log() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIds.compact_raft_log)
  return _internal_compact_raft_log();
}
inline void RegionIds::_internal_set_compact_raft_log(bool value) {
  _has_bits_[0] |= 0x00000004u;
  compact_raft_log_ = value;
}
inline void RegionIds::set_compact_raft_log(bool value) {
  _internal_set_compact_raft_log(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIds.compact_raft_log)
}

// optional int64 table_id = 3;
inline bool RegionIds::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegionIds::has_table_id() const {
  return _internal_has_table_id();
}
inline void RegionIds::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIds::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIds::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIds.table_id)
  return _internal_table_id();
}
inline void RegionIds::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  table_id_ = value;
}
inline void RegionIds::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIds.table_id)
}

// optional int32 compact_type = 4;
inline bool RegionIds::_internal_has_compact_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionIds::has_compact_type() const {
  return _internal_has_compact_type();
}
inline void RegionIds::clear_compact_type() {
  compact_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RegionIds::_internal_compact_type() const {
  return compact_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RegionIds::compact_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIds.compact_type)
  return _internal_compact_type();
}
inline void RegionIds::_internal_set_compact_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  compact_type_ = value;
}
inline void RegionIds::set_compact_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_compact_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIds.compact_type)
}

// optional bool clear_all_txns = 5;
inline bool RegionIds::_internal_has_clear_all_txns() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RegionIds::has_clear_all_txns() const {
  return _internal_has_clear_all_txns();
}
inline void RegionIds::clear_clear_all_txns() {
  clear_all_txns_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool RegionIds::_internal_clear_all_txns() const {
  return clear_all_txns_;
}
inline bool RegionIds::clear_all_txns() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIds.clear_all_txns)
  return _internal_clear_all_txns();
}
inline void RegionIds::_internal_set_clear_all_txns(bool value) {
  _has_bits_[0] |= 0x00000008u;
  clear_all_txns_ = value;
}
inline void RegionIds::set_clear_all_txns(bool value) {
  _internal_set_clear_all_txns(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIds.clear_all_txns)
}

// optional int64 txn_timeout = 6;
inline bool RegionIds::_internal_has_txn_timeout() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RegionIds::has_txn_timeout() const {
  return _internal_has_txn_timeout();
}
inline void RegionIds::clear_txn_timeout() {
  txn_timeout_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIds::_internal_txn_timeout() const {
  return txn_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIds::txn_timeout() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIds.txn_timeout)
  return _internal_txn_timeout();
}
inline void RegionIds::_internal_set_txn_timeout(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  txn_timeout_ = value;
}
inline void RegionIds::set_txn_timeout(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_txn_timeout(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIds.txn_timeout)
}

// optional bool query_apply_index = 7;
inline bool RegionIds::_internal_has_query_apply_index() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RegionIds::has_query_apply_index() const {
  return _internal_has_query_apply_index();
}
inline void RegionIds::clear_query_apply_index() {
  query_apply_index_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool RegionIds::_internal_query_apply_index() const {
  return query_apply_index_;
}
inline bool RegionIds::query_apply_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIds.query_apply_index)
  return _internal_query_apply_index();
}
inline void RegionIds::_internal_set_query_apply_index(bool value) {
  _has_bits_[0] |= 0x00000010u;
  query_apply_index_ = value;
}
inline void RegionIds::set_query_apply_index(bool value) {
  _internal_set_query_apply_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIds.query_apply_index)
}

// repeated int64 userids = 8;
inline int RegionIds::_internal_userids_size() const {
  return userids_.size();
}
inline int RegionIds::userids_size() const {
  return _internal_userids_size();
}
inline void RegionIds::clear_userids() {
  userids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIds::_internal_userids(int index) const {
  return userids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionIds::userids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIds.userids)
  return _internal_userids(index);
}
inline void RegionIds::set_userids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  userids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIds.userids)
}
inline void RegionIds::_internal_add_userids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  userids_.Add(value);
}
inline void RegionIds::add_userids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_userids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionIds.userids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
RegionIds::_internal_userids() const {
  return userids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
RegionIds::userids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RegionIds.userids)
  return _internal_userids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
RegionIds::_internal_mutable_userids() {
  return &userids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
RegionIds::mutable_userids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RegionIds.userids)
  return _internal_mutable_userids();
}

// optional bool query_all_afs_file = 9;
inline bool RegionIds::_internal_has_query_all_afs_file() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RegionIds::has_query_all_afs_file() const {
  return _internal_has_query_all_afs_file();
}
inline void RegionIds::clear_query_all_afs_file() {
  query_all_afs_file_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool RegionIds::_internal_query_all_afs_file() const {
  return query_all_afs_file_;
}
inline bool RegionIds::query_all_afs_file() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIds.query_all_afs_file)
  return _internal_query_all_afs_file();
}
inline void RegionIds::_internal_set_query_all_afs_file(bool value) {
  _has_bits_[0] |= 0x00000020u;
  query_all_afs_file_ = value;
}
inline void RegionIds::set_query_all_afs_file(bool value) {
  _internal_set_query_all_afs_file(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIds.query_all_afs_file)
}

// optional bool query_olap_keypoint = 10;
inline bool RegionIds::_internal_has_query_olap_keypoint() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool RegionIds::has_query_olap_keypoint() const {
  return _internal_has_query_olap_keypoint();
}
inline void RegionIds::clear_query_olap_keypoint() {
  query_olap_keypoint_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool RegionIds::_internal_query_olap_keypoint() const {
  return query_olap_keypoint_;
}
inline bool RegionIds::query_olap_keypoint() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionIds.query_olap_keypoint)
  return _internal_query_olap_keypoint();
}
inline void RegionIds::_internal_set_query_olap_keypoint(bool value) {
  _has_bits_[0] |= 0x00000080u;
  query_olap_keypoint_ = value;
}
inline void RegionIds::set_query_olap_keypoint(bool value) {
  _internal_set_query_olap_keypoint(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionIds.query_olap_keypoint)
}

// -------------------------------------------------------------------

// BackUpReq

// -------------------------------------------------------------------

// BackUpRes

// -------------------------------------------------------------------

// BackupRequest

// required int64 region_id = 1;
inline bool BackupRequest::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BackupRequest::has_region_id() const {
  return _internal_has_region_id();
}
inline void BackupRequest::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BackupRequest::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BackupRequest::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BackupRequest.region_id)
  return _internal_region_id();
}
inline void BackupRequest::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  region_id_ = value;
}
inline void BackupRequest::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BackupRequest.region_id)
}

// optional int64 log_index = 2;
inline bool BackupRequest::_internal_has_log_index() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BackupRequest::has_log_index() const {
  return _internal_has_log_index();
}
inline void BackupRequest::clear_log_index() {
  log_index_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BackupRequest::_internal_log_index() const {
  return log_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BackupRequest::log_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BackupRequest.log_index)
  return _internal_log_index();
}
inline void BackupRequest::_internal_set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  log_index_ = value;
}
inline void BackupRequest::set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_log_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BackupRequest.log_index)
}

// optional .baikaldb.pb.BackupOp backup_op = 3;
inline bool BackupRequest::_internal_has_backup_op() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BackupRequest::has_backup_op() const {
  return _internal_has_backup_op();
}
inline void BackupRequest::clear_backup_op() {
  backup_op_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::baikaldb::pb::BackupOp BackupRequest::_internal_backup_op() const {
  return static_cast< ::baikaldb::pb::BackupOp >(backup_op_);
}
inline ::baikaldb::pb::BackupOp BackupRequest::backup_op() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BackupRequest.backup_op)
  return _internal_backup_op();
}
inline void BackupRequest::_internal_set_backup_op(::baikaldb::pb::BackupOp value) {
  assert(::baikaldb::pb::BackupOp_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  backup_op_ = value;
}
inline void BackupRequest::set_backup_op(::baikaldb::pb::BackupOp value) {
  _internal_set_backup_op(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BackupRequest.backup_op)
}

// optional bool ingest_store_latest_sst = 4;
inline bool BackupRequest::_internal_has_ingest_store_latest_sst() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BackupRequest::has_ingest_store_latest_sst() const {
  return _internal_has_ingest_store_latest_sst();
}
inline void BackupRequest::clear_ingest_store_latest_sst() {
  ingest_store_latest_sst_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool BackupRequest::_internal_ingest_store_latest_sst() const {
  return ingest_store_latest_sst_;
}
inline bool BackupRequest::ingest_store_latest_sst() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BackupRequest.ingest_store_latest_sst)
  return _internal_ingest_store_latest_sst();
}
inline void BackupRequest::_internal_set_ingest_store_latest_sst(bool value) {
  _has_bits_[0] |= 0x00000008u;
  ingest_store_latest_sst_ = value;
}
inline void BackupRequest::set_ingest_store_latest_sst(bool value) {
  _internal_set_ingest_store_latest_sst(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BackupRequest.ingest_store_latest_sst)
}

// optional int64 data_sst_to_process_size = 5;
inline bool BackupRequest::_internal_has_data_sst_to_process_size() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BackupRequest::has_data_sst_to_process_size() const {
  return _internal_has_data_sst_to_process_size();
}
inline void BackupRequest::clear_data_sst_to_process_size() {
  data_sst_to_process_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BackupRequest::_internal_data_sst_to_process_size() const {
  return data_sst_to_process_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BackupRequest::data_sst_to_process_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BackupRequest.data_sst_to_process_size)
  return _internal_data_sst_to_process_size();
}
inline void BackupRequest::_internal_set_data_sst_to_process_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  data_sst_to_process_size_ = value;
}
inline void BackupRequest::set_data_sst_to_process_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_data_sst_to_process_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BackupRequest.data_sst_to_process_size)
}

// optional int64 row_size = 6;
inline bool BackupRequest::_internal_has_row_size() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BackupRequest::has_row_size() const {
  return _internal_has_row_size();
}
inline void BackupRequest::clear_row_size() {
  row_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BackupRequest::_internal_row_size() const {
  return row_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BackupRequest::row_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BackupRequest.row_size)
  return _internal_row_size();
}
inline void BackupRequest::_internal_set_row_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  row_size_ = value;
}
inline void BackupRequest::set_row_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_row_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BackupRequest.row_size)
}

// optional uint64 streaming_id = 7;
inline bool BackupRequest::_internal_has_streaming_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BackupRequest::has_streaming_id() const {
  return _internal_has_streaming_id();
}
inline void BackupRequest::clear_streaming_id() {
  streaming_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BackupRequest::_internal_streaming_id() const {
  return streaming_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BackupRequest::streaming_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BackupRequest.streaming_id)
  return _internal_streaming_id();
}
inline void BackupRequest::_internal_set_streaming_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  streaming_id_ = value;
}
inline void BackupRequest::set_streaming_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_streaming_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BackupRequest.streaming_id)
}

// -------------------------------------------------------------------

// BackupResponse

// optional int64 log_index = 1;
inline bool BackupResponse::_internal_has_log_index() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BackupResponse::has_log_index() const {
  return _internal_has_log_index();
}
inline void BackupResponse::clear_log_index() {
  log_index_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BackupResponse::_internal_log_index() const {
  return log_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BackupResponse::log_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BackupResponse.log_index)
  return _internal_log_index();
}
inline void BackupResponse::_internal_set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  log_index_ = value;
}
inline void BackupResponse::set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_log_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BackupResponse.log_index)
}

// optional .baikaldb.pb.ErrCode errcode = 2;
inline bool BackupResponse::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BackupResponse::has_errcode() const {
  return _internal_has_errcode();
}
inline void BackupResponse::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::baikaldb::pb::ErrCode BackupResponse::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::ErrCode >(errcode_);
}
inline ::baikaldb::pb::ErrCode BackupResponse::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BackupResponse.errcode)
  return _internal_errcode();
}
inline void BackupResponse::_internal_set_errcode(::baikaldb::pb::ErrCode value) {
  assert(::baikaldb::pb::ErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  errcode_ = value;
}
inline void BackupResponse::set_errcode(::baikaldb::pb::ErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BackupResponse.errcode)
}

// optional string leader = 3;
inline bool BackupResponse::_internal_has_leader() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BackupResponse::has_leader() const {
  return _internal_has_leader();
}
inline void BackupResponse::clear_leader() {
  leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BackupResponse::leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BackupResponse.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BackupResponse::set_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BackupResponse.leader)
}
inline std::string* BackupResponse::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BackupResponse.leader)
  return _s;
}
inline const std::string& BackupResponse::_internal_leader() const {
  return leader_.Get();
}
inline void BackupResponse::_internal_set_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BackupResponse::_internal_mutable_leader() {
  _has_bits_[0] |= 0x00000001u;
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BackupResponse::release_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BackupResponse.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BackupResponse::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BackupResponse.leader)
}

// repeated string peers = 4;
inline int BackupResponse::_internal_peers_size() const {
  return peers_.size();
}
inline int BackupResponse::peers_size() const {
  return _internal_peers_size();
}
inline void BackupResponse::clear_peers() {
  peers_.Clear();
}
inline std::string* BackupResponse::add_peers() {
  std::string* _s = _internal_add_peers();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.BackupResponse.peers)
  return _s;
}
inline const std::string& BackupResponse::_internal_peers(int index) const {
  return peers_.Get(index);
}
inline const std::string& BackupResponse::peers(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BackupResponse.peers)
  return _internal_peers(index);
}
inline std::string* BackupResponse::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BackupResponse.peers)
  return peers_.Mutable(index);
}
inline void BackupResponse::set_peers(int index, const std::string& value) {
  peers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BackupResponse.peers)
}
inline void BackupResponse::set_peers(int index, std::string&& value) {
  peers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.BackupResponse.peers)
}
inline void BackupResponse::set_peers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  peers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.BackupResponse.peers)
}
inline void BackupResponse::set_peers(int index, const char* value, size_t size) {
  peers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.BackupResponse.peers)
}
inline std::string* BackupResponse::_internal_add_peers() {
  return peers_.Add();
}
inline void BackupResponse::add_peers(const std::string& value) {
  peers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.BackupResponse.peers)
}
inline void BackupResponse::add_peers(std::string&& value) {
  peers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.BackupResponse.peers)
}
inline void BackupResponse::add_peers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  peers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.BackupResponse.peers)
}
inline void BackupResponse::add_peers(const char* value, size_t size) {
  peers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.BackupResponse.peers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BackupResponse::peers() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BackupResponse.peers)
  return peers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BackupResponse::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BackupResponse.peers)
  return &peers_;
}

// repeated string unstable_followers = 5;
inline int BackupResponse::_internal_unstable_followers_size() const {
  return unstable_followers_.size();
}
inline int BackupResponse::unstable_followers_size() const {
  return _internal_unstable_followers_size();
}
inline void BackupResponse::clear_unstable_followers() {
  unstable_followers_.Clear();
}
inline std::string* BackupResponse::add_unstable_followers() {
  std::string* _s = _internal_add_unstable_followers();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.BackupResponse.unstable_followers)
  return _s;
}
inline const std::string& BackupResponse::_internal_unstable_followers(int index) const {
  return unstable_followers_.Get(index);
}
inline const std::string& BackupResponse::unstable_followers(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BackupResponse.unstable_followers)
  return _internal_unstable_followers(index);
}
inline std::string* BackupResponse::mutable_unstable_followers(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BackupResponse.unstable_followers)
  return unstable_followers_.Mutable(index);
}
inline void BackupResponse::set_unstable_followers(int index, const std::string& value) {
  unstable_followers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BackupResponse.unstable_followers)
}
inline void BackupResponse::set_unstable_followers(int index, std::string&& value) {
  unstable_followers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.BackupResponse.unstable_followers)
}
inline void BackupResponse::set_unstable_followers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  unstable_followers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.BackupResponse.unstable_followers)
}
inline void BackupResponse::set_unstable_followers(int index, const char* value, size_t size) {
  unstable_followers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.BackupResponse.unstable_followers)
}
inline std::string* BackupResponse::_internal_add_unstable_followers() {
  return unstable_followers_.Add();
}
inline void BackupResponse::add_unstable_followers(const std::string& value) {
  unstable_followers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.BackupResponse.unstable_followers)
}
inline void BackupResponse::add_unstable_followers(std::string&& value) {
  unstable_followers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.BackupResponse.unstable_followers)
}
inline void BackupResponse::add_unstable_followers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  unstable_followers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.BackupResponse.unstable_followers)
}
inline void BackupResponse::add_unstable_followers(const char* value, size_t size) {
  unstable_followers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.BackupResponse.unstable_followers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BackupResponse::unstable_followers() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BackupResponse.unstable_followers)
  return unstable_followers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BackupResponse::mutable_unstable_followers() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BackupResponse.unstable_followers)
  return &unstable_followers_;
}

// optional uint64 streaming_id = 6;
inline bool BackupResponse::_internal_has_streaming_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BackupResponse::has_streaming_id() const {
  return _internal_has_streaming_id();
}
inline void BackupResponse::clear_streaming_id() {
  streaming_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BackupResponse::_internal_streaming_id() const {
  return streaming_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BackupResponse::streaming_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BackupResponse.streaming_id)
  return _internal_streaming_id();
}
inline void BackupResponse::_internal_set_streaming_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  streaming_id_ = value;
}
inline void BackupResponse::set_streaming_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_streaming_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BackupResponse.streaming_id)
}

// optional .baikaldb.pb.StreamState streaming_state = 7;
inline bool BackupResponse::_internal_has_streaming_state() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BackupResponse::has_streaming_state() const {
  return _internal_has_streaming_state();
}
inline void BackupResponse::clear_streaming_state() {
  streaming_state_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::baikaldb::pb::StreamState BackupResponse::_internal_streaming_state() const {
  return static_cast< ::baikaldb::pb::StreamState >(streaming_state_);
}
inline ::baikaldb::pb::StreamState BackupResponse::streaming_state() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BackupResponse.streaming_state)
  return _internal_streaming_state();
}
inline void BackupResponse::_internal_set_streaming_state(::baikaldb::pb::StreamState value) {
  assert(::baikaldb::pb::StreamState_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  streaming_state_ = value;
}
inline void BackupResponse::set_streaming_state(::baikaldb::pb::StreamState value) {
  _internal_set_streaming_state(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BackupResponse.streaming_state)
}

// -------------------------------------------------------------------

// HealthCheck

// -------------------------------------------------------------------

// OlapRegionIndexInfo

// required int64 index_id = 1;
inline bool OlapRegionIndexInfo::_internal_has_index_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OlapRegionIndexInfo::has_index_id() const {
  return _internal_has_index_id();
}
inline void OlapRegionIndexInfo::clear_index_id() {
  index_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OlapRegionIndexInfo::_internal_index_id() const {
  return index_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OlapRegionIndexInfo::index_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OlapRegionIndexInfo.index_id)
  return _internal_index_id();
}
inline void OlapRegionIndexInfo::_internal_set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  index_id_ = value;
}
inline void OlapRegionIndexInfo::set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_index_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OlapRegionIndexInfo.index_id)
}

// repeated string external_path = 2;
inline int OlapRegionIndexInfo::_internal_external_path_size() const {
  return external_path_.size();
}
inline int OlapRegionIndexInfo::external_path_size() const {
  return _internal_external_path_size();
}
inline void OlapRegionIndexInfo::clear_external_path() {
  external_path_.Clear();
}
inline std::string* OlapRegionIndexInfo::add_external_path() {
  std::string* _s = _internal_add_external_path();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.OlapRegionIndexInfo.external_path)
  return _s;
}
inline const std::string& OlapRegionIndexInfo::_internal_external_path(int index) const {
  return external_path_.Get(index);
}
inline const std::string& OlapRegionIndexInfo::external_path(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OlapRegionIndexInfo.external_path)
  return _internal_external_path(index);
}
inline std::string* OlapRegionIndexInfo::mutable_external_path(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OlapRegionIndexInfo.external_path)
  return external_path_.Mutable(index);
}
inline void OlapRegionIndexInfo::set_external_path(int index, const std::string& value) {
  external_path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OlapRegionIndexInfo.external_path)
}
inline void OlapRegionIndexInfo::set_external_path(int index, std::string&& value) {
  external_path_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.OlapRegionIndexInfo.external_path)
}
inline void OlapRegionIndexInfo::set_external_path(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  external_path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.OlapRegionIndexInfo.external_path)
}
inline void OlapRegionIndexInfo::set_external_path(int index, const char* value, size_t size) {
  external_path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.OlapRegionIndexInfo.external_path)
}
inline std::string* OlapRegionIndexInfo::_internal_add_external_path() {
  return external_path_.Add();
}
inline void OlapRegionIndexInfo::add_external_path(const std::string& value) {
  external_path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.OlapRegionIndexInfo.external_path)
}
inline void OlapRegionIndexInfo::add_external_path(std::string&& value) {
  external_path_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.OlapRegionIndexInfo.external_path)
}
inline void OlapRegionIndexInfo::add_external_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  external_path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.OlapRegionIndexInfo.external_path)
}
inline void OlapRegionIndexInfo::add_external_path(const char* value, size_t size) {
  external_path_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.OlapRegionIndexInfo.external_path)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OlapRegionIndexInfo::external_path() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.OlapRegionIndexInfo.external_path)
  return external_path_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OlapRegionIndexInfo::mutable_external_path() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.OlapRegionIndexInfo.external_path)
  return &external_path_;
}

// optional .baikaldb.pb.OlapRegionStat state = 3;
inline bool OlapRegionIndexInfo::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OlapRegionIndexInfo::has_state() const {
  return _internal_has_state();
}
inline void OlapRegionIndexInfo::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::baikaldb::pb::OlapRegionStat OlapRegionIndexInfo::_internal_state() const {
  return static_cast< ::baikaldb::pb::OlapRegionStat >(state_);
}
inline ::baikaldb::pb::OlapRegionStat OlapRegionIndexInfo::state() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OlapRegionIndexInfo.state)
  return _internal_state();
}
inline void OlapRegionIndexInfo::_internal_set_state(::baikaldb::pb::OlapRegionStat value) {
  assert(::baikaldb::pb::OlapRegionStat_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  state_ = value;
}
inline void OlapRegionIndexInfo::set_state(::baikaldb::pb::OlapRegionStat value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OlapRegionIndexInfo.state)
}

// -------------------------------------------------------------------

// OlapRegionInfo

// required .baikaldb.pb.OlapRegionStat state = 1 [default = OLAP_ACTIVE];
inline bool OlapRegionInfo::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OlapRegionInfo::has_state() const {
  return _internal_has_state();
}
inline void OlapRegionInfo::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::baikaldb::pb::OlapRegionStat OlapRegionInfo::_internal_state() const {
  return static_cast< ::baikaldb::pb::OlapRegionStat >(state_);
}
inline ::baikaldb::pb::OlapRegionStat OlapRegionInfo::state() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OlapRegionInfo.state)
  return _internal_state();
}
inline void OlapRegionInfo::_internal_set_state(::baikaldb::pb::OlapRegionStat value) {
  assert(::baikaldb::pb::OlapRegionStat_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  state_ = value;
}
inline void OlapRegionInfo::set_state(::baikaldb::pb::OlapRegionStat value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OlapRegionInfo.state)
}

// optional uint64 state_time = 2;
inline bool OlapRegionInfo::_internal_has_state_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OlapRegionInfo::has_state_time() const {
  return _internal_has_state_time();
}
inline void OlapRegionInfo::clear_state_time() {
  state_time_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OlapRegionInfo::_internal_state_time() const {
  return state_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OlapRegionInfo::state_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OlapRegionInfo.state_time)
  return _internal_state_time();
}
inline void OlapRegionInfo::_internal_set_state_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  state_time_ = value;
}
inline void OlapRegionInfo::set_state_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_state_time(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OlapRegionInfo.state_time)
}

// repeated string external_full_path = 3;
inline int OlapRegionInfo::_internal_external_full_path_size() const {
  return external_full_path_.size();
}
inline int OlapRegionInfo::external_full_path_size() const {
  return _internal_external_full_path_size();
}
inline void OlapRegionInfo::clear_external_full_path() {
  external_full_path_.Clear();
}
inline std::string* OlapRegionInfo::add_external_full_path() {
  std::string* _s = _internal_add_external_full_path();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.OlapRegionInfo.external_full_path)
  return _s;
}
inline const std::string& OlapRegionInfo::_internal_external_full_path(int index) const {
  return external_full_path_.Get(index);
}
inline const std::string& OlapRegionInfo::external_full_path(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OlapRegionInfo.external_full_path)
  return _internal_external_full_path(index);
}
inline std::string* OlapRegionInfo::mutable_external_full_path(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OlapRegionInfo.external_full_path)
  return external_full_path_.Mutable(index);
}
inline void OlapRegionInfo::set_external_full_path(int index, const std::string& value) {
  external_full_path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OlapRegionInfo.external_full_path)
}
inline void OlapRegionInfo::set_external_full_path(int index, std::string&& value) {
  external_full_path_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.OlapRegionInfo.external_full_path)
}
inline void OlapRegionInfo::set_external_full_path(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  external_full_path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.OlapRegionInfo.external_full_path)
}
inline void OlapRegionInfo::set_external_full_path(int index, const char* value, size_t size) {
  external_full_path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.OlapRegionInfo.external_full_path)
}
inline std::string* OlapRegionInfo::_internal_add_external_full_path() {
  return external_full_path_.Add();
}
inline void OlapRegionInfo::add_external_full_path(const std::string& value) {
  external_full_path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.OlapRegionInfo.external_full_path)
}
inline void OlapRegionInfo::add_external_full_path(std::string&& value) {
  external_full_path_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.OlapRegionInfo.external_full_path)
}
inline void OlapRegionInfo::add_external_full_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  external_full_path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.OlapRegionInfo.external_full_path)
}
inline void OlapRegionInfo::add_external_full_path(const char* value, size_t size) {
  external_full_path_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.OlapRegionInfo.external_full_path)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OlapRegionInfo::external_full_path() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.OlapRegionInfo.external_full_path)
  return external_full_path_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OlapRegionInfo::mutable_external_full_path() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.OlapRegionInfo.external_full_path)
  return &external_full_path_;
}

// repeated .baikaldb.pb.OlapRegionIndexInfo olap_index_info_list = 4;
inline int OlapRegionInfo::_internal_olap_index_info_list_size() const {
  return olap_index_info_list_.size();
}
inline int OlapRegionInfo::olap_index_info_list_size() const {
  return _internal_olap_index_info_list_size();
}
inline void OlapRegionInfo::clear_olap_index_info_list() {
  olap_index_info_list_.Clear();
}
inline ::baikaldb::pb::OlapRegionIndexInfo* OlapRegionInfo::mutable_olap_index_info_list(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OlapRegionInfo.olap_index_info_list)
  return olap_index_info_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::OlapRegionIndexInfo >*
OlapRegionInfo::mutable_olap_index_info_list() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.OlapRegionInfo.olap_index_info_list)
  return &olap_index_info_list_;
}
inline const ::baikaldb::pb::OlapRegionIndexInfo& OlapRegionInfo::_internal_olap_index_info_list(int index) const {
  return olap_index_info_list_.Get(index);
}
inline const ::baikaldb::pb::OlapRegionIndexInfo& OlapRegionInfo::olap_index_info_list(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OlapRegionInfo.olap_index_info_list)
  return _internal_olap_index_info_list(index);
}
inline ::baikaldb::pb::OlapRegionIndexInfo* OlapRegionInfo::_internal_add_olap_index_info_list() {
  return olap_index_info_list_.Add();
}
inline ::baikaldb::pb::OlapRegionIndexInfo* OlapRegionInfo::add_olap_index_info_list() {
  ::baikaldb::pb::OlapRegionIndexInfo* _add = _internal_add_olap_index_info_list();
  // @@protoc_insertion_point(field_add:baikaldb.pb.OlapRegionInfo.olap_index_info_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::OlapRegionIndexInfo >&
OlapRegionInfo::olap_index_info_list() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.OlapRegionInfo.olap_index_info_list)
  return olap_index_info_list_;
}

// optional .baikaldb.pb.OlapRegionIndexInfo new_olap_index_info = 5;
inline bool OlapRegionInfo::_internal_has_new_olap_index_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || new_olap_index_info_ != nullptr);
  return value;
}
inline bool OlapRegionInfo::has_new_olap_index_info() const {
  return _internal_has_new_olap_index_info();
}
inline void OlapRegionInfo::clear_new_olap_index_info() {
  if (new_olap_index_info_ != nullptr) new_olap_index_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::OlapRegionIndexInfo& OlapRegionInfo::_internal_new_olap_index_info() const {
  const ::baikaldb::pb::OlapRegionIndexInfo* p = new_olap_index_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::OlapRegionIndexInfo&>(
      ::baikaldb::pb::_OlapRegionIndexInfo_default_instance_);
}
inline const ::baikaldb::pb::OlapRegionIndexInfo& OlapRegionInfo::new_olap_index_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OlapRegionInfo.new_olap_index_info)
  return _internal_new_olap_index_info();
}
inline void OlapRegionInfo::unsafe_arena_set_allocated_new_olap_index_info(
    ::baikaldb::pb::OlapRegionIndexInfo* new_olap_index_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_olap_index_info_);
  }
  new_olap_index_info_ = new_olap_index_info;
  if (new_olap_index_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.OlapRegionInfo.new_olap_index_info)
}
inline ::baikaldb::pb::OlapRegionIndexInfo* OlapRegionInfo::release_new_olap_index_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::OlapRegionIndexInfo* temp = new_olap_index_info_;
  new_olap_index_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::OlapRegionIndexInfo* OlapRegionInfo::unsafe_arena_release_new_olap_index_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OlapRegionInfo.new_olap_index_info)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::OlapRegionIndexInfo* temp = new_olap_index_info_;
  new_olap_index_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::OlapRegionIndexInfo* OlapRegionInfo::_internal_mutable_new_olap_index_info() {
  _has_bits_[0] |= 0x00000001u;
  if (new_olap_index_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::OlapRegionIndexInfo>(GetArenaForAllocation());
    new_olap_index_info_ = p;
  }
  return new_olap_index_info_;
}
inline ::baikaldb::pb::OlapRegionIndexInfo* OlapRegionInfo::mutable_new_olap_index_info() {
  ::baikaldb::pb::OlapRegionIndexInfo* _msg = _internal_mutable_new_olap_index_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OlapRegionInfo.new_olap_index_info)
  return _msg;
}
inline void OlapRegionInfo::set_allocated_new_olap_index_info(::baikaldb::pb::OlapRegionIndexInfo* new_olap_index_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete new_olap_index_info_;
  }
  if (new_olap_index_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::OlapRegionIndexInfo>::GetOwningArena(new_olap_index_info);
    if (message_arena != submessage_arena) {
      new_olap_index_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_olap_index_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  new_olap_index_info_ = new_olap_index_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OlapRegionInfo.new_olap_index_info)
}

// -------------------------------------------------------------------

// RegionOfflineBinlogInfo

// required int64 oldest_ts = 1;
inline bool RegionOfflineBinlogInfo::_internal_has_oldest_ts() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegionOfflineBinlogInfo::has_oldest_ts() const {
  return _internal_has_oldest_ts();
}
inline void RegionOfflineBinlogInfo::clear_oldest_ts() {
  oldest_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionOfflineBinlogInfo::_internal_oldest_ts() const {
  return oldest_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionOfflineBinlogInfo::oldest_ts() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionOfflineBinlogInfo.oldest_ts)
  return _internal_oldest_ts();
}
inline void RegionOfflineBinlogInfo::_internal_set_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  oldest_ts_ = value;
}
inline void RegionOfflineBinlogInfo::set_oldest_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_oldest_ts(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionOfflineBinlogInfo.oldest_ts)
}

// required int64 newest_ts = 2;
inline bool RegionOfflineBinlogInfo::_internal_has_newest_ts() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionOfflineBinlogInfo::has_newest_ts() const {
  return _internal_has_newest_ts();
}
inline void RegionOfflineBinlogInfo::clear_newest_ts() {
  newest_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionOfflineBinlogInfo::_internal_newest_ts() const {
  return newest_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionOfflineBinlogInfo::newest_ts() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionOfflineBinlogInfo.newest_ts)
  return _internal_newest_ts();
}
inline void RegionOfflineBinlogInfo::_internal_set_newest_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  newest_ts_ = value;
}
inline void RegionOfflineBinlogInfo::set_newest_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_newest_ts(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionOfflineBinlogInfo.newest_ts)
}

// optional int64 task_start_ts = 3;
inline bool RegionOfflineBinlogInfo::_internal_has_task_start_ts() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegionOfflineBinlogInfo::has_task_start_ts() const {
  return _internal_has_task_start_ts();
}
inline void RegionOfflineBinlogInfo::clear_task_start_ts() {
  task_start_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionOfflineBinlogInfo::_internal_task_start_ts() const {
  return task_start_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionOfflineBinlogInfo::task_start_ts() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionOfflineBinlogInfo.task_start_ts)
  return _internal_task_start_ts();
}
inline void RegionOfflineBinlogInfo::_internal_set_task_start_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  task_start_ts_ = value;
}
inline void RegionOfflineBinlogInfo::set_task_start_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_task_start_ts(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionOfflineBinlogInfo.task_start_ts)
}

// optional int64 task_end_ts = 4;
inline bool RegionOfflineBinlogInfo::_internal_has_task_end_ts() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RegionOfflineBinlogInfo::has_task_end_ts() const {
  return _internal_has_task_end_ts();
}
inline void RegionOfflineBinlogInfo::clear_task_end_ts() {
  task_end_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionOfflineBinlogInfo::_internal_task_end_ts() const {
  return task_end_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionOfflineBinlogInfo::task_end_ts() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionOfflineBinlogInfo.task_end_ts)
  return _internal_task_end_ts();
}
inline void RegionOfflineBinlogInfo::_internal_set_task_end_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  task_end_ts_ = value;
}
inline void RegionOfflineBinlogInfo::set_task_end_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_task_end_ts(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionOfflineBinlogInfo.task_end_ts)
}

// repeated string external_full_path = 5;
inline int RegionOfflineBinlogInfo::_internal_external_full_path_size() const {
  return external_full_path_.size();
}
inline int RegionOfflineBinlogInfo::external_full_path_size() const {
  return _internal_external_full_path_size();
}
inline void RegionOfflineBinlogInfo::clear_external_full_path() {
  external_full_path_.Clear();
}
inline std::string* RegionOfflineBinlogInfo::add_external_full_path() {
  std::string* _s = _internal_add_external_full_path();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.RegionOfflineBinlogInfo.external_full_path)
  return _s;
}
inline const std::string& RegionOfflineBinlogInfo::_internal_external_full_path(int index) const {
  return external_full_path_.Get(index);
}
inline const std::string& RegionOfflineBinlogInfo::external_full_path(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionOfflineBinlogInfo.external_full_path)
  return _internal_external_full_path(index);
}
inline std::string* RegionOfflineBinlogInfo::mutable_external_full_path(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionOfflineBinlogInfo.external_full_path)
  return external_full_path_.Mutable(index);
}
inline void RegionOfflineBinlogInfo::set_external_full_path(int index, const std::string& value) {
  external_full_path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionOfflineBinlogInfo.external_full_path)
}
inline void RegionOfflineBinlogInfo::set_external_full_path(int index, std::string&& value) {
  external_full_path_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionOfflineBinlogInfo.external_full_path)
}
inline void RegionOfflineBinlogInfo::set_external_full_path(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  external_full_path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.RegionOfflineBinlogInfo.external_full_path)
}
inline void RegionOfflineBinlogInfo::set_external_full_path(int index, const char* value, size_t size) {
  external_full_path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.RegionOfflineBinlogInfo.external_full_path)
}
inline std::string* RegionOfflineBinlogInfo::_internal_add_external_full_path() {
  return external_full_path_.Add();
}
inline void RegionOfflineBinlogInfo::add_external_full_path(const std::string& value) {
  external_full_path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionOfflineBinlogInfo.external_full_path)
}
inline void RegionOfflineBinlogInfo::add_external_full_path(std::string&& value) {
  external_full_path_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionOfflineBinlogInfo.external_full_path)
}
inline void RegionOfflineBinlogInfo::add_external_full_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  external_full_path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.RegionOfflineBinlogInfo.external_full_path)
}
inline void RegionOfflineBinlogInfo::add_external_full_path(const char* value, size_t size) {
  external_full_path_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.RegionOfflineBinlogInfo.external_full_path)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RegionOfflineBinlogInfo::external_full_path() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RegionOfflineBinlogInfo.external_full_path)
  return external_full_path_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RegionOfflineBinlogInfo::mutable_external_full_path() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RegionOfflineBinlogInfo.external_full_path)
  return &external_full_path_;
}

// -------------------------------------------------------------------

// CompactionFileRequest

// required .baikaldb.pb.CompactionOpType op_type = 1;
inline bool CompactionFileRequest::_internal_has_op_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CompactionFileRequest::has_op_type() const {
  return _internal_has_op_type();
}
inline void CompactionFileRequest::clear_op_type() {
  op_type_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::baikaldb::pb::CompactionOpType CompactionFileRequest::_internal_op_type() const {
  return static_cast< ::baikaldb::pb::CompactionOpType >(op_type_);
}
inline ::baikaldb::pb::CompactionOpType CompactionFileRequest::op_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CompactionFileRequest.op_type)
  return _internal_op_type();
}
inline void CompactionFileRequest::_internal_set_op_type(::baikaldb::pb::CompactionOpType value) {
  assert(::baikaldb::pb::CompactionOpType_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  op_type_ = value;
}
inline void CompactionFileRequest::set_op_type(::baikaldb::pb::CompactionOpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CompactionFileRequest.op_type)
}

// required string remote_compaction_id = 2;
inline bool CompactionFileRequest::_internal_has_remote_compaction_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CompactionFileRequest::has_remote_compaction_id() const {
  return _internal_has_remote_compaction_id();
}
inline void CompactionFileRequest::clear_remote_compaction_id() {
  remote_compaction_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CompactionFileRequest::remote_compaction_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CompactionFileRequest.remote_compaction_id)
  return _internal_remote_compaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompactionFileRequest::set_remote_compaction_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 remote_compaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.CompactionFileRequest.remote_compaction_id)
}
inline std::string* CompactionFileRequest::mutable_remote_compaction_id() {
  std::string* _s = _internal_mutable_remote_compaction_id();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.CompactionFileRequest.remote_compaction_id)
  return _s;
}
inline const std::string& CompactionFileRequest::_internal_remote_compaction_id() const {
  return remote_compaction_id_.Get();
}
inline void CompactionFileRequest::_internal_set_remote_compaction_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  remote_compaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CompactionFileRequest::_internal_mutable_remote_compaction_id() {
  _has_bits_[0] |= 0x00000001u;
  return remote_compaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CompactionFileRequest::release_remote_compaction_id() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.CompactionFileRequest.remote_compaction_id)
  if (!_internal_has_remote_compaction_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return remote_compaction_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CompactionFileRequest::set_allocated_remote_compaction_id(std::string* remote_compaction_id) {
  if (remote_compaction_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  remote_compaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remote_compaction_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.CompactionFileRequest.remote_compaction_id)
}

// optional string file_name = 3;
inline bool CompactionFileRequest::_internal_has_file_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CompactionFileRequest::has_file_name() const {
  return _internal_has_file_name();
}
inline void CompactionFileRequest::clear_file_name() {
  file_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CompactionFileRequest::file_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CompactionFileRequest.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompactionFileRequest::set_file_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.CompactionFileRequest.file_name)
}
inline std::string* CompactionFileRequest::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.CompactionFileRequest.file_name)
  return _s;
}
inline const std::string& CompactionFileRequest::_internal_file_name() const {
  return file_name_.Get();
}
inline void CompactionFileRequest::_internal_set_file_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CompactionFileRequest::_internal_mutable_file_name() {
  _has_bits_[0] |= 0x00000002u;
  return file_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CompactionFileRequest::release_file_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.CompactionFileRequest.file_name)
  if (!_internal_has_file_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return file_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CompactionFileRequest::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  file_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.CompactionFileRequest.file_name)
}

// optional uint64 offset = 4;
inline bool CompactionFileRequest::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CompactionFileRequest::has_offset() const {
  return _internal_has_offset();
}
inline void CompactionFileRequest::clear_offset() {
  offset_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CompactionFileRequest::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CompactionFileRequest::offset() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CompactionFileRequest.offset)
  return _internal_offset();
}
inline void CompactionFileRequest::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  offset_ = value;
}
inline void CompactionFileRequest::set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CompactionFileRequest.offset)
}

// optional uint32 count = 5;
inline bool CompactionFileRequest::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CompactionFileRequest::has_count() const {
  return _internal_has_count();
}
inline void CompactionFileRequest::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CompactionFileRequest::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CompactionFileRequest::count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CompactionFileRequest.count)
  return _internal_count();
}
inline void CompactionFileRequest::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  count_ = value;
}
inline void CompactionFileRequest::set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CompactionFileRequest.count)
}

// optional bytes data = 6;
inline bool CompactionFileRequest::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CompactionFileRequest::has_data() const {
  return _internal_has_data();
}
inline void CompactionFileRequest::clear_data() {
  data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CompactionFileRequest::data() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CompactionFileRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompactionFileRequest::set_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.CompactionFileRequest.data)
}
inline std::string* CompactionFileRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.CompactionFileRequest.data)
  return _s;
}
inline const std::string& CompactionFileRequest::_internal_data() const {
  return data_.Get();
}
inline void CompactionFileRequest::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CompactionFileRequest::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000004u;
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CompactionFileRequest::release_data() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.CompactionFileRequest.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CompactionFileRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.CompactionFileRequest.data)
}

// optional bool recursive = 7;
inline bool CompactionFileRequest::_internal_has_recursive() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CompactionFileRequest::has_recursive() const {
  return _internal_has_recursive();
}
inline void CompactionFileRequest::clear_recursive() {
  recursive_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CompactionFileRequest::_internal_recursive() const {
  return recursive_;
}
inline bool CompactionFileRequest::recursive() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CompactionFileRequest.recursive)
  return _internal_recursive();
}
inline void CompactionFileRequest::_internal_set_recursive(bool value) {
  _has_bits_[0] |= 0x00000020u;
  recursive_ = value;
}
inline void CompactionFileRequest::set_recursive(bool value) {
  _internal_set_recursive(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CompactionFileRequest.recursive)
}

// -------------------------------------------------------------------

// CompactionFileResponse

// required .baikaldb.pb.ErrCode errcode = 1;
inline bool CompactionFileResponse::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CompactionFileResponse::has_errcode() const {
  return _internal_has_errcode();
}
inline void CompactionFileResponse::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::baikaldb::pb::ErrCode CompactionFileResponse::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::ErrCode >(errcode_);
}
inline ::baikaldb::pb::ErrCode CompactionFileResponse::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CompactionFileResponse.errcode)
  return _internal_errcode();
}
inline void CompactionFileResponse::_internal_set_errcode(::baikaldb::pb::ErrCode value) {
  assert(::baikaldb::pb::ErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  errcode_ = value;
}
inline void CompactionFileResponse::set_errcode(::baikaldb::pb::ErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CompactionFileResponse.errcode)
}

// optional bytes data = 2;
inline bool CompactionFileResponse::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CompactionFileResponse::has_data() const {
  return _internal_has_data();
}
inline void CompactionFileResponse::clear_data() {
  data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CompactionFileResponse::data() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CompactionFileResponse.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompactionFileResponse::set_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.CompactionFileResponse.data)
}
inline std::string* CompactionFileResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.CompactionFileResponse.data)
  return _s;
}
inline const std::string& CompactionFileResponse::_internal_data() const {
  return data_.Get();
}
inline void CompactionFileResponse::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CompactionFileResponse::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CompactionFileResponse::release_data() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.CompactionFileResponse.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CompactionFileResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.CompactionFileResponse.data)
}

// repeated .baikaldb.pb.CompactionFileInfo file_info = 3;
inline int CompactionFileResponse::_internal_file_info_size() const {
  return file_info_.size();
}
inline int CompactionFileResponse::file_info_size() const {
  return _internal_file_info_size();
}
inline ::baikaldb::pb::CompactionFileInfo* CompactionFileResponse::mutable_file_info(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.CompactionFileResponse.file_info)
  return file_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CompactionFileInfo >*
CompactionFileResponse::mutable_file_info() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.CompactionFileResponse.file_info)
  return &file_info_;
}
inline const ::baikaldb::pb::CompactionFileInfo& CompactionFileResponse::_internal_file_info(int index) const {
  return file_info_.Get(index);
}
inline const ::baikaldb::pb::CompactionFileInfo& CompactionFileResponse::file_info(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CompactionFileResponse.file_info)
  return _internal_file_info(index);
}
inline ::baikaldb::pb::CompactionFileInfo* CompactionFileResponse::_internal_add_file_info() {
  return file_info_.Add();
}
inline ::baikaldb::pb::CompactionFileInfo* CompactionFileResponse::add_file_info() {
  ::baikaldb::pb::CompactionFileInfo* _add = _internal_add_file_info();
  // @@protoc_insertion_point(field_add:baikaldb.pb.CompactionFileResponse.file_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CompactionFileInfo >&
CompactionFileResponse::file_info() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.CompactionFileResponse.file_info)
  return file_info_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace baikaldb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::baikaldb::pb::RedisCmd> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::RedisCmd>() {
  return ::baikaldb::pb::RedisCmd_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::TxnState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::TxnState>() {
  return ::baikaldb::pb::TxnState_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::StatisticType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::StatisticType>() {
  return ::baikaldb::pb::StatisticType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::ExecuteType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::ExecuteType>() {
  return ::baikaldb::pb::ExecuteType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::BackupOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::BackupOp>() {
  return ::baikaldb::pb::BackupOp_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::OlapRegionStat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::OlapRegionStat>() {
  return ::baikaldb::pb::OlapRegionStat_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::CompactionOpType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::CompactionOpType>() {
  return ::baikaldb::pb::CompactionOpType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_store_2einterface_2eproto
