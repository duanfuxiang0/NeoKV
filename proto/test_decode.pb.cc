// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: test_decode.proto

#include "test_decode.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr TestMessage::TestMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : col8_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , col1_(0)
  , col2_(0)
  , col3_(0u)
  , col4_(0u)
  , col5_(int64_t{0})
  , col6_(int64_t{0})
  , col7_(uint64_t{0u}){}
struct TestMessageDefaultTypeInternal {
  constexpr TestMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TestMessageDefaultTypeInternal() {}
  union {
    TestMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TestMessageDefaultTypeInternal _TestMessage_default_instance_;
constexpr TestTupleRecord::TestTupleRecord(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : col14_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , col2_(int64_t{0})
  , col1_(0)
  , col3_(0u)
  , col4_(uint64_t{0u})
  , col6_(int64_t{0})
  , col5_(0)
  , col7_(0u)
  , col8_(uint64_t{0u})
  , col10_(int64_t{0})
  , col9_(0)
  , col11_(0)
  , col12_(0)
  , col13_(false){}
struct TestTupleRecordDefaultTypeInternal {
  constexpr TestTupleRecordDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TestTupleRecordDefaultTypeInternal() {}
  union {
    TestTupleRecord _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TestTupleRecordDefaultTypeInternal _TestTupleRecord_default_instance_;
constexpr Pg::Pg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : a_()
  , b_(0){}
struct PgDefaultTypeInternal {
  constexpr PgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PgDefaultTypeInternal() {}
  union {
    Pg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PgDefaultTypeInternal _Pg_default_instance_;
constexpr Packed::Packed(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : a_(){}
struct PackedDefaultTypeInternal {
  constexpr PackedDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PackedDefaultTypeInternal() {}
  union {
    Packed _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PackedDefaultTypeInternal _Packed_default_instance_;
constexpr Optional::Optional(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : a_(nullptr){}
struct OptionalDefaultTypeInternal {
  constexpr OptionalDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OptionalDefaultTypeInternal() {}
  union {
    Optional _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OptionalDefaultTypeInternal _Optional_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_test_5fdecode_2eproto[5];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_test_5fdecode_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_test_5fdecode_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_test_5fdecode_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::TestMessage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::TestMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TestMessage, col1_),
  PROTOBUF_FIELD_OFFSET(::TestMessage, col2_),
  PROTOBUF_FIELD_OFFSET(::TestMessage, col3_),
  PROTOBUF_FIELD_OFFSET(::TestMessage, col4_),
  PROTOBUF_FIELD_OFFSET(::TestMessage, col5_),
  PROTOBUF_FIELD_OFFSET(::TestMessage, col6_),
  PROTOBUF_FIELD_OFFSET(::TestMessage, col7_),
  PROTOBUF_FIELD_OFFSET(::TestMessage, col8_),
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  0,
  PROTOBUF_FIELD_OFFSET(::TestTupleRecord, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::TestTupleRecord, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TestTupleRecord, col1_),
  PROTOBUF_FIELD_OFFSET(::TestTupleRecord, col2_),
  PROTOBUF_FIELD_OFFSET(::TestTupleRecord, col3_),
  PROTOBUF_FIELD_OFFSET(::TestTupleRecord, col4_),
  PROTOBUF_FIELD_OFFSET(::TestTupleRecord, col5_),
  PROTOBUF_FIELD_OFFSET(::TestTupleRecord, col6_),
  PROTOBUF_FIELD_OFFSET(::TestTupleRecord, col7_),
  PROTOBUF_FIELD_OFFSET(::TestTupleRecord, col8_),
  PROTOBUF_FIELD_OFFSET(::TestTupleRecord, col9_),
  PROTOBUF_FIELD_OFFSET(::TestTupleRecord, col10_),
  PROTOBUF_FIELD_OFFSET(::TestTupleRecord, col11_),
  PROTOBUF_FIELD_OFFSET(::TestTupleRecord, col12_),
  PROTOBUF_FIELD_OFFSET(::TestTupleRecord, col13_),
  PROTOBUF_FIELD_OFFSET(::TestTupleRecord, col14_),
  2,
  1,
  3,
  4,
  6,
  5,
  7,
  8,
  10,
  9,
  11,
  12,
  13,
  0,
  PROTOBUF_FIELD_OFFSET(::Pg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Pg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Pg, a_),
  PROTOBUF_FIELD_OFFSET(::Pg, b_),
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Packed, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Packed, a_),
  PROTOBUF_FIELD_OFFSET(::Optional, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Optional, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Optional, a_),
  0,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 14, -1, sizeof(::TestMessage)},
  { 22, 42, -1, sizeof(::TestTupleRecord)},
  { 56, 64, -1, sizeof(::Pg)},
  { 66, -1, -1, sizeof(::Packed)},
  { 73, 80, -1, sizeof(::Optional)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_TestMessage_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_TestTupleRecord_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Pg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Packed_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Optional_default_instance_),
};

const char descriptor_table_protodef_test_5fdecode_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021test_decode.proto\"}\n\013TestMessage\022\014\n\004co"
  "l1\030\001 \001(\021\022\014\n\004col2\030\002 \001(\021\022\014\n\004col3\030\003 \001(\r\022\014\n\004"
  "col4\030\004 \001(\r\022\014\n\004col5\030\005 \001(\022\022\014\n\004col6\030\006 \001(\022\022\014"
  "\n\004col7\030\007 \001(\004\022\014\n\004col8\030\010 \001(\t\"\332\001\n\017TestTuple"
  "Record\022\014\n\004col1\030\001 \001(\021\022\014\n\004col2\030\002 \001(\022\022\014\n\004co"
  "l3\030\003 \001(\r\022\014\n\004col4\030\004 \001(\004\022\014\n\004col5\030\005 \001(\005\022\014\n\004"
  "col6\030\006 \001(\003\022\014\n\004col7\030\007 \001(\007\022\014\n\004col8\030\010 \001(\006\022\014"
  "\n\004col9\030\t \001(\017\022\r\n\005col10\030\n \001(\020\022\r\n\005col11\030\013 \001"
  "(\002\022\r\n\005col12\030\014 \001(\001\022\r\n\005col13\030\r \001(\010\022\r\n\005col1"
  "4\030\016 \001(\014\"\032\n\002Pg\022\t\n\001a\030\001 \003(\005\022\t\n\001b\030\002 \001(\005\"\030\n\006P"
  "acked\022\016\n\001a\030\001 \003(\0132\003.Pg\"\032\n\010Optional\022\016\n\001a\030\001"
  " \001(\0132\003.PgB\003\370\001\001"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_test_5fdecode_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_test_5fdecode_2eproto = {
  false, false, 454, descriptor_table_protodef_test_5fdecode_2eproto, "test_decode.proto", 
  &descriptor_table_test_5fdecode_2eproto_once, nullptr, 0, 5,
  schemas, file_default_instances, TableStruct_test_5fdecode_2eproto::offsets,
  file_level_metadata_test_5fdecode_2eproto, file_level_enum_descriptors_test_5fdecode_2eproto, file_level_service_descriptors_test_5fdecode_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_test_5fdecode_2eproto_getter() {
  return &descriptor_table_test_5fdecode_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_test_5fdecode_2eproto(&descriptor_table_test_5fdecode_2eproto);

// ===================================================================

class TestMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<TestMessage>()._has_bits_);
  static void set_has_col1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_col2(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_col3(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_col4(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_col5(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_col6(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_col7(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_col8(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

TestMessage::TestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:TestMessage)
}
TestMessage::TestMessage(const TestMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  col8_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_col8()) {
    col8_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_col8(), 
      GetArenaForAllocation());
  }
  ::memcpy(&col1_, &from.col1_,
    static_cast<size_t>(reinterpret_cast<char*>(&col7_) -
    reinterpret_cast<char*>(&col1_)) + sizeof(col7_));
  // @@protoc_insertion_point(copy_constructor:TestMessage)
}

void TestMessage::SharedCtor() {
col8_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&col1_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&col7_) -
    reinterpret_cast<char*>(&col1_)) + sizeof(col7_));
}

TestMessage::~TestMessage() {
  // @@protoc_insertion_point(destructor:TestMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TestMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  col8_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TestMessage::ArenaDtor(void* object) {
  TestMessage* _this = reinterpret_cast< TestMessage* >(object);
  (void)_this;
}
void TestMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TestMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TestMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:TestMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    col8_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&col1_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&col7_) -
        reinterpret_cast<char*>(&col1_)) + sizeof(col7_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TestMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sint32 col1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_col1(&has_bits);
          col1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 col2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_col2(&has_bits);
          col2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 col3 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_col3(&has_bits);
          col3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 col4 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_col4(&has_bits);
          col4_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint64 col5 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_col5(&has_bits);
          col5_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint64 col6 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_col6(&has_bits);
          col6_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 col7 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_col7(&has_bits);
          col7_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string col8 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          auto str = _internal_mutable_col8();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "TestMessage.col8");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TestMessage::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TestMessage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sint32 col1 = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(1, this->_internal_col1(), target);
  }

  // optional sint32 col2 = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(2, this->_internal_col2(), target);
  }

  // optional uint32 col3 = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_col3(), target);
  }

  // optional uint32 col4 = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_col4(), target);
  }

  // optional sint64 col5 = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(5, this->_internal_col5(), target);
  }

  // optional sint64 col6 = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(6, this->_internal_col6(), target);
  }

  // optional uint64 col7 = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(7, this->_internal_col7(), target);
  }

  // optional string col8 = 8;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_col8().data(), static_cast<int>(this->_internal_col8().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "TestMessage.col8");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_col8(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TestMessage)
  return target;
}

size_t TestMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TestMessage)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string col8 = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_col8());
    }

    // optional sint32 col1 = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32SizePlusOne(this->_internal_col1());
    }

    // optional sint32 col2 = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32SizePlusOne(this->_internal_col2());
    }

    // optional uint32 col3 = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_col3());
    }

    // optional uint32 col4 = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_col4());
    }

    // optional sint64 col5 = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt64SizePlusOne(this->_internal_col5());
    }

    // optional sint64 col6 = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt64SizePlusOne(this->_internal_col6());
    }

    // optional uint64 col7 = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_col7());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TestMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TestMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TestMessage::GetClassData() const { return &_class_data_; }

void TestMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TestMessage *>(to)->MergeFrom(
      static_cast<const TestMessage &>(from));
}


void TestMessage::MergeFrom(const TestMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TestMessage)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_col8(from._internal_col8());
    }
    if (cached_has_bits & 0x00000002u) {
      col1_ = from.col1_;
    }
    if (cached_has_bits & 0x00000004u) {
      col2_ = from.col2_;
    }
    if (cached_has_bits & 0x00000008u) {
      col3_ = from.col3_;
    }
    if (cached_has_bits & 0x00000010u) {
      col4_ = from.col4_;
    }
    if (cached_has_bits & 0x00000020u) {
      col5_ = from.col5_;
    }
    if (cached_has_bits & 0x00000040u) {
      col6_ = from.col6_;
    }
    if (cached_has_bits & 0x00000080u) {
      col7_ = from.col7_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TestMessage::CopyFrom(const TestMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TestMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TestMessage::IsInitialized() const {
  return true;
}

void TestMessage::InternalSwap(TestMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &col8_, lhs_arena,
      &other->col8_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TestMessage, col7_)
      + sizeof(TestMessage::col7_)
      - PROTOBUF_FIELD_OFFSET(TestMessage, col1_)>(
          reinterpret_cast<char*>(&col1_),
          reinterpret_cast<char*>(&other->col1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TestMessage::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_test_5fdecode_2eproto_getter, &descriptor_table_test_5fdecode_2eproto_once,
      file_level_metadata_test_5fdecode_2eproto[0]);
}

// ===================================================================

class TestTupleRecord::_Internal {
 public:
  using HasBits = decltype(std::declval<TestTupleRecord>()._has_bits_);
  static void set_has_col1(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_col2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_col3(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_col4(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_col5(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_col6(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_col7(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_col8(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_col9(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_col10(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_col11(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_col12(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_col13(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_col14(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

TestTupleRecord::TestTupleRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:TestTupleRecord)
}
TestTupleRecord::TestTupleRecord(const TestTupleRecord& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  col14_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_col14()) {
    col14_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_col14(), 
      GetArenaForAllocation());
  }
  ::memcpy(&col2_, &from.col2_,
    static_cast<size_t>(reinterpret_cast<char*>(&col13_) -
    reinterpret_cast<char*>(&col2_)) + sizeof(col13_));
  // @@protoc_insertion_point(copy_constructor:TestTupleRecord)
}

void TestTupleRecord::SharedCtor() {
col14_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&col2_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&col13_) -
    reinterpret_cast<char*>(&col2_)) + sizeof(col13_));
}

TestTupleRecord::~TestTupleRecord() {
  // @@protoc_insertion_point(destructor:TestTupleRecord)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TestTupleRecord::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  col14_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TestTupleRecord::ArenaDtor(void* object) {
  TestTupleRecord* _this = reinterpret_cast< TestTupleRecord* >(object);
  (void)_this;
}
void TestTupleRecord::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TestTupleRecord::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TestTupleRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:TestTupleRecord)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    col14_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&col2_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&col7_) -
        reinterpret_cast<char*>(&col2_)) + sizeof(col7_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&col8_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&col13_) -
        reinterpret_cast<char*>(&col8_)) + sizeof(col13_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TestTupleRecord::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sint32 col1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_col1(&has_bits);
          col1_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint64 col2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_col2(&has_bits);
          col2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 col3 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_col3(&has_bits);
          col3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 col4 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_col4(&has_bits);
          col4_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 col5 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_col5(&has_bits);
          col5_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 col6 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_col6(&has_bits);
          col6_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 col7 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_col7(&has_bits);
          col7_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint32);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 col8 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 65)) {
          _Internal::set_has_col8(&has_bits);
          col8_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else
          goto handle_unusual;
        continue;
      // optional sfixed32 col9 = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_col9(&has_bits);
          col9_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int32>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int32);
        } else
          goto handle_unusual;
        continue;
      // optional sfixed64 col10 = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 81)) {
          _Internal::set_has_col10(&has_bits);
          col10_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::int64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::int64);
        } else
          goto handle_unusual;
        continue;
      // optional float col11 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 93)) {
          _Internal::set_has_col11(&has_bits);
          col11_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional double col12 = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 97)) {
          _Internal::set_has_col12(&has_bits);
          col12_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional bool col13 = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_col13(&has_bits);
          col13_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes col14 = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          auto str = _internal_mutable_col14();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TestTupleRecord::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TestTupleRecord)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional sint32 col1 = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(1, this->_internal_col1(), target);
  }

  // optional sint64 col2 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(2, this->_internal_col2(), target);
  }

  // optional uint32 col3 = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_col3(), target);
  }

  // optional uint64 col4 = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_col4(), target);
  }

  // optional int32 col5 = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_col5(), target);
  }

  // optional int64 col6 = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_col6(), target);
  }

  // optional fixed32 col7 = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(7, this->_internal_col7(), target);
  }

  // optional fixed64 col8 = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(8, this->_internal_col8(), target);
  }

  // optional sfixed32 col9 = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed32ToArray(9, this->_internal_col9(), target);
  }

  // optional sfixed64 col10 = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSFixed64ToArray(10, this->_internal_col10(), target);
  }

  // optional float col11 = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_col11(), target);
  }

  // optional double col12 = 12;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(12, this->_internal_col12(), target);
  }

  // optional bool col13 = 13;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_col13(), target);
  }

  // optional bytes col14 = 14;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        14, this->_internal_col14(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TestTupleRecord)
  return target;
}

size_t TestTupleRecord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TestTupleRecord)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes col14 = 14;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_col14());
    }

    // optional sint64 col2 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt64SizePlusOne(this->_internal_col2());
    }

    // optional sint32 col1 = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32SizePlusOne(this->_internal_col1());
    }

    // optional uint32 col3 = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_col3());
    }

    // optional uint64 col4 = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_col4());
    }

    // optional int64 col6 = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_col6());
    }

    // optional int32 col5 = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_col5());
    }

    // optional fixed32 col7 = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional fixed64 col8 = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional sfixed64 col10 = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional sfixed32 col9 = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional float col11 = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional double col12 = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 8;
    }

    // optional bool col13 = 13;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TestTupleRecord::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TestTupleRecord::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TestTupleRecord::GetClassData() const { return &_class_data_; }

void TestTupleRecord::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TestTupleRecord *>(to)->MergeFrom(
      static_cast<const TestTupleRecord &>(from));
}


void TestTupleRecord::MergeFrom(const TestTupleRecord& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TestTupleRecord)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_col14(from._internal_col14());
    }
    if (cached_has_bits & 0x00000002u) {
      col2_ = from.col2_;
    }
    if (cached_has_bits & 0x00000004u) {
      col1_ = from.col1_;
    }
    if (cached_has_bits & 0x00000008u) {
      col3_ = from.col3_;
    }
    if (cached_has_bits & 0x00000010u) {
      col4_ = from.col4_;
    }
    if (cached_has_bits & 0x00000020u) {
      col6_ = from.col6_;
    }
    if (cached_has_bits & 0x00000040u) {
      col5_ = from.col5_;
    }
    if (cached_has_bits & 0x00000080u) {
      col7_ = from.col7_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      col8_ = from.col8_;
    }
    if (cached_has_bits & 0x00000200u) {
      col10_ = from.col10_;
    }
    if (cached_has_bits & 0x00000400u) {
      col9_ = from.col9_;
    }
    if (cached_has_bits & 0x00000800u) {
      col11_ = from.col11_;
    }
    if (cached_has_bits & 0x00001000u) {
      col12_ = from.col12_;
    }
    if (cached_has_bits & 0x00002000u) {
      col13_ = from.col13_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TestTupleRecord::CopyFrom(const TestTupleRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TestTupleRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TestTupleRecord::IsInitialized() const {
  return true;
}

void TestTupleRecord::InternalSwap(TestTupleRecord* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &col14_, lhs_arena,
      &other->col14_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TestTupleRecord, col13_)
      + sizeof(TestTupleRecord::col13_)
      - PROTOBUF_FIELD_OFFSET(TestTupleRecord, col2_)>(
          reinterpret_cast<char*>(&col2_),
          reinterpret_cast<char*>(&other->col2_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TestTupleRecord::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_test_5fdecode_2eproto_getter, &descriptor_table_test_5fdecode_2eproto_once,
      file_level_metadata_test_5fdecode_2eproto[1]);
}

// ===================================================================

class Pg::_Internal {
 public:
  using HasBits = decltype(std::declval<Pg>()._has_bits_);
  static void set_has_b(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Pg::Pg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  a_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:Pg)
}
Pg::Pg(const Pg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      a_(from.a_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  b_ = from.b_;
  // @@protoc_insertion_point(copy_constructor:Pg)
}

void Pg::SharedCtor() {
b_ = 0;
}

Pg::~Pg() {
  // @@protoc_insertion_point(destructor:Pg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Pg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Pg::ArenaDtor(void* object) {
  Pg* _this = reinterpret_cast< Pg* >(object);
  (void)_this;
}
void Pg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Pg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Pg::Clear() {
// @@protoc_insertion_point(message_clear_start:Pg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  a_.Clear();
  b_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Pg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 a = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_a(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_a(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 b = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_b(&has_bits);
          b_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Pg::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Pg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 a = 1;
  for (int i = 0, n = this->_internal_a_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_a(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 b = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_b(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Pg)
  return target;
}

size_t Pg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Pg)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 a = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->a_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_a_size());
    total_size += data_size;
  }

  // optional int32 b = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_b());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Pg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Pg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Pg::GetClassData() const { return &_class_data_; }

void Pg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Pg *>(to)->MergeFrom(
      static_cast<const Pg &>(from));
}


void Pg::MergeFrom(const Pg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Pg)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  a_.MergeFrom(from.a_);
  if (from._internal_has_b()) {
    _internal_set_b(from._internal_b());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Pg::CopyFrom(const Pg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Pg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pg::IsInitialized() const {
  return true;
}

void Pg::InternalSwap(Pg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  a_.InternalSwap(&other->a_);
  swap(b_, other->b_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Pg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_test_5fdecode_2eproto_getter, &descriptor_table_test_5fdecode_2eproto_once,
      file_level_metadata_test_5fdecode_2eproto[2]);
}

// ===================================================================

class Packed::_Internal {
 public:
};

Packed::Packed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  a_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:Packed)
}
Packed::Packed(const Packed& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      a_(from.a_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Packed)
}

void Packed::SharedCtor() {
}

Packed::~Packed() {
  // @@protoc_insertion_point(destructor:Packed)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Packed::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Packed::ArenaDtor(void* object) {
  Packed* _this = reinterpret_cast< Packed* >(object);
  (void)_this;
}
void Packed::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Packed::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Packed::Clear() {
// @@protoc_insertion_point(message_clear_start:Packed)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  a_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Packed::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Pg a = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_a(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Packed::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Packed)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Pg a = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_a_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_a(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Packed)
  return target;
}

size_t Packed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Packed)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Pg a = 1;
  total_size += 1UL * this->_internal_a_size();
  for (const auto& msg : this->a_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Packed::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Packed::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Packed::GetClassData() const { return &_class_data_; }

void Packed::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Packed *>(to)->MergeFrom(
      static_cast<const Packed &>(from));
}


void Packed::MergeFrom(const Packed& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Packed)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  a_.MergeFrom(from.a_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Packed::CopyFrom(const Packed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Packed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Packed::IsInitialized() const {
  return true;
}

void Packed::InternalSwap(Packed* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  a_.InternalSwap(&other->a_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Packed::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_test_5fdecode_2eproto_getter, &descriptor_table_test_5fdecode_2eproto_once,
      file_level_metadata_test_5fdecode_2eproto[3]);
}

// ===================================================================

class Optional::_Internal {
 public:
  using HasBits = decltype(std::declval<Optional>()._has_bits_);
  static const ::Pg& a(const Optional* msg);
  static void set_has_a(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::Pg&
Optional::_Internal::a(const Optional* msg) {
  return *msg->a_;
}
Optional::Optional(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:Optional)
}
Optional::Optional(const Optional& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_a()) {
    a_ = new ::Pg(*from.a_);
  } else {
    a_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:Optional)
}

void Optional::SharedCtor() {
a_ = nullptr;
}

Optional::~Optional() {
  // @@protoc_insertion_point(destructor:Optional)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Optional::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete a_;
}

void Optional::ArenaDtor(void* object) {
  Optional* _this = reinterpret_cast< Optional* >(object);
  (void)_this;
}
void Optional::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Optional::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Optional::Clear() {
// @@protoc_insertion_point(message_clear_start:Optional)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(a_ != nullptr);
    a_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Optional::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .Pg a = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_a(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Optional::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Optional)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .Pg a = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::a(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Optional)
  return target;
}

size_t Optional::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Optional)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .Pg a = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *a_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Optional::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Optional::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Optional::GetClassData() const { return &_class_data_; }

void Optional::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Optional *>(to)->MergeFrom(
      static_cast<const Optional &>(from));
}


void Optional::MergeFrom(const Optional& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Optional)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_a()) {
    _internal_mutable_a()->::Pg::MergeFrom(from._internal_a());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Optional::CopyFrom(const Optional& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Optional)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Optional::IsInitialized() const {
  return true;
}

void Optional::InternalSwap(Optional* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(a_, other->a_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Optional::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_test_5fdecode_2eproto_getter, &descriptor_table_test_5fdecode_2eproto_once,
      file_level_metadata_test_5fdecode_2eproto[4]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::TestMessage* Arena::CreateMaybeMessage< ::TestMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TestMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::TestTupleRecord* Arena::CreateMaybeMessage< ::TestTupleRecord >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TestTupleRecord >(arena);
}
template<> PROTOBUF_NOINLINE ::Pg* Arena::CreateMaybeMessage< ::Pg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Pg >(arena);
}
template<> PROTOBUF_NOINLINE ::Packed* Arena::CreateMaybeMessage< ::Packed >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Packed >(arena);
}
template<> PROTOBUF_NOINLINE ::Optional* Arena::CreateMaybeMessage< ::Optional >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Optional >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
