// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: plan.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_plan_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_plan_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "optype.pb.h"
#include "expr.pb.h"
#include "meta.interface.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_plan_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_plan_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[40]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_plan_2eproto;
namespace baikaldb {
namespace pb {
class AggNode;
struct AggNodeDefaultTypeInternal;
extern AggNodeDefaultTypeInternal _AggNode_default_instance_;
class ApplyNode;
struct ApplyNodeDefaultTypeInternal;
extern ApplyNodeDefaultTypeInternal _ApplyNode_default_instance_;
class DeleteNode;
struct DeleteNodeDefaultTypeInternal;
extern DeleteNodeDefaultTypeInternal _DeleteNode_default_instance_;
class DerivePlanNode;
struct DerivePlanNodeDefaultTypeInternal;
extern DerivePlanNodeDefaultTypeInternal _DerivePlanNode_default_instance_;
class DualScanNode;
struct DualScanNodeDefaultTypeInternal;
extern DualScanNodeDefaultTypeInternal _DualScanNode_default_instance_;
class ExchangeDestination;
struct ExchangeDestinationDefaultTypeInternal;
extern ExchangeDestinationDefaultTypeInternal _ExchangeDestination_default_instance_;
class ExchangeReceiverNode;
struct ExchangeReceiverNodeDefaultTypeInternal;
extern ExchangeReceiverNodeDefaultTypeInternal _ExchangeReceiverNode_default_instance_;
class ExchangeSenderNode;
struct ExchangeSenderNodeDefaultTypeInternal;
extern ExchangeSenderNodeDefaultTypeInternal _ExchangeSenderNode_default_instance_;
class FetcherNode;
struct FetcherNodeDefaultTypeInternal;
extern FetcherNodeDefaultTypeInternal _FetcherNode_default_instance_;
class FilterNode;
struct FilterNodeDefaultTypeInternal;
extern FilterNodeDefaultTypeInternal _FilterNode_default_instance_;
class FragmentInfo;
struct FragmentInfoDefaultTypeInternal;
extern FragmentInfoDefaultTypeInternal _FragmentInfo_default_instance_;
class FrameBound;
struct FrameBoundDefaultTypeInternal;
extern FrameBoundDefaultTypeInternal _FrameBound_default_instance_;
class FrameExtent;
struct FrameExtentDefaultTypeInternal;
extern FrameExtentDefaultTypeInternal _FrameExtent_default_instance_;
class FulltextIndex;
struct FulltextIndexDefaultTypeInternal;
extern FulltextIndexDefaultTypeInternal _FulltextIndex_default_instance_;
class InsertNode;
struct InsertNodeDefaultTypeInternal;
extern InsertNodeDefaultTypeInternal _InsertNode_default_instance_;
class JoinNode;
struct JoinNodeDefaultTypeInternal;
extern JoinNodeDefaultTypeInternal _JoinNode_default_instance_;
class KillNode;
struct KillNodeDefaultTypeInternal;
extern KillNodeDefaultTypeInternal _KillNode_default_instance_;
class LimitNode;
struct LimitNodeDefaultTypeInternal;
extern LimitNodeDefaultTypeInternal _LimitNode_default_instance_;
class LoadNode;
struct LoadNodeDefaultTypeInternal;
extern LoadNodeDefaultTypeInternal _LoadNode_default_instance_;
class LocalTraceNode;
struct LocalTraceNodeDefaultTypeInternal;
extern LocalTraceNodeDefaultTypeInternal _LocalTraceNode_default_instance_;
class LockPrimaryNode;
struct LockPrimaryNodeDefaultTypeInternal;
extern LockPrimaryNodeDefaultTypeInternal _LockPrimaryNode_default_instance_;
class LockSecondaryNode;
struct LockSecondaryNodeDefaultTypeInternal;
extern LockSecondaryNodeDefaultTypeInternal _LockSecondaryNode_default_instance_;
class PacketNode;
struct PacketNodeDefaultTypeInternal;
extern PacketNodeDefaultTypeInternal _PacketNode_default_instance_;
class PartitionProperty;
struct PartitionPropertyDefaultTypeInternal;
extern PartitionPropertyDefaultTypeInternal _PartitionProperty_default_instance_;
class Plan;
struct PlanDefaultTypeInternal;
extern PlanDefaultTypeInternal _Plan_default_instance_;
class PlanNode;
struct PlanNodeDefaultTypeInternal;
extern PlanNodeDefaultTypeInternal _PlanNode_default_instance_;
class PossibleIndex;
struct PossibleIndexDefaultTypeInternal;
extern PossibleIndexDefaultTypeInternal _PossibleIndex_default_instance_;
class PossibleIndex_Range;
struct PossibleIndex_RangeDefaultTypeInternal;
extern PossibleIndex_RangeDefaultTypeInternal _PossibleIndex_Range_default_instance_;
class PossibleIndex_SortIndex;
struct PossibleIndex_SortIndexDefaultTypeInternal;
extern PossibleIndex_SortIndexDefaultTypeInternal _PossibleIndex_SortIndex_default_instance_;
class ScanNode;
struct ScanNodeDefaultTypeInternal;
extern ScanNodeDefaultTypeInternal _ScanNode_default_instance_;
class SelectManagerNode;
struct SelectManagerNodeDefaultTypeInternal;
extern SelectManagerNodeDefaultTypeInternal _SelectManagerNode_default_instance_;
class SortNode;
struct SortNodeDefaultTypeInternal;
extern SortNodeDefaultTypeInternal _SortNode_default_instance_;
class TraceNode;
struct TraceNodeDefaultTypeInternal;
extern TraceNodeDefaultTypeInternal _TraceNode_default_instance_;
class TransactionNode;
struct TransactionNodeDefaultTypeInternal;
extern TransactionNodeDefaultTypeInternal _TransactionNode_default_instance_;
class TruncateNode;
struct TruncateNodeDefaultTypeInternal;
extern TruncateNodeDefaultTypeInternal _TruncateNode_default_instance_;
class UnionNode;
struct UnionNodeDefaultTypeInternal;
extern UnionNodeDefaultTypeInternal _UnionNode_default_instance_;
class UpdateNode;
struct UpdateNodeDefaultTypeInternal;
extern UpdateNodeDefaultTypeInternal _UpdateNode_default_instance_;
class WindowFrame;
struct WindowFrameDefaultTypeInternal;
extern WindowFrameDefaultTypeInternal _WindowFrame_default_instance_;
class WindowNode;
struct WindowNodeDefaultTypeInternal;
extern WindowNodeDefaultTypeInternal _WindowNode_default_instance_;
class WindowSpec;
struct WindowSpecDefaultTypeInternal;
extern WindowSpecDefaultTypeInternal _WindowSpec_default_instance_;
}  // namespace pb
}  // namespace baikaldb
PROTOBUF_NAMESPACE_OPEN
template<> ::baikaldb::pb::AggNode* Arena::CreateMaybeMessage<::baikaldb::pb::AggNode>(Arena*);
template<> ::baikaldb::pb::ApplyNode* Arena::CreateMaybeMessage<::baikaldb::pb::ApplyNode>(Arena*);
template<> ::baikaldb::pb::DeleteNode* Arena::CreateMaybeMessage<::baikaldb::pb::DeleteNode>(Arena*);
template<> ::baikaldb::pb::DerivePlanNode* Arena::CreateMaybeMessage<::baikaldb::pb::DerivePlanNode>(Arena*);
template<> ::baikaldb::pb::DualScanNode* Arena::CreateMaybeMessage<::baikaldb::pb::DualScanNode>(Arena*);
template<> ::baikaldb::pb::ExchangeDestination* Arena::CreateMaybeMessage<::baikaldb::pb::ExchangeDestination>(Arena*);
template<> ::baikaldb::pb::ExchangeReceiverNode* Arena::CreateMaybeMessage<::baikaldb::pb::ExchangeReceiverNode>(Arena*);
template<> ::baikaldb::pb::ExchangeSenderNode* Arena::CreateMaybeMessage<::baikaldb::pb::ExchangeSenderNode>(Arena*);
template<> ::baikaldb::pb::FetcherNode* Arena::CreateMaybeMessage<::baikaldb::pb::FetcherNode>(Arena*);
template<> ::baikaldb::pb::FilterNode* Arena::CreateMaybeMessage<::baikaldb::pb::FilterNode>(Arena*);
template<> ::baikaldb::pb::FragmentInfo* Arena::CreateMaybeMessage<::baikaldb::pb::FragmentInfo>(Arena*);
template<> ::baikaldb::pb::FrameBound* Arena::CreateMaybeMessage<::baikaldb::pb::FrameBound>(Arena*);
template<> ::baikaldb::pb::FrameExtent* Arena::CreateMaybeMessage<::baikaldb::pb::FrameExtent>(Arena*);
template<> ::baikaldb::pb::FulltextIndex* Arena::CreateMaybeMessage<::baikaldb::pb::FulltextIndex>(Arena*);
template<> ::baikaldb::pb::InsertNode* Arena::CreateMaybeMessage<::baikaldb::pb::InsertNode>(Arena*);
template<> ::baikaldb::pb::JoinNode* Arena::CreateMaybeMessage<::baikaldb::pb::JoinNode>(Arena*);
template<> ::baikaldb::pb::KillNode* Arena::CreateMaybeMessage<::baikaldb::pb::KillNode>(Arena*);
template<> ::baikaldb::pb::LimitNode* Arena::CreateMaybeMessage<::baikaldb::pb::LimitNode>(Arena*);
template<> ::baikaldb::pb::LoadNode* Arena::CreateMaybeMessage<::baikaldb::pb::LoadNode>(Arena*);
template<> ::baikaldb::pb::LocalTraceNode* Arena::CreateMaybeMessage<::baikaldb::pb::LocalTraceNode>(Arena*);
template<> ::baikaldb::pb::LockPrimaryNode* Arena::CreateMaybeMessage<::baikaldb::pb::LockPrimaryNode>(Arena*);
template<> ::baikaldb::pb::LockSecondaryNode* Arena::CreateMaybeMessage<::baikaldb::pb::LockSecondaryNode>(Arena*);
template<> ::baikaldb::pb::PacketNode* Arena::CreateMaybeMessage<::baikaldb::pb::PacketNode>(Arena*);
template<> ::baikaldb::pb::PartitionProperty* Arena::CreateMaybeMessage<::baikaldb::pb::PartitionProperty>(Arena*);
template<> ::baikaldb::pb::Plan* Arena::CreateMaybeMessage<::baikaldb::pb::Plan>(Arena*);
template<> ::baikaldb::pb::PlanNode* Arena::CreateMaybeMessage<::baikaldb::pb::PlanNode>(Arena*);
template<> ::baikaldb::pb::PossibleIndex* Arena::CreateMaybeMessage<::baikaldb::pb::PossibleIndex>(Arena*);
template<> ::baikaldb::pb::PossibleIndex_Range* Arena::CreateMaybeMessage<::baikaldb::pb::PossibleIndex_Range>(Arena*);
template<> ::baikaldb::pb::PossibleIndex_SortIndex* Arena::CreateMaybeMessage<::baikaldb::pb::PossibleIndex_SortIndex>(Arena*);
template<> ::baikaldb::pb::ScanNode* Arena::CreateMaybeMessage<::baikaldb::pb::ScanNode>(Arena*);
template<> ::baikaldb::pb::SelectManagerNode* Arena::CreateMaybeMessage<::baikaldb::pb::SelectManagerNode>(Arena*);
template<> ::baikaldb::pb::SortNode* Arena::CreateMaybeMessage<::baikaldb::pb::SortNode>(Arena*);
template<> ::baikaldb::pb::TraceNode* Arena::CreateMaybeMessage<::baikaldb::pb::TraceNode>(Arena*);
template<> ::baikaldb::pb::TransactionNode* Arena::CreateMaybeMessage<::baikaldb::pb::TransactionNode>(Arena*);
template<> ::baikaldb::pb::TruncateNode* Arena::CreateMaybeMessage<::baikaldb::pb::TruncateNode>(Arena*);
template<> ::baikaldb::pb::UnionNode* Arena::CreateMaybeMessage<::baikaldb::pb::UnionNode>(Arena*);
template<> ::baikaldb::pb::UpdateNode* Arena::CreateMaybeMessage<::baikaldb::pb::UpdateNode>(Arena*);
template<> ::baikaldb::pb::WindowFrame* Arena::CreateMaybeMessage<::baikaldb::pb::WindowFrame>(Arena*);
template<> ::baikaldb::pb::WindowNode* Arena::CreateMaybeMessage<::baikaldb::pb::WindowNode>(Arena*);
template<> ::baikaldb::pb::WindowSpec* Arena::CreateMaybeMessage<::baikaldb::pb::WindowSpec>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace baikaldb {
namespace pb {

enum PlanNodeType : int {
  SCAN_NODE = 1,
  SORT_NODE = 2,
  AGG_NODE = 4,
  MERGE_AGG_NODE = 5,
  TABLE_FILTER_NODE = 6,
  JOIN_NODE = 7,
  FETCHER_NODE = 8,
  INSERT_NODE = 9,
  DELETE_NODE = 10,
  LIMIT_NODE = 11,
  WHERE_FILTER_NODE = 12,
  HAVING_FILTER_NODE = 13,
  PACKET_NODE = 14,
  UPDATE_NODE = 15,
  TRUNCATE_NODE = 17,
  TRANSACTION_NODE = 18,
  KILL_NODE = 19,
  BEGIN_MANAGER_NODE = 20,
  COMMIT_MANAGER_NODE = 21,
  ROLLBACK_MANAGER_NODE = 22,
  TXN_ROLLBACK_MANAGER_NODE = 23,
  SIGNEL_TXN_MANAGER_NODE = 24,
  SELECT_MANAGER_NODE = 25,
  INSERT_MANAGER_NODE = 26,
  UPDATE_MANAGER_NODE = 27,
  DELETE_MANAGER_NODE = 28,
  TRUNCATE_MANAGER_NODE = 29,
  KILL_MANAGER_NODE = 30,
  LOCK_PRIMARY_NODE = 31,
  LOCK_SECONDARY_NODE = 32,
  FULL_EXPORT_NODE = 33,
  DUAL_SCAN_NODE = 34,
  UNION_NODE = 35,
  INDEX_DDL_MANAGER_NODE = 36,
  APPLY_NODE = 37,
  LOAD_NODE = 38,
  BASE_SUBSCRIBE_MANAGER_NODE = 39,
  EXCHANGE_SENDER_NODE = 40,
  EXCHANGE_RECEIVER_NODE = 41,
  WINDOW_NODE = 42
};
bool PlanNodeType_IsValid(int value);
constexpr PlanNodeType PlanNodeType_MIN = SCAN_NODE;
constexpr PlanNodeType PlanNodeType_MAX = WINDOW_NODE;
constexpr int PlanNodeType_ARRAYSIZE = PlanNodeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlanNodeType_descriptor();
template<typename T>
inline const std::string& PlanNodeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlanNodeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlanNodeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlanNodeType_descriptor(), enum_t_value);
}
inline bool PlanNodeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlanNodeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlanNodeType>(
    PlanNodeType_descriptor(), name, value);
}
enum TxnCmdType : int {
  TXN_INVALID = 0,
  TXN_BEGIN = 1,
  TXN_BEGIN_STORE = 2,
  TXN_COMMIT = 3,
  TXN_COMMIT_STORE = 4,
  TXN_COMMIT_BEGIN = 5,
  TXN_ROLLBACK = 6,
  TXN_ROLLBACK_STORE = 7,
  TXN_ROLLBACK_BEGIN = 8,
  TXN_PREPARE = 9
};
bool TxnCmdType_IsValid(int value);
constexpr TxnCmdType TxnCmdType_MIN = TXN_INVALID;
constexpr TxnCmdType TxnCmdType_MAX = TXN_PREPARE;
constexpr int TxnCmdType_ARRAYSIZE = TxnCmdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TxnCmdType_descriptor();
template<typename T>
inline const std::string& TxnCmdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TxnCmdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TxnCmdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TxnCmdType_descriptor(), enum_t_value);
}
inline bool TxnCmdType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TxnCmdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TxnCmdType>(
    TxnCmdType_descriptor(), name, value);
}
enum LockCmdType : int {
  LOCK_INVALID = 0,
  LOCK_GET = 1,
  LOCK_GET_ONLY_PRIMARY = 2,
  LOCK_DML = 3,
  LOCK_GET_DML = 4,
  LOCK_NO = 5,
  LOCK_GLOBAL_DDL = 6,
  LOCK_NO_GLOBAL_DDL = 7
};
bool LockCmdType_IsValid(int value);
constexpr LockCmdType LockCmdType_MIN = LOCK_INVALID;
constexpr LockCmdType LockCmdType_MAX = LOCK_NO_GLOBAL_DDL;
constexpr int LockCmdType_ARRAYSIZE = LockCmdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LockCmdType_descriptor();
template<typename T>
inline const std::string& LockCmdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LockCmdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LockCmdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LockCmdType_descriptor(), enum_t_value);
}
inline bool LockCmdType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LockCmdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LockCmdType>(
    LockCmdType_descriptor(), name, value);
}
enum MatchMode : int {
  M_NONE = 0,
  M_NARUTAL_LANGUAGE = 1,
  M_BOOLEAN = 2
};
bool MatchMode_IsValid(int value);
constexpr MatchMode MatchMode_MIN = M_NONE;
constexpr MatchMode MatchMode_MAX = M_BOOLEAN;
constexpr int MatchMode_ARRAYSIZE = MatchMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchMode_descriptor();
template<typename T>
inline const std::string& MatchMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MatchMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MatchMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MatchMode_descriptor(), enum_t_value);
}
inline bool MatchMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MatchMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MatchMode>(
    MatchMode_descriptor(), name, value);
}
enum FulltextNodeType : int {
  FNT_OR = 1,
  FNT_AND = 2,
  FNT_TERM = 3
};
bool FulltextNodeType_IsValid(int value);
constexpr FulltextNodeType FulltextNodeType_MIN = FNT_OR;
constexpr FulltextNodeType FulltextNodeType_MAX = FNT_TERM;
constexpr int FulltextNodeType_ARRAYSIZE = FulltextNodeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FulltextNodeType_descriptor();
template<typename T>
inline const std::string& FulltextNodeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FulltextNodeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FulltextNodeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FulltextNodeType_descriptor(), enum_t_value);
}
inline bool FulltextNodeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FulltextNodeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FulltextNodeType>(
    FulltextNodeType_descriptor(), name, value);
}
enum DDLType : int {
  DDL_NONE = 0,
  DDL_LOCAL_INDEX = 1,
  DDL_GLOBAL_INDEX = 2,
  DDL_COLUMN = 3
};
bool DDLType_IsValid(int value);
constexpr DDLType DDLType_MIN = DDL_NONE;
constexpr DDLType DDLType_MAX = DDL_COLUMN;
constexpr int DDLType_ARRAYSIZE = DDLType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DDLType_descriptor();
template<typename T>
inline const std::string& DDLType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DDLType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DDLType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DDLType_descriptor(), enum_t_value);
}
inline bool DDLType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DDLType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DDLType>(
    DDLType_descriptor(), name, value);
}
enum JoinType : int {
  NULL_JOIN = 0,
  LEFT_JOIN = 1,
  RIGHT_JOIN = 2,
  INNER_JOIN = 3,
  SEMI_JOIN = 4,
  ANTI_SEMI_JOIN = 5,
  FULL_JOIN = 6
};
bool JoinType_IsValid(int value);
constexpr JoinType JoinType_MIN = NULL_JOIN;
constexpr JoinType JoinType_MAX = FULL_JOIN;
constexpr int JoinType_ARRAYSIZE = JoinType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JoinType_descriptor();
template<typename T>
inline const std::string& JoinType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JoinType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JoinType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    JoinType_descriptor(), enum_t_value);
}
inline bool JoinType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, JoinType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<JoinType>(
    JoinType_descriptor(), name, value);
}
enum CompareType : int {
  CMP_NULL = 0,
  CMP_ANY = 1,
  CMP_ALL = 2,
  CMP_SOME = 3
};
bool CompareType_IsValid(int value);
constexpr CompareType CompareType_MIN = CMP_NULL;
constexpr CompareType CompareType_MAX = CMP_SOME;
constexpr int CompareType_ARRAYSIZE = CompareType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompareType_descriptor();
template<typename T>
inline const std::string& CompareType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompareType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompareType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompareType_descriptor(), enum_t_value);
}
inline bool CompareType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompareType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompareType>(
    CompareType_descriptor(), name, value);
}
enum LockSecondaryType : int {
  LST_COMMON = 0,
  LST_GLOBAL_DDL = 1
};
bool LockSecondaryType_IsValid(int value);
constexpr LockSecondaryType LockSecondaryType_MIN = LST_COMMON;
constexpr LockSecondaryType LockSecondaryType_MAX = LST_GLOBAL_DDL;
constexpr int LockSecondaryType_ARRAYSIZE = LockSecondaryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LockSecondaryType_descriptor();
template<typename T>
inline const std::string& LockSecondaryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LockSecondaryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LockSecondaryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LockSecondaryType_descriptor(), enum_t_value);
}
inline bool LockSecondaryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LockSecondaryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LockSecondaryType>(
    LockSecondaryType_descriptor(), name, value);
}
enum PartitionPropertyType : int {
  AnyType = 1,
  SinglePartitionType = 2,
  HashPartitionType = 3,
  BroadcastPartitionType = 4,
  RandomPartitionType = 5
};
bool PartitionPropertyType_IsValid(int value);
constexpr PartitionPropertyType PartitionPropertyType_MIN = AnyType;
constexpr PartitionPropertyType PartitionPropertyType_MAX = RandomPartitionType;
constexpr int PartitionPropertyType_ARRAYSIZE = PartitionPropertyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PartitionPropertyType_descriptor();
template<typename T>
inline const std::string& PartitionPropertyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PartitionPropertyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PartitionPropertyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PartitionPropertyType_descriptor(), enum_t_value);
}
inline bool PartitionPropertyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PartitionPropertyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PartitionPropertyType>(
    PartitionPropertyType_descriptor(), name, value);
}
enum FrameType : int {
  FT_ROWS = 0,
  FT_RANGE = 1
};
bool FrameType_IsValid(int value);
constexpr FrameType FrameType_MIN = FT_ROWS;
constexpr FrameType FrameType_MAX = FT_RANGE;
constexpr int FrameType_ARRAYSIZE = FrameType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FrameType_descriptor();
template<typename T>
inline const std::string& FrameType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FrameType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FrameType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FrameType_descriptor(), enum_t_value);
}
inline bool FrameType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FrameType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FrameType>(
    FrameType_descriptor(), name, value);
}
enum BoundType : int {
  BT_PRECEDING = 0,
  BT_FOLLOWING = 1,
  BT_CURRENT_ROW = 2
};
bool BoundType_IsValid(int value);
constexpr BoundType BoundType_MIN = BT_PRECEDING;
constexpr BoundType BoundType_MAX = BT_CURRENT_ROW;
constexpr int BoundType_ARRAYSIZE = BoundType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BoundType_descriptor();
template<typename T>
inline const std::string& BoundType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BoundType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BoundType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BoundType_descriptor(), enum_t_value);
}
inline bool BoundType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BoundType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BoundType>(
    BoundType_descriptor(), name, value);
}
// ===================================================================

class SelectManagerNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.SelectManagerNode) */ {
 public:
  inline SelectManagerNode() : SelectManagerNode(nullptr) {}
  ~SelectManagerNode() override;
  explicit constexpr SelectManagerNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectManagerNode(const SelectManagerNode& from);
  SelectManagerNode(SelectManagerNode&& from) noexcept
    : SelectManagerNode() {
    *this = ::std::move(from);
  }

  inline SelectManagerNode& operator=(const SelectManagerNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectManagerNode& operator=(SelectManagerNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectManagerNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectManagerNode* internal_default_instance() {
    return reinterpret_cast<const SelectManagerNode*>(
               &_SelectManagerNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SelectManagerNode& a, SelectManagerNode& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectManagerNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectManagerNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SelectManagerNode* New() const final {
    return new SelectManagerNode();
  }

  SelectManagerNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SelectManagerNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectManagerNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SelectManagerNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectManagerNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.SelectManagerNode";
  }
  protected:
  explicit SelectManagerNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotOrderExprsFieldNumber = 2,
    kIsAscFieldNumber = 3,
    kIsNullFirstFieldNumber = 4,
    kSchemaFieldNumber = 1,
    kIsReturnEmptyFieldNumber = 5,
  };
  // repeated .baikaldb.pb.Expr slot_order_exprs = 2;
  int slot_order_exprs_size() const;
  private:
  int _internal_slot_order_exprs_size() const;
  public:
  void clear_slot_order_exprs();
  ::baikaldb::pb::Expr* mutable_slot_order_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_slot_order_exprs();
  private:
  const ::baikaldb::pb::Expr& _internal_slot_order_exprs(int index) const;
  ::baikaldb::pb::Expr* _internal_add_slot_order_exprs();
  public:
  const ::baikaldb::pb::Expr& slot_order_exprs(int index) const;
  ::baikaldb::pb::Expr* add_slot_order_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      slot_order_exprs() const;

  // repeated bool is_asc = 3;
  int is_asc_size() const;
  private:
  int _internal_is_asc_size() const;
  public:
  void clear_is_asc();
  private:
  bool _internal_is_asc(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_is_asc() const;
  void _internal_add_is_asc(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_is_asc();
  public:
  bool is_asc(int index) const;
  void set_is_asc(int index, bool value);
  void add_is_asc(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      is_asc() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_is_asc();

  // repeated bool is_null_first = 4;
  int is_null_first_size() const;
  private:
  int _internal_is_null_first_size() const;
  public:
  void clear_is_null_first();
  private:
  bool _internal_is_null_first(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_is_null_first() const;
  void _internal_add_is_null_first(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_is_null_first();
  public:
  bool is_null_first(int index) const;
  void set_is_null_first(int index, bool value);
  void add_is_null_first(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      is_null_first() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_is_null_first();

  // optional bytes schema = 1;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const std::string& schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema();
  PROTOBUF_MUST_USE_RESULT std::string* release_schema();
  void set_allocated_schema(std::string* schema);
  private:
  const std::string& _internal_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();
  public:

  // optional bool is_return_empty = 5;
  bool has_is_return_empty() const;
  private:
  bool _internal_has_is_return_empty() const;
  public:
  void clear_is_return_empty();
  bool is_return_empty() const;
  void set_is_return_empty(bool value);
  private:
  bool _internal_is_return_empty() const;
  void _internal_set_is_return_empty(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.SelectManagerNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > slot_order_exprs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > is_asc_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > is_null_first_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_;
  bool is_return_empty_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class PossibleIndex_Range final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.PossibleIndex.Range) */ {
 public:
  inline PossibleIndex_Range() : PossibleIndex_Range(nullptr) {}
  ~PossibleIndex_Range() override;
  explicit constexpr PossibleIndex_Range(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PossibleIndex_Range(const PossibleIndex_Range& from);
  PossibleIndex_Range(PossibleIndex_Range&& from) noexcept
    : PossibleIndex_Range() {
    *this = ::std::move(from);
  }

  inline PossibleIndex_Range& operator=(const PossibleIndex_Range& from) {
    CopyFrom(from);
    return *this;
  }
  inline PossibleIndex_Range& operator=(PossibleIndex_Range&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PossibleIndex_Range& default_instance() {
    return *internal_default_instance();
  }
  static inline const PossibleIndex_Range* internal_default_instance() {
    return reinterpret_cast<const PossibleIndex_Range*>(
               &_PossibleIndex_Range_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PossibleIndex_Range& a, PossibleIndex_Range& b) {
    a.Swap(&b);
  }
  inline void Swap(PossibleIndex_Range* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PossibleIndex_Range* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PossibleIndex_Range* New() const final {
    return new PossibleIndex_Range();
  }

  PossibleIndex_Range* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PossibleIndex_Range>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PossibleIndex_Range& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PossibleIndex_Range& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PossibleIndex_Range* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.PossibleIndex.Range";
  }
  protected:
  explicit PossibleIndex_Range(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionIdsFieldNumber = 15,
    kLeftPbRecordFieldNumber = 3,
    kRightPbRecordFieldNumber = 4,
    kLeftKeyFieldNumber = 11,
    kRightKeyFieldNumber = 12,
    kLeftFieldCntFieldNumber = 5,
    kRightFieldCntFieldNumber = 6,
    kLeftOpenFieldNumber = 7,
    kRightOpenFieldNumber = 8,
    kLikePrefixFieldNumber = 9,
    kLeftFullFieldNumber = 13,
    kMatchModeFieldNumber = 10,
    kRightFullFieldNumber = 14,
    kTopkFieldNumber = 16,
    kSeparateValueFieldNumber = 17,
    kEfsearchFieldNumber = 18,
  };
  // repeated int32 partition_ids = 15;
  int partition_ids_size() const;
  private:
  int _internal_partition_ids_size() const;
  public:
  void clear_partition_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_partition_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_partition_ids() const;
  void _internal_add_partition_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_partition_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 partition_ids(int index) const;
  void set_partition_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_partition_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      partition_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_partition_ids();

  // optional bytes left_pb_record = 3;
  bool has_left_pb_record() const;
  private:
  bool _internal_has_left_pb_record() const;
  public:
  void clear_left_pb_record();
  const std::string& left_pb_record() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_left_pb_record(ArgT0&& arg0, ArgT... args);
  std::string* mutable_left_pb_record();
  PROTOBUF_MUST_USE_RESULT std::string* release_left_pb_record();
  void set_allocated_left_pb_record(std::string* left_pb_record);
  private:
  const std::string& _internal_left_pb_record() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_left_pb_record(const std::string& value);
  std::string* _internal_mutable_left_pb_record();
  public:

  // optional bytes right_pb_record = 4;
  bool has_right_pb_record() const;
  private:
  bool _internal_has_right_pb_record() const;
  public:
  void clear_right_pb_record();
  const std::string& right_pb_record() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_right_pb_record(ArgT0&& arg0, ArgT... args);
  std::string* mutable_right_pb_record();
  PROTOBUF_MUST_USE_RESULT std::string* release_right_pb_record();
  void set_allocated_right_pb_record(std::string* right_pb_record);
  private:
  const std::string& _internal_right_pb_record() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_right_pb_record(const std::string& value);
  std::string* _internal_mutable_right_pb_record();
  public:

  // optional bytes left_key = 11;
  bool has_left_key() const;
  private:
  bool _internal_has_left_key() const;
  public:
  void clear_left_key();
  const std::string& left_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_left_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_left_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_left_key();
  void set_allocated_left_key(std::string* left_key);
  private:
  const std::string& _internal_left_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_left_key(const std::string& value);
  std::string* _internal_mutable_left_key();
  public:

  // optional bytes right_key = 12;
  bool has_right_key() const;
  private:
  bool _internal_has_right_key() const;
  public:
  void clear_right_key();
  const std::string& right_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_right_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_right_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_right_key();
  void set_allocated_right_key(std::string* right_key);
  private:
  const std::string& _internal_right_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_right_key(const std::string& value);
  std::string* _internal_mutable_right_key();
  public:

  // optional int32 left_field_cnt = 5;
  bool has_left_field_cnt() const;
  private:
  bool _internal_has_left_field_cnt() const;
  public:
  void clear_left_field_cnt();
  ::PROTOBUF_NAMESPACE_ID::int32 left_field_cnt() const;
  void set_left_field_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_left_field_cnt() const;
  void _internal_set_left_field_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 right_field_cnt = 6;
  bool has_right_field_cnt() const;
  private:
  bool _internal_has_right_field_cnt() const;
  public:
  void clear_right_field_cnt();
  ::PROTOBUF_NAMESPACE_ID::int32 right_field_cnt() const;
  void set_right_field_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_right_field_cnt() const;
  void _internal_set_right_field_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool left_open = 7;
  bool has_left_open() const;
  private:
  bool _internal_has_left_open() const;
  public:
  void clear_left_open();
  bool left_open() const;
  void set_left_open(bool value);
  private:
  bool _internal_left_open() const;
  void _internal_set_left_open(bool value);
  public:

  // optional bool right_open = 8;
  bool has_right_open() const;
  private:
  bool _internal_has_right_open() const;
  public:
  void clear_right_open();
  bool right_open() const;
  void set_right_open(bool value);
  private:
  bool _internal_right_open() const;
  void _internal_set_right_open(bool value);
  public:

  // optional bool like_prefix = 9;
  bool has_like_prefix() const;
  private:
  bool _internal_has_like_prefix() const;
  public:
  void clear_like_prefix();
  bool like_prefix() const;
  void set_like_prefix(bool value);
  private:
  bool _internal_like_prefix() const;
  void _internal_set_like_prefix(bool value);
  public:

  // optional bool left_full = 13;
  bool has_left_full() const;
  private:
  bool _internal_has_left_full() const;
  public:
  void clear_left_full();
  bool left_full() const;
  void set_left_full(bool value);
  private:
  bool _internal_left_full() const;
  void _internal_set_left_full(bool value);
  public:

  // optional .baikaldb.pb.MatchMode match_mode = 10;
  bool has_match_mode() const;
  private:
  bool _internal_has_match_mode() const;
  public:
  void clear_match_mode();
  ::baikaldb::pb::MatchMode match_mode() const;
  void set_match_mode(::baikaldb::pb::MatchMode value);
  private:
  ::baikaldb::pb::MatchMode _internal_match_mode() const;
  void _internal_set_match_mode(::baikaldb::pb::MatchMode value);
  public:

  // optional bool right_full = 14;
  bool has_right_full() const;
  private:
  bool _internal_has_right_full() const;
  public:
  void clear_right_full();
  bool right_full() const;
  void set_right_full(bool value);
  private:
  bool _internal_right_full() const;
  void _internal_set_right_full(bool value);
  public:

  // optional int32 topk = 16;
  bool has_topk() const;
  private:
  bool _internal_has_topk() const;
  public:
  void clear_topk();
  ::PROTOBUF_NAMESPACE_ID::int32 topk() const;
  void set_topk(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_topk() const;
  void _internal_set_topk(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional uint64 separate_value = 17;
  bool has_separate_value() const;
  private:
  bool _internal_has_separate_value() const;
  public:
  void clear_separate_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 separate_value() const;
  void set_separate_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_separate_value() const;
  void _internal_set_separate_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int32 efsearch = 18;
  bool has_efsearch() const;
  private:
  bool _internal_has_efsearch() const;
  public:
  void clear_efsearch();
  ::PROTOBUF_NAMESPACE_ID::int32 efsearch() const;
  void set_efsearch(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_efsearch() const;
  void _internal_set_efsearch(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.PossibleIndex.Range)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > partition_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr left_pb_record_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr right_pb_record_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr left_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr right_key_;
  ::PROTOBUF_NAMESPACE_ID::int32 left_field_cnt_;
  ::PROTOBUF_NAMESPACE_ID::int32 right_field_cnt_;
  bool left_open_;
  bool right_open_;
  bool like_prefix_;
  bool left_full_;
  int match_mode_;
  bool right_full_;
  ::PROTOBUF_NAMESPACE_ID::int32 topk_;
  ::PROTOBUF_NAMESPACE_ID::uint64 separate_value_;
  ::PROTOBUF_NAMESPACE_ID::int32 efsearch_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class PossibleIndex_SortIndex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.PossibleIndex.SortIndex) */ {
 public:
  inline PossibleIndex_SortIndex() : PossibleIndex_SortIndex(nullptr) {}
  ~PossibleIndex_SortIndex() override;
  explicit constexpr PossibleIndex_SortIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PossibleIndex_SortIndex(const PossibleIndex_SortIndex& from);
  PossibleIndex_SortIndex(PossibleIndex_SortIndex&& from) noexcept
    : PossibleIndex_SortIndex() {
    *this = ::std::move(from);
  }

  inline PossibleIndex_SortIndex& operator=(const PossibleIndex_SortIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline PossibleIndex_SortIndex& operator=(PossibleIndex_SortIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PossibleIndex_SortIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const PossibleIndex_SortIndex* internal_default_instance() {
    return reinterpret_cast<const PossibleIndex_SortIndex*>(
               &_PossibleIndex_SortIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PossibleIndex_SortIndex& a, PossibleIndex_SortIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(PossibleIndex_SortIndex* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PossibleIndex_SortIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PossibleIndex_SortIndex* New() const final {
    return new PossibleIndex_SortIndex();
  }

  PossibleIndex_SortIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PossibleIndex_SortIndex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PossibleIndex_SortIndex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PossibleIndex_SortIndex& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PossibleIndex_SortIndex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.PossibleIndex.SortIndex";
  }
  protected:
  explicit PossibleIndex_SortIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSortLimitFieldNumber = 2,
    kIsAscFieldNumber = 1,
  };
  // optional int64 sort_limit = 2;
  bool has_sort_limit() const;
  private:
  bool _internal_has_sort_limit() const;
  public:
  void clear_sort_limit();
  ::PROTOBUF_NAMESPACE_ID::int64 sort_limit() const;
  void set_sort_limit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_sort_limit() const;
  void _internal_set_sort_limit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool is_asc = 1;
  bool has_is_asc() const;
  private:
  bool _internal_has_is_asc() const;
  public:
  void clear_is_asc();
  bool is_asc() const;
  void set_is_asc(bool value);
  private:
  bool _internal_is_asc() const;
  void _internal_set_is_asc(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.PossibleIndex.SortIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 sort_limit_;
  bool is_asc_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class PossibleIndex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.PossibleIndex) */ {
 public:
  inline PossibleIndex() : PossibleIndex(nullptr) {}
  ~PossibleIndex() override;
  explicit constexpr PossibleIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PossibleIndex(const PossibleIndex& from);
  PossibleIndex(PossibleIndex&& from) noexcept
    : PossibleIndex() {
    *this = ::std::move(from);
  }

  inline PossibleIndex& operator=(const PossibleIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline PossibleIndex& operator=(PossibleIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PossibleIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const PossibleIndex* internal_default_instance() {
    return reinterpret_cast<const PossibleIndex*>(
               &_PossibleIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PossibleIndex& a, PossibleIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(PossibleIndex* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PossibleIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PossibleIndex* New() const final {
    return new PossibleIndex();
  }

  PossibleIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PossibleIndex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PossibleIndex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PossibleIndex& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PossibleIndex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.PossibleIndex";
  }
  protected:
  explicit PossibleIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PossibleIndex_Range Range;
  typedef PossibleIndex_SortIndex SortIndex;

  // accessors -------------------------------------------------------

  enum : int {
    kRangesFieldNumber = 2,
    kIndexConjunctsFieldNumber = 3,
    kSortIndexFieldNumber = 4,
    kIndexIdFieldNumber = 1,
    kBoolAndFieldNumber = 5,
    kIsCoveringIndexFieldNumber = 6,
    kUseForLearnerFieldNumber = 7,
    kRangeKeySortedFieldNumber = 8,
    kLeftFieldCntFieldNumber = 10,
    kRightFieldCntFieldNumber = 11,
    kIsEqFieldNumber = 9,
    kLeftOpenFieldNumber = 12,
    kRightOpenFieldNumber = 13,
    kLikePrefixFieldNumber = 14,
  };
  // repeated .baikaldb.pb.PossibleIndex.Range ranges = 2;
  int ranges_size() const;
  private:
  int _internal_ranges_size() const;
  public:
  void clear_ranges();
  ::baikaldb::pb::PossibleIndex_Range* mutable_ranges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PossibleIndex_Range >*
      mutable_ranges();
  private:
  const ::baikaldb::pb::PossibleIndex_Range& _internal_ranges(int index) const;
  ::baikaldb::pb::PossibleIndex_Range* _internal_add_ranges();
  public:
  const ::baikaldb::pb::PossibleIndex_Range& ranges(int index) const;
  ::baikaldb::pb::PossibleIndex_Range* add_ranges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PossibleIndex_Range >&
      ranges() const;

  // repeated .baikaldb.pb.Expr index_conjuncts = 3;
  int index_conjuncts_size() const;
  private:
  int _internal_index_conjuncts_size() const;
  public:
  void clear_index_conjuncts();
  ::baikaldb::pb::Expr* mutable_index_conjuncts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_index_conjuncts();
  private:
  const ::baikaldb::pb::Expr& _internal_index_conjuncts(int index) const;
  ::baikaldb::pb::Expr* _internal_add_index_conjuncts();
  public:
  const ::baikaldb::pb::Expr& index_conjuncts(int index) const;
  ::baikaldb::pb::Expr* add_index_conjuncts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      index_conjuncts() const;

  // optional .baikaldb.pb.PossibleIndex.SortIndex sort_index = 4;
  bool has_sort_index() const;
  private:
  bool _internal_has_sort_index() const;
  public:
  void clear_sort_index();
  const ::baikaldb::pb::PossibleIndex_SortIndex& sort_index() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::PossibleIndex_SortIndex* release_sort_index();
  ::baikaldb::pb::PossibleIndex_SortIndex* mutable_sort_index();
  void set_allocated_sort_index(::baikaldb::pb::PossibleIndex_SortIndex* sort_index);
  private:
  const ::baikaldb::pb::PossibleIndex_SortIndex& _internal_sort_index() const;
  ::baikaldb::pb::PossibleIndex_SortIndex* _internal_mutable_sort_index();
  public:
  void unsafe_arena_set_allocated_sort_index(
      ::baikaldb::pb::PossibleIndex_SortIndex* sort_index);
  ::baikaldb::pb::PossibleIndex_SortIndex* unsafe_arena_release_sort_index();

  // required int64 index_id = 1;
  bool has_index_id() const;
  private:
  bool _internal_has_index_id() const;
  public:
  void clear_index_id();
  ::PROTOBUF_NAMESPACE_ID::int64 index_id() const;
  void set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_index_id() const;
  void _internal_set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool bool_and = 5;
  bool has_bool_and() const;
  private:
  bool _internal_has_bool_and() const;
  public:
  void clear_bool_and();
  bool bool_and() const;
  void set_bool_and(bool value);
  private:
  bool _internal_bool_and() const;
  void _internal_set_bool_and(bool value);
  public:

  // optional bool is_covering_index = 6;
  bool has_is_covering_index() const;
  private:
  bool _internal_has_is_covering_index() const;
  public:
  void clear_is_covering_index();
  bool is_covering_index() const;
  void set_is_covering_index(bool value);
  private:
  bool _internal_is_covering_index() const;
  void _internal_set_is_covering_index(bool value);
  public:

  // optional bool use_for_learner = 7;
  bool has_use_for_learner() const;
  private:
  bool _internal_has_use_for_learner() const;
  public:
  void clear_use_for_learner();
  bool use_for_learner() const;
  void set_use_for_learner(bool value);
  private:
  bool _internal_use_for_learner() const;
  void _internal_set_use_for_learner(bool value);
  public:

  // optional bool range_key_sorted = 8;
  bool has_range_key_sorted() const;
  private:
  bool _internal_has_range_key_sorted() const;
  public:
  void clear_range_key_sorted();
  bool range_key_sorted() const;
  void set_range_key_sorted(bool value);
  private:
  bool _internal_range_key_sorted() const;
  void _internal_set_range_key_sorted(bool value);
  public:

  // optional int32 left_field_cnt = 10;
  bool has_left_field_cnt() const;
  private:
  bool _internal_has_left_field_cnt() const;
  public:
  void clear_left_field_cnt();
  ::PROTOBUF_NAMESPACE_ID::int32 left_field_cnt() const;
  void set_left_field_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_left_field_cnt() const;
  void _internal_set_left_field_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 right_field_cnt = 11;
  bool has_right_field_cnt() const;
  private:
  bool _internal_has_right_field_cnt() const;
  public:
  void clear_right_field_cnt();
  ::PROTOBUF_NAMESPACE_ID::int32 right_field_cnt() const;
  void set_right_field_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_right_field_cnt() const;
  void _internal_set_right_field_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool is_eq = 9;
  bool has_is_eq() const;
  private:
  bool _internal_has_is_eq() const;
  public:
  void clear_is_eq();
  bool is_eq() const;
  void set_is_eq(bool value);
  private:
  bool _internal_is_eq() const;
  void _internal_set_is_eq(bool value);
  public:

  // optional bool left_open = 12;
  bool has_left_open() const;
  private:
  bool _internal_has_left_open() const;
  public:
  void clear_left_open();
  bool left_open() const;
  void set_left_open(bool value);
  private:
  bool _internal_left_open() const;
  void _internal_set_left_open(bool value);
  public:

  // optional bool right_open = 13;
  bool has_right_open() const;
  private:
  bool _internal_has_right_open() const;
  public:
  void clear_right_open();
  bool right_open() const;
  void set_right_open(bool value);
  private:
  bool _internal_right_open() const;
  void _internal_set_right_open(bool value);
  public:

  // optional bool like_prefix = 14;
  bool has_like_prefix() const;
  private:
  bool _internal_has_like_prefix() const;
  public:
  void clear_like_prefix();
  bool like_prefix() const;
  void set_like_prefix(bool value);
  private:
  bool _internal_like_prefix() const;
  void _internal_set_like_prefix(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.PossibleIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PossibleIndex_Range > ranges_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > index_conjuncts_;
  ::baikaldb::pb::PossibleIndex_SortIndex* sort_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 index_id_;
  bool bool_and_;
  bool is_covering_index_;
  bool use_for_learner_;
  bool range_key_sorted_;
  ::PROTOBUF_NAMESPACE_ID::int32 left_field_cnt_;
  ::PROTOBUF_NAMESPACE_ID::int32 right_field_cnt_;
  bool is_eq_;
  bool left_open_;
  bool right_open_;
  bool like_prefix_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class FulltextIndex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.FulltextIndex) */ {
 public:
  inline FulltextIndex() : FulltextIndex(nullptr) {}
  ~FulltextIndex() override;
  explicit constexpr FulltextIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FulltextIndex(const FulltextIndex& from);
  FulltextIndex(FulltextIndex&& from) noexcept
    : FulltextIndex() {
    *this = ::std::move(from);
  }

  inline FulltextIndex& operator=(const FulltextIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline FulltextIndex& operator=(FulltextIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FulltextIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const FulltextIndex* internal_default_instance() {
    return reinterpret_cast<const FulltextIndex*>(
               &_FulltextIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FulltextIndex& a, FulltextIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(FulltextIndex* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FulltextIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FulltextIndex* New() const final {
    return new FulltextIndex();
  }

  FulltextIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FulltextIndex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FulltextIndex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FulltextIndex& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FulltextIndex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.FulltextIndex";
  }
  protected:
  explicit FulltextIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNestedFulltextIndexesFieldNumber = 3,
    kPossibleIndexFieldNumber = 2,
    kFulltextNodeTypeFieldNumber = 1,
  };
  // repeated .baikaldb.pb.FulltextIndex nested_fulltext_indexes = 3;
  int nested_fulltext_indexes_size() const;
  private:
  int _internal_nested_fulltext_indexes_size() const;
  public:
  void clear_nested_fulltext_indexes();
  ::baikaldb::pb::FulltextIndex* mutable_nested_fulltext_indexes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FulltextIndex >*
      mutable_nested_fulltext_indexes();
  private:
  const ::baikaldb::pb::FulltextIndex& _internal_nested_fulltext_indexes(int index) const;
  ::baikaldb::pb::FulltextIndex* _internal_add_nested_fulltext_indexes();
  public:
  const ::baikaldb::pb::FulltextIndex& nested_fulltext_indexes(int index) const;
  ::baikaldb::pb::FulltextIndex* add_nested_fulltext_indexes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FulltextIndex >&
      nested_fulltext_indexes() const;

  // optional .baikaldb.pb.PossibleIndex possible_index = 2;
  bool has_possible_index() const;
  private:
  bool _internal_has_possible_index() const;
  public:
  void clear_possible_index();
  const ::baikaldb::pb::PossibleIndex& possible_index() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::PossibleIndex* release_possible_index();
  ::baikaldb::pb::PossibleIndex* mutable_possible_index();
  void set_allocated_possible_index(::baikaldb::pb::PossibleIndex* possible_index);
  private:
  const ::baikaldb::pb::PossibleIndex& _internal_possible_index() const;
  ::baikaldb::pb::PossibleIndex* _internal_mutable_possible_index();
  public:
  void unsafe_arena_set_allocated_possible_index(
      ::baikaldb::pb::PossibleIndex* possible_index);
  ::baikaldb::pb::PossibleIndex* unsafe_arena_release_possible_index();

  // optional .baikaldb.pb.FulltextNodeType fulltext_node_type = 1;
  bool has_fulltext_node_type() const;
  private:
  bool _internal_has_fulltext_node_type() const;
  public:
  void clear_fulltext_node_type();
  ::baikaldb::pb::FulltextNodeType fulltext_node_type() const;
  void set_fulltext_node_type(::baikaldb::pb::FulltextNodeType value);
  private:
  ::baikaldb::pb::FulltextNodeType _internal_fulltext_node_type() const;
  void _internal_set_fulltext_node_type(::baikaldb::pb::FulltextNodeType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.FulltextIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FulltextIndex > nested_fulltext_indexes_;
  ::baikaldb::pb::PossibleIndex* possible_index_;
  int fulltext_node_type_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class ScanNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ScanNode) */ {
 public:
  inline ScanNode() : ScanNode(nullptr) {}
  ~ScanNode() override;
  explicit constexpr ScanNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScanNode(const ScanNode& from);
  ScanNode(ScanNode&& from) noexcept
    : ScanNode() {
    *this = ::std::move(from);
  }

  inline ScanNode& operator=(const ScanNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScanNode& operator=(ScanNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScanNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScanNode* internal_default_instance() {
    return reinterpret_cast<const ScanNode*>(
               &_ScanNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ScanNode& a, ScanNode& b) {
    a.Swap(&b);
  }
  inline void Swap(ScanNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScanNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScanNode* New() const final {
    return new ScanNode();
  }

  ScanNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScanNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScanNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ScanNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScanNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ScanNode";
  }
  protected:
  explicit ScanNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexesFieldNumber = 3,
    kUseIndexesFieldNumber = 4,
    kIgnoreIndexesFieldNumber = 6,
    kForceIndexesFieldNumber = 11,
    kLearnerIndexFieldNumber = 12,
    kFulltextIndexFieldNumber = 7,
    kColumnDdlInfoFieldNumber = 14,
    kTableIdFieldNumber = 2,
    kTupleIdFieldNumber = 1,
    kLockFieldNumber = 8,
    kDdlIndexIdFieldNumber = 10,
    kDdlWorkTypeFieldNumber = 13,
    kIsDdlWorkFieldNumber = 9,
    kUseColumnStorageFieldNumber = 17,
    kWattStatsVersionFieldNumber = 15,
    kUnionTupleIdFieldNumber = 16,
    kEngineFieldNumber = 5,
  };
  // repeated bytes indexes = 3;
  int indexes_size() const;
  private:
  int _internal_indexes_size() const;
  public:
  void clear_indexes();
  const std::string& indexes(int index) const;
  std::string* mutable_indexes(int index);
  void set_indexes(int index, const std::string& value);
  void set_indexes(int index, std::string&& value);
  void set_indexes(int index, const char* value);
  void set_indexes(int index, const void* value, size_t size);
  std::string* add_indexes();
  void add_indexes(const std::string& value);
  void add_indexes(std::string&& value);
  void add_indexes(const char* value);
  void add_indexes(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& indexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_indexes();
  private:
  const std::string& _internal_indexes(int index) const;
  std::string* _internal_add_indexes();
  public:

  // repeated int64 use_indexes = 4;
  int use_indexes_size() const;
  private:
  int _internal_use_indexes_size() const;
  public:
  void clear_use_indexes();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_use_indexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_use_indexes() const;
  void _internal_add_use_indexes(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_use_indexes();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 use_indexes(int index) const;
  void set_use_indexes(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_use_indexes(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      use_indexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_use_indexes();

  // repeated int64 ignore_indexes = 6;
  int ignore_indexes_size() const;
  private:
  int _internal_ignore_indexes_size() const;
  public:
  void clear_ignore_indexes();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ignore_indexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_ignore_indexes() const;
  void _internal_add_ignore_indexes(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_ignore_indexes();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 ignore_indexes(int index) const;
  void set_ignore_indexes(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_ignore_indexes(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      ignore_indexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_ignore_indexes();

  // repeated int64 force_indexes = 11;
  int force_indexes_size() const;
  private:
  int _internal_force_indexes_size() const;
  public:
  void clear_force_indexes();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_force_indexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_force_indexes() const;
  void _internal_add_force_indexes(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_force_indexes();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 force_indexes(int index) const;
  void set_force_indexes(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_force_indexes(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      force_indexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_force_indexes();

  // optional bytes learner_index = 12;
  bool has_learner_index() const;
  private:
  bool _internal_has_learner_index() const;
  public:
  void clear_learner_index();
  const std::string& learner_index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_learner_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_learner_index();
  PROTOBUF_MUST_USE_RESULT std::string* release_learner_index();
  void set_allocated_learner_index(std::string* learner_index);
  private:
  const std::string& _internal_learner_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_learner_index(const std::string& value);
  std::string* _internal_mutable_learner_index();
  public:

  // optional .baikaldb.pb.FulltextIndex fulltext_index = 7;
  bool has_fulltext_index() const;
  private:
  bool _internal_has_fulltext_index() const;
  public:
  void clear_fulltext_index();
  const ::baikaldb::pb::FulltextIndex& fulltext_index() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::FulltextIndex* release_fulltext_index();
  ::baikaldb::pb::FulltextIndex* mutable_fulltext_index();
  void set_allocated_fulltext_index(::baikaldb::pb::FulltextIndex* fulltext_index);
  private:
  const ::baikaldb::pb::FulltextIndex& _internal_fulltext_index() const;
  ::baikaldb::pb::FulltextIndex* _internal_mutable_fulltext_index();
  public:
  void unsafe_arena_set_allocated_fulltext_index(
      ::baikaldb::pb::FulltextIndex* fulltext_index);
  ::baikaldb::pb::FulltextIndex* unsafe_arena_release_fulltext_index();

  // optional .baikaldb.pb.ColumnDdlInfo column_ddl_info = 14;
  bool has_column_ddl_info() const;
  private:
  bool _internal_has_column_ddl_info() const;
  public:
  void clear_column_ddl_info();
  const ::baikaldb::pb::ColumnDdlInfo& column_ddl_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::ColumnDdlInfo* release_column_ddl_info();
  ::baikaldb::pb::ColumnDdlInfo* mutable_column_ddl_info();
  void set_allocated_column_ddl_info(::baikaldb::pb::ColumnDdlInfo* column_ddl_info);
  private:
  const ::baikaldb::pb::ColumnDdlInfo& _internal_column_ddl_info() const;
  ::baikaldb::pb::ColumnDdlInfo* _internal_mutable_column_ddl_info();
  public:
  void unsafe_arena_set_allocated_column_ddl_info(
      ::baikaldb::pb::ColumnDdlInfo* column_ddl_info);
  ::baikaldb::pb::ColumnDdlInfo* unsafe_arena_release_column_ddl_info();

  // required int64 table_id = 2;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int32 tuple_id = 1;
  bool has_tuple_id() const;
  private:
  bool _internal_has_tuple_id() const;
  public:
  void clear_tuple_id();
  ::PROTOBUF_NAMESPACE_ID::int32 tuple_id() const;
  void set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tuple_id() const;
  void _internal_set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .baikaldb.pb.LockCmdType lock = 8;
  bool has_lock() const;
  private:
  bool _internal_has_lock() const;
  public:
  void clear_lock();
  ::baikaldb::pb::LockCmdType lock() const;
  void set_lock(::baikaldb::pb::LockCmdType value);
  private:
  ::baikaldb::pb::LockCmdType _internal_lock() const;
  void _internal_set_lock(::baikaldb::pb::LockCmdType value);
  public:

  // optional int64 ddl_index_id = 10;
  bool has_ddl_index_id() const;
  private:
  bool _internal_has_ddl_index_id() const;
  public:
  void clear_ddl_index_id();
  ::PROTOBUF_NAMESPACE_ID::int64 ddl_index_id() const;
  void set_ddl_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ddl_index_id() const;
  void _internal_set_ddl_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.DDLType ddl_work_type = 13;
  bool has_ddl_work_type() const;
  private:
  bool _internal_has_ddl_work_type() const;
  public:
  void clear_ddl_work_type();
  ::baikaldb::pb::DDLType ddl_work_type() const;
  void set_ddl_work_type(::baikaldb::pb::DDLType value);
  private:
  ::baikaldb::pb::DDLType _internal_ddl_work_type() const;
  void _internal_set_ddl_work_type(::baikaldb::pb::DDLType value);
  public:

  // optional bool is_ddl_work = 9;
  bool has_is_ddl_work() const;
  private:
  bool _internal_has_is_ddl_work() const;
  public:
  void clear_is_ddl_work();
  bool is_ddl_work() const;
  void set_is_ddl_work(bool value);
  private:
  bool _internal_is_ddl_work() const;
  void _internal_set_is_ddl_work(bool value);
  public:

  // optional bool use_column_storage = 17;
  bool has_use_column_storage() const;
  private:
  bool _internal_has_use_column_storage() const;
  public:
  void clear_use_column_storage();
  bool use_column_storage() const;
  void set_use_column_storage(bool value);
  private:
  bool _internal_use_column_storage() const;
  void _internal_set_use_column_storage(bool value);
  public:

  // optional uint64 watt_stats_version = 15;
  bool has_watt_stats_version() const;
  private:
  bool _internal_has_watt_stats_version() const;
  public:
  void clear_watt_stats_version();
  ::PROTOBUF_NAMESPACE_ID::uint64 watt_stats_version() const;
  void set_watt_stats_version(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_watt_stats_version() const;
  void _internal_set_watt_stats_version(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int32 union_tuple_id = 16;
  bool has_union_tuple_id() const;
  private:
  bool _internal_has_union_tuple_id() const;
  public:
  void clear_union_tuple_id();
  ::PROTOBUF_NAMESPACE_ID::int32 union_tuple_id() const;
  void set_union_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_union_tuple_id() const;
  void _internal_set_union_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .baikaldb.pb.Engine engine = 5;
  bool has_engine() const;
  private:
  bool _internal_has_engine() const;
  public:
  void clear_engine();
  ::baikaldb::pb::Engine engine() const;
  void set_engine(::baikaldb::pb::Engine value);
  private:
  ::baikaldb::pb::Engine _internal_engine() const;
  void _internal_set_engine(::baikaldb::pb::Engine value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ScanNode)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> indexes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > use_indexes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > ignore_indexes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > force_indexes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr learner_index_;
  ::baikaldb::pb::FulltextIndex* fulltext_index_;
  ::baikaldb::pb::ColumnDdlInfo* column_ddl_info_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 tuple_id_;
  int lock_;
  ::PROTOBUF_NAMESPACE_ID::int64 ddl_index_id_;
  int ddl_work_type_;
  bool is_ddl_work_;
  bool use_column_storage_;
  ::PROTOBUF_NAMESPACE_ID::uint64 watt_stats_version_;
  ::PROTOBUF_NAMESPACE_ID::int32 union_tuple_id_;
  int engine_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class LimitNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.LimitNode) */ {
 public:
  inline LimitNode() : LimitNode(nullptr) {}
  ~LimitNode() override;
  explicit constexpr LimitNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LimitNode(const LimitNode& from);
  LimitNode(LimitNode&& from) noexcept
    : LimitNode() {
    *this = ::std::move(from);
  }

  inline LimitNode& operator=(const LimitNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline LimitNode& operator=(LimitNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LimitNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const LimitNode* internal_default_instance() {
    return reinterpret_cast<const LimitNode*>(
               &_LimitNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LimitNode& a, LimitNode& b) {
    a.Swap(&b);
  }
  inline void Swap(LimitNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LimitNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LimitNode* New() const final {
    return new LimitNode();
  }

  LimitNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LimitNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LimitNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LimitNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LimitNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.LimitNode";
  }
  protected:
  explicit LimitNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetExprFieldNumber = 2,
    kCountExprFieldNumber = 3,
    kOffsetFieldNumber = 1,
  };
  // optional .baikaldb.pb.Expr offset_expr = 2;
  bool has_offset_expr() const;
  private:
  bool _internal_has_offset_expr() const;
  public:
  void clear_offset_expr();
  const ::baikaldb::pb::Expr& offset_expr() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::Expr* release_offset_expr();
  ::baikaldb::pb::Expr* mutable_offset_expr();
  void set_allocated_offset_expr(::baikaldb::pb::Expr* offset_expr);
  private:
  const ::baikaldb::pb::Expr& _internal_offset_expr() const;
  ::baikaldb::pb::Expr* _internal_mutable_offset_expr();
  public:
  void unsafe_arena_set_allocated_offset_expr(
      ::baikaldb::pb::Expr* offset_expr);
  ::baikaldb::pb::Expr* unsafe_arena_release_offset_expr();

  // optional .baikaldb.pb.Expr count_expr = 3;
  bool has_count_expr() const;
  private:
  bool _internal_has_count_expr() const;
  public:
  void clear_count_expr();
  const ::baikaldb::pb::Expr& count_expr() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::Expr* release_count_expr();
  ::baikaldb::pb::Expr* mutable_count_expr();
  void set_allocated_count_expr(::baikaldb::pb::Expr* count_expr);
  private:
  const ::baikaldb::pb::Expr& _internal_count_expr() const;
  ::baikaldb::pb::Expr* _internal_mutable_count_expr();
  public:
  void unsafe_arena_set_allocated_count_expr(
      ::baikaldb::pb::Expr* count_expr);
  ::baikaldb::pb::Expr* unsafe_arena_release_count_expr();

  // optional int64 offset = 1;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.LimitNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::Expr* offset_expr_;
  ::baikaldb::pb::Expr* count_expr_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class SortNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.SortNode) */ {
 public:
  inline SortNode() : SortNode(nullptr) {}
  ~SortNode() override;
  explicit constexpr SortNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SortNode(const SortNode& from);
  SortNode(SortNode&& from) noexcept
    : SortNode() {
    *this = ::std::move(from);
  }

  inline SortNode& operator=(const SortNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline SortNode& operator=(SortNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SortNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const SortNode* internal_default_instance() {
    return reinterpret_cast<const SortNode*>(
               &_SortNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SortNode& a, SortNode& b) {
    a.Swap(&b);
  }
  inline void Swap(SortNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SortNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SortNode* New() const final {
    return new SortNode();
  }

  SortNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SortNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SortNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SortNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SortNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.SortNode";
  }
  protected:
  explicit SortNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOrderExprsFieldNumber = 1,
    kIsAscFieldNumber = 2,
    kIsNullFirstFieldNumber = 3,
    kSlotOrderExprsFieldNumber = 6,
    kTupleIdFieldNumber = 5,
  };
  // repeated .baikaldb.pb.Expr order_exprs = 1;
  int order_exprs_size() const;
  private:
  int _internal_order_exprs_size() const;
  public:
  void clear_order_exprs();
  ::baikaldb::pb::Expr* mutable_order_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_order_exprs();
  private:
  const ::baikaldb::pb::Expr& _internal_order_exprs(int index) const;
  ::baikaldb::pb::Expr* _internal_add_order_exprs();
  public:
  const ::baikaldb::pb::Expr& order_exprs(int index) const;
  ::baikaldb::pb::Expr* add_order_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      order_exprs() const;

  // repeated bool is_asc = 2;
  int is_asc_size() const;
  private:
  int _internal_is_asc_size() const;
  public:
  void clear_is_asc();
  private:
  bool _internal_is_asc(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_is_asc() const;
  void _internal_add_is_asc(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_is_asc();
  public:
  bool is_asc(int index) const;
  void set_is_asc(int index, bool value);
  void add_is_asc(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      is_asc() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_is_asc();

  // repeated bool is_null_first = 3;
  int is_null_first_size() const;
  private:
  int _internal_is_null_first_size() const;
  public:
  void clear_is_null_first();
  private:
  bool _internal_is_null_first(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_is_null_first() const;
  void _internal_add_is_null_first(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_is_null_first();
  public:
  bool is_null_first(int index) const;
  void set_is_null_first(int index, bool value);
  void add_is_null_first(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      is_null_first() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_is_null_first();

  // repeated .baikaldb.pb.Expr slot_order_exprs = 6;
  int slot_order_exprs_size() const;
  private:
  int _internal_slot_order_exprs_size() const;
  public:
  void clear_slot_order_exprs();
  ::baikaldb::pb::Expr* mutable_slot_order_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_slot_order_exprs();
  private:
  const ::baikaldb::pb::Expr& _internal_slot_order_exprs(int index) const;
  ::baikaldb::pb::Expr* _internal_add_slot_order_exprs();
  public:
  const ::baikaldb::pb::Expr& slot_order_exprs(int index) const;
  ::baikaldb::pb::Expr* add_slot_order_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      slot_order_exprs() const;

  // optional int32 tuple_id = 5;
  bool has_tuple_id() const;
  private:
  bool _internal_has_tuple_id() const;
  public:
  void clear_tuple_id();
  ::PROTOBUF_NAMESPACE_ID::int32 tuple_id() const;
  void set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tuple_id() const;
  void _internal_set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.SortNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > order_exprs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > is_asc_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > is_null_first_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > slot_order_exprs_;
  ::PROTOBUF_NAMESPACE_ID::int32 tuple_id_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class AggNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.AggNode) */ {
 public:
  inline AggNode() : AggNode(nullptr) {}
  ~AggNode() override;
  explicit constexpr AggNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggNode(const AggNode& from);
  AggNode(AggNode&& from) noexcept
    : AggNode() {
    *this = ::std::move(from);
  }

  inline AggNode& operator=(const AggNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggNode& operator=(AggNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggNode* internal_default_instance() {
    return reinterpret_cast<const AggNode*>(
               &_AggNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AggNode& a, AggNode& b) {
    a.Swap(&b);
  }
  inline void Swap(AggNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AggNode* New() const final {
    return new AggNode();
  }

  AggNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AggNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.AggNode";
  }
  protected:
  explicit AggNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupExprsFieldNumber = 1,
    kAggFuncsFieldNumber = 2,
    kAggTupleIdFieldNumber = 3,
    kArrowIgnoreTupleIdFieldNumber = 4,
    kIsPushdownFieldNumber = 5,
  };
  // repeated .baikaldb.pb.Expr group_exprs = 1;
  int group_exprs_size() const;
  private:
  int _internal_group_exprs_size() const;
  public:
  void clear_group_exprs();
  ::baikaldb::pb::Expr* mutable_group_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_group_exprs();
  private:
  const ::baikaldb::pb::Expr& _internal_group_exprs(int index) const;
  ::baikaldb::pb::Expr* _internal_add_group_exprs();
  public:
  const ::baikaldb::pb::Expr& group_exprs(int index) const;
  ::baikaldb::pb::Expr* add_group_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      group_exprs() const;

  // repeated .baikaldb.pb.Expr agg_funcs = 2;
  int agg_funcs_size() const;
  private:
  int _internal_agg_funcs_size() const;
  public:
  void clear_agg_funcs();
  ::baikaldb::pb::Expr* mutable_agg_funcs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_agg_funcs();
  private:
  const ::baikaldb::pb::Expr& _internal_agg_funcs(int index) const;
  ::baikaldb::pb::Expr* _internal_add_agg_funcs();
  public:
  const ::baikaldb::pb::Expr& agg_funcs(int index) const;
  ::baikaldb::pb::Expr* add_agg_funcs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      agg_funcs() const;

  // optional int32 agg_tuple_id = 3;
  bool has_agg_tuple_id() const;
  private:
  bool _internal_has_agg_tuple_id() const;
  public:
  void clear_agg_tuple_id();
  ::PROTOBUF_NAMESPACE_ID::int32 agg_tuple_id() const;
  void set_agg_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_agg_tuple_id() const;
  void _internal_set_agg_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 arrow_ignore_tuple_id = 4;
  bool has_arrow_ignore_tuple_id() const;
  private:
  bool _internal_has_arrow_ignore_tuple_id() const;
  public:
  void clear_arrow_ignore_tuple_id();
  ::PROTOBUF_NAMESPACE_ID::int32 arrow_ignore_tuple_id() const;
  void set_arrow_ignore_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_arrow_ignore_tuple_id() const;
  void _internal_set_arrow_ignore_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool is_pushdown = 5;
  bool has_is_pushdown() const;
  private:
  bool _internal_has_is_pushdown() const;
  public:
  void clear_is_pushdown();
  bool is_pushdown() const;
  void set_is_pushdown(bool value);
  private:
  bool _internal_is_pushdown() const;
  void _internal_set_is_pushdown(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.AggNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > group_exprs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > agg_funcs_;
  ::PROTOBUF_NAMESPACE_ID::int32 agg_tuple_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 arrow_ignore_tuple_id_;
  bool is_pushdown_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class FilterNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.FilterNode) */ {
 public:
  inline FilterNode() : FilterNode(nullptr) {}
  ~FilterNode() override;
  explicit constexpr FilterNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FilterNode(const FilterNode& from);
  FilterNode(FilterNode&& from) noexcept
    : FilterNode() {
    *this = ::std::move(from);
  }

  inline FilterNode& operator=(const FilterNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilterNode& operator=(FilterNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilterNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilterNode* internal_default_instance() {
    return reinterpret_cast<const FilterNode*>(
               &_FilterNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FilterNode& a, FilterNode& b) {
    a.Swap(&b);
  }
  inline void Swap(FilterNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilterNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FilterNode* New() const final {
    return new FilterNode();
  }

  FilterNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FilterNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FilterNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FilterNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.FilterNode";
  }
  protected:
  explicit FilterNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConjunctsFieldNumber = 1,
    kConjunctsLearnerFieldNumber = 2,
  };
  // repeated .baikaldb.pb.Expr conjuncts = 1;
  int conjuncts_size() const;
  private:
  int _internal_conjuncts_size() const;
  public:
  void clear_conjuncts();
  ::baikaldb::pb::Expr* mutable_conjuncts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_conjuncts();
  private:
  const ::baikaldb::pb::Expr& _internal_conjuncts(int index) const;
  ::baikaldb::pb::Expr* _internal_add_conjuncts();
  public:
  const ::baikaldb::pb::Expr& conjuncts(int index) const;
  ::baikaldb::pb::Expr* add_conjuncts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      conjuncts() const;

  // repeated .baikaldb.pb.Expr conjuncts_learner = 2;
  int conjuncts_learner_size() const;
  private:
  int _internal_conjuncts_learner_size() const;
  public:
  void clear_conjuncts_learner();
  ::baikaldb::pb::Expr* mutable_conjuncts_learner(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_conjuncts_learner();
  private:
  const ::baikaldb::pb::Expr& _internal_conjuncts_learner(int index) const;
  ::baikaldb::pb::Expr* _internal_add_conjuncts_learner();
  public:
  const ::baikaldb::pb::Expr& conjuncts_learner(int index) const;
  ::baikaldb::pb::Expr* add_conjuncts_learner();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      conjuncts_learner() const;

  // @@protoc_insertion_point(class_scope:baikaldb.pb.FilterNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > conjuncts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > conjuncts_learner_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class DualScanNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.DualScanNode) */ {
 public:
  inline DualScanNode() : DualScanNode(nullptr) {}
  ~DualScanNode() override;
  explicit constexpr DualScanNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DualScanNode(const DualScanNode& from);
  DualScanNode(DualScanNode&& from) noexcept
    : DualScanNode() {
    *this = ::std::move(from);
  }

  inline DualScanNode& operator=(const DualScanNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline DualScanNode& operator=(DualScanNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DualScanNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const DualScanNode* internal_default_instance() {
    return reinterpret_cast<const DualScanNode*>(
               &_DualScanNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DualScanNode& a, DualScanNode& b) {
    a.Swap(&b);
  }
  inline void Swap(DualScanNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DualScanNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DualScanNode* New() const final {
    return new DualScanNode();
  }

  DualScanNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DualScanNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DualScanNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DualScanNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DualScanNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.DualScanNode";
  }
  protected:
  explicit DualScanNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDerivedTableProjectionsFieldNumber = 2,
    kSlotColumnFieldNumber = 4,
    kDerivedTableProjectionsAggOrWindowVecFieldNumber = 5,
    kAggTupleIdPairFieldNumber = 6,
    kAggSlotIdsFieldNumber = 7,
    kMultiDistinctAggSlotIdsFieldNumber = 8,
    kSubQueryNodeFieldNumber = 1,
    kRuntimeStateFieldNumber = 3,
  };
  // repeated .baikaldb.pb.Expr derived_table_projections = 2;
  int derived_table_projections_size() const;
  private:
  int _internal_derived_table_projections_size() const;
  public:
  void clear_derived_table_projections();
  ::baikaldb::pb::Expr* mutable_derived_table_projections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_derived_table_projections();
  private:
  const ::baikaldb::pb::Expr& _internal_derived_table_projections(int index) const;
  ::baikaldb::pb::Expr* _internal_add_derived_table_projections();
  public:
  const ::baikaldb::pb::Expr& derived_table_projections(int index) const;
  ::baikaldb::pb::Expr* add_derived_table_projections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      derived_table_projections() const;

  // repeated .baikaldb.pb.SlotColumn slot_column = 4;
  int slot_column_size() const;
  private:
  int _internal_slot_column_size() const;
  public:
  void clear_slot_column();
  ::baikaldb::pb::SlotColumn* mutable_slot_column(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotColumn >*
      mutable_slot_column();
  private:
  const ::baikaldb::pb::SlotColumn& _internal_slot_column(int index) const;
  ::baikaldb::pb::SlotColumn* _internal_add_slot_column();
  public:
  const ::baikaldb::pb::SlotColumn& slot_column(int index) const;
  ::baikaldb::pb::SlotColumn* add_slot_column();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotColumn >&
      slot_column() const;

  // repeated bool derived_table_projections_agg_or_window_vec = 5;
  int derived_table_projections_agg_or_window_vec_size() const;
  private:
  int _internal_derived_table_projections_agg_or_window_vec_size() const;
  public:
  void clear_derived_table_projections_agg_or_window_vec();
  private:
  bool _internal_derived_table_projections_agg_or_window_vec(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_derived_table_projections_agg_or_window_vec() const;
  void _internal_add_derived_table_projections_agg_or_window_vec(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_derived_table_projections_agg_or_window_vec();
  public:
  bool derived_table_projections_agg_or_window_vec(int index) const;
  void set_derived_table_projections_agg_or_window_vec(int index, bool value);
  void add_derived_table_projections_agg_or_window_vec(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      derived_table_projections_agg_or_window_vec() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_derived_table_projections_agg_or_window_vec();

  // repeated int32 agg_tuple_id_pair = 6;
  int agg_tuple_id_pair_size() const;
  private:
  int _internal_agg_tuple_id_pair_size() const;
  public:
  void clear_agg_tuple_id_pair();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_agg_tuple_id_pair(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_agg_tuple_id_pair() const;
  void _internal_add_agg_tuple_id_pair(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_agg_tuple_id_pair();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 agg_tuple_id_pair(int index) const;
  void set_agg_tuple_id_pair(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_agg_tuple_id_pair(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      agg_tuple_id_pair() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_agg_tuple_id_pair();

  // repeated int32 agg_slot_ids = 7;
  int agg_slot_ids_size() const;
  private:
  int _internal_agg_slot_ids_size() const;
  public:
  void clear_agg_slot_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_agg_slot_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_agg_slot_ids() const;
  void _internal_add_agg_slot_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_agg_slot_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 agg_slot_ids(int index) const;
  void set_agg_slot_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_agg_slot_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      agg_slot_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_agg_slot_ids();

  // repeated int32 multi_distinct_agg_slot_ids = 8;
  int multi_distinct_agg_slot_ids_size() const;
  private:
  int _internal_multi_distinct_agg_slot_ids_size() const;
  public:
  void clear_multi_distinct_agg_slot_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_multi_distinct_agg_slot_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_multi_distinct_agg_slot_ids() const;
  void _internal_add_multi_distinct_agg_slot_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_multi_distinct_agg_slot_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 multi_distinct_agg_slot_ids(int index) const;
  void set_multi_distinct_agg_slot_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_multi_distinct_agg_slot_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      multi_distinct_agg_slot_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_multi_distinct_agg_slot_ids();

  // optional .baikaldb.pb.Plan sub_query_node = 1;
  bool has_sub_query_node() const;
  private:
  bool _internal_has_sub_query_node() const;
  public:
  void clear_sub_query_node();
  const ::baikaldb::pb::Plan& sub_query_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::Plan* release_sub_query_node();
  ::baikaldb::pb::Plan* mutable_sub_query_node();
  void set_allocated_sub_query_node(::baikaldb::pb::Plan* sub_query_node);
  private:
  const ::baikaldb::pb::Plan& _internal_sub_query_node() const;
  ::baikaldb::pb::Plan* _internal_mutable_sub_query_node();
  public:
  void unsafe_arena_set_allocated_sub_query_node(
      ::baikaldb::pb::Plan* sub_query_node);
  ::baikaldb::pb::Plan* unsafe_arena_release_sub_query_node();

  // optional .baikaldb.pb.RuntimeState runtime_state = 3;
  bool has_runtime_state() const;
  private:
  bool _internal_has_runtime_state() const;
  public:
  void clear_runtime_state();
  const ::baikaldb::pb::RuntimeState& runtime_state() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RuntimeState* release_runtime_state();
  ::baikaldb::pb::RuntimeState* mutable_runtime_state();
  void set_allocated_runtime_state(::baikaldb::pb::RuntimeState* runtime_state);
  private:
  const ::baikaldb::pb::RuntimeState& _internal_runtime_state() const;
  ::baikaldb::pb::RuntimeState* _internal_mutable_runtime_state();
  public:
  void unsafe_arena_set_allocated_runtime_state(
      ::baikaldb::pb::RuntimeState* runtime_state);
  ::baikaldb::pb::RuntimeState* unsafe_arena_release_runtime_state();

  // @@protoc_insertion_point(class_scope:baikaldb.pb.DualScanNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > derived_table_projections_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotColumn > slot_column_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > derived_table_projections_agg_or_window_vec_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > agg_tuple_id_pair_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > agg_slot_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > multi_distinct_agg_slot_ids_;
  ::baikaldb::pb::Plan* sub_query_node_;
  ::baikaldb::pb::RuntimeState* runtime_state_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class JoinNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.JoinNode) */ {
 public:
  inline JoinNode() : JoinNode(nullptr) {}
  ~JoinNode() override;
  explicit constexpr JoinNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinNode(const JoinNode& from);
  JoinNode(JoinNode&& from) noexcept
    : JoinNode() {
    *this = ::std::move(from);
  }

  inline JoinNode& operator=(const JoinNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinNode& operator=(JoinNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinNode* internal_default_instance() {
    return reinterpret_cast<const JoinNode*>(
               &_JoinNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(JoinNode& a, JoinNode& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JoinNode* New() const final {
    return new JoinNode();
  }

  JoinNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JoinNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const JoinNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.JoinNode";
  }
  protected:
  explicit JoinNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionsFieldNumber = 2,
    kUsingClosFieldNumber = 3,
    kLeftTupleIdsFieldNumber = 4,
    kLeftTableIdsFieldNumber = 5,
    kRightTupleIdsFieldNumber = 6,
    kRightTableIdsFieldNumber = 7,
    kJoinTypeFieldNumber = 1,
    kUseIndexJoinFieldNumber = 8,
  };
  // repeated .baikaldb.pb.Expr conditions = 2;
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;
  public:
  void clear_conditions();
  ::baikaldb::pb::Expr* mutable_conditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_conditions();
  private:
  const ::baikaldb::pb::Expr& _internal_conditions(int index) const;
  ::baikaldb::pb::Expr* _internal_add_conditions();
  public:
  const ::baikaldb::pb::Expr& conditions(int index) const;
  ::baikaldb::pb::Expr* add_conditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      conditions() const;

  // repeated string using_clos = 3;
  int using_clos_size() const;
  private:
  int _internal_using_clos_size() const;
  public:
  void clear_using_clos();
  const std::string& using_clos(int index) const;
  std::string* mutable_using_clos(int index);
  void set_using_clos(int index, const std::string& value);
  void set_using_clos(int index, std::string&& value);
  void set_using_clos(int index, const char* value);
  void set_using_clos(int index, const char* value, size_t size);
  std::string* add_using_clos();
  void add_using_clos(const std::string& value);
  void add_using_clos(std::string&& value);
  void add_using_clos(const char* value);
  void add_using_clos(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& using_clos() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_using_clos();
  private:
  const std::string& _internal_using_clos(int index) const;
  std::string* _internal_add_using_clos();
  public:

  // repeated int32 left_tuple_ids = 4;
  int left_tuple_ids_size() const;
  private:
  int _internal_left_tuple_ids_size() const;
  public:
  void clear_left_tuple_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_left_tuple_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_left_tuple_ids() const;
  void _internal_add_left_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_left_tuple_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 left_tuple_ids(int index) const;
  void set_left_tuple_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_left_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      left_tuple_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_left_tuple_ids();

  // repeated int64 left_table_ids = 5;
  int left_table_ids_size() const;
  private:
  int _internal_left_table_ids_size() const;
  public:
  void clear_left_table_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_left_table_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_left_table_ids() const;
  void _internal_add_left_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_left_table_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 left_table_ids(int index) const;
  void set_left_table_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_left_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      left_table_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_left_table_ids();

  // repeated int32 right_tuple_ids = 6;
  int right_tuple_ids_size() const;
  private:
  int _internal_right_tuple_ids_size() const;
  public:
  void clear_right_tuple_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_right_tuple_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_right_tuple_ids() const;
  void _internal_add_right_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_right_tuple_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 right_tuple_ids(int index) const;
  void set_right_tuple_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_right_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      right_tuple_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_right_tuple_ids();

  // repeated int64 right_table_ids = 7;
  int right_table_ids_size() const;
  private:
  int _internal_right_table_ids_size() const;
  public:
  void clear_right_table_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_right_table_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_right_table_ids() const;
  void _internal_add_right_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_right_table_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 right_table_ids(int index) const;
  void set_right_table_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_right_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      right_table_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_right_table_ids();

  // required .baikaldb.pb.JoinType join_type = 1;
  bool has_join_type() const;
  private:
  bool _internal_has_join_type() const;
  public:
  void clear_join_type();
  ::baikaldb::pb::JoinType join_type() const;
  void set_join_type(::baikaldb::pb::JoinType value);
  private:
  ::baikaldb::pb::JoinType _internal_join_type() const;
  void _internal_set_join_type(::baikaldb::pb::JoinType value);
  public:

  // optional bool use_index_join = 8;
  bool has_use_index_join() const;
  private:
  bool _internal_has_use_index_join() const;
  public:
  void clear_use_index_join();
  bool use_index_join() const;
  void set_use_index_join(bool value);
  private:
  bool _internal_use_index_join() const;
  void _internal_set_use_index_join(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.JoinNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > conditions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> using_clos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > left_tuple_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > left_table_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > right_tuple_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > right_table_ids_;
  int join_type_;
  bool use_index_join_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class ApplyNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ApplyNode) */ {
 public:
  inline ApplyNode() : ApplyNode(nullptr) {}
  ~ApplyNode() override;
  explicit constexpr ApplyNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyNode(const ApplyNode& from);
  ApplyNode(ApplyNode&& from) noexcept
    : ApplyNode() {
    *this = ::std::move(from);
  }

  inline ApplyNode& operator=(const ApplyNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyNode& operator=(ApplyNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyNode* internal_default_instance() {
    return reinterpret_cast<const ApplyNode*>(
               &_ApplyNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ApplyNode& a, ApplyNode& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApplyNode* New() const final {
    return new ApplyNode();
  }

  ApplyNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApplyNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ApplyNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ApplyNode";
  }
  protected:
  explicit ApplyNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionsFieldNumber = 2,
    kLeftTupleIdsFieldNumber = 4,
    kLeftTableIdsFieldNumber = 5,
    kRightTupleIdsFieldNumber = 6,
    kRightTableIdsFieldNumber = 7,
    kJoinTypeFieldNumber = 1,
    kCompareTypeFieldNumber = 9,
    kMaxOneRowFieldNumber = 8,
    kIsSelectFieldFieldNumber = 10,
  };
  // repeated .baikaldb.pb.Expr conditions = 2;
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;
  public:
  void clear_conditions();
  ::baikaldb::pb::Expr* mutable_conditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_conditions();
  private:
  const ::baikaldb::pb::Expr& _internal_conditions(int index) const;
  ::baikaldb::pb::Expr* _internal_add_conditions();
  public:
  const ::baikaldb::pb::Expr& conditions(int index) const;
  ::baikaldb::pb::Expr* add_conditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      conditions() const;

  // repeated int32 left_tuple_ids = 4;
  int left_tuple_ids_size() const;
  private:
  int _internal_left_tuple_ids_size() const;
  public:
  void clear_left_tuple_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_left_tuple_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_left_tuple_ids() const;
  void _internal_add_left_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_left_tuple_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 left_tuple_ids(int index) const;
  void set_left_tuple_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_left_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      left_tuple_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_left_tuple_ids();

  // repeated int64 left_table_ids = 5;
  int left_table_ids_size() const;
  private:
  int _internal_left_table_ids_size() const;
  public:
  void clear_left_table_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_left_table_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_left_table_ids() const;
  void _internal_add_left_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_left_table_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 left_table_ids(int index) const;
  void set_left_table_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_left_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      left_table_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_left_table_ids();

  // repeated int32 right_tuple_ids = 6;
  int right_tuple_ids_size() const;
  private:
  int _internal_right_tuple_ids_size() const;
  public:
  void clear_right_tuple_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_right_tuple_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_right_tuple_ids() const;
  void _internal_add_right_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_right_tuple_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 right_tuple_ids(int index) const;
  void set_right_tuple_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_right_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      right_tuple_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_right_tuple_ids();

  // repeated int64 right_table_ids = 7;
  int right_table_ids_size() const;
  private:
  int _internal_right_table_ids_size() const;
  public:
  void clear_right_table_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_right_table_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_right_table_ids() const;
  void _internal_add_right_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_right_table_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 right_table_ids(int index) const;
  void set_right_table_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_right_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      right_table_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_right_table_ids();

  // required .baikaldb.pb.JoinType join_type = 1;
  bool has_join_type() const;
  private:
  bool _internal_has_join_type() const;
  public:
  void clear_join_type();
  ::baikaldb::pb::JoinType join_type() const;
  void set_join_type(::baikaldb::pb::JoinType value);
  private:
  ::baikaldb::pb::JoinType _internal_join_type() const;
  void _internal_set_join_type(::baikaldb::pb::JoinType value);
  public:

  // optional .baikaldb.pb.CompareType compare_type = 9;
  bool has_compare_type() const;
  private:
  bool _internal_has_compare_type() const;
  public:
  void clear_compare_type();
  ::baikaldb::pb::CompareType compare_type() const;
  void set_compare_type(::baikaldb::pb::CompareType value);
  private:
  ::baikaldb::pb::CompareType _internal_compare_type() const;
  void _internal_set_compare_type(::baikaldb::pb::CompareType value);
  public:

  // optional bool max_one_row = 8;
  bool has_max_one_row() const;
  private:
  bool _internal_has_max_one_row() const;
  public:
  void clear_max_one_row();
  bool max_one_row() const;
  void set_max_one_row(bool value);
  private:
  bool _internal_max_one_row() const;
  void _internal_set_max_one_row(bool value);
  public:

  // optional bool is_select_field = 10;
  bool has_is_select_field() const;
  private:
  bool _internal_has_is_select_field() const;
  public:
  void clear_is_select_field();
  bool is_select_field() const;
  void set_is_select_field(bool value);
  private:
  bool _internal_is_select_field() const;
  void _internal_set_is_select_field(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ApplyNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > conditions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > left_tuple_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > left_table_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > right_tuple_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > right_table_ids_;
  int join_type_;
  int compare_type_;
  bool max_one_row_;
  bool is_select_field_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class FetcherNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.FetcherNode) */ {
 public:
  inline FetcherNode() : FetcherNode(nullptr) {}
  ~FetcherNode() override;
  explicit constexpr FetcherNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetcherNode(const FetcherNode& from);
  FetcherNode(FetcherNode&& from) noexcept
    : FetcherNode() {
    *this = ::std::move(from);
  }

  inline FetcherNode& operator=(const FetcherNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetcherNode& operator=(FetcherNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetcherNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetcherNode* internal_default_instance() {
    return reinterpret_cast<const FetcherNode*>(
               &_FetcherNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(FetcherNode& a, FetcherNode& b) {
    a.Swap(&b);
  }
  inline void Swap(FetcherNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetcherNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FetcherNode* New() const final {
    return new FetcherNode();
  }

  FetcherNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FetcherNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetcherNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FetcherNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetcherNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.FetcherNode";
  }
  protected:
  explicit FetcherNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotOrderExprsFieldNumber = 3,
    kIsAscFieldNumber = 4,
    kIsNullFirstFieldNumber = 5,
    kOpTypeFieldNumber = 1,
  };
  // repeated .baikaldb.pb.Expr slot_order_exprs = 3;
  int slot_order_exprs_size() const;
  private:
  int _internal_slot_order_exprs_size() const;
  public:
  void clear_slot_order_exprs();
  ::baikaldb::pb::Expr* mutable_slot_order_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_slot_order_exprs();
  private:
  const ::baikaldb::pb::Expr& _internal_slot_order_exprs(int index) const;
  ::baikaldb::pb::Expr* _internal_add_slot_order_exprs();
  public:
  const ::baikaldb::pb::Expr& slot_order_exprs(int index) const;
  ::baikaldb::pb::Expr* add_slot_order_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      slot_order_exprs() const;

  // repeated bool is_asc = 4;
  int is_asc_size() const;
  private:
  int _internal_is_asc_size() const;
  public:
  void clear_is_asc();
  private:
  bool _internal_is_asc(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_is_asc() const;
  void _internal_add_is_asc(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_is_asc();
  public:
  bool is_asc(int index) const;
  void set_is_asc(int index, bool value);
  void add_is_asc(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      is_asc() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_is_asc();

  // repeated bool is_null_first = 5;
  int is_null_first_size() const;
  private:
  int _internal_is_null_first_size() const;
  public:
  void clear_is_null_first();
  private:
  bool _internal_is_null_first(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_is_null_first() const;
  void _internal_add_is_null_first(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_is_null_first();
  public:
  bool is_null_first(int index) const;
  void set_is_null_first(int index, bool value);
  void add_is_null_first(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      is_null_first() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_is_null_first();

  // required .baikaldb.pb.OpType op_type = 1;
  bool has_op_type() const;
  private:
  bool _internal_has_op_type() const;
  public:
  void clear_op_type();
  ::baikaldb::pb::OpType op_type() const;
  void set_op_type(::baikaldb::pb::OpType value);
  private:
  ::baikaldb::pb::OpType _internal_op_type() const;
  void _internal_set_op_type(::baikaldb::pb::OpType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.FetcherNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > slot_order_exprs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > is_asc_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > is_null_first_;
  int op_type_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class InsertNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.InsertNode) */ {
 public:
  inline InsertNode() : InsertNode(nullptr) {}
  ~InsertNode() override;
  explicit constexpr InsertNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertNode(const InsertNode& from);
  InsertNode(InsertNode&& from) noexcept
    : InsertNode() {
    *this = ::std::move(from);
  }

  inline InsertNode& operator=(const InsertNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertNode& operator=(InsertNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertNode* internal_default_instance() {
    return reinterpret_cast<const InsertNode*>(
               &_InsertNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(InsertNode& a, InsertNode& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertNode* New() const final {
    return new InsertNode();
  }

  InsertNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InsertNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.InsertNode";
  }
  protected:
  explicit InsertNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordsFieldNumber = 2,
    kUpdateSlotsFieldNumber = 4,
    kUpdateExprsFieldNumber = 5,
    kFieldIdsFieldNumber = 9,
    kInsertValuesFieldNumber = 10,
    kTableIdFieldNumber = 1,
    kTupleIdFieldNumber = 6,
    kValuesTupleIdFieldNumber = 7,
    kRowTtlDurationFieldNumber = 11,
    kDdlIndexIdFieldNumber = 13,
    kWattStatsVersionFieldNumber = 15,
    kNeedIgnoreFieldNumber = 3,
    kIsReplaceFieldNumber = 8,
    kDdlNeedWriteFieldNumber = 12,
    kIsMergeFieldNumber = 14,
  };
  // repeated bytes records = 2;
  int records_size() const;
  private:
  int _internal_records_size() const;
  public:
  void clear_records();
  const std::string& records(int index) const;
  std::string* mutable_records(int index);
  void set_records(int index, const std::string& value);
  void set_records(int index, std::string&& value);
  void set_records(int index, const char* value);
  void set_records(int index, const void* value, size_t size);
  std::string* add_records();
  void add_records(const std::string& value);
  void add_records(std::string&& value);
  void add_records(const char* value);
  void add_records(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& records() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_records();
  private:
  const std::string& _internal_records(int index) const;
  std::string* _internal_add_records();
  public:

  // repeated .baikaldb.pb.SlotDescriptor update_slots = 4;
  int update_slots_size() const;
  private:
  int _internal_update_slots_size() const;
  public:
  void clear_update_slots();
  ::baikaldb::pb::SlotDescriptor* mutable_update_slots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >*
      mutable_update_slots();
  private:
  const ::baikaldb::pb::SlotDescriptor& _internal_update_slots(int index) const;
  ::baikaldb::pb::SlotDescriptor* _internal_add_update_slots();
  public:
  const ::baikaldb::pb::SlotDescriptor& update_slots(int index) const;
  ::baikaldb::pb::SlotDescriptor* add_update_slots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >&
      update_slots() const;

  // repeated .baikaldb.pb.Expr update_exprs = 5;
  int update_exprs_size() const;
  private:
  int _internal_update_exprs_size() const;
  public:
  void clear_update_exprs();
  ::baikaldb::pb::Expr* mutable_update_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_update_exprs();
  private:
  const ::baikaldb::pb::Expr& _internal_update_exprs(int index) const;
  ::baikaldb::pb::Expr* _internal_add_update_exprs();
  public:
  const ::baikaldb::pb::Expr& update_exprs(int index) const;
  ::baikaldb::pb::Expr* add_update_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      update_exprs() const;

  // repeated int32 field_ids = 9;
  int field_ids_size() const;
  private:
  int _internal_field_ids_size() const;
  public:
  void clear_field_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_field_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_field_ids() const;
  void _internal_add_field_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_field_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 field_ids(int index) const;
  void set_field_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_field_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      field_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_field_ids();

  // repeated .baikaldb.pb.Expr insert_values = 10;
  int insert_values_size() const;
  private:
  int _internal_insert_values_size() const;
  public:
  void clear_insert_values();
  ::baikaldb::pb::Expr* mutable_insert_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_insert_values();
  private:
  const ::baikaldb::pb::Expr& _internal_insert_values(int index) const;
  ::baikaldb::pb::Expr* _internal_add_insert_values();
  public:
  const ::baikaldb::pb::Expr& insert_values(int index) const;
  ::baikaldb::pb::Expr* add_insert_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      insert_values() const;

  // required int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 tuple_id = 6;
  bool has_tuple_id() const;
  private:
  bool _internal_has_tuple_id() const;
  public:
  void clear_tuple_id();
  ::PROTOBUF_NAMESPACE_ID::int32 tuple_id() const;
  void set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tuple_id() const;
  void _internal_set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 values_tuple_id = 7;
  bool has_values_tuple_id() const;
  private:
  bool _internal_has_values_tuple_id() const;
  public:
  void clear_values_tuple_id();
  ::PROTOBUF_NAMESPACE_ID::int32 values_tuple_id() const;
  void set_values_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_values_tuple_id() const;
  void _internal_set_values_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int64 row_ttl_duration = 11;
  bool has_row_ttl_duration() const;
  private:
  bool _internal_has_row_ttl_duration() const;
  public:
  void clear_row_ttl_duration();
  ::PROTOBUF_NAMESPACE_ID::int64 row_ttl_duration() const;
  void set_row_ttl_duration(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_row_ttl_duration() const;
  void _internal_set_row_ttl_duration(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 ddl_index_id = 13;
  bool has_ddl_index_id() const;
  private:
  bool _internal_has_ddl_index_id() const;
  public:
  void clear_ddl_index_id();
  ::PROTOBUF_NAMESPACE_ID::int64 ddl_index_id() const;
  void set_ddl_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ddl_index_id() const;
  void _internal_set_ddl_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint64 watt_stats_version = 15;
  bool has_watt_stats_version() const;
  private:
  bool _internal_has_watt_stats_version() const;
  public:
  void clear_watt_stats_version();
  ::PROTOBUF_NAMESPACE_ID::uint64 watt_stats_version() const;
  void set_watt_stats_version(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_watt_stats_version() const;
  void _internal_set_watt_stats_version(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool need_ignore = 3;
  bool has_need_ignore() const;
  private:
  bool _internal_has_need_ignore() const;
  public:
  void clear_need_ignore();
  bool need_ignore() const;
  void set_need_ignore(bool value);
  private:
  bool _internal_need_ignore() const;
  void _internal_set_need_ignore(bool value);
  public:

  // optional bool is_replace = 8;
  bool has_is_replace() const;
  private:
  bool _internal_has_is_replace() const;
  public:
  void clear_is_replace();
  bool is_replace() const;
  void set_is_replace(bool value);
  private:
  bool _internal_is_replace() const;
  void _internal_set_is_replace(bool value);
  public:

  // optional bool ddl_need_write = 12;
  bool has_ddl_need_write() const;
  private:
  bool _internal_has_ddl_need_write() const;
  public:
  void clear_ddl_need_write();
  bool ddl_need_write() const;
  void set_ddl_need_write(bool value);
  private:
  bool _internal_ddl_need_write() const;
  void _internal_set_ddl_need_write(bool value);
  public:

  // optional bool is_merge = 14;
  bool has_is_merge() const;
  private:
  bool _internal_has_is_merge() const;
  public:
  void clear_is_merge();
  bool is_merge() const;
  void set_is_merge(bool value);
  private:
  bool _internal_is_merge() const;
  void _internal_set_is_merge(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.InsertNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> records_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor > update_slots_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > update_exprs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > field_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > insert_values_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 tuple_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 values_tuple_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 row_ttl_duration_;
  ::PROTOBUF_NAMESPACE_ID::int64 ddl_index_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 watt_stats_version_;
  bool need_ignore_;
  bool is_replace_;
  bool ddl_need_write_;
  bool is_merge_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class LockPrimaryNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.LockPrimaryNode) */ {
 public:
  inline LockPrimaryNode() : LockPrimaryNode(nullptr) {}
  ~LockPrimaryNode() override;
  explicit constexpr LockPrimaryNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LockPrimaryNode(const LockPrimaryNode& from);
  LockPrimaryNode(LockPrimaryNode&& from) noexcept
    : LockPrimaryNode() {
    *this = ::std::move(from);
  }

  inline LockPrimaryNode& operator=(const LockPrimaryNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline LockPrimaryNode& operator=(LockPrimaryNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LockPrimaryNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const LockPrimaryNode* internal_default_instance() {
    return reinterpret_cast<const LockPrimaryNode*>(
               &_LockPrimaryNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LockPrimaryNode& a, LockPrimaryNode& b) {
    a.Swap(&b);
  }
  inline void Swap(LockPrimaryNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LockPrimaryNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LockPrimaryNode* New() const final {
    return new LockPrimaryNode();
  }

  LockPrimaryNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LockPrimaryNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LockPrimaryNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LockPrimaryNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockPrimaryNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.LockPrimaryNode";
  }
  protected:
  explicit LockPrimaryNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPutRecordsFieldNumber = 3,
    kDeleteRecordsFieldNumber = 4,
    kAffectIndexIdsFieldNumber = 6,
    kConjunctsFieldNumber = 8,
    kTableIdFieldNumber = 1,
    kRowTtlDurationSFieldNumber = 7,
    kLockTypeFieldNumber = 2,
    kAffectPrimaryFieldNumber = 5,
  };
  // repeated bytes put_records = 3;
  int put_records_size() const;
  private:
  int _internal_put_records_size() const;
  public:
  void clear_put_records();
  const std::string& put_records(int index) const;
  std::string* mutable_put_records(int index);
  void set_put_records(int index, const std::string& value);
  void set_put_records(int index, std::string&& value);
  void set_put_records(int index, const char* value);
  void set_put_records(int index, const void* value, size_t size);
  std::string* add_put_records();
  void add_put_records(const std::string& value);
  void add_put_records(std::string&& value);
  void add_put_records(const char* value);
  void add_put_records(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& put_records() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_put_records();
  private:
  const std::string& _internal_put_records(int index) const;
  std::string* _internal_add_put_records();
  public:

  // repeated bytes delete_records = 4;
  int delete_records_size() const;
  private:
  int _internal_delete_records_size() const;
  public:
  void clear_delete_records();
  const std::string& delete_records(int index) const;
  std::string* mutable_delete_records(int index);
  void set_delete_records(int index, const std::string& value);
  void set_delete_records(int index, std::string&& value);
  void set_delete_records(int index, const char* value);
  void set_delete_records(int index, const void* value, size_t size);
  std::string* add_delete_records();
  void add_delete_records(const std::string& value);
  void add_delete_records(std::string&& value);
  void add_delete_records(const char* value);
  void add_delete_records(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& delete_records() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_delete_records();
  private:
  const std::string& _internal_delete_records(int index) const;
  std::string* _internal_add_delete_records();
  public:

  // repeated int64 affect_index_ids = 6;
  int affect_index_ids_size() const;
  private:
  int _internal_affect_index_ids_size() const;
  public:
  void clear_affect_index_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_affect_index_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_affect_index_ids() const;
  void _internal_add_affect_index_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_affect_index_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 affect_index_ids(int index) const;
  void set_affect_index_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_affect_index_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      affect_index_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_affect_index_ids();

  // repeated .baikaldb.pb.Expr conjuncts = 8;
  int conjuncts_size() const;
  private:
  int _internal_conjuncts_size() const;
  public:
  void clear_conjuncts();
  ::baikaldb::pb::Expr* mutable_conjuncts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_conjuncts();
  private:
  const ::baikaldb::pb::Expr& _internal_conjuncts(int index) const;
  ::baikaldb::pb::Expr* _internal_add_conjuncts();
  public:
  const ::baikaldb::pb::Expr& conjuncts(int index) const;
  ::baikaldb::pb::Expr* add_conjuncts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      conjuncts() const;

  // required int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 row_ttl_duration_s = 7;
  bool has_row_ttl_duration_s() const;
  private:
  bool _internal_has_row_ttl_duration_s() const;
  public:
  void clear_row_ttl_duration_s();
  ::PROTOBUF_NAMESPACE_ID::int64 row_ttl_duration_s() const;
  void set_row_ttl_duration_s(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_row_ttl_duration_s() const;
  void _internal_set_row_ttl_duration_s(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required .baikaldb.pb.LockCmdType lock_type = 2;
  bool has_lock_type() const;
  private:
  bool _internal_has_lock_type() const;
  public:
  void clear_lock_type();
  ::baikaldb::pb::LockCmdType lock_type() const;
  void set_lock_type(::baikaldb::pb::LockCmdType value);
  private:
  ::baikaldb::pb::LockCmdType _internal_lock_type() const;
  void _internal_set_lock_type(::baikaldb::pb::LockCmdType value);
  public:

  // optional bool affect_primary = 5 [default = true];
  bool has_affect_primary() const;
  private:
  bool _internal_has_affect_primary() const;
  public:
  void clear_affect_primary();
  bool affect_primary() const;
  void set_affect_primary(bool value);
  private:
  bool _internal_affect_primary() const;
  void _internal_set_affect_primary(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.LockPrimaryNode)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> put_records_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> delete_records_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > affect_index_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > conjuncts_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 row_ttl_duration_s_;
  int lock_type_;
  bool affect_primary_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class LockSecondaryNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.LockSecondaryNode) */ {
 public:
  inline LockSecondaryNode() : LockSecondaryNode(nullptr) {}
  ~LockSecondaryNode() override;
  explicit constexpr LockSecondaryNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LockSecondaryNode(const LockSecondaryNode& from);
  LockSecondaryNode(LockSecondaryNode&& from) noexcept
    : LockSecondaryNode() {
    *this = ::std::move(from);
  }

  inline LockSecondaryNode& operator=(const LockSecondaryNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline LockSecondaryNode& operator=(LockSecondaryNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LockSecondaryNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const LockSecondaryNode* internal_default_instance() {
    return reinterpret_cast<const LockSecondaryNode*>(
               &_LockSecondaryNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(LockSecondaryNode& a, LockSecondaryNode& b) {
    a.Swap(&b);
  }
  inline void Swap(LockSecondaryNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LockSecondaryNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LockSecondaryNode* New() const final {
    return new LockSecondaryNode();
  }

  LockSecondaryNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LockSecondaryNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LockSecondaryNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LockSecondaryNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockSecondaryNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.LockSecondaryNode";
  }
  protected:
  explicit LockSecondaryNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPutRecordsFieldNumber = 4,
    kDeleteRecordsFieldNumber = 5,
    kGlobalDdlTtlTimestampUsFieldNumber = 8,
    kTableIdFieldNumber = 1,
    kGlobalIndexIdFieldNumber = 2,
    kLockTypeFieldNumber = 3,
    kLockSecondaryTypeFieldNumber = 6,
    kRowTtlDurationSFieldNumber = 7,
  };
  // repeated bytes put_records = 4;
  int put_records_size() const;
  private:
  int _internal_put_records_size() const;
  public:
  void clear_put_records();
  const std::string& put_records(int index) const;
  std::string* mutable_put_records(int index);
  void set_put_records(int index, const std::string& value);
  void set_put_records(int index, std::string&& value);
  void set_put_records(int index, const char* value);
  void set_put_records(int index, const void* value, size_t size);
  std::string* add_put_records();
  void add_put_records(const std::string& value);
  void add_put_records(std::string&& value);
  void add_put_records(const char* value);
  void add_put_records(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& put_records() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_put_records();
  private:
  const std::string& _internal_put_records(int index) const;
  std::string* _internal_add_put_records();
  public:

  // repeated bytes delete_records = 5;
  int delete_records_size() const;
  private:
  int _internal_delete_records_size() const;
  public:
  void clear_delete_records();
  const std::string& delete_records(int index) const;
  std::string* mutable_delete_records(int index);
  void set_delete_records(int index, const std::string& value);
  void set_delete_records(int index, std::string&& value);
  void set_delete_records(int index, const char* value);
  void set_delete_records(int index, const void* value, size_t size);
  std::string* add_delete_records();
  void add_delete_records(const std::string& value);
  void add_delete_records(std::string&& value);
  void add_delete_records(const char* value);
  void add_delete_records(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& delete_records() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_delete_records();
  private:
  const std::string& _internal_delete_records(int index) const;
  std::string* _internal_add_delete_records();
  public:

  // repeated int64 global_ddl_ttl_timestamp_us = 8;
  int global_ddl_ttl_timestamp_us_size() const;
  private:
  int _internal_global_ddl_ttl_timestamp_us_size() const;
  public:
  void clear_global_ddl_ttl_timestamp_us();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_global_ddl_ttl_timestamp_us(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_global_ddl_ttl_timestamp_us() const;
  void _internal_add_global_ddl_ttl_timestamp_us(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_global_ddl_ttl_timestamp_us();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 global_ddl_ttl_timestamp_us(int index) const;
  void set_global_ddl_ttl_timestamp_us(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_global_ddl_ttl_timestamp_us(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      global_ddl_ttl_timestamp_us() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_global_ddl_ttl_timestamp_us();

  // required int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 global_index_id = 2;
  bool has_global_index_id() const;
  private:
  bool _internal_has_global_index_id() const;
  public:
  void clear_global_index_id();
  ::PROTOBUF_NAMESPACE_ID::int64 global_index_id() const;
  void set_global_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_global_index_id() const;
  void _internal_set_global_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required .baikaldb.pb.LockCmdType lock_type = 3;
  bool has_lock_type() const;
  private:
  bool _internal_has_lock_type() const;
  public:
  void clear_lock_type();
  ::baikaldb::pb::LockCmdType lock_type() const;
  void set_lock_type(::baikaldb::pb::LockCmdType value);
  private:
  ::baikaldb::pb::LockCmdType _internal_lock_type() const;
  void _internal_set_lock_type(::baikaldb::pb::LockCmdType value);
  public:

  // optional .baikaldb.pb.LockSecondaryType lock_secondary_type = 6;
  bool has_lock_secondary_type() const;
  private:
  bool _internal_has_lock_secondary_type() const;
  public:
  void clear_lock_secondary_type();
  ::baikaldb::pb::LockSecondaryType lock_secondary_type() const;
  void set_lock_secondary_type(::baikaldb::pb::LockSecondaryType value);
  private:
  ::baikaldb::pb::LockSecondaryType _internal_lock_secondary_type() const;
  void _internal_set_lock_secondary_type(::baikaldb::pb::LockSecondaryType value);
  public:

  // optional int64 row_ttl_duration_s = 7;
  bool has_row_ttl_duration_s() const;
  private:
  bool _internal_has_row_ttl_duration_s() const;
  public:
  void clear_row_ttl_duration_s();
  ::PROTOBUF_NAMESPACE_ID::int64 row_ttl_duration_s() const;
  void set_row_ttl_duration_s(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_row_ttl_duration_s() const;
  void _internal_set_row_ttl_duration_s(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.LockSecondaryNode)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> put_records_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> delete_records_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > global_ddl_ttl_timestamp_us_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 global_index_id_;
  int lock_type_;
  int lock_secondary_type_;
  ::PROTOBUF_NAMESPACE_ID::int64 row_ttl_duration_s_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class DeleteNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.DeleteNode) */ {
 public:
  inline DeleteNode() : DeleteNode(nullptr) {}
  ~DeleteNode() override;
  explicit constexpr DeleteNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteNode(const DeleteNode& from);
  DeleteNode(DeleteNode&& from) noexcept
    : DeleteNode() {
    *this = ::std::move(from);
  }

  inline DeleteNode& operator=(const DeleteNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteNode& operator=(DeleteNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteNode* internal_default_instance() {
    return reinterpret_cast<const DeleteNode*>(
               &_DeleteNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DeleteNode& a, DeleteNode& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteNode* New() const final {
    return new DeleteNode();
  }

  DeleteNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.DeleteNode";
  }
  protected:
  explicit DeleteNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrimarySlotsFieldNumber = 2,
    kTableIdFieldNumber = 1,
  };
  // repeated .baikaldb.pb.SlotDescriptor primary_slots = 2;
  int primary_slots_size() const;
  private:
  int _internal_primary_slots_size() const;
  public:
  void clear_primary_slots();
  ::baikaldb::pb::SlotDescriptor* mutable_primary_slots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >*
      mutable_primary_slots();
  private:
  const ::baikaldb::pb::SlotDescriptor& _internal_primary_slots(int index) const;
  ::baikaldb::pb::SlotDescriptor* _internal_add_primary_slots();
  public:
  const ::baikaldb::pb::SlotDescriptor& primary_slots(int index) const;
  ::baikaldb::pb::SlotDescriptor* add_primary_slots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >&
      primary_slots() const;

  // required int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.DeleteNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor > primary_slots_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class TruncateNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TruncateNode) */ {
 public:
  inline TruncateNode() : TruncateNode(nullptr) {}
  ~TruncateNode() override;
  explicit constexpr TruncateNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TruncateNode(const TruncateNode& from);
  TruncateNode(TruncateNode&& from) noexcept
    : TruncateNode() {
    *this = ::std::move(from);
  }

  inline TruncateNode& operator=(const TruncateNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TruncateNode& operator=(TruncateNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TruncateNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const TruncateNode* internal_default_instance() {
    return reinterpret_cast<const TruncateNode*>(
               &_TruncateNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TruncateNode& a, TruncateNode& b) {
    a.Swap(&b);
  }
  inline void Swap(TruncateNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TruncateNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TruncateNode* New() const final {
    return new TruncateNode();
  }

  TruncateNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TruncateNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TruncateNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TruncateNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TruncateNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TruncateNode";
  }
  protected:
  explicit TruncateNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableIdFieldNumber = 1,
  };
  // required int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TruncateNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class UpdateNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.UpdateNode) */ {
 public:
  inline UpdateNode() : UpdateNode(nullptr) {}
  ~UpdateNode() override;
  explicit constexpr UpdateNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateNode(const UpdateNode& from);
  UpdateNode(UpdateNode&& from) noexcept
    : UpdateNode() {
    *this = ::std::move(from);
  }

  inline UpdateNode& operator=(const UpdateNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNode& operator=(UpdateNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateNode* internal_default_instance() {
    return reinterpret_cast<const UpdateNode*>(
               &_UpdateNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateNode& a, UpdateNode& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateNode* New() const final {
    return new UpdateNode();
  }

  UpdateNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.UpdateNode";
  }
  protected:
  explicit UpdateNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrimarySlotsFieldNumber = 2,
    kUpdateSlotsFieldNumber = 3,
    kUpdateExprsFieldNumber = 4,
    kTableIdFieldNumber = 1,
    kRowTtlDurationFieldNumber = 6,
  };
  // repeated .baikaldb.pb.SlotDescriptor primary_slots = 2;
  int primary_slots_size() const;
  private:
  int _internal_primary_slots_size() const;
  public:
  void clear_primary_slots();
  ::baikaldb::pb::SlotDescriptor* mutable_primary_slots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >*
      mutable_primary_slots();
  private:
  const ::baikaldb::pb::SlotDescriptor& _internal_primary_slots(int index) const;
  ::baikaldb::pb::SlotDescriptor* _internal_add_primary_slots();
  public:
  const ::baikaldb::pb::SlotDescriptor& primary_slots(int index) const;
  ::baikaldb::pb::SlotDescriptor* add_primary_slots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >&
      primary_slots() const;

  // repeated .baikaldb.pb.SlotDescriptor update_slots = 3;
  int update_slots_size() const;
  private:
  int _internal_update_slots_size() const;
  public:
  void clear_update_slots();
  ::baikaldb::pb::SlotDescriptor* mutable_update_slots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >*
      mutable_update_slots();
  private:
  const ::baikaldb::pb::SlotDescriptor& _internal_update_slots(int index) const;
  ::baikaldb::pb::SlotDescriptor* _internal_add_update_slots();
  public:
  const ::baikaldb::pb::SlotDescriptor& update_slots(int index) const;
  ::baikaldb::pb::SlotDescriptor* add_update_slots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >&
      update_slots() const;

  // repeated .baikaldb.pb.Expr update_exprs = 4;
  int update_exprs_size() const;
  private:
  int _internal_update_exprs_size() const;
  public:
  void clear_update_exprs();
  ::baikaldb::pb::Expr* mutable_update_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_update_exprs();
  private:
  const ::baikaldb::pb::Expr& _internal_update_exprs(int index) const;
  ::baikaldb::pb::Expr* _internal_add_update_exprs();
  public:
  const ::baikaldb::pb::Expr& update_exprs(int index) const;
  ::baikaldb::pb::Expr* add_update_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      update_exprs() const;

  // required int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 row_ttl_duration = 6;
  bool has_row_ttl_duration() const;
  private:
  bool _internal_has_row_ttl_duration() const;
  public:
  void clear_row_ttl_duration();
  ::PROTOBUF_NAMESPACE_ID::int64 row_ttl_duration() const;
  void set_row_ttl_duration(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_row_ttl_duration() const;
  void _internal_set_row_ttl_duration(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.UpdateNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor > primary_slots_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor > update_slots_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > update_exprs_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 row_ttl_duration_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class PacketNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.PacketNode) */ {
 public:
  inline PacketNode() : PacketNode(nullptr) {}
  ~PacketNode() override;
  explicit constexpr PacketNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PacketNode(const PacketNode& from);
  PacketNode(PacketNode&& from) noexcept
    : PacketNode() {
    *this = ::std::move(from);
  }

  inline PacketNode& operator=(const PacketNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline PacketNode& operator=(PacketNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PacketNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const PacketNode* internal_default_instance() {
    return reinterpret_cast<const PacketNode*>(
               &_PacketNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PacketNode& a, PacketNode& b) {
    a.Swap(&b);
  }
  inline void Swap(PacketNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PacketNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PacketNode* New() const final {
    return new PacketNode();
  }

  PacketNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PacketNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PacketNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PacketNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.PacketNode";
  }
  protected:
  explicit PacketNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectionsFieldNumber = 2,
    kColNamesFieldNumber = 3,
    kOpTypeFieldNumber = 1,
  };
  // repeated .baikaldb.pb.Expr projections = 2;
  int projections_size() const;
  private:
  int _internal_projections_size() const;
  public:
  void clear_projections();
  ::baikaldb::pb::Expr* mutable_projections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_projections();
  private:
  const ::baikaldb::pb::Expr& _internal_projections(int index) const;
  ::baikaldb::pb::Expr* _internal_add_projections();
  public:
  const ::baikaldb::pb::Expr& projections(int index) const;
  ::baikaldb::pb::Expr* add_projections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      projections() const;

  // repeated string col_names = 3;
  int col_names_size() const;
  private:
  int _internal_col_names_size() const;
  public:
  void clear_col_names();
  const std::string& col_names(int index) const;
  std::string* mutable_col_names(int index);
  void set_col_names(int index, const std::string& value);
  void set_col_names(int index, std::string&& value);
  void set_col_names(int index, const char* value);
  void set_col_names(int index, const char* value, size_t size);
  std::string* add_col_names();
  void add_col_names(const std::string& value);
  void add_col_names(std::string&& value);
  void add_col_names(const char* value);
  void add_col_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& col_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_col_names();
  private:
  const std::string& _internal_col_names(int index) const;
  std::string* _internal_add_col_names();
  public:

  // required .baikaldb.pb.OpType op_type = 1;
  bool has_op_type() const;
  private:
  bool _internal_has_op_type() const;
  public:
  void clear_op_type();
  ::baikaldb::pb::OpType op_type() const;
  void set_op_type(::baikaldb::pb::OpType value);
  private:
  ::baikaldb::pb::OpType _internal_op_type() const;
  void _internal_set_op_type(::baikaldb::pb::OpType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.PacketNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > projections_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> col_names_;
  int op_type_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class TransactionNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TransactionNode) */ {
 public:
  inline TransactionNode() : TransactionNode(nullptr) {}
  ~TransactionNode() override;
  explicit constexpr TransactionNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionNode(const TransactionNode& from);
  TransactionNode(TransactionNode&& from) noexcept
    : TransactionNode() {
    *this = ::std::move(from);
  }

  inline TransactionNode& operator=(const TransactionNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionNode& operator=(TransactionNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionNode* internal_default_instance() {
    return reinterpret_cast<const TransactionNode*>(
               &_TransactionNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TransactionNode& a, TransactionNode& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionNode* New() const final {
    return new TransactionNode();
  }

  TransactionNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TransactionNode";
  }
  protected:
  explicit TransactionNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxnTimeoutFieldNumber = 2,
    kTxnLockTimeoutFieldNumber = 3,
    kTxnCmdFieldNumber = 1,
  };
  // optional int64 txn_timeout = 2;
  bool has_txn_timeout() const;
  private:
  bool _internal_has_txn_timeout() const;
  public:
  void clear_txn_timeout();
  ::PROTOBUF_NAMESPACE_ID::int64 txn_timeout() const;
  void set_txn_timeout(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_txn_timeout() const;
  void _internal_set_txn_timeout(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 txn_lock_timeout = 3;
  bool has_txn_lock_timeout() const;
  private:
  bool _internal_has_txn_lock_timeout() const;
  public:
  void clear_txn_lock_timeout();
  ::PROTOBUF_NAMESPACE_ID::int64 txn_lock_timeout() const;
  void set_txn_lock_timeout(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_txn_lock_timeout() const;
  void _internal_set_txn_lock_timeout(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required .baikaldb.pb.TxnCmdType txn_cmd = 1;
  bool has_txn_cmd() const;
  private:
  bool _internal_has_txn_cmd() const;
  public:
  void clear_txn_cmd();
  ::baikaldb::pb::TxnCmdType txn_cmd() const;
  void set_txn_cmd(::baikaldb::pb::TxnCmdType value);
  private:
  ::baikaldb::pb::TxnCmdType _internal_txn_cmd() const;
  void _internal_set_txn_cmd(::baikaldb::pb::TxnCmdType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TransactionNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 txn_timeout_;
  ::PROTOBUF_NAMESPACE_ID::int64 txn_lock_timeout_;
  int txn_cmd_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class KillNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.KillNode) */ {
 public:
  inline KillNode() : KillNode(nullptr) {}
  ~KillNode() override;
  explicit constexpr KillNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KillNode(const KillNode& from);
  KillNode(KillNode&& from) noexcept
    : KillNode() {
    *this = ::std::move(from);
  }

  inline KillNode& operator=(const KillNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline KillNode& operator=(KillNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KillNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const KillNode* internal_default_instance() {
    return reinterpret_cast<const KillNode*>(
               &_KillNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(KillNode& a, KillNode& b) {
    a.Swap(&b);
  }
  inline void Swap(KillNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KillNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KillNode* New() const final {
    return new KillNode();
  }

  KillNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KillNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KillNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KillNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KillNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.KillNode";
  }
  protected:
  explicit KillNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbConnIdFieldNumber = 1,
    kIsQueryFieldNumber = 2,
  };
  // required uint64 db_conn_id = 1;
  bool has_db_conn_id() const;
  private:
  bool _internal_has_db_conn_id() const;
  public:
  void clear_db_conn_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 db_conn_id() const;
  void set_db_conn_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_db_conn_id() const;
  void _internal_set_db_conn_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool is_query = 2;
  bool has_is_query() const;
  private:
  bool _internal_has_is_query() const;
  public:
  void clear_is_query();
  bool is_query() const;
  void set_is_query(bool value);
  private:
  bool _internal_is_query() const;
  void _internal_set_is_query(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.KillNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 db_conn_id_;
  bool is_query_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class UnionNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.UnionNode) */ {
 public:
  inline UnionNode() : UnionNode(nullptr) {}
  ~UnionNode() override;
  explicit constexpr UnionNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnionNode(const UnionNode& from);
  UnionNode(UnionNode&& from) noexcept
    : UnionNode() {
    *this = ::std::move(from);
  }

  inline UnionNode& operator=(const UnionNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnionNode& operator=(UnionNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnionNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnionNode* internal_default_instance() {
    return reinterpret_cast<const UnionNode*>(
               &_UnionNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(UnionNode& a, UnionNode& b) {
    a.Swap(&b);
  }
  inline void Swap(UnionNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnionNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnionNode* New() const final {
    return new UnionNode();
  }

  UnionNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnionNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnionNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnionNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnionNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.UnionNode";
  }
  protected:
  explicit UnionNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotOrderExprsFieldNumber = 2,
    kIsAscFieldNumber = 3,
    kIsNullFirstFieldNumber = 4,
    kUnionTupleIdFieldNumber = 1,
  };
  // repeated .baikaldb.pb.Expr slot_order_exprs = 2;
  int slot_order_exprs_size() const;
  private:
  int _internal_slot_order_exprs_size() const;
  public:
  void clear_slot_order_exprs();
  ::baikaldb::pb::Expr* mutable_slot_order_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_slot_order_exprs();
  private:
  const ::baikaldb::pb::Expr& _internal_slot_order_exprs(int index) const;
  ::baikaldb::pb::Expr* _internal_add_slot_order_exprs();
  public:
  const ::baikaldb::pb::Expr& slot_order_exprs(int index) const;
  ::baikaldb::pb::Expr* add_slot_order_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      slot_order_exprs() const;

  // repeated bool is_asc = 3;
  int is_asc_size() const;
  private:
  int _internal_is_asc_size() const;
  public:
  void clear_is_asc();
  private:
  bool _internal_is_asc(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_is_asc() const;
  void _internal_add_is_asc(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_is_asc();
  public:
  bool is_asc(int index) const;
  void set_is_asc(int index, bool value);
  void add_is_asc(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      is_asc() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_is_asc();

  // repeated bool is_null_first = 4;
  int is_null_first_size() const;
  private:
  int _internal_is_null_first_size() const;
  public:
  void clear_is_null_first();
  private:
  bool _internal_is_null_first(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_is_null_first() const;
  void _internal_add_is_null_first(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_is_null_first();
  public:
  bool is_null_first(int index) const;
  void set_is_null_first(int index, bool value);
  void add_is_null_first(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      is_null_first() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_is_null_first();

  // optional int32 union_tuple_id = 1;
  bool has_union_tuple_id() const;
  private:
  bool _internal_has_union_tuple_id() const;
  public:
  void clear_union_tuple_id();
  ::PROTOBUF_NAMESPACE_ID::int32 union_tuple_id() const;
  void set_union_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_union_tuple_id() const;
  void _internal_set_union_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.UnionNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > slot_order_exprs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > is_asc_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > is_null_first_;
  ::PROTOBUF_NAMESPACE_ID::int32 union_tuple_id_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class LoadNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.LoadNode) */ {
 public:
  inline LoadNode() : LoadNode(nullptr) {}
  ~LoadNode() override;
  explicit constexpr LoadNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoadNode(const LoadNode& from);
  LoadNode(LoadNode&& from) noexcept
    : LoadNode() {
    *this = ::std::move(from);
  }

  inline LoadNode& operator=(const LoadNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadNode& operator=(LoadNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadNode* internal_default_instance() {
    return reinterpret_cast<const LoadNode*>(
               &_LoadNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(LoadNode& a, LoadNode& b) {
    a.Swap(&b);
  }
  inline void Swap(LoadNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoadNode* New() const final {
    return new LoadNode();
  }

  LoadNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoadNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoadNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoadNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoadNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.LoadNode";
  }
  protected:
  explicit LoadNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetSlotsFieldNumber = 4,
    kSetExprsFieldNumber = 5,
    kFieldIdsFieldNumber = 6,
    kDefaultFieldIdsFieldNumber = 7,
    kIngoreFieldIndexesFieldNumber = 8,
    kDataPathFieldNumber = 3,
    kTerminatedFieldNumber = 10,
    kEnclosedFieldNumber = 11,
    kEscapedFieldNumber = 12,
    kLineStartingFieldNumber = 13,
    kLineTerminatedFieldNumber = 14,
    kTableIdFieldNumber = 1,
    kIgnoreLinesFieldNumber = 9,
    kOptEnclosedFieldNumber = 15,
    kFileSizeFieldNumber = 16,
    kCharSetFieldNumber = 17,
  };
  // repeated .baikaldb.pb.SlotDescriptor set_slots = 4;
  int set_slots_size() const;
  private:
  int _internal_set_slots_size() const;
  public:
  void clear_set_slots();
  ::baikaldb::pb::SlotDescriptor* mutable_set_slots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >*
      mutable_set_slots();
  private:
  const ::baikaldb::pb::SlotDescriptor& _internal_set_slots(int index) const;
  ::baikaldb::pb::SlotDescriptor* _internal_add_set_slots();
  public:
  const ::baikaldb::pb::SlotDescriptor& set_slots(int index) const;
  ::baikaldb::pb::SlotDescriptor* add_set_slots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >&
      set_slots() const;

  // repeated .baikaldb.pb.Expr set_exprs = 5;
  int set_exprs_size() const;
  private:
  int _internal_set_exprs_size() const;
  public:
  void clear_set_exprs();
  ::baikaldb::pb::Expr* mutable_set_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_set_exprs();
  private:
  const ::baikaldb::pb::Expr& _internal_set_exprs(int index) const;
  ::baikaldb::pb::Expr* _internal_add_set_exprs();
  public:
  const ::baikaldb::pb::Expr& set_exprs(int index) const;
  ::baikaldb::pb::Expr* add_set_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      set_exprs() const;

  // repeated int32 field_ids = 6;
  int field_ids_size() const;
  private:
  int _internal_field_ids_size() const;
  public:
  void clear_field_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_field_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_field_ids() const;
  void _internal_add_field_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_field_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 field_ids(int index) const;
  void set_field_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_field_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      field_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_field_ids();

  // repeated int32 default_field_ids = 7;
  int default_field_ids_size() const;
  private:
  int _internal_default_field_ids_size() const;
  public:
  void clear_default_field_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_default_field_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_default_field_ids() const;
  void _internal_add_default_field_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_default_field_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 default_field_ids(int index) const;
  void set_default_field_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_default_field_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      default_field_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_default_field_ids();

  // repeated int32 ingore_field_indexes = 8;
  int ingore_field_indexes_size() const;
  private:
  int _internal_ingore_field_indexes_size() const;
  public:
  void clear_ingore_field_indexes();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ingore_field_indexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_ingore_field_indexes() const;
  void _internal_add_ingore_field_indexes(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_ingore_field_indexes();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 ingore_field_indexes(int index) const;
  void set_ingore_field_indexes(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_ingore_field_indexes(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      ingore_field_indexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_ingore_field_indexes();

  // optional string data_path = 3;
  bool has_data_path() const;
  private:
  bool _internal_has_data_path() const;
  public:
  void clear_data_path();
  const std::string& data_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_data_path();
  void set_allocated_data_path(std::string* data_path);
  private:
  const std::string& _internal_data_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_path(const std::string& value);
  std::string* _internal_mutable_data_path();
  public:

  // optional bytes terminated = 10;
  bool has_terminated() const;
  private:
  bool _internal_has_terminated() const;
  public:
  void clear_terminated();
  const std::string& terminated() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_terminated(ArgT0&& arg0, ArgT... args);
  std::string* mutable_terminated();
  PROTOBUF_MUST_USE_RESULT std::string* release_terminated();
  void set_allocated_terminated(std::string* terminated);
  private:
  const std::string& _internal_terminated() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_terminated(const std::string& value);
  std::string* _internal_mutable_terminated();
  public:

  // optional bytes enclosed = 11;
  bool has_enclosed() const;
  private:
  bool _internal_has_enclosed() const;
  public:
  void clear_enclosed();
  const std::string& enclosed() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enclosed(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enclosed();
  PROTOBUF_MUST_USE_RESULT std::string* release_enclosed();
  void set_allocated_enclosed(std::string* enclosed);
  private:
  const std::string& _internal_enclosed() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enclosed(const std::string& value);
  std::string* _internal_mutable_enclosed();
  public:

  // optional bytes escaped = 12;
  bool has_escaped() const;
  private:
  bool _internal_has_escaped() const;
  public:
  void clear_escaped();
  const std::string& escaped() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_escaped(ArgT0&& arg0, ArgT... args);
  std::string* mutable_escaped();
  PROTOBUF_MUST_USE_RESULT std::string* release_escaped();
  void set_allocated_escaped(std::string* escaped);
  private:
  const std::string& _internal_escaped() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escaped(const std::string& value);
  std::string* _internal_mutable_escaped();
  public:

  // optional bytes line_starting = 13;
  bool has_line_starting() const;
  private:
  bool _internal_has_line_starting() const;
  public:
  void clear_line_starting();
  const std::string& line_starting() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_line_starting(ArgT0&& arg0, ArgT... args);
  std::string* mutable_line_starting();
  PROTOBUF_MUST_USE_RESULT std::string* release_line_starting();
  void set_allocated_line_starting(std::string* line_starting);
  private:
  const std::string& _internal_line_starting() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_line_starting(const std::string& value);
  std::string* _internal_mutable_line_starting();
  public:

  // optional bytes line_terminated = 14;
  bool has_line_terminated() const;
  private:
  bool _internal_has_line_terminated() const;
  public:
  void clear_line_terminated();
  const std::string& line_terminated() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_line_terminated(ArgT0&& arg0, ArgT... args);
  std::string* mutable_line_terminated();
  PROTOBUF_MUST_USE_RESULT std::string* release_line_terminated();
  void set_allocated_line_terminated(std::string* line_terminated);
  private:
  const std::string& _internal_line_terminated() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_line_terminated(const std::string& value);
  std::string* _internal_mutable_line_terminated();
  public:

  // required int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 ignore_lines = 9;
  bool has_ignore_lines() const;
  private:
  bool _internal_has_ignore_lines() const;
  public:
  void clear_ignore_lines();
  ::PROTOBUF_NAMESPACE_ID::int32 ignore_lines() const;
  void set_ignore_lines(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ignore_lines() const;
  void _internal_set_ignore_lines(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool opt_enclosed = 15;
  bool has_opt_enclosed() const;
  private:
  bool _internal_has_opt_enclosed() const;
  public:
  void clear_opt_enclosed();
  bool opt_enclosed() const;
  void set_opt_enclosed(bool value);
  private:
  bool _internal_opt_enclosed() const;
  void _internal_set_opt_enclosed(bool value);
  public:

  // optional int64 file_size = 16;
  bool has_file_size() const;
  private:
  bool _internal_has_file_size() const;
  public:
  void clear_file_size();
  ::PROTOBUF_NAMESPACE_ID::int64 file_size() const;
  void set_file_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_file_size() const;
  void _internal_set_file_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.Charset char_set = 17;
  bool has_char_set() const;
  private:
  bool _internal_has_char_set() const;
  public:
  void clear_char_set();
  ::baikaldb::pb::Charset char_set() const;
  void set_char_set(::baikaldb::pb::Charset value);
  private:
  ::baikaldb::pb::Charset _internal_char_set() const;
  void _internal_set_char_set(::baikaldb::pb::Charset value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.LoadNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor > set_slots_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > set_exprs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > field_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > default_field_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > ingore_field_indexes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr terminated_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enclosed_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr escaped_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line_starting_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line_terminated_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 ignore_lines_;
  bool opt_enclosed_;
  ::PROTOBUF_NAMESPACE_ID::int64 file_size_;
  int char_set_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class PartitionProperty final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.PartitionProperty) */ {
 public:
  inline PartitionProperty() : PartitionProperty(nullptr) {}
  ~PartitionProperty() override;
  explicit constexpr PartitionProperty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionProperty(const PartitionProperty& from);
  PartitionProperty(PartitionProperty&& from) noexcept
    : PartitionProperty() {
    *this = ::std::move(from);
  }

  inline PartitionProperty& operator=(const PartitionProperty& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionProperty& operator=(PartitionProperty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionProperty& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionProperty* internal_default_instance() {
    return reinterpret_cast<const PartitionProperty*>(
               &_PartitionProperty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(PartitionProperty& a, PartitionProperty& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionProperty* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionProperty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartitionProperty* New() const final {
    return new PartitionProperty();
  }

  PartitionProperty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartitionProperty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartitionProperty& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PartitionProperty& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionProperty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.PartitionProperty";
  }
  protected:
  explicit PartitionProperty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashColsFieldNumber = 2,
    kNeedCastStringColsFieldNumber = 3,
    kNeedProjectHashColsFieldNumber = 4,
    kNeedProjectHashExprsFieldNumber = 5,
    kTypeFieldNumber = 1,
  };
  // repeated bytes hash_cols = 2;
  int hash_cols_size() const;
  private:
  int _internal_hash_cols_size() const;
  public:
  void clear_hash_cols();
  const std::string& hash_cols(int index) const;
  std::string* mutable_hash_cols(int index);
  void set_hash_cols(int index, const std::string& value);
  void set_hash_cols(int index, std::string&& value);
  void set_hash_cols(int index, const char* value);
  void set_hash_cols(int index, const void* value, size_t size);
  std::string* add_hash_cols();
  void add_hash_cols(const std::string& value);
  void add_hash_cols(std::string&& value);
  void add_hash_cols(const char* value);
  void add_hash_cols(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hash_cols() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hash_cols();
  private:
  const std::string& _internal_hash_cols(int index) const;
  std::string* _internal_add_hash_cols();
  public:

  // repeated bytes need_cast_string_cols = 3;
  int need_cast_string_cols_size() const;
  private:
  int _internal_need_cast_string_cols_size() const;
  public:
  void clear_need_cast_string_cols();
  const std::string& need_cast_string_cols(int index) const;
  std::string* mutable_need_cast_string_cols(int index);
  void set_need_cast_string_cols(int index, const std::string& value);
  void set_need_cast_string_cols(int index, std::string&& value);
  void set_need_cast_string_cols(int index, const char* value);
  void set_need_cast_string_cols(int index, const void* value, size_t size);
  std::string* add_need_cast_string_cols();
  void add_need_cast_string_cols(const std::string& value);
  void add_need_cast_string_cols(std::string&& value);
  void add_need_cast_string_cols(const char* value);
  void add_need_cast_string_cols(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& need_cast_string_cols() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_need_cast_string_cols();
  private:
  const std::string& _internal_need_cast_string_cols(int index) const;
  std::string* _internal_add_need_cast_string_cols();
  public:

  // repeated bytes need_project_hash_cols = 4;
  int need_project_hash_cols_size() const;
  private:
  int _internal_need_project_hash_cols_size() const;
  public:
  void clear_need_project_hash_cols();
  const std::string& need_project_hash_cols(int index) const;
  std::string* mutable_need_project_hash_cols(int index);
  void set_need_project_hash_cols(int index, const std::string& value);
  void set_need_project_hash_cols(int index, std::string&& value);
  void set_need_project_hash_cols(int index, const char* value);
  void set_need_project_hash_cols(int index, const void* value, size_t size);
  std::string* add_need_project_hash_cols();
  void add_need_project_hash_cols(const std::string& value);
  void add_need_project_hash_cols(std::string&& value);
  void add_need_project_hash_cols(const char* value);
  void add_need_project_hash_cols(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& need_project_hash_cols() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_need_project_hash_cols();
  private:
  const std::string& _internal_need_project_hash_cols(int index) const;
  std::string* _internal_add_need_project_hash_cols();
  public:

  // repeated .baikaldb.pb.Expr need_project_hash_exprs = 5;
  int need_project_hash_exprs_size() const;
  private:
  int _internal_need_project_hash_exprs_size() const;
  public:
  void clear_need_project_hash_exprs();
  ::baikaldb::pb::Expr* mutable_need_project_hash_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_need_project_hash_exprs();
  private:
  const ::baikaldb::pb::Expr& _internal_need_project_hash_exprs(int index) const;
  ::baikaldb::pb::Expr* _internal_add_need_project_hash_exprs();
  public:
  const ::baikaldb::pb::Expr& need_project_hash_exprs(int index) const;
  ::baikaldb::pb::Expr* add_need_project_hash_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      need_project_hash_exprs() const;

  // required .baikaldb.pb.PartitionPropertyType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::baikaldb::pb::PartitionPropertyType type() const;
  void set_type(::baikaldb::pb::PartitionPropertyType value);
  private:
  ::baikaldb::pb::PartitionPropertyType _internal_type() const;
  void _internal_set_type(::baikaldb::pb::PartitionPropertyType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.PartitionProperty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hash_cols_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> need_cast_string_cols_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> need_project_hash_cols_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > need_project_hash_exprs_;
  int type_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class ExchangeDestination final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ExchangeDestination) */ {
 public:
  inline ExchangeDestination() : ExchangeDestination(nullptr) {}
  ~ExchangeDestination() override;
  explicit constexpr ExchangeDestination(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExchangeDestination(const ExchangeDestination& from);
  ExchangeDestination(ExchangeDestination&& from) noexcept
    : ExchangeDestination() {
    *this = ::std::move(from);
  }

  inline ExchangeDestination& operator=(const ExchangeDestination& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeDestination& operator=(ExchangeDestination&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeDestination& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExchangeDestination* internal_default_instance() {
    return reinterpret_cast<const ExchangeDestination*>(
               &_ExchangeDestination_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ExchangeDestination& a, ExchangeDestination& b) {
    a.Swap(&b);
  }
  inline void Swap(ExchangeDestination* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeDestination* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExchangeDestination* New() const final {
    return new ExchangeDestination();
  }

  ExchangeDestination* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeDestination>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExchangeDestination& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExchangeDestination& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeDestination* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ExchangeDestination";
  }
  protected:
  explicit ExchangeDestination(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 3,
    kFragmentInstanceIdFieldNumber = 1,
    kNodeIdFieldNumber = 2,
  };
  // optional bytes address = 3;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // required uint64 fragment_instance_id = 1;
  bool has_fragment_instance_id() const;
  private:
  bool _internal_has_fragment_instance_id() const;
  public:
  void clear_fragment_instance_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 fragment_instance_id() const;
  void set_fragment_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fragment_instance_id() const;
  void _internal_set_fragment_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required int32 node_id = 2;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  ::PROTOBUF_NAMESPACE_ID::int32 node_id() const;
  void set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_node_id() const;
  void _internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ExchangeDestination)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fragment_instance_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_id_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class ExchangeSenderNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ExchangeSenderNode) */ {
 public:
  inline ExchangeSenderNode() : ExchangeSenderNode(nullptr) {}
  ~ExchangeSenderNode() override;
  explicit constexpr ExchangeSenderNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExchangeSenderNode(const ExchangeSenderNode& from);
  ExchangeSenderNode(ExchangeSenderNode&& from) noexcept
    : ExchangeSenderNode() {
    *this = ::std::move(from);
  }

  inline ExchangeSenderNode& operator=(const ExchangeSenderNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeSenderNode& operator=(ExchangeSenderNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeSenderNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExchangeSenderNode* internal_default_instance() {
    return reinterpret_cast<const ExchangeSenderNode*>(
               &_ExchangeSenderNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ExchangeSenderNode& a, ExchangeSenderNode& b) {
    a.Swap(&b);
  }
  inline void Swap(ExchangeSenderNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeSenderNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExchangeSenderNode* New() const final {
    return new ExchangeSenderNode();
  }

  ExchangeSenderNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeSenderNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExchangeSenderNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExchangeSenderNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeSenderNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ExchangeSenderNode";
  }
  protected:
  explicit ExchangeSenderNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReceiverDestinationsFieldNumber = 6,
    kFragmentAddressesFieldNumber = 7,
    kSchemaFieldNumber = 9,
    kPartitionPropertyFieldNumber = 8,
    kLogIdFieldNumber = 1,
    kFragmentIdFieldNumber = 2,
    kReceiverFragmentIdFieldNumber = 3,
    kFragmentInstanceIdFieldNumber = 4,
    kNodeIdFieldNumber = 5,
  };
  // repeated .baikaldb.pb.ExchangeDestination receiver_destinations = 6;
  int receiver_destinations_size() const;
  private:
  int _internal_receiver_destinations_size() const;
  public:
  void clear_receiver_destinations();
  ::baikaldb::pb::ExchangeDestination* mutable_receiver_destinations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ExchangeDestination >*
      mutable_receiver_destinations();
  private:
  const ::baikaldb::pb::ExchangeDestination& _internal_receiver_destinations(int index) const;
  ::baikaldb::pb::ExchangeDestination* _internal_add_receiver_destinations();
  public:
  const ::baikaldb::pb::ExchangeDestination& receiver_destinations(int index) const;
  ::baikaldb::pb::ExchangeDestination* add_receiver_destinations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ExchangeDestination >&
      receiver_destinations() const;

  // repeated .baikaldb.pb.ExchangeDestination fragment_addresses = 7;
  int fragment_addresses_size() const;
  private:
  int _internal_fragment_addresses_size() const;
  public:
  void clear_fragment_addresses();
  ::baikaldb::pb::ExchangeDestination* mutable_fragment_addresses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ExchangeDestination >*
      mutable_fragment_addresses();
  private:
  const ::baikaldb::pb::ExchangeDestination& _internal_fragment_addresses(int index) const;
  ::baikaldb::pb::ExchangeDestination* _internal_add_fragment_addresses();
  public:
  const ::baikaldb::pb::ExchangeDestination& fragment_addresses(int index) const;
  ::baikaldb::pb::ExchangeDestination* add_fragment_addresses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ExchangeDestination >&
      fragment_addresses() const;

  // optional bytes schema = 9;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const std::string& schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema();
  PROTOBUF_MUST_USE_RESULT std::string* release_schema();
  void set_allocated_schema(std::string* schema);
  private:
  const std::string& _internal_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();
  public:

  // optional .baikaldb.pb.PartitionProperty partition_property = 8;
  bool has_partition_property() const;
  private:
  bool _internal_has_partition_property() const;
  public:
  void clear_partition_property();
  const ::baikaldb::pb::PartitionProperty& partition_property() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::PartitionProperty* release_partition_property();
  ::baikaldb::pb::PartitionProperty* mutable_partition_property();
  void set_allocated_partition_property(::baikaldb::pb::PartitionProperty* partition_property);
  private:
  const ::baikaldb::pb::PartitionProperty& _internal_partition_property() const;
  ::baikaldb::pb::PartitionProperty* _internal_mutable_partition_property();
  public:
  void unsafe_arena_set_allocated_partition_property(
      ::baikaldb::pb::PartitionProperty* partition_property);
  ::baikaldb::pb::PartitionProperty* unsafe_arena_release_partition_property();

  // required uint64 log_id = 1;
  bool has_log_id() const;
  private:
  bool _internal_has_log_id() const;
  public:
  void clear_log_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 log_id() const;
  void set_log_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_log_id() const;
  void _internal_set_log_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required int32 fragment_id = 2;
  bool has_fragment_id() const;
  private:
  bool _internal_has_fragment_id() const;
  public:
  void clear_fragment_id();
  ::PROTOBUF_NAMESPACE_ID::int32 fragment_id() const;
  void set_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_fragment_id() const;
  void _internal_set_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 receiver_fragment_id = 3;
  bool has_receiver_fragment_id() const;
  private:
  bool _internal_has_receiver_fragment_id() const;
  public:
  void clear_receiver_fragment_id();
  ::PROTOBUF_NAMESPACE_ID::int32 receiver_fragment_id() const;
  void set_receiver_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_receiver_fragment_id() const;
  void _internal_set_receiver_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required uint64 fragment_instance_id = 4;
  bool has_fragment_instance_id() const;
  private:
  bool _internal_has_fragment_instance_id() const;
  public:
  void clear_fragment_instance_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 fragment_instance_id() const;
  void set_fragment_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fragment_instance_id() const;
  void _internal_set_fragment_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required int32 node_id = 5;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  ::PROTOBUF_NAMESPACE_ID::int32 node_id() const;
  void set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_node_id() const;
  void _internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ExchangeSenderNode)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ExchangeDestination > receiver_destinations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ExchangeDestination > fragment_addresses_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_;
  ::baikaldb::pb::PartitionProperty* partition_property_;
  ::PROTOBUF_NAMESPACE_ID::uint64 log_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 fragment_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 receiver_fragment_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fragment_instance_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_id_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class ExchangeReceiverNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ExchangeReceiverNode) */ {
 public:
  inline ExchangeReceiverNode() : ExchangeReceiverNode(nullptr) {}
  ~ExchangeReceiverNode() override;
  explicit constexpr ExchangeReceiverNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExchangeReceiverNode(const ExchangeReceiverNode& from);
  ExchangeReceiverNode(ExchangeReceiverNode&& from) noexcept
    : ExchangeReceiverNode() {
    *this = ::std::move(from);
  }

  inline ExchangeReceiverNode& operator=(const ExchangeReceiverNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeReceiverNode& operator=(ExchangeReceiverNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExchangeReceiverNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExchangeReceiverNode* internal_default_instance() {
    return reinterpret_cast<const ExchangeReceiverNode*>(
               &_ExchangeReceiverNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ExchangeReceiverNode& a, ExchangeReceiverNode& b) {
    a.Swap(&b);
  }
  inline void Swap(ExchangeReceiverNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeReceiverNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExchangeReceiverNode* New() const final {
    return new ExchangeReceiverNode();
  }

  ExchangeReceiverNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeReceiverNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExchangeReceiverNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExchangeReceiverNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeReceiverNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ExchangeReceiverNode";
  }
  protected:
  explicit ExchangeReceiverNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderDestinationsFieldNumber = 6,
    kRegionsFieldNumber = 7,
    kSlotOrderExprsFieldNumber = 10,
    kIsAscFieldNumber = 11,
    kIsNullFirstFieldNumber = 12,
    kSchemaFieldNumber = 9,
    kPartitionPropertyFieldNumber = 8,
    kLogIdFieldNumber = 1,
    kFragmentIdFieldNumber = 2,
    kSenderFragmentIdFieldNumber = 3,
    kFragmentInstanceIdFieldNumber = 4,
    kNodeIdFieldNumber = 5,
  };
  // repeated .baikaldb.pb.ExchangeDestination sender_destinations = 6;
  int sender_destinations_size() const;
  private:
  int _internal_sender_destinations_size() const;
  public:
  void clear_sender_destinations();
  ::baikaldb::pb::ExchangeDestination* mutable_sender_destinations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ExchangeDestination >*
      mutable_sender_destinations();
  private:
  const ::baikaldb::pb::ExchangeDestination& _internal_sender_destinations(int index) const;
  ::baikaldb::pb::ExchangeDestination* _internal_add_sender_destinations();
  public:
  const ::baikaldb::pb::ExchangeDestination& sender_destinations(int index) const;
  ::baikaldb::pb::ExchangeDestination* add_sender_destinations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ExchangeDestination >&
      sender_destinations() const;

  // repeated .baikaldb.pb.RegionInfo regions = 7;
  int regions_size() const;
  private:
  int _internal_regions_size() const;
  public:
  void clear_regions();
  ::baikaldb::pb::RegionInfo* mutable_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >*
      mutable_regions();
  private:
  const ::baikaldb::pb::RegionInfo& _internal_regions(int index) const;
  ::baikaldb::pb::RegionInfo* _internal_add_regions();
  public:
  const ::baikaldb::pb::RegionInfo& regions(int index) const;
  ::baikaldb::pb::RegionInfo* add_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >&
      regions() const;

  // repeated .baikaldb.pb.Expr slot_order_exprs = 10;
  int slot_order_exprs_size() const;
  private:
  int _internal_slot_order_exprs_size() const;
  public:
  void clear_slot_order_exprs();
  ::baikaldb::pb::Expr* mutable_slot_order_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_slot_order_exprs();
  private:
  const ::baikaldb::pb::Expr& _internal_slot_order_exprs(int index) const;
  ::baikaldb::pb::Expr* _internal_add_slot_order_exprs();
  public:
  const ::baikaldb::pb::Expr& slot_order_exprs(int index) const;
  ::baikaldb::pb::Expr* add_slot_order_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      slot_order_exprs() const;

  // repeated bool is_asc = 11;
  int is_asc_size() const;
  private:
  int _internal_is_asc_size() const;
  public:
  void clear_is_asc();
  private:
  bool _internal_is_asc(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_is_asc() const;
  void _internal_add_is_asc(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_is_asc();
  public:
  bool is_asc(int index) const;
  void set_is_asc(int index, bool value);
  void add_is_asc(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      is_asc() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_is_asc();

  // repeated bool is_null_first = 12;
  int is_null_first_size() const;
  private:
  int _internal_is_null_first_size() const;
  public:
  void clear_is_null_first();
  private:
  bool _internal_is_null_first(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_is_null_first() const;
  void _internal_add_is_null_first(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_is_null_first();
  public:
  bool is_null_first(int index) const;
  void set_is_null_first(int index, bool value);
  void add_is_null_first(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      is_null_first() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_is_null_first();

  // required bytes schema = 9;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const std::string& schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema();
  PROTOBUF_MUST_USE_RESULT std::string* release_schema();
  void set_allocated_schema(std::string* schema);
  private:
  const std::string& _internal_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();
  public:

  // optional .baikaldb.pb.PartitionProperty partition_property = 8;
  bool has_partition_property() const;
  private:
  bool _internal_has_partition_property() const;
  public:
  void clear_partition_property();
  const ::baikaldb::pb::PartitionProperty& partition_property() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::PartitionProperty* release_partition_property();
  ::baikaldb::pb::PartitionProperty* mutable_partition_property();
  void set_allocated_partition_property(::baikaldb::pb::PartitionProperty* partition_property);
  private:
  const ::baikaldb::pb::PartitionProperty& _internal_partition_property() const;
  ::baikaldb::pb::PartitionProperty* _internal_mutable_partition_property();
  public:
  void unsafe_arena_set_allocated_partition_property(
      ::baikaldb::pb::PartitionProperty* partition_property);
  ::baikaldb::pb::PartitionProperty* unsafe_arena_release_partition_property();

  // required uint64 log_id = 1;
  bool has_log_id() const;
  private:
  bool _internal_has_log_id() const;
  public:
  void clear_log_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 log_id() const;
  void set_log_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_log_id() const;
  void _internal_set_log_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required int32 fragment_id = 2;
  bool has_fragment_id() const;
  private:
  bool _internal_has_fragment_id() const;
  public:
  void clear_fragment_id();
  ::PROTOBUF_NAMESPACE_ID::int32 fragment_id() const;
  void set_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_fragment_id() const;
  void _internal_set_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 sender_fragment_id = 3;
  bool has_sender_fragment_id() const;
  private:
  bool _internal_has_sender_fragment_id() const;
  public:
  void clear_sender_fragment_id();
  ::PROTOBUF_NAMESPACE_ID::int32 sender_fragment_id() const;
  void set_sender_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sender_fragment_id() const;
  void _internal_set_sender_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required uint64 fragment_instance_id = 4;
  bool has_fragment_instance_id() const;
  private:
  bool _internal_has_fragment_instance_id() const;
  public:
  void clear_fragment_instance_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 fragment_instance_id() const;
  void set_fragment_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fragment_instance_id() const;
  void _internal_set_fragment_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required int32 node_id = 5;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  ::PROTOBUF_NAMESPACE_ID::int32 node_id() const;
  void set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_node_id() const;
  void _internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ExchangeReceiverNode)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ExchangeDestination > sender_destinations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo > regions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > slot_order_exprs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > is_asc_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > is_null_first_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_;
  ::baikaldb::pb::PartitionProperty* partition_property_;
  ::PROTOBUF_NAMESPACE_ID::uint64 log_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 fragment_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 sender_fragment_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fragment_instance_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 node_id_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class FrameBound final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.FrameBound) */ {
 public:
  inline FrameBound() : FrameBound(nullptr) {}
  ~FrameBound() override;
  explicit constexpr FrameBound(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameBound(const FrameBound& from);
  FrameBound(FrameBound&& from) noexcept
    : FrameBound() {
    *this = ::std::move(from);
  }

  inline FrameBound& operator=(const FrameBound& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameBound& operator=(FrameBound&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameBound& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameBound* internal_default_instance() {
    return reinterpret_cast<const FrameBound*>(
               &_FrameBound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(FrameBound& a, FrameBound& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameBound* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameBound* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FrameBound* New() const final {
    return new FrameBound();
  }

  FrameBound* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FrameBound>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameBound& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FrameBound& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameBound* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.FrameBound";
  }
  protected:
  explicit FrameBound(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExprFieldNumber = 3,
    kBoundTypeFieldNumber = 1,
    kIsUnboundedFieldNumber = 2,
  };
  // optional .baikaldb.pb.Expr expr = 3;
  bool has_expr() const;
  private:
  bool _internal_has_expr() const;
  public:
  void clear_expr();
  const ::baikaldb::pb::Expr& expr() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::Expr* release_expr();
  ::baikaldb::pb::Expr* mutable_expr();
  void set_allocated_expr(::baikaldb::pb::Expr* expr);
  private:
  const ::baikaldb::pb::Expr& _internal_expr() const;
  ::baikaldb::pb::Expr* _internal_mutable_expr();
  public:
  void unsafe_arena_set_allocated_expr(
      ::baikaldb::pb::Expr* expr);
  ::baikaldb::pb::Expr* unsafe_arena_release_expr();

  // optional .baikaldb.pb.BoundType bound_type = 1;
  bool has_bound_type() const;
  private:
  bool _internal_has_bound_type() const;
  public:
  void clear_bound_type();
  ::baikaldb::pb::BoundType bound_type() const;
  void set_bound_type(::baikaldb::pb::BoundType value);
  private:
  ::baikaldb::pb::BoundType _internal_bound_type() const;
  void _internal_set_bound_type(::baikaldb::pb::BoundType value);
  public:

  // optional bool is_unbounded = 2;
  bool has_is_unbounded() const;
  private:
  bool _internal_has_is_unbounded() const;
  public:
  void clear_is_unbounded();
  bool is_unbounded() const;
  void set_is_unbounded(bool value);
  private:
  bool _internal_is_unbounded() const;
  void _internal_set_is_unbounded(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.FrameBound)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::Expr* expr_;
  int bound_type_;
  bool is_unbounded_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class FrameExtent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.FrameExtent) */ {
 public:
  inline FrameExtent() : FrameExtent(nullptr) {}
  ~FrameExtent() override;
  explicit constexpr FrameExtent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameExtent(const FrameExtent& from);
  FrameExtent(FrameExtent&& from) noexcept
    : FrameExtent() {
    *this = ::std::move(from);
  }

  inline FrameExtent& operator=(const FrameExtent& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameExtent& operator=(FrameExtent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameExtent& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameExtent* internal_default_instance() {
    return reinterpret_cast<const FrameExtent*>(
               &_FrameExtent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(FrameExtent& a, FrameExtent& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameExtent* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameExtent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FrameExtent* New() const final {
    return new FrameExtent();
  }

  FrameExtent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FrameExtent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameExtent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FrameExtent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameExtent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.FrameExtent";
  }
  protected:
  explicit FrameExtent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameStartFieldNumber = 1,
    kFrameEndFieldNumber = 2,
  };
  // optional .baikaldb.pb.FrameBound frame_start = 1;
  bool has_frame_start() const;
  private:
  bool _internal_has_frame_start() const;
  public:
  void clear_frame_start();
  const ::baikaldb::pb::FrameBound& frame_start() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::FrameBound* release_frame_start();
  ::baikaldb::pb::FrameBound* mutable_frame_start();
  void set_allocated_frame_start(::baikaldb::pb::FrameBound* frame_start);
  private:
  const ::baikaldb::pb::FrameBound& _internal_frame_start() const;
  ::baikaldb::pb::FrameBound* _internal_mutable_frame_start();
  public:
  void unsafe_arena_set_allocated_frame_start(
      ::baikaldb::pb::FrameBound* frame_start);
  ::baikaldb::pb::FrameBound* unsafe_arena_release_frame_start();

  // optional .baikaldb.pb.FrameBound frame_end = 2;
  bool has_frame_end() const;
  private:
  bool _internal_has_frame_end() const;
  public:
  void clear_frame_end();
  const ::baikaldb::pb::FrameBound& frame_end() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::FrameBound* release_frame_end();
  ::baikaldb::pb::FrameBound* mutable_frame_end();
  void set_allocated_frame_end(::baikaldb::pb::FrameBound* frame_end);
  private:
  const ::baikaldb::pb::FrameBound& _internal_frame_end() const;
  ::baikaldb::pb::FrameBound* _internal_mutable_frame_end();
  public:
  void unsafe_arena_set_allocated_frame_end(
      ::baikaldb::pb::FrameBound* frame_end);
  ::baikaldb::pb::FrameBound* unsafe_arena_release_frame_end();

  // @@protoc_insertion_point(class_scope:baikaldb.pb.FrameExtent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::FrameBound* frame_start_;
  ::baikaldb::pb::FrameBound* frame_end_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class WindowFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.WindowFrame) */ {
 public:
  inline WindowFrame() : WindowFrame(nullptr) {}
  ~WindowFrame() override;
  explicit constexpr WindowFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WindowFrame(const WindowFrame& from);
  WindowFrame(WindowFrame&& from) noexcept
    : WindowFrame() {
    *this = ::std::move(from);
  }

  inline WindowFrame& operator=(const WindowFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowFrame& operator=(WindowFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const WindowFrame* internal_default_instance() {
    return reinterpret_cast<const WindowFrame*>(
               &_WindowFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(WindowFrame& a, WindowFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowFrame* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WindowFrame* New() const final {
    return new WindowFrame();
  }

  WindowFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WindowFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WindowFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WindowFrame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WindowFrame* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.WindowFrame";
  }
  protected:
  explicit WindowFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameExtentFieldNumber = 2,
    kFrameTypeFieldNumber = 1,
  };
  // optional .baikaldb.pb.FrameExtent frame_extent = 2;
  bool has_frame_extent() const;
  private:
  bool _internal_has_frame_extent() const;
  public:
  void clear_frame_extent();
  const ::baikaldb::pb::FrameExtent& frame_extent() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::FrameExtent* release_frame_extent();
  ::baikaldb::pb::FrameExtent* mutable_frame_extent();
  void set_allocated_frame_extent(::baikaldb::pb::FrameExtent* frame_extent);
  private:
  const ::baikaldb::pb::FrameExtent& _internal_frame_extent() const;
  ::baikaldb::pb::FrameExtent* _internal_mutable_frame_extent();
  public:
  void unsafe_arena_set_allocated_frame_extent(
      ::baikaldb::pb::FrameExtent* frame_extent);
  ::baikaldb::pb::FrameExtent* unsafe_arena_release_frame_extent();

  // optional .baikaldb.pb.FrameType frame_type = 1;
  bool has_frame_type() const;
  private:
  bool _internal_has_frame_type() const;
  public:
  void clear_frame_type();
  ::baikaldb::pb::FrameType frame_type() const;
  void set_frame_type(::baikaldb::pb::FrameType value);
  private:
  ::baikaldb::pb::FrameType _internal_frame_type() const;
  void _internal_set_frame_type(::baikaldb::pb::FrameType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.WindowFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::FrameExtent* frame_extent_;
  int frame_type_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class WindowSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.WindowSpec) */ {
 public:
  inline WindowSpec() : WindowSpec(nullptr) {}
  ~WindowSpec() override;
  explicit constexpr WindowSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WindowSpec(const WindowSpec& from);
  WindowSpec(WindowSpec&& from) noexcept
    : WindowSpec() {
    *this = ::std::move(from);
  }

  inline WindowSpec& operator=(const WindowSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowSpec& operator=(WindowSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const WindowSpec* internal_default_instance() {
    return reinterpret_cast<const WindowSpec*>(
               &_WindowSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(WindowSpec& a, WindowSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowSpec* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WindowSpec* New() const final {
    return new WindowSpec();
  }

  WindowSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WindowSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WindowSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WindowSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WindowSpec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.WindowSpec";
  }
  protected:
  explicit WindowSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionExprsFieldNumber = 1,
    kOrderExprsFieldNumber = 2,
    kIsAscFieldNumber = 3,
    kWindowFrameFieldNumber = 5,
    kTupleIdFieldNumber = 4,
  };
  // repeated .baikaldb.pb.Expr partition_exprs = 1;
  int partition_exprs_size() const;
  private:
  int _internal_partition_exprs_size() const;
  public:
  void clear_partition_exprs();
  ::baikaldb::pb::Expr* mutable_partition_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_partition_exprs();
  private:
  const ::baikaldb::pb::Expr& _internal_partition_exprs(int index) const;
  ::baikaldb::pb::Expr* _internal_add_partition_exprs();
  public:
  const ::baikaldb::pb::Expr& partition_exprs(int index) const;
  ::baikaldb::pb::Expr* add_partition_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      partition_exprs() const;

  // repeated .baikaldb.pb.Expr order_exprs = 2;
  int order_exprs_size() const;
  private:
  int _internal_order_exprs_size() const;
  public:
  void clear_order_exprs();
  ::baikaldb::pb::Expr* mutable_order_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_order_exprs();
  private:
  const ::baikaldb::pb::Expr& _internal_order_exprs(int index) const;
  ::baikaldb::pb::Expr* _internal_add_order_exprs();
  public:
  const ::baikaldb::pb::Expr& order_exprs(int index) const;
  ::baikaldb::pb::Expr* add_order_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      order_exprs() const;

  // repeated bool is_asc = 3;
  int is_asc_size() const;
  private:
  int _internal_is_asc_size() const;
  public:
  void clear_is_asc();
  private:
  bool _internal_is_asc(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_is_asc() const;
  void _internal_add_is_asc(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_is_asc();
  public:
  bool is_asc(int index) const;
  void set_is_asc(int index, bool value);
  void add_is_asc(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      is_asc() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_is_asc();

  // optional .baikaldb.pb.WindowFrame window_frame = 5;
  bool has_window_frame() const;
  private:
  bool _internal_has_window_frame() const;
  public:
  void clear_window_frame();
  const ::baikaldb::pb::WindowFrame& window_frame() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::WindowFrame* release_window_frame();
  ::baikaldb::pb::WindowFrame* mutable_window_frame();
  void set_allocated_window_frame(::baikaldb::pb::WindowFrame* window_frame);
  private:
  const ::baikaldb::pb::WindowFrame& _internal_window_frame() const;
  ::baikaldb::pb::WindowFrame* _internal_mutable_window_frame();
  public:
  void unsafe_arena_set_allocated_window_frame(
      ::baikaldb::pb::WindowFrame* window_frame);
  ::baikaldb::pb::WindowFrame* unsafe_arena_release_window_frame();

  // optional int32 tuple_id = 4;
  bool has_tuple_id() const;
  private:
  bool _internal_has_tuple_id() const;
  public:
  void clear_tuple_id();
  ::PROTOBUF_NAMESPACE_ID::int32 tuple_id() const;
  void set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tuple_id() const;
  void _internal_set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.WindowSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > partition_exprs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > order_exprs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > is_asc_;
  ::baikaldb::pb::WindowFrame* window_frame_;
  ::PROTOBUF_NAMESPACE_ID::int32 tuple_id_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class WindowNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.WindowNode) */ {
 public:
  inline WindowNode() : WindowNode(nullptr) {}
  ~WindowNode() override;
  explicit constexpr WindowNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WindowNode(const WindowNode& from);
  WindowNode(WindowNode&& from) noexcept
    : WindowNode() {
    *this = ::std::move(from);
  }

  inline WindowNode& operator=(const WindowNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowNode& operator=(WindowNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const WindowNode* internal_default_instance() {
    return reinterpret_cast<const WindowNode*>(
               &_WindowNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(WindowNode& a, WindowNode& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WindowNode* New() const final {
    return new WindowNode();
  }

  WindowNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WindowNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WindowNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WindowNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WindowNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.WindowNode";
  }
  protected:
  explicit WindowNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuncExprsFieldNumber = 1,
    kWindowSpecFieldNumber = 2,
  };
  // repeated .baikaldb.pb.Expr func_exprs = 1;
  int func_exprs_size() const;
  private:
  int _internal_func_exprs_size() const;
  public:
  void clear_func_exprs();
  ::baikaldb::pb::Expr* mutable_func_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_func_exprs();
  private:
  const ::baikaldb::pb::Expr& _internal_func_exprs(int index) const;
  ::baikaldb::pb::Expr* _internal_add_func_exprs();
  public:
  const ::baikaldb::pb::Expr& func_exprs(int index) const;
  ::baikaldb::pb::Expr* add_func_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      func_exprs() const;

  // optional .baikaldb.pb.WindowSpec window_spec = 2;
  bool has_window_spec() const;
  private:
  bool _internal_has_window_spec() const;
  public:
  void clear_window_spec();
  const ::baikaldb::pb::WindowSpec& window_spec() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::WindowSpec* release_window_spec();
  ::baikaldb::pb::WindowSpec* mutable_window_spec();
  void set_allocated_window_spec(::baikaldb::pb::WindowSpec* window_spec);
  private:
  const ::baikaldb::pb::WindowSpec& _internal_window_spec() const;
  ::baikaldb::pb::WindowSpec* _internal_mutable_window_spec();
  public:
  void unsafe_arena_set_allocated_window_spec(
      ::baikaldb::pb::WindowSpec* window_spec);
  ::baikaldb::pb::WindowSpec* unsafe_arena_release_window_spec();

  // @@protoc_insertion_point(class_scope:baikaldb.pb.WindowNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > func_exprs_;
  ::baikaldb::pb::WindowSpec* window_spec_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class DerivePlanNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.DerivePlanNode) */ {
 public:
  inline DerivePlanNode() : DerivePlanNode(nullptr) {}
  ~DerivePlanNode() override;
  explicit constexpr DerivePlanNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DerivePlanNode(const DerivePlanNode& from);
  DerivePlanNode(DerivePlanNode&& from) noexcept
    : DerivePlanNode() {
    *this = ::std::move(from);
  }

  inline DerivePlanNode& operator=(const DerivePlanNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivePlanNode& operator=(DerivePlanNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivePlanNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivePlanNode* internal_default_instance() {
    return reinterpret_cast<const DerivePlanNode*>(
               &_DerivePlanNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(DerivePlanNode& a, DerivePlanNode& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivePlanNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivePlanNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DerivePlanNode* New() const final {
    return new DerivePlanNode();
  }

  DerivePlanNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DerivePlanNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DerivePlanNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DerivePlanNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DerivePlanNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.DerivePlanNode";
  }
  protected:
  explicit DerivePlanNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterNodeFieldNumber = 4,
    kScanNodeFieldNumber = 1,
    kSortNodeFieldNumber = 2,
    kAggNodeFieldNumber = 3,
    kJoinNodeFieldNumber = 5,
    kInsertNodeFieldNumber = 6,
    kDeleteNodeFieldNumber = 7,
    kUpdateNodeFieldNumber = 8,
    kFetcherNodeFieldNumber = 9,
    kLimitNodeFieldNumber = 10,
    kPacketNodeFieldNumber = 11,
    kTruncateNodeFieldNumber = 12,
    kTransactionNodeFieldNumber = 13,
    kKillNodeFieldNumber = 14,
    kLockPrimaryNodeFieldNumber = 15,
    kLockSecondaryNodeFieldNumber = 16,
    kUnionNodeFieldNumber = 17,
    kApplyNodeFieldNumber = 18,
    kLoadNodeFieldNumber = 19,
    kRawFilterNodeFieldNumber = 20,
    kExchangeSenderNodeFieldNumber = 21,
    kExchangeReceiverNodeFieldNumber = 22,
    kSelectManagerNodeFieldNumber = 23,
    kDualScanNodeFieldNumber = 24,
    kWindowNodeFieldNumber = 25,
  };
  // optional bytes filter_node = 4;
  bool has_filter_node() const;
  private:
  bool _internal_has_filter_node() const;
  public:
  void clear_filter_node();
  const std::string& filter_node() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter_node(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter_node();
  PROTOBUF_MUST_USE_RESULT std::string* release_filter_node();
  void set_allocated_filter_node(std::string* filter_node);
  private:
  const std::string& _internal_filter_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter_node(const std::string& value);
  std::string* _internal_mutable_filter_node();
  public:

  // optional .baikaldb.pb.ScanNode scan_node = 1;
  bool has_scan_node() const;
  private:
  bool _internal_has_scan_node() const;
  public:
  void clear_scan_node();
  const ::baikaldb::pb::ScanNode& scan_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::ScanNode* release_scan_node();
  ::baikaldb::pb::ScanNode* mutable_scan_node();
  void set_allocated_scan_node(::baikaldb::pb::ScanNode* scan_node);
  private:
  const ::baikaldb::pb::ScanNode& _internal_scan_node() const;
  ::baikaldb::pb::ScanNode* _internal_mutable_scan_node();
  public:
  void unsafe_arena_set_allocated_scan_node(
      ::baikaldb::pb::ScanNode* scan_node);
  ::baikaldb::pb::ScanNode* unsafe_arena_release_scan_node();

  // optional .baikaldb.pb.SortNode sort_node = 2;
  bool has_sort_node() const;
  private:
  bool _internal_has_sort_node() const;
  public:
  void clear_sort_node();
  const ::baikaldb::pb::SortNode& sort_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::SortNode* release_sort_node();
  ::baikaldb::pb::SortNode* mutable_sort_node();
  void set_allocated_sort_node(::baikaldb::pb::SortNode* sort_node);
  private:
  const ::baikaldb::pb::SortNode& _internal_sort_node() const;
  ::baikaldb::pb::SortNode* _internal_mutable_sort_node();
  public:
  void unsafe_arena_set_allocated_sort_node(
      ::baikaldb::pb::SortNode* sort_node);
  ::baikaldb::pb::SortNode* unsafe_arena_release_sort_node();

  // optional .baikaldb.pb.AggNode agg_node = 3;
  bool has_agg_node() const;
  private:
  bool _internal_has_agg_node() const;
  public:
  void clear_agg_node();
  const ::baikaldb::pb::AggNode& agg_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::AggNode* release_agg_node();
  ::baikaldb::pb::AggNode* mutable_agg_node();
  void set_allocated_agg_node(::baikaldb::pb::AggNode* agg_node);
  private:
  const ::baikaldb::pb::AggNode& _internal_agg_node() const;
  ::baikaldb::pb::AggNode* _internal_mutable_agg_node();
  public:
  void unsafe_arena_set_allocated_agg_node(
      ::baikaldb::pb::AggNode* agg_node);
  ::baikaldb::pb::AggNode* unsafe_arena_release_agg_node();

  // optional .baikaldb.pb.JoinNode join_node = 5;
  bool has_join_node() const;
  private:
  bool _internal_has_join_node() const;
  public:
  void clear_join_node();
  const ::baikaldb::pb::JoinNode& join_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::JoinNode* release_join_node();
  ::baikaldb::pb::JoinNode* mutable_join_node();
  void set_allocated_join_node(::baikaldb::pb::JoinNode* join_node);
  private:
  const ::baikaldb::pb::JoinNode& _internal_join_node() const;
  ::baikaldb::pb::JoinNode* _internal_mutable_join_node();
  public:
  void unsafe_arena_set_allocated_join_node(
      ::baikaldb::pb::JoinNode* join_node);
  ::baikaldb::pb::JoinNode* unsafe_arena_release_join_node();

  // optional .baikaldb.pb.InsertNode insert_node = 6;
  bool has_insert_node() const;
  private:
  bool _internal_has_insert_node() const;
  public:
  void clear_insert_node();
  const ::baikaldb::pb::InsertNode& insert_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::InsertNode* release_insert_node();
  ::baikaldb::pb::InsertNode* mutable_insert_node();
  void set_allocated_insert_node(::baikaldb::pb::InsertNode* insert_node);
  private:
  const ::baikaldb::pb::InsertNode& _internal_insert_node() const;
  ::baikaldb::pb::InsertNode* _internal_mutable_insert_node();
  public:
  void unsafe_arena_set_allocated_insert_node(
      ::baikaldb::pb::InsertNode* insert_node);
  ::baikaldb::pb::InsertNode* unsafe_arena_release_insert_node();

  // optional .baikaldb.pb.DeleteNode delete_node = 7;
  bool has_delete_node() const;
  private:
  bool _internal_has_delete_node() const;
  public:
  void clear_delete_node();
  const ::baikaldb::pb::DeleteNode& delete_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::DeleteNode* release_delete_node();
  ::baikaldb::pb::DeleteNode* mutable_delete_node();
  void set_allocated_delete_node(::baikaldb::pb::DeleteNode* delete_node);
  private:
  const ::baikaldb::pb::DeleteNode& _internal_delete_node() const;
  ::baikaldb::pb::DeleteNode* _internal_mutable_delete_node();
  public:
  void unsafe_arena_set_allocated_delete_node(
      ::baikaldb::pb::DeleteNode* delete_node);
  ::baikaldb::pb::DeleteNode* unsafe_arena_release_delete_node();

  // optional .baikaldb.pb.UpdateNode update_node = 8;
  bool has_update_node() const;
  private:
  bool _internal_has_update_node() const;
  public:
  void clear_update_node();
  const ::baikaldb::pb::UpdateNode& update_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::UpdateNode* release_update_node();
  ::baikaldb::pb::UpdateNode* mutable_update_node();
  void set_allocated_update_node(::baikaldb::pb::UpdateNode* update_node);
  private:
  const ::baikaldb::pb::UpdateNode& _internal_update_node() const;
  ::baikaldb::pb::UpdateNode* _internal_mutable_update_node();
  public:
  void unsafe_arena_set_allocated_update_node(
      ::baikaldb::pb::UpdateNode* update_node);
  ::baikaldb::pb::UpdateNode* unsafe_arena_release_update_node();

  // optional .baikaldb.pb.FetcherNode fetcher_node = 9;
  bool has_fetcher_node() const;
  private:
  bool _internal_has_fetcher_node() const;
  public:
  void clear_fetcher_node();
  const ::baikaldb::pb::FetcherNode& fetcher_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::FetcherNode* release_fetcher_node();
  ::baikaldb::pb::FetcherNode* mutable_fetcher_node();
  void set_allocated_fetcher_node(::baikaldb::pb::FetcherNode* fetcher_node);
  private:
  const ::baikaldb::pb::FetcherNode& _internal_fetcher_node() const;
  ::baikaldb::pb::FetcherNode* _internal_mutable_fetcher_node();
  public:
  void unsafe_arena_set_allocated_fetcher_node(
      ::baikaldb::pb::FetcherNode* fetcher_node);
  ::baikaldb::pb::FetcherNode* unsafe_arena_release_fetcher_node();

  // optional .baikaldb.pb.LimitNode limit_node = 10;
  bool has_limit_node() const;
  private:
  bool _internal_has_limit_node() const;
  public:
  void clear_limit_node();
  const ::baikaldb::pb::LimitNode& limit_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::LimitNode* release_limit_node();
  ::baikaldb::pb::LimitNode* mutable_limit_node();
  void set_allocated_limit_node(::baikaldb::pb::LimitNode* limit_node);
  private:
  const ::baikaldb::pb::LimitNode& _internal_limit_node() const;
  ::baikaldb::pb::LimitNode* _internal_mutable_limit_node();
  public:
  void unsafe_arena_set_allocated_limit_node(
      ::baikaldb::pb::LimitNode* limit_node);
  ::baikaldb::pb::LimitNode* unsafe_arena_release_limit_node();

  // optional .baikaldb.pb.PacketNode packet_node = 11;
  bool has_packet_node() const;
  private:
  bool _internal_has_packet_node() const;
  public:
  void clear_packet_node();
  const ::baikaldb::pb::PacketNode& packet_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::PacketNode* release_packet_node();
  ::baikaldb::pb::PacketNode* mutable_packet_node();
  void set_allocated_packet_node(::baikaldb::pb::PacketNode* packet_node);
  private:
  const ::baikaldb::pb::PacketNode& _internal_packet_node() const;
  ::baikaldb::pb::PacketNode* _internal_mutable_packet_node();
  public:
  void unsafe_arena_set_allocated_packet_node(
      ::baikaldb::pb::PacketNode* packet_node);
  ::baikaldb::pb::PacketNode* unsafe_arena_release_packet_node();

  // optional .baikaldb.pb.TruncateNode truncate_node = 12;
  bool has_truncate_node() const;
  private:
  bool _internal_has_truncate_node() const;
  public:
  void clear_truncate_node();
  const ::baikaldb::pb::TruncateNode& truncate_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::TruncateNode* release_truncate_node();
  ::baikaldb::pb::TruncateNode* mutable_truncate_node();
  void set_allocated_truncate_node(::baikaldb::pb::TruncateNode* truncate_node);
  private:
  const ::baikaldb::pb::TruncateNode& _internal_truncate_node() const;
  ::baikaldb::pb::TruncateNode* _internal_mutable_truncate_node();
  public:
  void unsafe_arena_set_allocated_truncate_node(
      ::baikaldb::pb::TruncateNode* truncate_node);
  ::baikaldb::pb::TruncateNode* unsafe_arena_release_truncate_node();

  // optional .baikaldb.pb.TransactionNode transaction_node = 13;
  bool has_transaction_node() const;
  private:
  bool _internal_has_transaction_node() const;
  public:
  void clear_transaction_node();
  const ::baikaldb::pb::TransactionNode& transaction_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::TransactionNode* release_transaction_node();
  ::baikaldb::pb::TransactionNode* mutable_transaction_node();
  void set_allocated_transaction_node(::baikaldb::pb::TransactionNode* transaction_node);
  private:
  const ::baikaldb::pb::TransactionNode& _internal_transaction_node() const;
  ::baikaldb::pb::TransactionNode* _internal_mutable_transaction_node();
  public:
  void unsafe_arena_set_allocated_transaction_node(
      ::baikaldb::pb::TransactionNode* transaction_node);
  ::baikaldb::pb::TransactionNode* unsafe_arena_release_transaction_node();

  // optional .baikaldb.pb.KillNode kill_node = 14;
  bool has_kill_node() const;
  private:
  bool _internal_has_kill_node() const;
  public:
  void clear_kill_node();
  const ::baikaldb::pb::KillNode& kill_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::KillNode* release_kill_node();
  ::baikaldb::pb::KillNode* mutable_kill_node();
  void set_allocated_kill_node(::baikaldb::pb::KillNode* kill_node);
  private:
  const ::baikaldb::pb::KillNode& _internal_kill_node() const;
  ::baikaldb::pb::KillNode* _internal_mutable_kill_node();
  public:
  void unsafe_arena_set_allocated_kill_node(
      ::baikaldb::pb::KillNode* kill_node);
  ::baikaldb::pb::KillNode* unsafe_arena_release_kill_node();

  // optional .baikaldb.pb.LockPrimaryNode lock_primary_node = 15;
  bool has_lock_primary_node() const;
  private:
  bool _internal_has_lock_primary_node() const;
  public:
  void clear_lock_primary_node();
  const ::baikaldb::pb::LockPrimaryNode& lock_primary_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::LockPrimaryNode* release_lock_primary_node();
  ::baikaldb::pb::LockPrimaryNode* mutable_lock_primary_node();
  void set_allocated_lock_primary_node(::baikaldb::pb::LockPrimaryNode* lock_primary_node);
  private:
  const ::baikaldb::pb::LockPrimaryNode& _internal_lock_primary_node() const;
  ::baikaldb::pb::LockPrimaryNode* _internal_mutable_lock_primary_node();
  public:
  void unsafe_arena_set_allocated_lock_primary_node(
      ::baikaldb::pb::LockPrimaryNode* lock_primary_node);
  ::baikaldb::pb::LockPrimaryNode* unsafe_arena_release_lock_primary_node();

  // optional .baikaldb.pb.LockSecondaryNode lock_secondary_node = 16;
  bool has_lock_secondary_node() const;
  private:
  bool _internal_has_lock_secondary_node() const;
  public:
  void clear_lock_secondary_node();
  const ::baikaldb::pb::LockSecondaryNode& lock_secondary_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::LockSecondaryNode* release_lock_secondary_node();
  ::baikaldb::pb::LockSecondaryNode* mutable_lock_secondary_node();
  void set_allocated_lock_secondary_node(::baikaldb::pb::LockSecondaryNode* lock_secondary_node);
  private:
  const ::baikaldb::pb::LockSecondaryNode& _internal_lock_secondary_node() const;
  ::baikaldb::pb::LockSecondaryNode* _internal_mutable_lock_secondary_node();
  public:
  void unsafe_arena_set_allocated_lock_secondary_node(
      ::baikaldb::pb::LockSecondaryNode* lock_secondary_node);
  ::baikaldb::pb::LockSecondaryNode* unsafe_arena_release_lock_secondary_node();

  // optional .baikaldb.pb.UnionNode union_node = 17;
  bool has_union_node() const;
  private:
  bool _internal_has_union_node() const;
  public:
  void clear_union_node();
  const ::baikaldb::pb::UnionNode& union_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::UnionNode* release_union_node();
  ::baikaldb::pb::UnionNode* mutable_union_node();
  void set_allocated_union_node(::baikaldb::pb::UnionNode* union_node);
  private:
  const ::baikaldb::pb::UnionNode& _internal_union_node() const;
  ::baikaldb::pb::UnionNode* _internal_mutable_union_node();
  public:
  void unsafe_arena_set_allocated_union_node(
      ::baikaldb::pb::UnionNode* union_node);
  ::baikaldb::pb::UnionNode* unsafe_arena_release_union_node();

  // optional .baikaldb.pb.ApplyNode apply_node = 18;
  bool has_apply_node() const;
  private:
  bool _internal_has_apply_node() const;
  public:
  void clear_apply_node();
  const ::baikaldb::pb::ApplyNode& apply_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::ApplyNode* release_apply_node();
  ::baikaldb::pb::ApplyNode* mutable_apply_node();
  void set_allocated_apply_node(::baikaldb::pb::ApplyNode* apply_node);
  private:
  const ::baikaldb::pb::ApplyNode& _internal_apply_node() const;
  ::baikaldb::pb::ApplyNode* _internal_mutable_apply_node();
  public:
  void unsafe_arena_set_allocated_apply_node(
      ::baikaldb::pb::ApplyNode* apply_node);
  ::baikaldb::pb::ApplyNode* unsafe_arena_release_apply_node();

  // optional .baikaldb.pb.LoadNode load_node = 19;
  bool has_load_node() const;
  private:
  bool _internal_has_load_node() const;
  public:
  void clear_load_node();
  const ::baikaldb::pb::LoadNode& load_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::LoadNode* release_load_node();
  ::baikaldb::pb::LoadNode* mutable_load_node();
  void set_allocated_load_node(::baikaldb::pb::LoadNode* load_node);
  private:
  const ::baikaldb::pb::LoadNode& _internal_load_node() const;
  ::baikaldb::pb::LoadNode* _internal_mutable_load_node();
  public:
  void unsafe_arena_set_allocated_load_node(
      ::baikaldb::pb::LoadNode* load_node);
  ::baikaldb::pb::LoadNode* unsafe_arena_release_load_node();

  // optional .baikaldb.pb.FilterNode raw_filter_node = 20;
  bool has_raw_filter_node() const;
  private:
  bool _internal_has_raw_filter_node() const;
  public:
  void clear_raw_filter_node();
  const ::baikaldb::pb::FilterNode& raw_filter_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::FilterNode* release_raw_filter_node();
  ::baikaldb::pb::FilterNode* mutable_raw_filter_node();
  void set_allocated_raw_filter_node(::baikaldb::pb::FilterNode* raw_filter_node);
  private:
  const ::baikaldb::pb::FilterNode& _internal_raw_filter_node() const;
  ::baikaldb::pb::FilterNode* _internal_mutable_raw_filter_node();
  public:
  void unsafe_arena_set_allocated_raw_filter_node(
      ::baikaldb::pb::FilterNode* raw_filter_node);
  ::baikaldb::pb::FilterNode* unsafe_arena_release_raw_filter_node();

  // optional .baikaldb.pb.ExchangeSenderNode exchange_sender_node = 21;
  bool has_exchange_sender_node() const;
  private:
  bool _internal_has_exchange_sender_node() const;
  public:
  void clear_exchange_sender_node();
  const ::baikaldb::pb::ExchangeSenderNode& exchange_sender_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::ExchangeSenderNode* release_exchange_sender_node();
  ::baikaldb::pb::ExchangeSenderNode* mutable_exchange_sender_node();
  void set_allocated_exchange_sender_node(::baikaldb::pb::ExchangeSenderNode* exchange_sender_node);
  private:
  const ::baikaldb::pb::ExchangeSenderNode& _internal_exchange_sender_node() const;
  ::baikaldb::pb::ExchangeSenderNode* _internal_mutable_exchange_sender_node();
  public:
  void unsafe_arena_set_allocated_exchange_sender_node(
      ::baikaldb::pb::ExchangeSenderNode* exchange_sender_node);
  ::baikaldb::pb::ExchangeSenderNode* unsafe_arena_release_exchange_sender_node();

  // optional .baikaldb.pb.ExchangeReceiverNode exchange_receiver_node = 22;
  bool has_exchange_receiver_node() const;
  private:
  bool _internal_has_exchange_receiver_node() const;
  public:
  void clear_exchange_receiver_node();
  const ::baikaldb::pb::ExchangeReceiverNode& exchange_receiver_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::ExchangeReceiverNode* release_exchange_receiver_node();
  ::baikaldb::pb::ExchangeReceiverNode* mutable_exchange_receiver_node();
  void set_allocated_exchange_receiver_node(::baikaldb::pb::ExchangeReceiverNode* exchange_receiver_node);
  private:
  const ::baikaldb::pb::ExchangeReceiverNode& _internal_exchange_receiver_node() const;
  ::baikaldb::pb::ExchangeReceiverNode* _internal_mutable_exchange_receiver_node();
  public:
  void unsafe_arena_set_allocated_exchange_receiver_node(
      ::baikaldb::pb::ExchangeReceiverNode* exchange_receiver_node);
  ::baikaldb::pb::ExchangeReceiverNode* unsafe_arena_release_exchange_receiver_node();

  // optional .baikaldb.pb.SelectManagerNode select_manager_node = 23;
  bool has_select_manager_node() const;
  private:
  bool _internal_has_select_manager_node() const;
  public:
  void clear_select_manager_node();
  const ::baikaldb::pb::SelectManagerNode& select_manager_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::SelectManagerNode* release_select_manager_node();
  ::baikaldb::pb::SelectManagerNode* mutable_select_manager_node();
  void set_allocated_select_manager_node(::baikaldb::pb::SelectManagerNode* select_manager_node);
  private:
  const ::baikaldb::pb::SelectManagerNode& _internal_select_manager_node() const;
  ::baikaldb::pb::SelectManagerNode* _internal_mutable_select_manager_node();
  public:
  void unsafe_arena_set_allocated_select_manager_node(
      ::baikaldb::pb::SelectManagerNode* select_manager_node);
  ::baikaldb::pb::SelectManagerNode* unsafe_arena_release_select_manager_node();

  // optional .baikaldb.pb.DualScanNode dual_scan_node = 24;
  bool has_dual_scan_node() const;
  private:
  bool _internal_has_dual_scan_node() const;
  public:
  void clear_dual_scan_node();
  const ::baikaldb::pb::DualScanNode& dual_scan_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::DualScanNode* release_dual_scan_node();
  ::baikaldb::pb::DualScanNode* mutable_dual_scan_node();
  void set_allocated_dual_scan_node(::baikaldb::pb::DualScanNode* dual_scan_node);
  private:
  const ::baikaldb::pb::DualScanNode& _internal_dual_scan_node() const;
  ::baikaldb::pb::DualScanNode* _internal_mutable_dual_scan_node();
  public:
  void unsafe_arena_set_allocated_dual_scan_node(
      ::baikaldb::pb::DualScanNode* dual_scan_node);
  ::baikaldb::pb::DualScanNode* unsafe_arena_release_dual_scan_node();

  // optional .baikaldb.pb.WindowNode window_node = 25;
  bool has_window_node() const;
  private:
  bool _internal_has_window_node() const;
  public:
  void clear_window_node();
  const ::baikaldb::pb::WindowNode& window_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::WindowNode* release_window_node();
  ::baikaldb::pb::WindowNode* mutable_window_node();
  void set_allocated_window_node(::baikaldb::pb::WindowNode* window_node);
  private:
  const ::baikaldb::pb::WindowNode& _internal_window_node() const;
  ::baikaldb::pb::WindowNode* _internal_mutable_window_node();
  public:
  void unsafe_arena_set_allocated_window_node(
      ::baikaldb::pb::WindowNode* window_node);
  ::baikaldb::pb::WindowNode* unsafe_arena_release_window_node();

  // @@protoc_insertion_point(class_scope:baikaldb.pb.DerivePlanNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_node_;
  ::baikaldb::pb::ScanNode* scan_node_;
  ::baikaldb::pb::SortNode* sort_node_;
  ::baikaldb::pb::AggNode* agg_node_;
  ::baikaldb::pb::JoinNode* join_node_;
  ::baikaldb::pb::InsertNode* insert_node_;
  ::baikaldb::pb::DeleteNode* delete_node_;
  ::baikaldb::pb::UpdateNode* update_node_;
  ::baikaldb::pb::FetcherNode* fetcher_node_;
  ::baikaldb::pb::LimitNode* limit_node_;
  ::baikaldb::pb::PacketNode* packet_node_;
  ::baikaldb::pb::TruncateNode* truncate_node_;
  ::baikaldb::pb::TransactionNode* transaction_node_;
  ::baikaldb::pb::KillNode* kill_node_;
  ::baikaldb::pb::LockPrimaryNode* lock_primary_node_;
  ::baikaldb::pb::LockSecondaryNode* lock_secondary_node_;
  ::baikaldb::pb::UnionNode* union_node_;
  ::baikaldb::pb::ApplyNode* apply_node_;
  ::baikaldb::pb::LoadNode* load_node_;
  ::baikaldb::pb::FilterNode* raw_filter_node_;
  ::baikaldb::pb::ExchangeSenderNode* exchange_sender_node_;
  ::baikaldb::pb::ExchangeReceiverNode* exchange_receiver_node_;
  ::baikaldb::pb::SelectManagerNode* select_manager_node_;
  ::baikaldb::pb::DualScanNode* dual_scan_node_;
  ::baikaldb::pb::WindowNode* window_node_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class PlanNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.PlanNode) */ {
 public:
  inline PlanNode() : PlanNode(nullptr) {}
  ~PlanNode() override;
  explicit constexpr PlanNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanNode(const PlanNode& from);
  PlanNode(PlanNode&& from) noexcept
    : PlanNode() {
    *this = ::std::move(from);
  }

  inline PlanNode& operator=(const PlanNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanNode& operator=(PlanNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanNode* internal_default_instance() {
    return reinterpret_cast<const PlanNode*>(
               &_PlanNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(PlanNode& a, PlanNode& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlanNode* New() const final {
    return new PlanNode();
  }

  PlanNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlanNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlanNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.PlanNode";
  }
  protected:
  explicit PlanNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionsFieldNumber = 9,
    kDeriveNodeFieldNumber = 6,
    kLimitFieldNumber = 5,
    kNumChildrenFieldNumber = 3,
    kIsExplainFieldNumber = 7,
    kLocalIndexBinlogFieldNumber = 8,
    kIsGetKeypointFieldNumber = 10,
    kNodeTypeFieldNumber = 2,
  };
  // repeated int64 partitions = 9;
  int partitions_size() const;
  private:
  int _internal_partitions_size() const;
  public:
  void clear_partitions();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_partitions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_partitions() const;
  void _internal_add_partitions(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_partitions();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 partitions(int index) const;
  void set_partitions(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_partitions(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      partitions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_partitions();

  // optional .baikaldb.pb.DerivePlanNode derive_node = 6;
  bool has_derive_node() const;
  private:
  bool _internal_has_derive_node() const;
  public:
  void clear_derive_node();
  const ::baikaldb::pb::DerivePlanNode& derive_node() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::DerivePlanNode* release_derive_node();
  ::baikaldb::pb::DerivePlanNode* mutable_derive_node();
  void set_allocated_derive_node(::baikaldb::pb::DerivePlanNode* derive_node);
  private:
  const ::baikaldb::pb::DerivePlanNode& _internal_derive_node() const;
  ::baikaldb::pb::DerivePlanNode* _internal_mutable_derive_node();
  public:
  void unsafe_arena_set_allocated_derive_node(
      ::baikaldb::pb::DerivePlanNode* derive_node);
  ::baikaldb::pb::DerivePlanNode* unsafe_arena_release_derive_node();

  // optional int64 limit = 5;
  bool has_limit() const;
  private:
  bool _internal_has_limit() const;
  public:
  void clear_limit();
  ::PROTOBUF_NAMESPACE_ID::int64 limit() const;
  void set_limit(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_limit() const;
  void _internal_set_limit(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int32 num_children = 3;
  bool has_num_children() const;
  private:
  bool _internal_has_num_children() const;
  public:
  void clear_num_children();
  ::PROTOBUF_NAMESPACE_ID::int32 num_children() const;
  void set_num_children(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_children() const;
  void _internal_set_num_children(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool is_explain = 7;
  bool has_is_explain() const;
  private:
  bool _internal_has_is_explain() const;
  public:
  void clear_is_explain();
  bool is_explain() const;
  void set_is_explain(bool value);
  private:
  bool _internal_is_explain() const;
  void _internal_set_is_explain(bool value);
  public:

  // optional bool local_index_binlog = 8;
  bool has_local_index_binlog() const;
  private:
  bool _internal_has_local_index_binlog() const;
  public:
  void clear_local_index_binlog();
  bool local_index_binlog() const;
  void set_local_index_binlog(bool value);
  private:
  bool _internal_local_index_binlog() const;
  void _internal_set_local_index_binlog(bool value);
  public:

  // optional bool is_get_keypoint = 10;
  bool has_is_get_keypoint() const;
  private:
  bool _internal_has_is_get_keypoint() const;
  public:
  void clear_is_get_keypoint();
  bool is_get_keypoint() const;
  void set_is_get_keypoint(bool value);
  private:
  bool _internal_is_get_keypoint() const;
  void _internal_set_is_get_keypoint(bool value);
  public:

  // required .baikaldb.pb.PlanNodeType node_type = 2;
  bool has_node_type() const;
  private:
  bool _internal_has_node_type() const;
  public:
  void clear_node_type();
  ::baikaldb::pb::PlanNodeType node_type() const;
  void set_node_type(::baikaldb::pb::PlanNodeType value);
  private:
  ::baikaldb::pb::PlanNodeType _internal_node_type() const;
  void _internal_set_node_type(::baikaldb::pb::PlanNodeType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.PlanNode)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > partitions_;
  ::baikaldb::pb::DerivePlanNode* derive_node_;
  ::PROTOBUF_NAMESPACE_ID::int64 limit_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_children_;
  bool is_explain_;
  bool local_index_binlog_;
  bool is_get_keypoint_;
  int node_type_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class Plan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.Plan) */ {
 public:
  inline Plan() : Plan(nullptr) {}
  ~Plan() override;
  explicit constexpr Plan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Plan(const Plan& from);
  Plan(Plan&& from) noexcept
    : Plan() {
    *this = ::std::move(from);
  }

  inline Plan& operator=(const Plan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Plan& operator=(Plan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Plan& default_instance() {
    return *internal_default_instance();
  }
  static inline const Plan* internal_default_instance() {
    return reinterpret_cast<const Plan*>(
               &_Plan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(Plan& a, Plan& b) {
    a.Swap(&b);
  }
  inline void Swap(Plan* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Plan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Plan* New() const final {
    return new Plan();
  }

  Plan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Plan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Plan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Plan& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Plan* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.Plan";
  }
  protected:
  explicit Plan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated .baikaldb.pb.PlanNode nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::baikaldb::pb::PlanNode* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PlanNode >*
      mutable_nodes();
  private:
  const ::baikaldb::pb::PlanNode& _internal_nodes(int index) const;
  ::baikaldb::pb::PlanNode* _internal_add_nodes();
  public:
  const ::baikaldb::pb::PlanNode& nodes(int index) const;
  ::baikaldb::pb::PlanNode* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PlanNode >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:baikaldb.pb.Plan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PlanNode > nodes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class LocalTraceNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.LocalTraceNode) */ {
 public:
  inline LocalTraceNode() : LocalTraceNode(nullptr) {}
  ~LocalTraceNode() override;
  explicit constexpr LocalTraceNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalTraceNode(const LocalTraceNode& from);
  LocalTraceNode(LocalTraceNode&& from) noexcept
    : LocalTraceNode() {
    *this = ::std::move(from);
  }

  inline LocalTraceNode& operator=(const LocalTraceNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalTraceNode& operator=(LocalTraceNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalTraceNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalTraceNode* internal_default_instance() {
    return reinterpret_cast<const LocalTraceNode*>(
               &_LocalTraceNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(LocalTraceNode& a, LocalTraceNode& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalTraceNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalTraceNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LocalTraceNode* New() const final {
    return new LocalTraceNode();
  }

  LocalTraceNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LocalTraceNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalTraceNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocalTraceNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalTraceNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.LocalTraceNode";
  }
  protected:
  explicit LocalTraceNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrowPlanFieldNumber = 11,
    kDescriptionFieldNumber = 8,
    kIndexNameFieldNumber = 10,
    kMppPropertyFieldNumber = 12,
    kTimeCostUsFieldNumber = 1,
    kSortTimeFieldNumber = 2,
    kAffectRowsFieldNumber = 3,
    kScanRowsFieldNumber = 4,
    kIndexFilterRowsFieldNumber = 5,
    kGetPrimaryRowsFieldNumber = 6,
    kWhereFilterRowsFieldNumber = 9,
  };
  // repeated string arrow_plan = 11;
  int arrow_plan_size() const;
  private:
  int _internal_arrow_plan_size() const;
  public:
  void clear_arrow_plan();
  const std::string& arrow_plan(int index) const;
  std::string* mutable_arrow_plan(int index);
  void set_arrow_plan(int index, const std::string& value);
  void set_arrow_plan(int index, std::string&& value);
  void set_arrow_plan(int index, const char* value);
  void set_arrow_plan(int index, const char* value, size_t size);
  std::string* add_arrow_plan();
  void add_arrow_plan(const std::string& value);
  void add_arrow_plan(std::string&& value);
  void add_arrow_plan(const char* value);
  void add_arrow_plan(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& arrow_plan() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_arrow_plan();
  private:
  const std::string& _internal_arrow_plan(int index) const;
  std::string* _internal_add_arrow_plan();
  public:

  // optional string description = 8;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string index_name = 10;
  bool has_index_name() const;
  private:
  bool _internal_has_index_name() const;
  public:
  void clear_index_name();
  const std::string& index_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_index_name();
  void set_allocated_index_name(std::string* index_name);
  private:
  const std::string& _internal_index_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index_name(const std::string& value);
  std::string* _internal_mutable_index_name();
  public:

  // optional string mpp_property = 12;
  bool has_mpp_property() const;
  private:
  bool _internal_has_mpp_property() const;
  public:
  void clear_mpp_property();
  const std::string& mpp_property() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mpp_property(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mpp_property();
  PROTOBUF_MUST_USE_RESULT std::string* release_mpp_property();
  void set_allocated_mpp_property(std::string* mpp_property);
  private:
  const std::string& _internal_mpp_property() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mpp_property(const std::string& value);
  std::string* _internal_mutable_mpp_property();
  public:

  // optional int64 time_cost_us = 1;
  bool has_time_cost_us() const;
  private:
  bool _internal_has_time_cost_us() const;
  public:
  void clear_time_cost_us();
  ::PROTOBUF_NAMESPACE_ID::int64 time_cost_us() const;
  void set_time_cost_us(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time_cost_us() const;
  void _internal_set_time_cost_us(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 sort_time = 2;
  bool has_sort_time() const;
  private:
  bool _internal_has_sort_time() const;
  public:
  void clear_sort_time();
  ::PROTOBUF_NAMESPACE_ID::int64 sort_time() const;
  void set_sort_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_sort_time() const;
  void _internal_set_sort_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 affect_rows = 3;
  bool has_affect_rows() const;
  private:
  bool _internal_has_affect_rows() const;
  public:
  void clear_affect_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 affect_rows() const;
  void set_affect_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_affect_rows() const;
  void _internal_set_affect_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 scan_rows = 4;
  bool has_scan_rows() const;
  private:
  bool _internal_has_scan_rows() const;
  public:
  void clear_scan_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 scan_rows() const;
  void set_scan_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_scan_rows() const;
  void _internal_set_scan_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 index_filter_rows = 5;
  bool has_index_filter_rows() const;
  private:
  bool _internal_has_index_filter_rows() const;
  public:
  void clear_index_filter_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 index_filter_rows() const;
  void set_index_filter_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_index_filter_rows() const;
  void _internal_set_index_filter_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 get_primary_rows = 6;
  bool has_get_primary_rows() const;
  private:
  bool _internal_has_get_primary_rows() const;
  public:
  void clear_get_primary_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 get_primary_rows() const;
  void set_get_primary_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_get_primary_rows() const;
  void _internal_set_get_primary_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 where_filter_rows = 9;
  bool has_where_filter_rows() const;
  private:
  bool _internal_has_where_filter_rows() const;
  public:
  void clear_where_filter_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 where_filter_rows() const;
  void set_where_filter_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_where_filter_rows() const;
  void _internal_set_where_filter_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.LocalTraceNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> arrow_plan_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mpp_property_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_cost_us_;
  ::PROTOBUF_NAMESPACE_ID::int64 sort_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 affect_rows_;
  ::PROTOBUF_NAMESPACE_ID::int64 scan_rows_;
  ::PROTOBUF_NAMESPACE_ID::int64 index_filter_rows_;
  ::PROTOBUF_NAMESPACE_ID::int64 get_primary_rows_;
  ::PROTOBUF_NAMESPACE_ID::int64 where_filter_rows_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class TraceNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TraceNode) */ {
 public:
  inline TraceNode() : TraceNode(nullptr) {}
  ~TraceNode() override;
  explicit constexpr TraceNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TraceNode(const TraceNode& from);
  TraceNode(TraceNode&& from) noexcept
    : TraceNode() {
    *this = ::std::move(from);
  }

  inline TraceNode& operator=(const TraceNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TraceNode& operator=(TraceNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TraceNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const TraceNode* internal_default_instance() {
    return reinterpret_cast<const TraceNode*>(
               &_TraceNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(TraceNode& a, TraceNode& b) {
    a.Swap(&b);
  }
  inline void Swap(TraceNode* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TraceNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TraceNode* New() const final {
    return new TraceNode();
  }

  TraceNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TraceNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TraceNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TraceNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TraceNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TraceNode";
  }
  protected:
  explicit TraceNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildNodesFieldNumber = 14,
    kDescriptionFieldNumber = 2,
    kInstanceFieldNumber = 3,
    kOpenTraceFieldNumber = 7,
    kGetNextTraceFieldNumber = 8,
    kTxnGetTraceFieldNumber = 9,
    kTxnPutTraceFieldNumber = 10,
    kTxnDeleteTraceFieldNumber = 11,
    kTxnCommitTraceFieldNumber = 12,
    kStoreAggFieldNumber = 13,
    kRegionIdFieldNumber = 4,
    kTotalTimeFieldNumber = 5,
    kAffectRowsFieldNumber = 6,
    kPartitionIdFieldNumber = 15,
    kNodeTypeFieldNumber = 1,
  };
  // repeated .baikaldb.pb.TraceNode child_nodes = 14;
  int child_nodes_size() const;
  private:
  int _internal_child_nodes_size() const;
  public:
  void clear_child_nodes();
  ::baikaldb::pb::TraceNode* mutable_child_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TraceNode >*
      mutable_child_nodes();
  private:
  const ::baikaldb::pb::TraceNode& _internal_child_nodes(int index) const;
  ::baikaldb::pb::TraceNode* _internal_add_child_nodes();
  public:
  const ::baikaldb::pb::TraceNode& child_nodes(int index) const;
  ::baikaldb::pb::TraceNode* add_child_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TraceNode >&
      child_nodes() const;

  // optional string description = 2;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string instance = 3;
  bool has_instance() const;
  private:
  bool _internal_has_instance() const;
  public:
  void clear_instance();
  const std::string& instance() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance();
  PROTOBUF_MUST_USE_RESULT std::string* release_instance();
  void set_allocated_instance(std::string* instance);
  private:
  const std::string& _internal_instance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance(const std::string& value);
  std::string* _internal_mutable_instance();
  public:

  // optional .baikaldb.pb.LocalTraceNode open_trace = 7;
  bool has_open_trace() const;
  private:
  bool _internal_has_open_trace() const;
  public:
  void clear_open_trace();
  const ::baikaldb::pb::LocalTraceNode& open_trace() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::LocalTraceNode* release_open_trace();
  ::baikaldb::pb::LocalTraceNode* mutable_open_trace();
  void set_allocated_open_trace(::baikaldb::pb::LocalTraceNode* open_trace);
  private:
  const ::baikaldb::pb::LocalTraceNode& _internal_open_trace() const;
  ::baikaldb::pb::LocalTraceNode* _internal_mutable_open_trace();
  public:
  void unsafe_arena_set_allocated_open_trace(
      ::baikaldb::pb::LocalTraceNode* open_trace);
  ::baikaldb::pb::LocalTraceNode* unsafe_arena_release_open_trace();

  // optional .baikaldb.pb.LocalTraceNode get_next_trace = 8;
  bool has_get_next_trace() const;
  private:
  bool _internal_has_get_next_trace() const;
  public:
  void clear_get_next_trace();
  const ::baikaldb::pb::LocalTraceNode& get_next_trace() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::LocalTraceNode* release_get_next_trace();
  ::baikaldb::pb::LocalTraceNode* mutable_get_next_trace();
  void set_allocated_get_next_trace(::baikaldb::pb::LocalTraceNode* get_next_trace);
  private:
  const ::baikaldb::pb::LocalTraceNode& _internal_get_next_trace() const;
  ::baikaldb::pb::LocalTraceNode* _internal_mutable_get_next_trace();
  public:
  void unsafe_arena_set_allocated_get_next_trace(
      ::baikaldb::pb::LocalTraceNode* get_next_trace);
  ::baikaldb::pb::LocalTraceNode* unsafe_arena_release_get_next_trace();

  // optional .baikaldb.pb.LocalTraceNode txn_get_trace = 9;
  bool has_txn_get_trace() const;
  private:
  bool _internal_has_txn_get_trace() const;
  public:
  void clear_txn_get_trace();
  const ::baikaldb::pb::LocalTraceNode& txn_get_trace() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::LocalTraceNode* release_txn_get_trace();
  ::baikaldb::pb::LocalTraceNode* mutable_txn_get_trace();
  void set_allocated_txn_get_trace(::baikaldb::pb::LocalTraceNode* txn_get_trace);
  private:
  const ::baikaldb::pb::LocalTraceNode& _internal_txn_get_trace() const;
  ::baikaldb::pb::LocalTraceNode* _internal_mutable_txn_get_trace();
  public:
  void unsafe_arena_set_allocated_txn_get_trace(
      ::baikaldb::pb::LocalTraceNode* txn_get_trace);
  ::baikaldb::pb::LocalTraceNode* unsafe_arena_release_txn_get_trace();

  // optional .baikaldb.pb.LocalTraceNode txn_put_trace = 10;
  bool has_txn_put_trace() const;
  private:
  bool _internal_has_txn_put_trace() const;
  public:
  void clear_txn_put_trace();
  const ::baikaldb::pb::LocalTraceNode& txn_put_trace() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::LocalTraceNode* release_txn_put_trace();
  ::baikaldb::pb::LocalTraceNode* mutable_txn_put_trace();
  void set_allocated_txn_put_trace(::baikaldb::pb::LocalTraceNode* txn_put_trace);
  private:
  const ::baikaldb::pb::LocalTraceNode& _internal_txn_put_trace() const;
  ::baikaldb::pb::LocalTraceNode* _internal_mutable_txn_put_trace();
  public:
  void unsafe_arena_set_allocated_txn_put_trace(
      ::baikaldb::pb::LocalTraceNode* txn_put_trace);
  ::baikaldb::pb::LocalTraceNode* unsafe_arena_release_txn_put_trace();

  // optional .baikaldb.pb.LocalTraceNode txn_delete_trace = 11;
  bool has_txn_delete_trace() const;
  private:
  bool _internal_has_txn_delete_trace() const;
  public:
  void clear_txn_delete_trace();
  const ::baikaldb::pb::LocalTraceNode& txn_delete_trace() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::LocalTraceNode* release_txn_delete_trace();
  ::baikaldb::pb::LocalTraceNode* mutable_txn_delete_trace();
  void set_allocated_txn_delete_trace(::baikaldb::pb::LocalTraceNode* txn_delete_trace);
  private:
  const ::baikaldb::pb::LocalTraceNode& _internal_txn_delete_trace() const;
  ::baikaldb::pb::LocalTraceNode* _internal_mutable_txn_delete_trace();
  public:
  void unsafe_arena_set_allocated_txn_delete_trace(
      ::baikaldb::pb::LocalTraceNode* txn_delete_trace);
  ::baikaldb::pb::LocalTraceNode* unsafe_arena_release_txn_delete_trace();

  // optional .baikaldb.pb.LocalTraceNode txn_commit_trace = 12;
  bool has_txn_commit_trace() const;
  private:
  bool _internal_has_txn_commit_trace() const;
  public:
  void clear_txn_commit_trace();
  const ::baikaldb::pb::LocalTraceNode& txn_commit_trace() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::LocalTraceNode* release_txn_commit_trace();
  ::baikaldb::pb::LocalTraceNode* mutable_txn_commit_trace();
  void set_allocated_txn_commit_trace(::baikaldb::pb::LocalTraceNode* txn_commit_trace);
  private:
  const ::baikaldb::pb::LocalTraceNode& _internal_txn_commit_trace() const;
  ::baikaldb::pb::LocalTraceNode* _internal_mutable_txn_commit_trace();
  public:
  void unsafe_arena_set_allocated_txn_commit_trace(
      ::baikaldb::pb::LocalTraceNode* txn_commit_trace);
  ::baikaldb::pb::LocalTraceNode* unsafe_arena_release_txn_commit_trace();

  // optional .baikaldb.pb.LocalTraceNode store_agg = 13;
  bool has_store_agg() const;
  private:
  bool _internal_has_store_agg() const;
  public:
  void clear_store_agg();
  const ::baikaldb::pb::LocalTraceNode& store_agg() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::LocalTraceNode* release_store_agg();
  ::baikaldb::pb::LocalTraceNode* mutable_store_agg();
  void set_allocated_store_agg(::baikaldb::pb::LocalTraceNode* store_agg);
  private:
  const ::baikaldb::pb::LocalTraceNode& _internal_store_agg() const;
  ::baikaldb::pb::LocalTraceNode* _internal_mutable_store_agg();
  public:
  void unsafe_arena_set_allocated_store_agg(
      ::baikaldb::pb::LocalTraceNode* store_agg);
  ::baikaldb::pb::LocalTraceNode* unsafe_arena_release_store_agg();

  // optional int64 region_id = 4;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 total_time = 5;
  bool has_total_time() const;
  private:
  bool _internal_has_total_time() const;
  public:
  void clear_total_time();
  ::PROTOBUF_NAMESPACE_ID::int64 total_time() const;
  void set_total_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_total_time() const;
  void _internal_set_total_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 affect_rows = 6;
  bool has_affect_rows() const;
  private:
  bool _internal_has_affect_rows() const;
  public:
  void clear_affect_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 affect_rows() const;
  void set_affect_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_affect_rows() const;
  void _internal_set_affect_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 partition_id = 15;
  bool has_partition_id() const;
  private:
  bool _internal_has_partition_id() const;
  public:
  void clear_partition_id();
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id() const;
  void set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_partition_id() const;
  void _internal_set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.PlanNodeType node_type = 1;
  bool has_node_type() const;
  private:
  bool _internal_has_node_type() const;
  public:
  void clear_node_type();
  ::baikaldb::pb::PlanNodeType node_type() const;
  void set_node_type(::baikaldb::pb::PlanNodeType value);
  private:
  ::baikaldb::pb::PlanNodeType _internal_node_type() const;
  void _internal_set_node_type(::baikaldb::pb::PlanNodeType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TraceNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TraceNode > child_nodes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_;
  ::baikaldb::pb::LocalTraceNode* open_trace_;
  ::baikaldb::pb::LocalTraceNode* get_next_trace_;
  ::baikaldb::pb::LocalTraceNode* txn_get_trace_;
  ::baikaldb::pb::LocalTraceNode* txn_put_trace_;
  ::baikaldb::pb::LocalTraceNode* txn_delete_trace_;
  ::baikaldb::pb::LocalTraceNode* txn_commit_trace_;
  ::baikaldb::pb::LocalTraceNode* store_agg_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 affect_rows_;
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id_;
  int node_type_;
  friend struct ::TableStruct_plan_2eproto;
};
// -------------------------------------------------------------------

class FragmentInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.FragmentInfo) */ {
 public:
  inline FragmentInfo() : FragmentInfo(nullptr) {}
  ~FragmentInfo() override;
  explicit constexpr FragmentInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FragmentInfo(const FragmentInfo& from);
  FragmentInfo(FragmentInfo&& from) noexcept
    : FragmentInfo() {
    *this = ::std::move(from);
  }

  inline FragmentInfo& operator=(const FragmentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FragmentInfo& operator=(FragmentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FragmentInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FragmentInfo* internal_default_instance() {
    return reinterpret_cast<const FragmentInfo*>(
               &_FragmentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(FragmentInfo& a, FragmentInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FragmentInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FragmentInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FragmentInfo* New() const final {
    return new FragmentInfo();
  }

  FragmentInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FragmentInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FragmentInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FragmentInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FragmentInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.FragmentInfo";
  }
  protected:
  explicit FragmentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlanFieldNumber = 2,
    kRuntimeStateFieldNumber = 3,
    kFragmentIdFieldNumber = 1,
  };
  // required .baikaldb.pb.Plan plan = 2;
  bool has_plan() const;
  private:
  bool _internal_has_plan() const;
  public:
  void clear_plan();
  const ::baikaldb::pb::Plan& plan() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::Plan* release_plan();
  ::baikaldb::pb::Plan* mutable_plan();
  void set_allocated_plan(::baikaldb::pb::Plan* plan);
  private:
  const ::baikaldb::pb::Plan& _internal_plan() const;
  ::baikaldb::pb::Plan* _internal_mutable_plan();
  public:
  void unsafe_arena_set_allocated_plan(
      ::baikaldb::pb::Plan* plan);
  ::baikaldb::pb::Plan* unsafe_arena_release_plan();

  // optional .baikaldb.pb.RuntimeState runtime_state = 3;
  bool has_runtime_state() const;
  private:
  bool _internal_has_runtime_state() const;
  public:
  void clear_runtime_state();
  const ::baikaldb::pb::RuntimeState& runtime_state() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RuntimeState* release_runtime_state();
  ::baikaldb::pb::RuntimeState* mutable_runtime_state();
  void set_allocated_runtime_state(::baikaldb::pb::RuntimeState* runtime_state);
  private:
  const ::baikaldb::pb::RuntimeState& _internal_runtime_state() const;
  ::baikaldb::pb::RuntimeState* _internal_mutable_runtime_state();
  public:
  void unsafe_arena_set_allocated_runtime_state(
      ::baikaldb::pb::RuntimeState* runtime_state);
  ::baikaldb::pb::RuntimeState* unsafe_arena_release_runtime_state();

  // required int32 fragment_id = 1;
  bool has_fragment_id() const;
  private:
  bool _internal_has_fragment_id() const;
  public:
  void clear_fragment_id();
  ::PROTOBUF_NAMESPACE_ID::int32 fragment_id() const;
  void set_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_fragment_id() const;
  void _internal_set_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.FragmentInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::Plan* plan_;
  ::baikaldb::pb::RuntimeState* runtime_state_;
  ::PROTOBUF_NAMESPACE_ID::int32 fragment_id_;
  friend struct ::TableStruct_plan_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SelectManagerNode

// optional bytes schema = 1;
inline bool SelectManagerNode::_internal_has_schema() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SelectManagerNode::has_schema() const {
  return _internal_has_schema();
}
inline void SelectManagerNode::clear_schema() {
  schema_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SelectManagerNode::schema() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SelectManagerNode.schema)
  return _internal_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectManagerNode::set_schema(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 schema_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SelectManagerNode.schema)
}
inline std::string* SelectManagerNode::mutable_schema() {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SelectManagerNode.schema)
  return _s;
}
inline const std::string& SelectManagerNode::_internal_schema() const {
  return schema_.Get();
}
inline void SelectManagerNode::_internal_set_schema(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SelectManagerNode::_internal_mutable_schema() {
  _has_bits_[0] |= 0x00000001u;
  return schema_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SelectManagerNode::release_schema() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SelectManagerNode.schema)
  if (!_internal_has_schema()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return schema_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SelectManagerNode::set_allocated_schema(std::string* schema) {
  if (schema != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  schema_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SelectManagerNode.schema)
}

// repeated .baikaldb.pb.Expr slot_order_exprs = 2;
inline int SelectManagerNode::_internal_slot_order_exprs_size() const {
  return slot_order_exprs_.size();
}
inline int SelectManagerNode::slot_order_exprs_size() const {
  return _internal_slot_order_exprs_size();
}
inline ::baikaldb::pb::Expr* SelectManagerNode::mutable_slot_order_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SelectManagerNode.slot_order_exprs)
  return slot_order_exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
SelectManagerNode::mutable_slot_order_exprs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SelectManagerNode.slot_order_exprs)
  return &slot_order_exprs_;
}
inline const ::baikaldb::pb::Expr& SelectManagerNode::_internal_slot_order_exprs(int index) const {
  return slot_order_exprs_.Get(index);
}
inline const ::baikaldb::pb::Expr& SelectManagerNode::slot_order_exprs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SelectManagerNode.slot_order_exprs)
  return _internal_slot_order_exprs(index);
}
inline ::baikaldb::pb::Expr* SelectManagerNode::_internal_add_slot_order_exprs() {
  return slot_order_exprs_.Add();
}
inline ::baikaldb::pb::Expr* SelectManagerNode::add_slot_order_exprs() {
  ::baikaldb::pb::Expr* _add = _internal_add_slot_order_exprs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.SelectManagerNode.slot_order_exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
SelectManagerNode::slot_order_exprs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SelectManagerNode.slot_order_exprs)
  return slot_order_exprs_;
}

// repeated bool is_asc = 3;
inline int SelectManagerNode::_internal_is_asc_size() const {
  return is_asc_.size();
}
inline int SelectManagerNode::is_asc_size() const {
  return _internal_is_asc_size();
}
inline void SelectManagerNode::clear_is_asc() {
  is_asc_.Clear();
}
inline bool SelectManagerNode::_internal_is_asc(int index) const {
  return is_asc_.Get(index);
}
inline bool SelectManagerNode::is_asc(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SelectManagerNode.is_asc)
  return _internal_is_asc(index);
}
inline void SelectManagerNode::set_is_asc(int index, bool value) {
  is_asc_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SelectManagerNode.is_asc)
}
inline void SelectManagerNode::_internal_add_is_asc(bool value) {
  is_asc_.Add(value);
}
inline void SelectManagerNode::add_is_asc(bool value) {
  _internal_add_is_asc(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.SelectManagerNode.is_asc)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
SelectManagerNode::_internal_is_asc() const {
  return is_asc_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
SelectManagerNode::is_asc() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SelectManagerNode.is_asc)
  return _internal_is_asc();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
SelectManagerNode::_internal_mutable_is_asc() {
  return &is_asc_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
SelectManagerNode::mutable_is_asc() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SelectManagerNode.is_asc)
  return _internal_mutable_is_asc();
}

// repeated bool is_null_first = 4;
inline int SelectManagerNode::_internal_is_null_first_size() const {
  return is_null_first_.size();
}
inline int SelectManagerNode::is_null_first_size() const {
  return _internal_is_null_first_size();
}
inline void SelectManagerNode::clear_is_null_first() {
  is_null_first_.Clear();
}
inline bool SelectManagerNode::_internal_is_null_first(int index) const {
  return is_null_first_.Get(index);
}
inline bool SelectManagerNode::is_null_first(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SelectManagerNode.is_null_first)
  return _internal_is_null_first(index);
}
inline void SelectManagerNode::set_is_null_first(int index, bool value) {
  is_null_first_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SelectManagerNode.is_null_first)
}
inline void SelectManagerNode::_internal_add_is_null_first(bool value) {
  is_null_first_.Add(value);
}
inline void SelectManagerNode::add_is_null_first(bool value) {
  _internal_add_is_null_first(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.SelectManagerNode.is_null_first)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
SelectManagerNode::_internal_is_null_first() const {
  return is_null_first_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
SelectManagerNode::is_null_first() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SelectManagerNode.is_null_first)
  return _internal_is_null_first();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
SelectManagerNode::_internal_mutable_is_null_first() {
  return &is_null_first_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
SelectManagerNode::mutable_is_null_first() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SelectManagerNode.is_null_first)
  return _internal_mutable_is_null_first();
}

// optional bool is_return_empty = 5;
inline bool SelectManagerNode::_internal_has_is_return_empty() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SelectManagerNode::has_is_return_empty() const {
  return _internal_has_is_return_empty();
}
inline void SelectManagerNode::clear_is_return_empty() {
  is_return_empty_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool SelectManagerNode::_internal_is_return_empty() const {
  return is_return_empty_;
}
inline bool SelectManagerNode::is_return_empty() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SelectManagerNode.is_return_empty)
  return _internal_is_return_empty();
}
inline void SelectManagerNode::_internal_set_is_return_empty(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_return_empty_ = value;
}
inline void SelectManagerNode::set_is_return_empty(bool value) {
  _internal_set_is_return_empty(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SelectManagerNode.is_return_empty)
}

// -------------------------------------------------------------------

// PossibleIndex_Range

// optional bytes left_pb_record = 3;
inline bool PossibleIndex_Range::_internal_has_left_pb_record() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PossibleIndex_Range::has_left_pb_record() const {
  return _internal_has_left_pb_record();
}
inline void PossibleIndex_Range::clear_left_pb_record() {
  left_pb_record_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PossibleIndex_Range::left_pb_record() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.Range.left_pb_record)
  return _internal_left_pb_record();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PossibleIndex_Range::set_left_pb_record(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 left_pb_record_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.Range.left_pb_record)
}
inline std::string* PossibleIndex_Range::mutable_left_pb_record() {
  std::string* _s = _internal_mutable_left_pb_record();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PossibleIndex.Range.left_pb_record)
  return _s;
}
inline const std::string& PossibleIndex_Range::_internal_left_pb_record() const {
  return left_pb_record_.Get();
}
inline void PossibleIndex_Range::_internal_set_left_pb_record(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  left_pb_record_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PossibleIndex_Range::_internal_mutable_left_pb_record() {
  _has_bits_[0] |= 0x00000001u;
  return left_pb_record_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PossibleIndex_Range::release_left_pb_record() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PossibleIndex.Range.left_pb_record)
  if (!_internal_has_left_pb_record()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return left_pb_record_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PossibleIndex_Range::set_allocated_left_pb_record(std::string* left_pb_record) {
  if (left_pb_record != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  left_pb_record_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), left_pb_record,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PossibleIndex.Range.left_pb_record)
}

// optional bytes right_pb_record = 4;
inline bool PossibleIndex_Range::_internal_has_right_pb_record() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PossibleIndex_Range::has_right_pb_record() const {
  return _internal_has_right_pb_record();
}
inline void PossibleIndex_Range::clear_right_pb_record() {
  right_pb_record_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PossibleIndex_Range::right_pb_record() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.Range.right_pb_record)
  return _internal_right_pb_record();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PossibleIndex_Range::set_right_pb_record(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 right_pb_record_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.Range.right_pb_record)
}
inline std::string* PossibleIndex_Range::mutable_right_pb_record() {
  std::string* _s = _internal_mutable_right_pb_record();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PossibleIndex.Range.right_pb_record)
  return _s;
}
inline const std::string& PossibleIndex_Range::_internal_right_pb_record() const {
  return right_pb_record_.Get();
}
inline void PossibleIndex_Range::_internal_set_right_pb_record(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  right_pb_record_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PossibleIndex_Range::_internal_mutable_right_pb_record() {
  _has_bits_[0] |= 0x00000002u;
  return right_pb_record_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PossibleIndex_Range::release_right_pb_record() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PossibleIndex.Range.right_pb_record)
  if (!_internal_has_right_pb_record()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return right_pb_record_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PossibleIndex_Range::set_allocated_right_pb_record(std::string* right_pb_record) {
  if (right_pb_record != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  right_pb_record_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), right_pb_record,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PossibleIndex.Range.right_pb_record)
}

// optional int32 left_field_cnt = 5;
inline bool PossibleIndex_Range::_internal_has_left_field_cnt() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PossibleIndex_Range::has_left_field_cnt() const {
  return _internal_has_left_field_cnt();
}
inline void PossibleIndex_Range::clear_left_field_cnt() {
  left_field_cnt_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PossibleIndex_Range::_internal_left_field_cnt() const {
  return left_field_cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PossibleIndex_Range::left_field_cnt() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.Range.left_field_cnt)
  return _internal_left_field_cnt();
}
inline void PossibleIndex_Range::_internal_set_left_field_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  left_field_cnt_ = value;
}
inline void PossibleIndex_Range::set_left_field_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_left_field_cnt(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.Range.left_field_cnt)
}

// optional int32 right_field_cnt = 6;
inline bool PossibleIndex_Range::_internal_has_right_field_cnt() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PossibleIndex_Range::has_right_field_cnt() const {
  return _internal_has_right_field_cnt();
}
inline void PossibleIndex_Range::clear_right_field_cnt() {
  right_field_cnt_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PossibleIndex_Range::_internal_right_field_cnt() const {
  return right_field_cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PossibleIndex_Range::right_field_cnt() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.Range.right_field_cnt)
  return _internal_right_field_cnt();
}
inline void PossibleIndex_Range::_internal_set_right_field_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  right_field_cnt_ = value;
}
inline void PossibleIndex_Range::set_right_field_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_right_field_cnt(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.Range.right_field_cnt)
}

// optional bool left_open = 7;
inline bool PossibleIndex_Range::_internal_has_left_open() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PossibleIndex_Range::has_left_open() const {
  return _internal_has_left_open();
}
inline void PossibleIndex_Range::clear_left_open() {
  left_open_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool PossibleIndex_Range::_internal_left_open() const {
  return left_open_;
}
inline bool PossibleIndex_Range::left_open() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.Range.left_open)
  return _internal_left_open();
}
inline void PossibleIndex_Range::_internal_set_left_open(bool value) {
  _has_bits_[0] |= 0x00000040u;
  left_open_ = value;
}
inline void PossibleIndex_Range::set_left_open(bool value) {
  _internal_set_left_open(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.Range.left_open)
}

// optional bool right_open = 8;
inline bool PossibleIndex_Range::_internal_has_right_open() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PossibleIndex_Range::has_right_open() const {
  return _internal_has_right_open();
}
inline void PossibleIndex_Range::clear_right_open() {
  right_open_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool PossibleIndex_Range::_internal_right_open() const {
  return right_open_;
}
inline bool PossibleIndex_Range::right_open() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.Range.right_open)
  return _internal_right_open();
}
inline void PossibleIndex_Range::_internal_set_right_open(bool value) {
  _has_bits_[0] |= 0x00000080u;
  right_open_ = value;
}
inline void PossibleIndex_Range::set_right_open(bool value) {
  _internal_set_right_open(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.Range.right_open)
}

// optional bool like_prefix = 9;
inline bool PossibleIndex_Range::_internal_has_like_prefix() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PossibleIndex_Range::has_like_prefix() const {
  return _internal_has_like_prefix();
}
inline void PossibleIndex_Range::clear_like_prefix() {
  like_prefix_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool PossibleIndex_Range::_internal_like_prefix() const {
  return like_prefix_;
}
inline bool PossibleIndex_Range::like_prefix() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.Range.like_prefix)
  return _internal_like_prefix();
}
inline void PossibleIndex_Range::_internal_set_like_prefix(bool value) {
  _has_bits_[0] |= 0x00000100u;
  like_prefix_ = value;
}
inline void PossibleIndex_Range::set_like_prefix(bool value) {
  _internal_set_like_prefix(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.Range.like_prefix)
}

// optional .baikaldb.pb.MatchMode match_mode = 10;
inline bool PossibleIndex_Range::_internal_has_match_mode() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool PossibleIndex_Range::has_match_mode() const {
  return _internal_has_match_mode();
}
inline void PossibleIndex_Range::clear_match_mode() {
  match_mode_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::baikaldb::pb::MatchMode PossibleIndex_Range::_internal_match_mode() const {
  return static_cast< ::baikaldb::pb::MatchMode >(match_mode_);
}
inline ::baikaldb::pb::MatchMode PossibleIndex_Range::match_mode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.Range.match_mode)
  return _internal_match_mode();
}
inline void PossibleIndex_Range::_internal_set_match_mode(::baikaldb::pb::MatchMode value) {
  assert(::baikaldb::pb::MatchMode_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  match_mode_ = value;
}
inline void PossibleIndex_Range::set_match_mode(::baikaldb::pb::MatchMode value) {
  _internal_set_match_mode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.Range.match_mode)
}

// optional bytes left_key = 11;
inline bool PossibleIndex_Range::_internal_has_left_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PossibleIndex_Range::has_left_key() const {
  return _internal_has_left_key();
}
inline void PossibleIndex_Range::clear_left_key() {
  left_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PossibleIndex_Range::left_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.Range.left_key)
  return _internal_left_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PossibleIndex_Range::set_left_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 left_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.Range.left_key)
}
inline std::string* PossibleIndex_Range::mutable_left_key() {
  std::string* _s = _internal_mutable_left_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PossibleIndex.Range.left_key)
  return _s;
}
inline const std::string& PossibleIndex_Range::_internal_left_key() const {
  return left_key_.Get();
}
inline void PossibleIndex_Range::_internal_set_left_key(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  left_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PossibleIndex_Range::_internal_mutable_left_key() {
  _has_bits_[0] |= 0x00000004u;
  return left_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PossibleIndex_Range::release_left_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PossibleIndex.Range.left_key)
  if (!_internal_has_left_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return left_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PossibleIndex_Range::set_allocated_left_key(std::string* left_key) {
  if (left_key != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  left_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), left_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PossibleIndex.Range.left_key)
}

// optional bytes right_key = 12;
inline bool PossibleIndex_Range::_internal_has_right_key() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PossibleIndex_Range::has_right_key() const {
  return _internal_has_right_key();
}
inline void PossibleIndex_Range::clear_right_key() {
  right_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PossibleIndex_Range::right_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.Range.right_key)
  return _internal_right_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PossibleIndex_Range::set_right_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 right_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.Range.right_key)
}
inline std::string* PossibleIndex_Range::mutable_right_key() {
  std::string* _s = _internal_mutable_right_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PossibleIndex.Range.right_key)
  return _s;
}
inline const std::string& PossibleIndex_Range::_internal_right_key() const {
  return right_key_.Get();
}
inline void PossibleIndex_Range::_internal_set_right_key(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  right_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PossibleIndex_Range::_internal_mutable_right_key() {
  _has_bits_[0] |= 0x00000008u;
  return right_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PossibleIndex_Range::release_right_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PossibleIndex.Range.right_key)
  if (!_internal_has_right_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return right_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PossibleIndex_Range::set_allocated_right_key(std::string* right_key) {
  if (right_key != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  right_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), right_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PossibleIndex.Range.right_key)
}

// optional bool left_full = 13;
inline bool PossibleIndex_Range::_internal_has_left_full() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool PossibleIndex_Range::has_left_full() const {
  return _internal_has_left_full();
}
inline void PossibleIndex_Range::clear_left_full() {
  left_full_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool PossibleIndex_Range::_internal_left_full() const {
  return left_full_;
}
inline bool PossibleIndex_Range::left_full() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.Range.left_full)
  return _internal_left_full();
}
inline void PossibleIndex_Range::_internal_set_left_full(bool value) {
  _has_bits_[0] |= 0x00000200u;
  left_full_ = value;
}
inline void PossibleIndex_Range::set_left_full(bool value) {
  _internal_set_left_full(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.Range.left_full)
}

// optional bool right_full = 14;
inline bool PossibleIndex_Range::_internal_has_right_full() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool PossibleIndex_Range::has_right_full() const {
  return _internal_has_right_full();
}
inline void PossibleIndex_Range::clear_right_full() {
  right_full_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool PossibleIndex_Range::_internal_right_full() const {
  return right_full_;
}
inline bool PossibleIndex_Range::right_full() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.Range.right_full)
  return _internal_right_full();
}
inline void PossibleIndex_Range::_internal_set_right_full(bool value) {
  _has_bits_[0] |= 0x00000800u;
  right_full_ = value;
}
inline void PossibleIndex_Range::set_right_full(bool value) {
  _internal_set_right_full(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.Range.right_full)
}

// repeated int32 partition_ids = 15;
inline int PossibleIndex_Range::_internal_partition_ids_size() const {
  return partition_ids_.size();
}
inline int PossibleIndex_Range::partition_ids_size() const {
  return _internal_partition_ids_size();
}
inline void PossibleIndex_Range::clear_partition_ids() {
  partition_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PossibleIndex_Range::_internal_partition_ids(int index) const {
  return partition_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PossibleIndex_Range::partition_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.Range.partition_ids)
  return _internal_partition_ids(index);
}
inline void PossibleIndex_Range::set_partition_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  partition_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.Range.partition_ids)
}
inline void PossibleIndex_Range::_internal_add_partition_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  partition_ids_.Add(value);
}
inline void PossibleIndex_Range::add_partition_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_partition_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.PossibleIndex.Range.partition_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
PossibleIndex_Range::_internal_partition_ids() const {
  return partition_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
PossibleIndex_Range::partition_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PossibleIndex.Range.partition_ids)
  return _internal_partition_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
PossibleIndex_Range::_internal_mutable_partition_ids() {
  return &partition_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
PossibleIndex_Range::mutable_partition_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PossibleIndex.Range.partition_ids)
  return _internal_mutable_partition_ids();
}

// optional int32 topk = 16;
inline bool PossibleIndex_Range::_internal_has_topk() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool PossibleIndex_Range::has_topk() const {
  return _internal_has_topk();
}
inline void PossibleIndex_Range::clear_topk() {
  topk_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PossibleIndex_Range::_internal_topk() const {
  return topk_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PossibleIndex_Range::topk() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.Range.topk)
  return _internal_topk();
}
inline void PossibleIndex_Range::_internal_set_topk(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00001000u;
  topk_ = value;
}
inline void PossibleIndex_Range::set_topk(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_topk(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.Range.topk)
}

// optional uint64 separate_value = 17;
inline bool PossibleIndex_Range::_internal_has_separate_value() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool PossibleIndex_Range::has_separate_value() const {
  return _internal_has_separate_value();
}
inline void PossibleIndex_Range::clear_separate_value() {
  separate_value_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PossibleIndex_Range::_internal_separate_value() const {
  return separate_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PossibleIndex_Range::separate_value() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.Range.separate_value)
  return _internal_separate_value();
}
inline void PossibleIndex_Range::_internal_set_separate_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00002000u;
  separate_value_ = value;
}
inline void PossibleIndex_Range::set_separate_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_separate_value(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.Range.separate_value)
}

// optional int32 efsearch = 18;
inline bool PossibleIndex_Range::_internal_has_efsearch() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool PossibleIndex_Range::has_efsearch() const {
  return _internal_has_efsearch();
}
inline void PossibleIndex_Range::clear_efsearch() {
  efsearch_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PossibleIndex_Range::_internal_efsearch() const {
  return efsearch_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PossibleIndex_Range::efsearch() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.Range.efsearch)
  return _internal_efsearch();
}
inline void PossibleIndex_Range::_internal_set_efsearch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00004000u;
  efsearch_ = value;
}
inline void PossibleIndex_Range::set_efsearch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_efsearch(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.Range.efsearch)
}

// -------------------------------------------------------------------

// PossibleIndex_SortIndex

// optional bool is_asc = 1;
inline bool PossibleIndex_SortIndex::_internal_has_is_asc() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PossibleIndex_SortIndex::has_is_asc() const {
  return _internal_has_is_asc();
}
inline void PossibleIndex_SortIndex::clear_is_asc() {
  is_asc_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool PossibleIndex_SortIndex::_internal_is_asc() const {
  return is_asc_;
}
inline bool PossibleIndex_SortIndex::is_asc() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.SortIndex.is_asc)
  return _internal_is_asc();
}
inline void PossibleIndex_SortIndex::_internal_set_is_asc(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_asc_ = value;
}
inline void PossibleIndex_SortIndex::set_is_asc(bool value) {
  _internal_set_is_asc(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.SortIndex.is_asc)
}

// optional int64 sort_limit = 2;
inline bool PossibleIndex_SortIndex::_internal_has_sort_limit() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PossibleIndex_SortIndex::has_sort_limit() const {
  return _internal_has_sort_limit();
}
inline void PossibleIndex_SortIndex::clear_sort_limit() {
  sort_limit_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PossibleIndex_SortIndex::_internal_sort_limit() const {
  return sort_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PossibleIndex_SortIndex::sort_limit() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.SortIndex.sort_limit)
  return _internal_sort_limit();
}
inline void PossibleIndex_SortIndex::_internal_set_sort_limit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  sort_limit_ = value;
}
inline void PossibleIndex_SortIndex::set_sort_limit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_sort_limit(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.SortIndex.sort_limit)
}

// -------------------------------------------------------------------

// PossibleIndex

// required int64 index_id = 1;
inline bool PossibleIndex::_internal_has_index_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PossibleIndex::has_index_id() const {
  return _internal_has_index_id();
}
inline void PossibleIndex::clear_index_id() {
  index_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PossibleIndex::_internal_index_id() const {
  return index_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PossibleIndex::index_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.index_id)
  return _internal_index_id();
}
inline void PossibleIndex::_internal_set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  index_id_ = value;
}
inline void PossibleIndex::set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_index_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.index_id)
}

// repeated .baikaldb.pb.PossibleIndex.Range ranges = 2;
inline int PossibleIndex::_internal_ranges_size() const {
  return ranges_.size();
}
inline int PossibleIndex::ranges_size() const {
  return _internal_ranges_size();
}
inline void PossibleIndex::clear_ranges() {
  ranges_.Clear();
}
inline ::baikaldb::pb::PossibleIndex_Range* PossibleIndex::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PossibleIndex.ranges)
  return ranges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PossibleIndex_Range >*
PossibleIndex::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PossibleIndex.ranges)
  return &ranges_;
}
inline const ::baikaldb::pb::PossibleIndex_Range& PossibleIndex::_internal_ranges(int index) const {
  return ranges_.Get(index);
}
inline const ::baikaldb::pb::PossibleIndex_Range& PossibleIndex::ranges(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.ranges)
  return _internal_ranges(index);
}
inline ::baikaldb::pb::PossibleIndex_Range* PossibleIndex::_internal_add_ranges() {
  return ranges_.Add();
}
inline ::baikaldb::pb::PossibleIndex_Range* PossibleIndex::add_ranges() {
  ::baikaldb::pb::PossibleIndex_Range* _add = _internal_add_ranges();
  // @@protoc_insertion_point(field_add:baikaldb.pb.PossibleIndex.ranges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PossibleIndex_Range >&
PossibleIndex::ranges() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PossibleIndex.ranges)
  return ranges_;
}

// repeated .baikaldb.pb.Expr index_conjuncts = 3;
inline int PossibleIndex::_internal_index_conjuncts_size() const {
  return index_conjuncts_.size();
}
inline int PossibleIndex::index_conjuncts_size() const {
  return _internal_index_conjuncts_size();
}
inline ::baikaldb::pb::Expr* PossibleIndex::mutable_index_conjuncts(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PossibleIndex.index_conjuncts)
  return index_conjuncts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
PossibleIndex::mutable_index_conjuncts() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PossibleIndex.index_conjuncts)
  return &index_conjuncts_;
}
inline const ::baikaldb::pb::Expr& PossibleIndex::_internal_index_conjuncts(int index) const {
  return index_conjuncts_.Get(index);
}
inline const ::baikaldb::pb::Expr& PossibleIndex::index_conjuncts(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.index_conjuncts)
  return _internal_index_conjuncts(index);
}
inline ::baikaldb::pb::Expr* PossibleIndex::_internal_add_index_conjuncts() {
  return index_conjuncts_.Add();
}
inline ::baikaldb::pb::Expr* PossibleIndex::add_index_conjuncts() {
  ::baikaldb::pb::Expr* _add = _internal_add_index_conjuncts();
  // @@protoc_insertion_point(field_add:baikaldb.pb.PossibleIndex.index_conjuncts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
PossibleIndex::index_conjuncts() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PossibleIndex.index_conjuncts)
  return index_conjuncts_;
}

// optional .baikaldb.pb.PossibleIndex.SortIndex sort_index = 4;
inline bool PossibleIndex::_internal_has_sort_index() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || sort_index_ != nullptr);
  return value;
}
inline bool PossibleIndex::has_sort_index() const {
  return _internal_has_sort_index();
}
inline void PossibleIndex::clear_sort_index() {
  if (sort_index_ != nullptr) sort_index_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::PossibleIndex_SortIndex& PossibleIndex::_internal_sort_index() const {
  const ::baikaldb::pb::PossibleIndex_SortIndex* p = sort_index_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::PossibleIndex_SortIndex&>(
      ::baikaldb::pb::_PossibleIndex_SortIndex_default_instance_);
}
inline const ::baikaldb::pb::PossibleIndex_SortIndex& PossibleIndex::sort_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.sort_index)
  return _internal_sort_index();
}
inline void PossibleIndex::unsafe_arena_set_allocated_sort_index(
    ::baikaldb::pb::PossibleIndex_SortIndex* sort_index) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sort_index_);
  }
  sort_index_ = sort_index;
  if (sort_index) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.PossibleIndex.sort_index)
}
inline ::baikaldb::pb::PossibleIndex_SortIndex* PossibleIndex::release_sort_index() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::PossibleIndex_SortIndex* temp = sort_index_;
  sort_index_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::PossibleIndex_SortIndex* PossibleIndex::unsafe_arena_release_sort_index() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PossibleIndex.sort_index)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::PossibleIndex_SortIndex* temp = sort_index_;
  sort_index_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::PossibleIndex_SortIndex* PossibleIndex::_internal_mutable_sort_index() {
  _has_bits_[0] |= 0x00000001u;
  if (sort_index_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::PossibleIndex_SortIndex>(GetArenaForAllocation());
    sort_index_ = p;
  }
  return sort_index_;
}
inline ::baikaldb::pb::PossibleIndex_SortIndex* PossibleIndex::mutable_sort_index() {
  ::baikaldb::pb::PossibleIndex_SortIndex* _msg = _internal_mutable_sort_index();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PossibleIndex.sort_index)
  return _msg;
}
inline void PossibleIndex::set_allocated_sort_index(::baikaldb::pb::PossibleIndex_SortIndex* sort_index) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sort_index_;
  }
  if (sort_index) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::PossibleIndex_SortIndex>::GetOwningArena(sort_index);
    if (message_arena != submessage_arena) {
      sort_index = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sort_index, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sort_index_ = sort_index;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PossibleIndex.sort_index)
}

// optional bool bool_and = 5;
inline bool PossibleIndex::_internal_has_bool_and() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PossibleIndex::has_bool_and() const {
  return _internal_has_bool_and();
}
inline void PossibleIndex::clear_bool_and() {
  bool_and_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool PossibleIndex::_internal_bool_and() const {
  return bool_and_;
}
inline bool PossibleIndex::bool_and() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.bool_and)
  return _internal_bool_and();
}
inline void PossibleIndex::_internal_set_bool_and(bool value) {
  _has_bits_[0] |= 0x00000004u;
  bool_and_ = value;
}
inline void PossibleIndex::set_bool_and(bool value) {
  _internal_set_bool_and(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.bool_and)
}

// optional bool is_covering_index = 6;
inline bool PossibleIndex::_internal_has_is_covering_index() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PossibleIndex::has_is_covering_index() const {
  return _internal_has_is_covering_index();
}
inline void PossibleIndex::clear_is_covering_index() {
  is_covering_index_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool PossibleIndex::_internal_is_covering_index() const {
  return is_covering_index_;
}
inline bool PossibleIndex::is_covering_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.is_covering_index)
  return _internal_is_covering_index();
}
inline void PossibleIndex::_internal_set_is_covering_index(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_covering_index_ = value;
}
inline void PossibleIndex::set_is_covering_index(bool value) {
  _internal_set_is_covering_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.is_covering_index)
}

// optional bool use_for_learner = 7;
inline bool PossibleIndex::_internal_has_use_for_learner() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PossibleIndex::has_use_for_learner() const {
  return _internal_has_use_for_learner();
}
inline void PossibleIndex::clear_use_for_learner() {
  use_for_learner_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool PossibleIndex::_internal_use_for_learner() const {
  return use_for_learner_;
}
inline bool PossibleIndex::use_for_learner() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.use_for_learner)
  return _internal_use_for_learner();
}
inline void PossibleIndex::_internal_set_use_for_learner(bool value) {
  _has_bits_[0] |= 0x00000010u;
  use_for_learner_ = value;
}
inline void PossibleIndex::set_use_for_learner(bool value) {
  _internal_set_use_for_learner(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.use_for_learner)
}

// optional bool range_key_sorted = 8;
inline bool PossibleIndex::_internal_has_range_key_sorted() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PossibleIndex::has_range_key_sorted() const {
  return _internal_has_range_key_sorted();
}
inline void PossibleIndex::clear_range_key_sorted() {
  range_key_sorted_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool PossibleIndex::_internal_range_key_sorted() const {
  return range_key_sorted_;
}
inline bool PossibleIndex::range_key_sorted() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.range_key_sorted)
  return _internal_range_key_sorted();
}
inline void PossibleIndex::_internal_set_range_key_sorted(bool value) {
  _has_bits_[0] |= 0x00000020u;
  range_key_sorted_ = value;
}
inline void PossibleIndex::set_range_key_sorted(bool value) {
  _internal_set_range_key_sorted(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.range_key_sorted)
}

// optional bool is_eq = 9;
inline bool PossibleIndex::_internal_has_is_eq() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PossibleIndex::has_is_eq() const {
  return _internal_has_is_eq();
}
inline void PossibleIndex::clear_is_eq() {
  is_eq_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool PossibleIndex::_internal_is_eq() const {
  return is_eq_;
}
inline bool PossibleIndex::is_eq() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.is_eq)
  return _internal_is_eq();
}
inline void PossibleIndex::_internal_set_is_eq(bool value) {
  _has_bits_[0] |= 0x00000100u;
  is_eq_ = value;
}
inline void PossibleIndex::set_is_eq(bool value) {
  _internal_set_is_eq(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.is_eq)
}

// optional int32 left_field_cnt = 10;
inline bool PossibleIndex::_internal_has_left_field_cnt() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PossibleIndex::has_left_field_cnt() const {
  return _internal_has_left_field_cnt();
}
inline void PossibleIndex::clear_left_field_cnt() {
  left_field_cnt_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PossibleIndex::_internal_left_field_cnt() const {
  return left_field_cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PossibleIndex::left_field_cnt() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.left_field_cnt)
  return _internal_left_field_cnt();
}
inline void PossibleIndex::_internal_set_left_field_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  left_field_cnt_ = value;
}
inline void PossibleIndex::set_left_field_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_left_field_cnt(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.left_field_cnt)
}

// optional int32 right_field_cnt = 11;
inline bool PossibleIndex::_internal_has_right_field_cnt() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PossibleIndex::has_right_field_cnt() const {
  return _internal_has_right_field_cnt();
}
inline void PossibleIndex::clear_right_field_cnt() {
  right_field_cnt_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PossibleIndex::_internal_right_field_cnt() const {
  return right_field_cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PossibleIndex::right_field_cnt() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.right_field_cnt)
  return _internal_right_field_cnt();
}
inline void PossibleIndex::_internal_set_right_field_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  right_field_cnt_ = value;
}
inline void PossibleIndex::set_right_field_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_right_field_cnt(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.right_field_cnt)
}

// optional bool left_open = 12;
inline bool PossibleIndex::_internal_has_left_open() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool PossibleIndex::has_left_open() const {
  return _internal_has_left_open();
}
inline void PossibleIndex::clear_left_open() {
  left_open_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool PossibleIndex::_internal_left_open() const {
  return left_open_;
}
inline bool PossibleIndex::left_open() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.left_open)
  return _internal_left_open();
}
inline void PossibleIndex::_internal_set_left_open(bool value) {
  _has_bits_[0] |= 0x00000200u;
  left_open_ = value;
}
inline void PossibleIndex::set_left_open(bool value) {
  _internal_set_left_open(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.left_open)
}

// optional bool right_open = 13;
inline bool PossibleIndex::_internal_has_right_open() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool PossibleIndex::has_right_open() const {
  return _internal_has_right_open();
}
inline void PossibleIndex::clear_right_open() {
  right_open_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool PossibleIndex::_internal_right_open() const {
  return right_open_;
}
inline bool PossibleIndex::right_open() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.right_open)
  return _internal_right_open();
}
inline void PossibleIndex::_internal_set_right_open(bool value) {
  _has_bits_[0] |= 0x00000400u;
  right_open_ = value;
}
inline void PossibleIndex::set_right_open(bool value) {
  _internal_set_right_open(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.right_open)
}

// optional bool like_prefix = 14;
inline bool PossibleIndex::_internal_has_like_prefix() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool PossibleIndex::has_like_prefix() const {
  return _internal_has_like_prefix();
}
inline void PossibleIndex::clear_like_prefix() {
  like_prefix_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool PossibleIndex::_internal_like_prefix() const {
  return like_prefix_;
}
inline bool PossibleIndex::like_prefix() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PossibleIndex.like_prefix)
  return _internal_like_prefix();
}
inline void PossibleIndex::_internal_set_like_prefix(bool value) {
  _has_bits_[0] |= 0x00000800u;
  like_prefix_ = value;
}
inline void PossibleIndex::set_like_prefix(bool value) {
  _internal_set_like_prefix(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PossibleIndex.like_prefix)
}

// -------------------------------------------------------------------

// FulltextIndex

// optional .baikaldb.pb.FulltextNodeType fulltext_node_type = 1;
inline bool FulltextIndex::_internal_has_fulltext_node_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FulltextIndex::has_fulltext_node_type() const {
  return _internal_has_fulltext_node_type();
}
inline void FulltextIndex::clear_fulltext_node_type() {
  fulltext_node_type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::baikaldb::pb::FulltextNodeType FulltextIndex::_internal_fulltext_node_type() const {
  return static_cast< ::baikaldb::pb::FulltextNodeType >(fulltext_node_type_);
}
inline ::baikaldb::pb::FulltextNodeType FulltextIndex::fulltext_node_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FulltextIndex.fulltext_node_type)
  return _internal_fulltext_node_type();
}
inline void FulltextIndex::_internal_set_fulltext_node_type(::baikaldb::pb::FulltextNodeType value) {
  assert(::baikaldb::pb::FulltextNodeType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  fulltext_node_type_ = value;
}
inline void FulltextIndex::set_fulltext_node_type(::baikaldb::pb::FulltextNodeType value) {
  _internal_set_fulltext_node_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FulltextIndex.fulltext_node_type)
}

// optional .baikaldb.pb.PossibleIndex possible_index = 2;
inline bool FulltextIndex::_internal_has_possible_index() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || possible_index_ != nullptr);
  return value;
}
inline bool FulltextIndex::has_possible_index() const {
  return _internal_has_possible_index();
}
inline void FulltextIndex::clear_possible_index() {
  if (possible_index_ != nullptr) possible_index_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::PossibleIndex& FulltextIndex::_internal_possible_index() const {
  const ::baikaldb::pb::PossibleIndex* p = possible_index_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::PossibleIndex&>(
      ::baikaldb::pb::_PossibleIndex_default_instance_);
}
inline const ::baikaldb::pb::PossibleIndex& FulltextIndex::possible_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FulltextIndex.possible_index)
  return _internal_possible_index();
}
inline void FulltextIndex::unsafe_arena_set_allocated_possible_index(
    ::baikaldb::pb::PossibleIndex* possible_index) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(possible_index_);
  }
  possible_index_ = possible_index;
  if (possible_index) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.FulltextIndex.possible_index)
}
inline ::baikaldb::pb::PossibleIndex* FulltextIndex::release_possible_index() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::PossibleIndex* temp = possible_index_;
  possible_index_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::PossibleIndex* FulltextIndex::unsafe_arena_release_possible_index() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.FulltextIndex.possible_index)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::PossibleIndex* temp = possible_index_;
  possible_index_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::PossibleIndex* FulltextIndex::_internal_mutable_possible_index() {
  _has_bits_[0] |= 0x00000001u;
  if (possible_index_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::PossibleIndex>(GetArenaForAllocation());
    possible_index_ = p;
  }
  return possible_index_;
}
inline ::baikaldb::pb::PossibleIndex* FulltextIndex::mutable_possible_index() {
  ::baikaldb::pb::PossibleIndex* _msg = _internal_mutable_possible_index();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FulltextIndex.possible_index)
  return _msg;
}
inline void FulltextIndex::set_allocated_possible_index(::baikaldb::pb::PossibleIndex* possible_index) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete possible_index_;
  }
  if (possible_index) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::PossibleIndex>::GetOwningArena(possible_index);
    if (message_arena != submessage_arena) {
      possible_index = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, possible_index, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  possible_index_ = possible_index;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.FulltextIndex.possible_index)
}

// repeated .baikaldb.pb.FulltextIndex nested_fulltext_indexes = 3;
inline int FulltextIndex::_internal_nested_fulltext_indexes_size() const {
  return nested_fulltext_indexes_.size();
}
inline int FulltextIndex::nested_fulltext_indexes_size() const {
  return _internal_nested_fulltext_indexes_size();
}
inline void FulltextIndex::clear_nested_fulltext_indexes() {
  nested_fulltext_indexes_.Clear();
}
inline ::baikaldb::pb::FulltextIndex* FulltextIndex::mutable_nested_fulltext_indexes(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FulltextIndex.nested_fulltext_indexes)
  return nested_fulltext_indexes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FulltextIndex >*
FulltextIndex::mutable_nested_fulltext_indexes() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.FulltextIndex.nested_fulltext_indexes)
  return &nested_fulltext_indexes_;
}
inline const ::baikaldb::pb::FulltextIndex& FulltextIndex::_internal_nested_fulltext_indexes(int index) const {
  return nested_fulltext_indexes_.Get(index);
}
inline const ::baikaldb::pb::FulltextIndex& FulltextIndex::nested_fulltext_indexes(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FulltextIndex.nested_fulltext_indexes)
  return _internal_nested_fulltext_indexes(index);
}
inline ::baikaldb::pb::FulltextIndex* FulltextIndex::_internal_add_nested_fulltext_indexes() {
  return nested_fulltext_indexes_.Add();
}
inline ::baikaldb::pb::FulltextIndex* FulltextIndex::add_nested_fulltext_indexes() {
  ::baikaldb::pb::FulltextIndex* _add = _internal_add_nested_fulltext_indexes();
  // @@protoc_insertion_point(field_add:baikaldb.pb.FulltextIndex.nested_fulltext_indexes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FulltextIndex >&
FulltextIndex::nested_fulltext_indexes() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.FulltextIndex.nested_fulltext_indexes)
  return nested_fulltext_indexes_;
}

// -------------------------------------------------------------------

// ScanNode

// required int32 tuple_id = 1;
inline bool ScanNode::_internal_has_tuple_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ScanNode::has_tuple_id() const {
  return _internal_has_tuple_id();
}
inline void ScanNode::clear_tuple_id() {
  tuple_id_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ScanNode::_internal_tuple_id() const {
  return tuple_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ScanNode::tuple_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.tuple_id)
  return _internal_tuple_id();
}
inline void ScanNode::_internal_set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  tuple_id_ = value;
}
inline void ScanNode::set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tuple_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ScanNode.tuple_id)
}

// required int64 table_id = 2;
inline bool ScanNode::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ScanNode::has_table_id() const {
  return _internal_has_table_id();
}
inline void ScanNode::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ScanNode::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ScanNode::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.table_id)
  return _internal_table_id();
}
inline void ScanNode::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  table_id_ = value;
}
inline void ScanNode::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ScanNode.table_id)
}

// repeated bytes indexes = 3;
inline int ScanNode::_internal_indexes_size() const {
  return indexes_.size();
}
inline int ScanNode::indexes_size() const {
  return _internal_indexes_size();
}
inline void ScanNode::clear_indexes() {
  indexes_.Clear();
}
inline std::string* ScanNode::add_indexes() {
  std::string* _s = _internal_add_indexes();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.ScanNode.indexes)
  return _s;
}
inline const std::string& ScanNode::_internal_indexes(int index) const {
  return indexes_.Get(index);
}
inline const std::string& ScanNode::indexes(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.indexes)
  return _internal_indexes(index);
}
inline std::string* ScanNode::mutable_indexes(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ScanNode.indexes)
  return indexes_.Mutable(index);
}
inline void ScanNode::set_indexes(int index, const std::string& value) {
  indexes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ScanNode.indexes)
}
inline void ScanNode::set_indexes(int index, std::string&& value) {
  indexes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.ScanNode.indexes)
}
inline void ScanNode::set_indexes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  indexes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.ScanNode.indexes)
}
inline void ScanNode::set_indexes(int index, const void* value, size_t size) {
  indexes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.ScanNode.indexes)
}
inline std::string* ScanNode::_internal_add_indexes() {
  return indexes_.Add();
}
inline void ScanNode::add_indexes(const std::string& value) {
  indexes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.ScanNode.indexes)
}
inline void ScanNode::add_indexes(std::string&& value) {
  indexes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.ScanNode.indexes)
}
inline void ScanNode::add_indexes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  indexes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.ScanNode.indexes)
}
inline void ScanNode::add_indexes(const void* value, size_t size) {
  indexes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.ScanNode.indexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ScanNode::indexes() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ScanNode.indexes)
  return indexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ScanNode::mutable_indexes() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ScanNode.indexes)
  return &indexes_;
}

// repeated int64 use_indexes = 4;
inline int ScanNode::_internal_use_indexes_size() const {
  return use_indexes_.size();
}
inline int ScanNode::use_indexes_size() const {
  return _internal_use_indexes_size();
}
inline void ScanNode::clear_use_indexes() {
  use_indexes_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ScanNode::_internal_use_indexes(int index) const {
  return use_indexes_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ScanNode::use_indexes(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.use_indexes)
  return _internal_use_indexes(index);
}
inline void ScanNode::set_use_indexes(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  use_indexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ScanNode.use_indexes)
}
inline void ScanNode::_internal_add_use_indexes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  use_indexes_.Add(value);
}
inline void ScanNode::add_use_indexes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_use_indexes(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.ScanNode.use_indexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ScanNode::_internal_use_indexes() const {
  return use_indexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ScanNode::use_indexes() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ScanNode.use_indexes)
  return _internal_use_indexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ScanNode::_internal_mutable_use_indexes() {
  return &use_indexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ScanNode::mutable_use_indexes() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ScanNode.use_indexes)
  return _internal_mutable_use_indexes();
}

// optional .baikaldb.pb.Engine engine = 5;
inline bool ScanNode::_internal_has_engine() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ScanNode::has_engine() const {
  return _internal_has_engine();
}
inline void ScanNode::clear_engine() {
  engine_ = 1;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::baikaldb::pb::Engine ScanNode::_internal_engine() const {
  return static_cast< ::baikaldb::pb::Engine >(engine_);
}
inline ::baikaldb::pb::Engine ScanNode::engine() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.engine)
  return _internal_engine();
}
inline void ScanNode::_internal_set_engine(::baikaldb::pb::Engine value) {
  assert(::baikaldb::pb::Engine_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  engine_ = value;
}
inline void ScanNode::set_engine(::baikaldb::pb::Engine value) {
  _internal_set_engine(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ScanNode.engine)
}

// repeated int64 ignore_indexes = 6;
inline int ScanNode::_internal_ignore_indexes_size() const {
  return ignore_indexes_.size();
}
inline int ScanNode::ignore_indexes_size() const {
  return _internal_ignore_indexes_size();
}
inline void ScanNode::clear_ignore_indexes() {
  ignore_indexes_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ScanNode::_internal_ignore_indexes(int index) const {
  return ignore_indexes_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ScanNode::ignore_indexes(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.ignore_indexes)
  return _internal_ignore_indexes(index);
}
inline void ScanNode::set_ignore_indexes(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  ignore_indexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ScanNode.ignore_indexes)
}
inline void ScanNode::_internal_add_ignore_indexes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  ignore_indexes_.Add(value);
}
inline void ScanNode::add_ignore_indexes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_ignore_indexes(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.ScanNode.ignore_indexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ScanNode::_internal_ignore_indexes() const {
  return ignore_indexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ScanNode::ignore_indexes() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ScanNode.ignore_indexes)
  return _internal_ignore_indexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ScanNode::_internal_mutable_ignore_indexes() {
  return &ignore_indexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ScanNode::mutable_ignore_indexes() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ScanNode.ignore_indexes)
  return _internal_mutable_ignore_indexes();
}

// optional .baikaldb.pb.FulltextIndex fulltext_index = 7;
inline bool ScanNode::_internal_has_fulltext_index() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || fulltext_index_ != nullptr);
  return value;
}
inline bool ScanNode::has_fulltext_index() const {
  return _internal_has_fulltext_index();
}
inline void ScanNode::clear_fulltext_index() {
  if (fulltext_index_ != nullptr) fulltext_index_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::baikaldb::pb::FulltextIndex& ScanNode::_internal_fulltext_index() const {
  const ::baikaldb::pb::FulltextIndex* p = fulltext_index_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::FulltextIndex&>(
      ::baikaldb::pb::_FulltextIndex_default_instance_);
}
inline const ::baikaldb::pb::FulltextIndex& ScanNode::fulltext_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.fulltext_index)
  return _internal_fulltext_index();
}
inline void ScanNode::unsafe_arena_set_allocated_fulltext_index(
    ::baikaldb::pb::FulltextIndex* fulltext_index) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fulltext_index_);
  }
  fulltext_index_ = fulltext_index;
  if (fulltext_index) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.ScanNode.fulltext_index)
}
inline ::baikaldb::pb::FulltextIndex* ScanNode::release_fulltext_index() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::FulltextIndex* temp = fulltext_index_;
  fulltext_index_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::FulltextIndex* ScanNode::unsafe_arena_release_fulltext_index() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ScanNode.fulltext_index)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::FulltextIndex* temp = fulltext_index_;
  fulltext_index_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::FulltextIndex* ScanNode::_internal_mutable_fulltext_index() {
  _has_bits_[0] |= 0x00000002u;
  if (fulltext_index_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::FulltextIndex>(GetArenaForAllocation());
    fulltext_index_ = p;
  }
  return fulltext_index_;
}
inline ::baikaldb::pb::FulltextIndex* ScanNode::mutable_fulltext_index() {
  ::baikaldb::pb::FulltextIndex* _msg = _internal_mutable_fulltext_index();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ScanNode.fulltext_index)
  return _msg;
}
inline void ScanNode::set_allocated_fulltext_index(::baikaldb::pb::FulltextIndex* fulltext_index) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fulltext_index_;
  }
  if (fulltext_index) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::FulltextIndex>::GetOwningArena(fulltext_index);
    if (message_arena != submessage_arena) {
      fulltext_index = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fulltext_index, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  fulltext_index_ = fulltext_index;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ScanNode.fulltext_index)
}

// optional .baikaldb.pb.LockCmdType lock = 8;
inline bool ScanNode::_internal_has_lock() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ScanNode::has_lock() const {
  return _internal_has_lock();
}
inline void ScanNode::clear_lock() {
  lock_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::baikaldb::pb::LockCmdType ScanNode::_internal_lock() const {
  return static_cast< ::baikaldb::pb::LockCmdType >(lock_);
}
inline ::baikaldb::pb::LockCmdType ScanNode::lock() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.lock)
  return _internal_lock();
}
inline void ScanNode::_internal_set_lock(::baikaldb::pb::LockCmdType value) {
  assert(::baikaldb::pb::LockCmdType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  lock_ = value;
}
inline void ScanNode::set_lock(::baikaldb::pb::LockCmdType value) {
  _internal_set_lock(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ScanNode.lock)
}

// optional bool is_ddl_work = 9;
inline bool ScanNode::_internal_has_is_ddl_work() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ScanNode::has_is_ddl_work() const {
  return _internal_has_is_ddl_work();
}
inline void ScanNode::clear_is_ddl_work() {
  is_ddl_work_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ScanNode::_internal_is_ddl_work() const {
  return is_ddl_work_;
}
inline bool ScanNode::is_ddl_work() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.is_ddl_work)
  return _internal_is_ddl_work();
}
inline void ScanNode::_internal_set_is_ddl_work(bool value) {
  _has_bits_[0] |= 0x00000100u;
  is_ddl_work_ = value;
}
inline void ScanNode::set_is_ddl_work(bool value) {
  _internal_set_is_ddl_work(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ScanNode.is_ddl_work)
}

// optional int64 ddl_index_id = 10;
inline bool ScanNode::_internal_has_ddl_index_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ScanNode::has_ddl_index_id() const {
  return _internal_has_ddl_index_id();
}
inline void ScanNode::clear_ddl_index_id() {
  ddl_index_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ScanNode::_internal_ddl_index_id() const {
  return ddl_index_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ScanNode::ddl_index_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.ddl_index_id)
  return _internal_ddl_index_id();
}
inline void ScanNode::_internal_set_ddl_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  ddl_index_id_ = value;
}
inline void ScanNode::set_ddl_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_ddl_index_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ScanNode.ddl_index_id)
}

// repeated int64 force_indexes = 11;
inline int ScanNode::_internal_force_indexes_size() const {
  return force_indexes_.size();
}
inline int ScanNode::force_indexes_size() const {
  return _internal_force_indexes_size();
}
inline void ScanNode::clear_force_indexes() {
  force_indexes_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ScanNode::_internal_force_indexes(int index) const {
  return force_indexes_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ScanNode::force_indexes(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.force_indexes)
  return _internal_force_indexes(index);
}
inline void ScanNode::set_force_indexes(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  force_indexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ScanNode.force_indexes)
}
inline void ScanNode::_internal_add_force_indexes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  force_indexes_.Add(value);
}
inline void ScanNode::add_force_indexes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_force_indexes(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.ScanNode.force_indexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ScanNode::_internal_force_indexes() const {
  return force_indexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ScanNode::force_indexes() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ScanNode.force_indexes)
  return _internal_force_indexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ScanNode::_internal_mutable_force_indexes() {
  return &force_indexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ScanNode::mutable_force_indexes() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ScanNode.force_indexes)
  return _internal_mutable_force_indexes();
}

// optional bytes learner_index = 12;
inline bool ScanNode::_internal_has_learner_index() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ScanNode::has_learner_index() const {
  return _internal_has_learner_index();
}
inline void ScanNode::clear_learner_index() {
  learner_index_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ScanNode::learner_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.learner_index)
  return _internal_learner_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ScanNode::set_learner_index(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 learner_index_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ScanNode.learner_index)
}
inline std::string* ScanNode::mutable_learner_index() {
  std::string* _s = _internal_mutable_learner_index();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ScanNode.learner_index)
  return _s;
}
inline const std::string& ScanNode::_internal_learner_index() const {
  return learner_index_.Get();
}
inline void ScanNode::_internal_set_learner_index(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  learner_index_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ScanNode::_internal_mutable_learner_index() {
  _has_bits_[0] |= 0x00000001u;
  return learner_index_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ScanNode::release_learner_index() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ScanNode.learner_index)
  if (!_internal_has_learner_index()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return learner_index_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ScanNode::set_allocated_learner_index(std::string* learner_index) {
  if (learner_index != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  learner_index_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), learner_index,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ScanNode.learner_index)
}

// optional .baikaldb.pb.DDLType ddl_work_type = 13;
inline bool ScanNode::_internal_has_ddl_work_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ScanNode::has_ddl_work_type() const {
  return _internal_has_ddl_work_type();
}
inline void ScanNode::clear_ddl_work_type() {
  ddl_work_type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::baikaldb::pb::DDLType ScanNode::_internal_ddl_work_type() const {
  return static_cast< ::baikaldb::pb::DDLType >(ddl_work_type_);
}
inline ::baikaldb::pb::DDLType ScanNode::ddl_work_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.ddl_work_type)
  return _internal_ddl_work_type();
}
inline void ScanNode::_internal_set_ddl_work_type(::baikaldb::pb::DDLType value) {
  assert(::baikaldb::pb::DDLType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  ddl_work_type_ = value;
}
inline void ScanNode::set_ddl_work_type(::baikaldb::pb::DDLType value) {
  _internal_set_ddl_work_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ScanNode.ddl_work_type)
}

// optional .baikaldb.pb.ColumnDdlInfo column_ddl_info = 14;
inline bool ScanNode::_internal_has_column_ddl_info() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || column_ddl_info_ != nullptr);
  return value;
}
inline bool ScanNode::has_column_ddl_info() const {
  return _internal_has_column_ddl_info();
}
inline const ::baikaldb::pb::ColumnDdlInfo& ScanNode::_internal_column_ddl_info() const {
  const ::baikaldb::pb::ColumnDdlInfo* p = column_ddl_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::ColumnDdlInfo&>(
      ::baikaldb::pb::_ColumnDdlInfo_default_instance_);
}
inline const ::baikaldb::pb::ColumnDdlInfo& ScanNode::column_ddl_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.column_ddl_info)
  return _internal_column_ddl_info();
}
inline void ScanNode::unsafe_arena_set_allocated_column_ddl_info(
    ::baikaldb::pb::ColumnDdlInfo* column_ddl_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(column_ddl_info_);
  }
  column_ddl_info_ = column_ddl_info;
  if (column_ddl_info) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.ScanNode.column_ddl_info)
}
inline ::baikaldb::pb::ColumnDdlInfo* ScanNode::release_column_ddl_info() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::ColumnDdlInfo* temp = column_ddl_info_;
  column_ddl_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::ColumnDdlInfo* ScanNode::unsafe_arena_release_column_ddl_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ScanNode.column_ddl_info)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::ColumnDdlInfo* temp = column_ddl_info_;
  column_ddl_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::ColumnDdlInfo* ScanNode::_internal_mutable_column_ddl_info() {
  _has_bits_[0] |= 0x00000004u;
  if (column_ddl_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::ColumnDdlInfo>(GetArenaForAllocation());
    column_ddl_info_ = p;
  }
  return column_ddl_info_;
}
inline ::baikaldb::pb::ColumnDdlInfo* ScanNode::mutable_column_ddl_info() {
  ::baikaldb::pb::ColumnDdlInfo* _msg = _internal_mutable_column_ddl_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ScanNode.column_ddl_info)
  return _msg;
}
inline void ScanNode::set_allocated_column_ddl_info(::baikaldb::pb::ColumnDdlInfo* column_ddl_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(column_ddl_info_);
  }
  if (column_ddl_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(column_ddl_info));
    if (message_arena != submessage_arena) {
      column_ddl_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_ddl_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  column_ddl_info_ = column_ddl_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ScanNode.column_ddl_info)
}

// optional uint64 watt_stats_version = 15;
inline bool ScanNode::_internal_has_watt_stats_version() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ScanNode::has_watt_stats_version() const {
  return _internal_has_watt_stats_version();
}
inline void ScanNode::clear_watt_stats_version() {
  watt_stats_version_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ScanNode::_internal_watt_stats_version() const {
  return watt_stats_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ScanNode::watt_stats_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.watt_stats_version)
  return _internal_watt_stats_version();
}
inline void ScanNode::_internal_set_watt_stats_version(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000400u;
  watt_stats_version_ = value;
}
inline void ScanNode::set_watt_stats_version(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_watt_stats_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ScanNode.watt_stats_version)
}

// optional int32 union_tuple_id = 16;
inline bool ScanNode::_internal_has_union_tuple_id() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ScanNode::has_union_tuple_id() const {
  return _internal_has_union_tuple_id();
}
inline void ScanNode::clear_union_tuple_id() {
  union_tuple_id_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ScanNode::_internal_union_tuple_id() const {
  return union_tuple_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ScanNode::union_tuple_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.union_tuple_id)
  return _internal_union_tuple_id();
}
inline void ScanNode::_internal_set_union_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000800u;
  union_tuple_id_ = value;
}
inline void ScanNode::set_union_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_union_tuple_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ScanNode.union_tuple_id)
}

// optional bool use_column_storage = 17;
inline bool ScanNode::_internal_has_use_column_storage() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ScanNode::has_use_column_storage() const {
  return _internal_has_use_column_storage();
}
inline void ScanNode::clear_use_column_storage() {
  use_column_storage_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool ScanNode::_internal_use_column_storage() const {
  return use_column_storage_;
}
inline bool ScanNode::use_column_storage() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ScanNode.use_column_storage)
  return _internal_use_column_storage();
}
inline void ScanNode::_internal_set_use_column_storage(bool value) {
  _has_bits_[0] |= 0x00000200u;
  use_column_storage_ = value;
}
inline void ScanNode::set_use_column_storage(bool value) {
  _internal_set_use_column_storage(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ScanNode.use_column_storage)
}

// -------------------------------------------------------------------

// LimitNode

// optional int64 offset = 1;
inline bool LimitNode::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LimitNode::has_offset() const {
  return _internal_has_offset();
}
inline void LimitNode::clear_offset() {
  offset_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LimitNode::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LimitNode::offset() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LimitNode.offset)
  return _internal_offset();
}
inline void LimitNode::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  offset_ = value;
}
inline void LimitNode::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LimitNode.offset)
}

// optional .baikaldb.pb.Expr offset_expr = 2;
inline bool LimitNode::_internal_has_offset_expr() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || offset_expr_ != nullptr);
  return value;
}
inline bool LimitNode::has_offset_expr() const {
  return _internal_has_offset_expr();
}
inline const ::baikaldb::pb::Expr& LimitNode::_internal_offset_expr() const {
  const ::baikaldb::pb::Expr* p = offset_expr_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::Expr&>(
      ::baikaldb::pb::_Expr_default_instance_);
}
inline const ::baikaldb::pb::Expr& LimitNode::offset_expr() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LimitNode.offset_expr)
  return _internal_offset_expr();
}
inline void LimitNode::unsafe_arena_set_allocated_offset_expr(
    ::baikaldb::pb::Expr* offset_expr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(offset_expr_);
  }
  offset_expr_ = offset_expr;
  if (offset_expr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.LimitNode.offset_expr)
}
inline ::baikaldb::pb::Expr* LimitNode::release_offset_expr() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::Expr* temp = offset_expr_;
  offset_expr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::Expr* LimitNode::unsafe_arena_release_offset_expr() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.LimitNode.offset_expr)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::Expr* temp = offset_expr_;
  offset_expr_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::Expr* LimitNode::_internal_mutable_offset_expr() {
  _has_bits_[0] |= 0x00000001u;
  if (offset_expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::Expr>(GetArenaForAllocation());
    offset_expr_ = p;
  }
  return offset_expr_;
}
inline ::baikaldb::pb::Expr* LimitNode::mutable_offset_expr() {
  ::baikaldb::pb::Expr* _msg = _internal_mutable_offset_expr();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LimitNode.offset_expr)
  return _msg;
}
inline void LimitNode::set_allocated_offset_expr(::baikaldb::pb::Expr* offset_expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(offset_expr_);
  }
  if (offset_expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(offset_expr));
    if (message_arena != submessage_arena) {
      offset_expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offset_expr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  offset_expr_ = offset_expr;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.LimitNode.offset_expr)
}

// optional .baikaldb.pb.Expr count_expr = 3;
inline bool LimitNode::_internal_has_count_expr() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || count_expr_ != nullptr);
  return value;
}
inline bool LimitNode::has_count_expr() const {
  return _internal_has_count_expr();
}
inline const ::baikaldb::pb::Expr& LimitNode::_internal_count_expr() const {
  const ::baikaldb::pb::Expr* p = count_expr_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::Expr&>(
      ::baikaldb::pb::_Expr_default_instance_);
}
inline const ::baikaldb::pb::Expr& LimitNode::count_expr() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LimitNode.count_expr)
  return _internal_count_expr();
}
inline void LimitNode::unsafe_arena_set_allocated_count_expr(
    ::baikaldb::pb::Expr* count_expr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(count_expr_);
  }
  count_expr_ = count_expr;
  if (count_expr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.LimitNode.count_expr)
}
inline ::baikaldb::pb::Expr* LimitNode::release_count_expr() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::Expr* temp = count_expr_;
  count_expr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::Expr* LimitNode::unsafe_arena_release_count_expr() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.LimitNode.count_expr)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::Expr* temp = count_expr_;
  count_expr_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::Expr* LimitNode::_internal_mutable_count_expr() {
  _has_bits_[0] |= 0x00000002u;
  if (count_expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::Expr>(GetArenaForAllocation());
    count_expr_ = p;
  }
  return count_expr_;
}
inline ::baikaldb::pb::Expr* LimitNode::mutable_count_expr() {
  ::baikaldb::pb::Expr* _msg = _internal_mutable_count_expr();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LimitNode.count_expr)
  return _msg;
}
inline void LimitNode::set_allocated_count_expr(::baikaldb::pb::Expr* count_expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(count_expr_);
  }
  if (count_expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(count_expr));
    if (message_arena != submessage_arena) {
      count_expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, count_expr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  count_expr_ = count_expr;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.LimitNode.count_expr)
}

// -------------------------------------------------------------------

// SortNode

// repeated .baikaldb.pb.Expr order_exprs = 1;
inline int SortNode::_internal_order_exprs_size() const {
  return order_exprs_.size();
}
inline int SortNode::order_exprs_size() const {
  return _internal_order_exprs_size();
}
inline ::baikaldb::pb::Expr* SortNode::mutable_order_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SortNode.order_exprs)
  return order_exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
SortNode::mutable_order_exprs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SortNode.order_exprs)
  return &order_exprs_;
}
inline const ::baikaldb::pb::Expr& SortNode::_internal_order_exprs(int index) const {
  return order_exprs_.Get(index);
}
inline const ::baikaldb::pb::Expr& SortNode::order_exprs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SortNode.order_exprs)
  return _internal_order_exprs(index);
}
inline ::baikaldb::pb::Expr* SortNode::_internal_add_order_exprs() {
  return order_exprs_.Add();
}
inline ::baikaldb::pb::Expr* SortNode::add_order_exprs() {
  ::baikaldb::pb::Expr* _add = _internal_add_order_exprs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.SortNode.order_exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
SortNode::order_exprs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SortNode.order_exprs)
  return order_exprs_;
}

// repeated bool is_asc = 2;
inline int SortNode::_internal_is_asc_size() const {
  return is_asc_.size();
}
inline int SortNode::is_asc_size() const {
  return _internal_is_asc_size();
}
inline void SortNode::clear_is_asc() {
  is_asc_.Clear();
}
inline bool SortNode::_internal_is_asc(int index) const {
  return is_asc_.Get(index);
}
inline bool SortNode::is_asc(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SortNode.is_asc)
  return _internal_is_asc(index);
}
inline void SortNode::set_is_asc(int index, bool value) {
  is_asc_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SortNode.is_asc)
}
inline void SortNode::_internal_add_is_asc(bool value) {
  is_asc_.Add(value);
}
inline void SortNode::add_is_asc(bool value) {
  _internal_add_is_asc(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.SortNode.is_asc)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
SortNode::_internal_is_asc() const {
  return is_asc_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
SortNode::is_asc() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SortNode.is_asc)
  return _internal_is_asc();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
SortNode::_internal_mutable_is_asc() {
  return &is_asc_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
SortNode::mutable_is_asc() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SortNode.is_asc)
  return _internal_mutable_is_asc();
}

// repeated bool is_null_first = 3;
inline int SortNode::_internal_is_null_first_size() const {
  return is_null_first_.size();
}
inline int SortNode::is_null_first_size() const {
  return _internal_is_null_first_size();
}
inline void SortNode::clear_is_null_first() {
  is_null_first_.Clear();
}
inline bool SortNode::_internal_is_null_first(int index) const {
  return is_null_first_.Get(index);
}
inline bool SortNode::is_null_first(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SortNode.is_null_first)
  return _internal_is_null_first(index);
}
inline void SortNode::set_is_null_first(int index, bool value) {
  is_null_first_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SortNode.is_null_first)
}
inline void SortNode::_internal_add_is_null_first(bool value) {
  is_null_first_.Add(value);
}
inline void SortNode::add_is_null_first(bool value) {
  _internal_add_is_null_first(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.SortNode.is_null_first)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
SortNode::_internal_is_null_first() const {
  return is_null_first_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
SortNode::is_null_first() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SortNode.is_null_first)
  return _internal_is_null_first();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
SortNode::_internal_mutable_is_null_first() {
  return &is_null_first_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
SortNode::mutable_is_null_first() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SortNode.is_null_first)
  return _internal_mutable_is_null_first();
}

// optional int32 tuple_id = 5;
inline bool SortNode::_internal_has_tuple_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SortNode::has_tuple_id() const {
  return _internal_has_tuple_id();
}
inline void SortNode::clear_tuple_id() {
  tuple_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SortNode::_internal_tuple_id() const {
  return tuple_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SortNode::tuple_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SortNode.tuple_id)
  return _internal_tuple_id();
}
inline void SortNode::_internal_set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  tuple_id_ = value;
}
inline void SortNode::set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tuple_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SortNode.tuple_id)
}

// repeated .baikaldb.pb.Expr slot_order_exprs = 6;
inline int SortNode::_internal_slot_order_exprs_size() const {
  return slot_order_exprs_.size();
}
inline int SortNode::slot_order_exprs_size() const {
  return _internal_slot_order_exprs_size();
}
inline ::baikaldb::pb::Expr* SortNode::mutable_slot_order_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SortNode.slot_order_exprs)
  return slot_order_exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
SortNode::mutable_slot_order_exprs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SortNode.slot_order_exprs)
  return &slot_order_exprs_;
}
inline const ::baikaldb::pb::Expr& SortNode::_internal_slot_order_exprs(int index) const {
  return slot_order_exprs_.Get(index);
}
inline const ::baikaldb::pb::Expr& SortNode::slot_order_exprs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SortNode.slot_order_exprs)
  return _internal_slot_order_exprs(index);
}
inline ::baikaldb::pb::Expr* SortNode::_internal_add_slot_order_exprs() {
  return slot_order_exprs_.Add();
}
inline ::baikaldb::pb::Expr* SortNode::add_slot_order_exprs() {
  ::baikaldb::pb::Expr* _add = _internal_add_slot_order_exprs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.SortNode.slot_order_exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
SortNode::slot_order_exprs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SortNode.slot_order_exprs)
  return slot_order_exprs_;
}

// -------------------------------------------------------------------

// AggNode

// repeated .baikaldb.pb.Expr group_exprs = 1;
inline int AggNode::_internal_group_exprs_size() const {
  return group_exprs_.size();
}
inline int AggNode::group_exprs_size() const {
  return _internal_group_exprs_size();
}
inline ::baikaldb::pb::Expr* AggNode::mutable_group_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.AggNode.group_exprs)
  return group_exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
AggNode::mutable_group_exprs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.AggNode.group_exprs)
  return &group_exprs_;
}
inline const ::baikaldb::pb::Expr& AggNode::_internal_group_exprs(int index) const {
  return group_exprs_.Get(index);
}
inline const ::baikaldb::pb::Expr& AggNode::group_exprs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AggNode.group_exprs)
  return _internal_group_exprs(index);
}
inline ::baikaldb::pb::Expr* AggNode::_internal_add_group_exprs() {
  return group_exprs_.Add();
}
inline ::baikaldb::pb::Expr* AggNode::add_group_exprs() {
  ::baikaldb::pb::Expr* _add = _internal_add_group_exprs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.AggNode.group_exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
AggNode::group_exprs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.AggNode.group_exprs)
  return group_exprs_;
}

// repeated .baikaldb.pb.Expr agg_funcs = 2;
inline int AggNode::_internal_agg_funcs_size() const {
  return agg_funcs_.size();
}
inline int AggNode::agg_funcs_size() const {
  return _internal_agg_funcs_size();
}
inline ::baikaldb::pb::Expr* AggNode::mutable_agg_funcs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.AggNode.agg_funcs)
  return agg_funcs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
AggNode::mutable_agg_funcs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.AggNode.agg_funcs)
  return &agg_funcs_;
}
inline const ::baikaldb::pb::Expr& AggNode::_internal_agg_funcs(int index) const {
  return agg_funcs_.Get(index);
}
inline const ::baikaldb::pb::Expr& AggNode::agg_funcs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AggNode.agg_funcs)
  return _internal_agg_funcs(index);
}
inline ::baikaldb::pb::Expr* AggNode::_internal_add_agg_funcs() {
  return agg_funcs_.Add();
}
inline ::baikaldb::pb::Expr* AggNode::add_agg_funcs() {
  ::baikaldb::pb::Expr* _add = _internal_add_agg_funcs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.AggNode.agg_funcs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
AggNode::agg_funcs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.AggNode.agg_funcs)
  return agg_funcs_;
}

// optional int32 agg_tuple_id = 3;
inline bool AggNode::_internal_has_agg_tuple_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AggNode::has_agg_tuple_id() const {
  return _internal_has_agg_tuple_id();
}
inline void AggNode::clear_agg_tuple_id() {
  agg_tuple_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AggNode::_internal_agg_tuple_id() const {
  return agg_tuple_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AggNode::agg_tuple_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AggNode.agg_tuple_id)
  return _internal_agg_tuple_id();
}
inline void AggNode::_internal_set_agg_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  agg_tuple_id_ = value;
}
inline void AggNode::set_agg_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_agg_tuple_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AggNode.agg_tuple_id)
}

// optional int32 arrow_ignore_tuple_id = 4;
inline bool AggNode::_internal_has_arrow_ignore_tuple_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AggNode::has_arrow_ignore_tuple_id() const {
  return _internal_has_arrow_ignore_tuple_id();
}
inline void AggNode::clear_arrow_ignore_tuple_id() {
  arrow_ignore_tuple_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AggNode::_internal_arrow_ignore_tuple_id() const {
  return arrow_ignore_tuple_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AggNode::arrow_ignore_tuple_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AggNode.arrow_ignore_tuple_id)
  return _internal_arrow_ignore_tuple_id();
}
inline void AggNode::_internal_set_arrow_ignore_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  arrow_ignore_tuple_id_ = value;
}
inline void AggNode::set_arrow_ignore_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_arrow_ignore_tuple_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AggNode.arrow_ignore_tuple_id)
}

// optional bool is_pushdown = 5;
inline bool AggNode::_internal_has_is_pushdown() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AggNode::has_is_pushdown() const {
  return _internal_has_is_pushdown();
}
inline void AggNode::clear_is_pushdown() {
  is_pushdown_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool AggNode::_internal_is_pushdown() const {
  return is_pushdown_;
}
inline bool AggNode::is_pushdown() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AggNode.is_pushdown)
  return _internal_is_pushdown();
}
inline void AggNode::_internal_set_is_pushdown(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_pushdown_ = value;
}
inline void AggNode::set_is_pushdown(bool value) {
  _internal_set_is_pushdown(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AggNode.is_pushdown)
}

// -------------------------------------------------------------------

// FilterNode

// repeated .baikaldb.pb.Expr conjuncts = 1;
inline int FilterNode::_internal_conjuncts_size() const {
  return conjuncts_.size();
}
inline int FilterNode::conjuncts_size() const {
  return _internal_conjuncts_size();
}
inline ::baikaldb::pb::Expr* FilterNode::mutable_conjuncts(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FilterNode.conjuncts)
  return conjuncts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
FilterNode::mutable_conjuncts() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.FilterNode.conjuncts)
  return &conjuncts_;
}
inline const ::baikaldb::pb::Expr& FilterNode::_internal_conjuncts(int index) const {
  return conjuncts_.Get(index);
}
inline const ::baikaldb::pb::Expr& FilterNode::conjuncts(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FilterNode.conjuncts)
  return _internal_conjuncts(index);
}
inline ::baikaldb::pb::Expr* FilterNode::_internal_add_conjuncts() {
  return conjuncts_.Add();
}
inline ::baikaldb::pb::Expr* FilterNode::add_conjuncts() {
  ::baikaldb::pb::Expr* _add = _internal_add_conjuncts();
  // @@protoc_insertion_point(field_add:baikaldb.pb.FilterNode.conjuncts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
FilterNode::conjuncts() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.FilterNode.conjuncts)
  return conjuncts_;
}

// repeated .baikaldb.pb.Expr conjuncts_learner = 2;
inline int FilterNode::_internal_conjuncts_learner_size() const {
  return conjuncts_learner_.size();
}
inline int FilterNode::conjuncts_learner_size() const {
  return _internal_conjuncts_learner_size();
}
inline ::baikaldb::pb::Expr* FilterNode::mutable_conjuncts_learner(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FilterNode.conjuncts_learner)
  return conjuncts_learner_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
FilterNode::mutable_conjuncts_learner() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.FilterNode.conjuncts_learner)
  return &conjuncts_learner_;
}
inline const ::baikaldb::pb::Expr& FilterNode::_internal_conjuncts_learner(int index) const {
  return conjuncts_learner_.Get(index);
}
inline const ::baikaldb::pb::Expr& FilterNode::conjuncts_learner(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FilterNode.conjuncts_learner)
  return _internal_conjuncts_learner(index);
}
inline ::baikaldb::pb::Expr* FilterNode::_internal_add_conjuncts_learner() {
  return conjuncts_learner_.Add();
}
inline ::baikaldb::pb::Expr* FilterNode::add_conjuncts_learner() {
  ::baikaldb::pb::Expr* _add = _internal_add_conjuncts_learner();
  // @@protoc_insertion_point(field_add:baikaldb.pb.FilterNode.conjuncts_learner)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
FilterNode::conjuncts_learner() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.FilterNode.conjuncts_learner)
  return conjuncts_learner_;
}

// -------------------------------------------------------------------

// DualScanNode

// optional .baikaldb.pb.Plan sub_query_node = 1;
inline bool DualScanNode::_internal_has_sub_query_node() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || sub_query_node_ != nullptr);
  return value;
}
inline bool DualScanNode::has_sub_query_node() const {
  return _internal_has_sub_query_node();
}
inline void DualScanNode::clear_sub_query_node() {
  if (sub_query_node_ != nullptr) sub_query_node_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::Plan& DualScanNode::_internal_sub_query_node() const {
  const ::baikaldb::pb::Plan* p = sub_query_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::Plan&>(
      ::baikaldb::pb::_Plan_default_instance_);
}
inline const ::baikaldb::pb::Plan& DualScanNode::sub_query_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DualScanNode.sub_query_node)
  return _internal_sub_query_node();
}
inline void DualScanNode::unsafe_arena_set_allocated_sub_query_node(
    ::baikaldb::pb::Plan* sub_query_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sub_query_node_);
  }
  sub_query_node_ = sub_query_node;
  if (sub_query_node) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DualScanNode.sub_query_node)
}
inline ::baikaldb::pb::Plan* DualScanNode::release_sub_query_node() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::Plan* temp = sub_query_node_;
  sub_query_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::Plan* DualScanNode::unsafe_arena_release_sub_query_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DualScanNode.sub_query_node)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::Plan* temp = sub_query_node_;
  sub_query_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::Plan* DualScanNode::_internal_mutable_sub_query_node() {
  _has_bits_[0] |= 0x00000001u;
  if (sub_query_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::Plan>(GetArenaForAllocation());
    sub_query_node_ = p;
  }
  return sub_query_node_;
}
inline ::baikaldb::pb::Plan* DualScanNode::mutable_sub_query_node() {
  ::baikaldb::pb::Plan* _msg = _internal_mutable_sub_query_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DualScanNode.sub_query_node)
  return _msg;
}
inline void DualScanNode::set_allocated_sub_query_node(::baikaldb::pb::Plan* sub_query_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sub_query_node_;
  }
  if (sub_query_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::Plan>::GetOwningArena(sub_query_node);
    if (message_arena != submessage_arena) {
      sub_query_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sub_query_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sub_query_node_ = sub_query_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DualScanNode.sub_query_node)
}

// repeated .baikaldb.pb.Expr derived_table_projections = 2;
inline int DualScanNode::_internal_derived_table_projections_size() const {
  return derived_table_projections_.size();
}
inline int DualScanNode::derived_table_projections_size() const {
  return _internal_derived_table_projections_size();
}
inline ::baikaldb::pb::Expr* DualScanNode::mutable_derived_table_projections(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DualScanNode.derived_table_projections)
  return derived_table_projections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
DualScanNode::mutable_derived_table_projections() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.DualScanNode.derived_table_projections)
  return &derived_table_projections_;
}
inline const ::baikaldb::pb::Expr& DualScanNode::_internal_derived_table_projections(int index) const {
  return derived_table_projections_.Get(index);
}
inline const ::baikaldb::pb::Expr& DualScanNode::derived_table_projections(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DualScanNode.derived_table_projections)
  return _internal_derived_table_projections(index);
}
inline ::baikaldb::pb::Expr* DualScanNode::_internal_add_derived_table_projections() {
  return derived_table_projections_.Add();
}
inline ::baikaldb::pb::Expr* DualScanNode::add_derived_table_projections() {
  ::baikaldb::pb::Expr* _add = _internal_add_derived_table_projections();
  // @@protoc_insertion_point(field_add:baikaldb.pb.DualScanNode.derived_table_projections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
DualScanNode::derived_table_projections() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.DualScanNode.derived_table_projections)
  return derived_table_projections_;
}

// optional .baikaldb.pb.RuntimeState runtime_state = 3;
inline bool DualScanNode::_internal_has_runtime_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || runtime_state_ != nullptr);
  return value;
}
inline bool DualScanNode::has_runtime_state() const {
  return _internal_has_runtime_state();
}
inline const ::baikaldb::pb::RuntimeState& DualScanNode::_internal_runtime_state() const {
  const ::baikaldb::pb::RuntimeState* p = runtime_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RuntimeState&>(
      ::baikaldb::pb::_RuntimeState_default_instance_);
}
inline const ::baikaldb::pb::RuntimeState& DualScanNode::runtime_state() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DualScanNode.runtime_state)
  return _internal_runtime_state();
}
inline void DualScanNode::unsafe_arena_set_allocated_runtime_state(
    ::baikaldb::pb::RuntimeState* runtime_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_state_);
  }
  runtime_state_ = runtime_state;
  if (runtime_state) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DualScanNode.runtime_state)
}
inline ::baikaldb::pb::RuntimeState* DualScanNode::release_runtime_state() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::RuntimeState* temp = runtime_state_;
  runtime_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RuntimeState* DualScanNode::unsafe_arena_release_runtime_state() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DualScanNode.runtime_state)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::RuntimeState* temp = runtime_state_;
  runtime_state_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RuntimeState* DualScanNode::_internal_mutable_runtime_state() {
  _has_bits_[0] |= 0x00000002u;
  if (runtime_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RuntimeState>(GetArenaForAllocation());
    runtime_state_ = p;
  }
  return runtime_state_;
}
inline ::baikaldb::pb::RuntimeState* DualScanNode::mutable_runtime_state() {
  ::baikaldb::pb::RuntimeState* _msg = _internal_mutable_runtime_state();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DualScanNode.runtime_state)
  return _msg;
}
inline void DualScanNode::set_allocated_runtime_state(::baikaldb::pb::RuntimeState* runtime_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_state_);
  }
  if (runtime_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_state));
    if (message_arena != submessage_arena) {
      runtime_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, runtime_state, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  runtime_state_ = runtime_state;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DualScanNode.runtime_state)
}

// repeated .baikaldb.pb.SlotColumn slot_column = 4;
inline int DualScanNode::_internal_slot_column_size() const {
  return slot_column_.size();
}
inline int DualScanNode::slot_column_size() const {
  return _internal_slot_column_size();
}
inline ::baikaldb::pb::SlotColumn* DualScanNode::mutable_slot_column(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DualScanNode.slot_column)
  return slot_column_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotColumn >*
DualScanNode::mutable_slot_column() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.DualScanNode.slot_column)
  return &slot_column_;
}
inline const ::baikaldb::pb::SlotColumn& DualScanNode::_internal_slot_column(int index) const {
  return slot_column_.Get(index);
}
inline const ::baikaldb::pb::SlotColumn& DualScanNode::slot_column(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DualScanNode.slot_column)
  return _internal_slot_column(index);
}
inline ::baikaldb::pb::SlotColumn* DualScanNode::_internal_add_slot_column() {
  return slot_column_.Add();
}
inline ::baikaldb::pb::SlotColumn* DualScanNode::add_slot_column() {
  ::baikaldb::pb::SlotColumn* _add = _internal_add_slot_column();
  // @@protoc_insertion_point(field_add:baikaldb.pb.DualScanNode.slot_column)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotColumn >&
DualScanNode::slot_column() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.DualScanNode.slot_column)
  return slot_column_;
}

// repeated bool derived_table_projections_agg_or_window_vec = 5;
inline int DualScanNode::_internal_derived_table_projections_agg_or_window_vec_size() const {
  return derived_table_projections_agg_or_window_vec_.size();
}
inline int DualScanNode::derived_table_projections_agg_or_window_vec_size() const {
  return _internal_derived_table_projections_agg_or_window_vec_size();
}
inline void DualScanNode::clear_derived_table_projections_agg_or_window_vec() {
  derived_table_projections_agg_or_window_vec_.Clear();
}
inline bool DualScanNode::_internal_derived_table_projections_agg_or_window_vec(int index) const {
  return derived_table_projections_agg_or_window_vec_.Get(index);
}
inline bool DualScanNode::derived_table_projections_agg_or_window_vec(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DualScanNode.derived_table_projections_agg_or_window_vec)
  return _internal_derived_table_projections_agg_or_window_vec(index);
}
inline void DualScanNode::set_derived_table_projections_agg_or_window_vec(int index, bool value) {
  derived_table_projections_agg_or_window_vec_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DualScanNode.derived_table_projections_agg_or_window_vec)
}
inline void DualScanNode::_internal_add_derived_table_projections_agg_or_window_vec(bool value) {
  derived_table_projections_agg_or_window_vec_.Add(value);
}
inline void DualScanNode::add_derived_table_projections_agg_or_window_vec(bool value) {
  _internal_add_derived_table_projections_agg_or_window_vec(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.DualScanNode.derived_table_projections_agg_or_window_vec)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
DualScanNode::_internal_derived_table_projections_agg_or_window_vec() const {
  return derived_table_projections_agg_or_window_vec_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
DualScanNode::derived_table_projections_agg_or_window_vec() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.DualScanNode.derived_table_projections_agg_or_window_vec)
  return _internal_derived_table_projections_agg_or_window_vec();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
DualScanNode::_internal_mutable_derived_table_projections_agg_or_window_vec() {
  return &derived_table_projections_agg_or_window_vec_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
DualScanNode::mutable_derived_table_projections_agg_or_window_vec() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.DualScanNode.derived_table_projections_agg_or_window_vec)
  return _internal_mutable_derived_table_projections_agg_or_window_vec();
}

// repeated int32 agg_tuple_id_pair = 6;
inline int DualScanNode::_internal_agg_tuple_id_pair_size() const {
  return agg_tuple_id_pair_.size();
}
inline int DualScanNode::agg_tuple_id_pair_size() const {
  return _internal_agg_tuple_id_pair_size();
}
inline void DualScanNode::clear_agg_tuple_id_pair() {
  agg_tuple_id_pair_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DualScanNode::_internal_agg_tuple_id_pair(int index) const {
  return agg_tuple_id_pair_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DualScanNode::agg_tuple_id_pair(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DualScanNode.agg_tuple_id_pair)
  return _internal_agg_tuple_id_pair(index);
}
inline void DualScanNode::set_agg_tuple_id_pair(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  agg_tuple_id_pair_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DualScanNode.agg_tuple_id_pair)
}
inline void DualScanNode::_internal_add_agg_tuple_id_pair(::PROTOBUF_NAMESPACE_ID::int32 value) {
  agg_tuple_id_pair_.Add(value);
}
inline void DualScanNode::add_agg_tuple_id_pair(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_agg_tuple_id_pair(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.DualScanNode.agg_tuple_id_pair)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
DualScanNode::_internal_agg_tuple_id_pair() const {
  return agg_tuple_id_pair_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
DualScanNode::agg_tuple_id_pair() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.DualScanNode.agg_tuple_id_pair)
  return _internal_agg_tuple_id_pair();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
DualScanNode::_internal_mutable_agg_tuple_id_pair() {
  return &agg_tuple_id_pair_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
DualScanNode::mutable_agg_tuple_id_pair() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.DualScanNode.agg_tuple_id_pair)
  return _internal_mutable_agg_tuple_id_pair();
}

// repeated int32 agg_slot_ids = 7;
inline int DualScanNode::_internal_agg_slot_ids_size() const {
  return agg_slot_ids_.size();
}
inline int DualScanNode::agg_slot_ids_size() const {
  return _internal_agg_slot_ids_size();
}
inline void DualScanNode::clear_agg_slot_ids() {
  agg_slot_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DualScanNode::_internal_agg_slot_ids(int index) const {
  return agg_slot_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DualScanNode::agg_slot_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DualScanNode.agg_slot_ids)
  return _internal_agg_slot_ids(index);
}
inline void DualScanNode::set_agg_slot_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  agg_slot_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DualScanNode.agg_slot_ids)
}
inline void DualScanNode::_internal_add_agg_slot_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  agg_slot_ids_.Add(value);
}
inline void DualScanNode::add_agg_slot_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_agg_slot_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.DualScanNode.agg_slot_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
DualScanNode::_internal_agg_slot_ids() const {
  return agg_slot_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
DualScanNode::agg_slot_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.DualScanNode.agg_slot_ids)
  return _internal_agg_slot_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
DualScanNode::_internal_mutable_agg_slot_ids() {
  return &agg_slot_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
DualScanNode::mutable_agg_slot_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.DualScanNode.agg_slot_ids)
  return _internal_mutable_agg_slot_ids();
}

// repeated int32 multi_distinct_agg_slot_ids = 8;
inline int DualScanNode::_internal_multi_distinct_agg_slot_ids_size() const {
  return multi_distinct_agg_slot_ids_.size();
}
inline int DualScanNode::multi_distinct_agg_slot_ids_size() const {
  return _internal_multi_distinct_agg_slot_ids_size();
}
inline void DualScanNode::clear_multi_distinct_agg_slot_ids() {
  multi_distinct_agg_slot_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DualScanNode::_internal_multi_distinct_agg_slot_ids(int index) const {
  return multi_distinct_agg_slot_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DualScanNode::multi_distinct_agg_slot_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DualScanNode.multi_distinct_agg_slot_ids)
  return _internal_multi_distinct_agg_slot_ids(index);
}
inline void DualScanNode::set_multi_distinct_agg_slot_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  multi_distinct_agg_slot_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DualScanNode.multi_distinct_agg_slot_ids)
}
inline void DualScanNode::_internal_add_multi_distinct_agg_slot_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  multi_distinct_agg_slot_ids_.Add(value);
}
inline void DualScanNode::add_multi_distinct_agg_slot_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_multi_distinct_agg_slot_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.DualScanNode.multi_distinct_agg_slot_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
DualScanNode::_internal_multi_distinct_agg_slot_ids() const {
  return multi_distinct_agg_slot_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
DualScanNode::multi_distinct_agg_slot_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.DualScanNode.multi_distinct_agg_slot_ids)
  return _internal_multi_distinct_agg_slot_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
DualScanNode::_internal_mutable_multi_distinct_agg_slot_ids() {
  return &multi_distinct_agg_slot_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
DualScanNode::mutable_multi_distinct_agg_slot_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.DualScanNode.multi_distinct_agg_slot_ids)
  return _internal_mutable_multi_distinct_agg_slot_ids();
}

// -------------------------------------------------------------------

// JoinNode

// required .baikaldb.pb.JoinType join_type = 1;
inline bool JoinNode::_internal_has_join_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool JoinNode::has_join_type() const {
  return _internal_has_join_type();
}
inline void JoinNode::clear_join_type() {
  join_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::baikaldb::pb::JoinType JoinNode::_internal_join_type() const {
  return static_cast< ::baikaldb::pb::JoinType >(join_type_);
}
inline ::baikaldb::pb::JoinType JoinNode::join_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.JoinNode.join_type)
  return _internal_join_type();
}
inline void JoinNode::_internal_set_join_type(::baikaldb::pb::JoinType value) {
  assert(::baikaldb::pb::JoinType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  join_type_ = value;
}
inline void JoinNode::set_join_type(::baikaldb::pb::JoinType value) {
  _internal_set_join_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.JoinNode.join_type)
}

// repeated .baikaldb.pb.Expr conditions = 2;
inline int JoinNode::_internal_conditions_size() const {
  return conditions_.size();
}
inline int JoinNode::conditions_size() const {
  return _internal_conditions_size();
}
inline ::baikaldb::pb::Expr* JoinNode::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.JoinNode.conditions)
  return conditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
JoinNode::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.JoinNode.conditions)
  return &conditions_;
}
inline const ::baikaldb::pb::Expr& JoinNode::_internal_conditions(int index) const {
  return conditions_.Get(index);
}
inline const ::baikaldb::pb::Expr& JoinNode::conditions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.JoinNode.conditions)
  return _internal_conditions(index);
}
inline ::baikaldb::pb::Expr* JoinNode::_internal_add_conditions() {
  return conditions_.Add();
}
inline ::baikaldb::pb::Expr* JoinNode::add_conditions() {
  ::baikaldb::pb::Expr* _add = _internal_add_conditions();
  // @@protoc_insertion_point(field_add:baikaldb.pb.JoinNode.conditions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
JoinNode::conditions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.JoinNode.conditions)
  return conditions_;
}

// repeated string using_clos = 3;
inline int JoinNode::_internal_using_clos_size() const {
  return using_clos_.size();
}
inline int JoinNode::using_clos_size() const {
  return _internal_using_clos_size();
}
inline void JoinNode::clear_using_clos() {
  using_clos_.Clear();
}
inline std::string* JoinNode::add_using_clos() {
  std::string* _s = _internal_add_using_clos();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.JoinNode.using_clos)
  return _s;
}
inline const std::string& JoinNode::_internal_using_clos(int index) const {
  return using_clos_.Get(index);
}
inline const std::string& JoinNode::using_clos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.JoinNode.using_clos)
  return _internal_using_clos(index);
}
inline std::string* JoinNode::mutable_using_clos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.JoinNode.using_clos)
  return using_clos_.Mutable(index);
}
inline void JoinNode::set_using_clos(int index, const std::string& value) {
  using_clos_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.JoinNode.using_clos)
}
inline void JoinNode::set_using_clos(int index, std::string&& value) {
  using_clos_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.JoinNode.using_clos)
}
inline void JoinNode::set_using_clos(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  using_clos_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.JoinNode.using_clos)
}
inline void JoinNode::set_using_clos(int index, const char* value, size_t size) {
  using_clos_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.JoinNode.using_clos)
}
inline std::string* JoinNode::_internal_add_using_clos() {
  return using_clos_.Add();
}
inline void JoinNode::add_using_clos(const std::string& value) {
  using_clos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.JoinNode.using_clos)
}
inline void JoinNode::add_using_clos(std::string&& value) {
  using_clos_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.JoinNode.using_clos)
}
inline void JoinNode::add_using_clos(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  using_clos_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.JoinNode.using_clos)
}
inline void JoinNode::add_using_clos(const char* value, size_t size) {
  using_clos_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.JoinNode.using_clos)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
JoinNode::using_clos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.JoinNode.using_clos)
  return using_clos_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
JoinNode::mutable_using_clos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.JoinNode.using_clos)
  return &using_clos_;
}

// repeated int32 left_tuple_ids = 4;
inline int JoinNode::_internal_left_tuple_ids_size() const {
  return left_tuple_ids_.size();
}
inline int JoinNode::left_tuple_ids_size() const {
  return _internal_left_tuple_ids_size();
}
inline void JoinNode::clear_left_tuple_ids() {
  left_tuple_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JoinNode::_internal_left_tuple_ids(int index) const {
  return left_tuple_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JoinNode::left_tuple_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.JoinNode.left_tuple_ids)
  return _internal_left_tuple_ids(index);
}
inline void JoinNode::set_left_tuple_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  left_tuple_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.JoinNode.left_tuple_ids)
}
inline void JoinNode::_internal_add_left_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  left_tuple_ids_.Add(value);
}
inline void JoinNode::add_left_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_left_tuple_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.JoinNode.left_tuple_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
JoinNode::_internal_left_tuple_ids() const {
  return left_tuple_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
JoinNode::left_tuple_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.JoinNode.left_tuple_ids)
  return _internal_left_tuple_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
JoinNode::_internal_mutable_left_tuple_ids() {
  return &left_tuple_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
JoinNode::mutable_left_tuple_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.JoinNode.left_tuple_ids)
  return _internal_mutable_left_tuple_ids();
}

// repeated int64 left_table_ids = 5;
inline int JoinNode::_internal_left_table_ids_size() const {
  return left_table_ids_.size();
}
inline int JoinNode::left_table_ids_size() const {
  return _internal_left_table_ids_size();
}
inline void JoinNode::clear_left_table_ids() {
  left_table_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 JoinNode::_internal_left_table_ids(int index) const {
  return left_table_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 JoinNode::left_table_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.JoinNode.left_table_ids)
  return _internal_left_table_ids(index);
}
inline void JoinNode::set_left_table_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  left_table_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.JoinNode.left_table_ids)
}
inline void JoinNode::_internal_add_left_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  left_table_ids_.Add(value);
}
inline void JoinNode::add_left_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_left_table_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.JoinNode.left_table_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
JoinNode::_internal_left_table_ids() const {
  return left_table_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
JoinNode::left_table_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.JoinNode.left_table_ids)
  return _internal_left_table_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
JoinNode::_internal_mutable_left_table_ids() {
  return &left_table_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
JoinNode::mutable_left_table_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.JoinNode.left_table_ids)
  return _internal_mutable_left_table_ids();
}

// repeated int32 right_tuple_ids = 6;
inline int JoinNode::_internal_right_tuple_ids_size() const {
  return right_tuple_ids_.size();
}
inline int JoinNode::right_tuple_ids_size() const {
  return _internal_right_tuple_ids_size();
}
inline void JoinNode::clear_right_tuple_ids() {
  right_tuple_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JoinNode::_internal_right_tuple_ids(int index) const {
  return right_tuple_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JoinNode::right_tuple_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.JoinNode.right_tuple_ids)
  return _internal_right_tuple_ids(index);
}
inline void JoinNode::set_right_tuple_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  right_tuple_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.JoinNode.right_tuple_ids)
}
inline void JoinNode::_internal_add_right_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  right_tuple_ids_.Add(value);
}
inline void JoinNode::add_right_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_right_tuple_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.JoinNode.right_tuple_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
JoinNode::_internal_right_tuple_ids() const {
  return right_tuple_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
JoinNode::right_tuple_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.JoinNode.right_tuple_ids)
  return _internal_right_tuple_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
JoinNode::_internal_mutable_right_tuple_ids() {
  return &right_tuple_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
JoinNode::mutable_right_tuple_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.JoinNode.right_tuple_ids)
  return _internal_mutable_right_tuple_ids();
}

// repeated int64 right_table_ids = 7;
inline int JoinNode::_internal_right_table_ids_size() const {
  return right_table_ids_.size();
}
inline int JoinNode::right_table_ids_size() const {
  return _internal_right_table_ids_size();
}
inline void JoinNode::clear_right_table_ids() {
  right_table_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 JoinNode::_internal_right_table_ids(int index) const {
  return right_table_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 JoinNode::right_table_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.JoinNode.right_table_ids)
  return _internal_right_table_ids(index);
}
inline void JoinNode::set_right_table_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  right_table_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.JoinNode.right_table_ids)
}
inline void JoinNode::_internal_add_right_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  right_table_ids_.Add(value);
}
inline void JoinNode::add_right_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_right_table_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.JoinNode.right_table_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
JoinNode::_internal_right_table_ids() const {
  return right_table_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
JoinNode::right_table_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.JoinNode.right_table_ids)
  return _internal_right_table_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
JoinNode::_internal_mutable_right_table_ids() {
  return &right_table_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
JoinNode::mutable_right_table_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.JoinNode.right_table_ids)
  return _internal_mutable_right_table_ids();
}

// optional bool use_index_join = 8;
inline bool JoinNode::_internal_has_use_index_join() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool JoinNode::has_use_index_join() const {
  return _internal_has_use_index_join();
}
inline void JoinNode::clear_use_index_join() {
  use_index_join_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool JoinNode::_internal_use_index_join() const {
  return use_index_join_;
}
inline bool JoinNode::use_index_join() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.JoinNode.use_index_join)
  return _internal_use_index_join();
}
inline void JoinNode::_internal_set_use_index_join(bool value) {
  _has_bits_[0] |= 0x00000002u;
  use_index_join_ = value;
}
inline void JoinNode::set_use_index_join(bool value) {
  _internal_set_use_index_join(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.JoinNode.use_index_join)
}

// -------------------------------------------------------------------

// ApplyNode

// required .baikaldb.pb.JoinType join_type = 1;
inline bool ApplyNode::_internal_has_join_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ApplyNode::has_join_type() const {
  return _internal_has_join_type();
}
inline void ApplyNode::clear_join_type() {
  join_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::baikaldb::pb::JoinType ApplyNode::_internal_join_type() const {
  return static_cast< ::baikaldb::pb::JoinType >(join_type_);
}
inline ::baikaldb::pb::JoinType ApplyNode::join_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ApplyNode.join_type)
  return _internal_join_type();
}
inline void ApplyNode::_internal_set_join_type(::baikaldb::pb::JoinType value) {
  assert(::baikaldb::pb::JoinType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  join_type_ = value;
}
inline void ApplyNode::set_join_type(::baikaldb::pb::JoinType value) {
  _internal_set_join_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ApplyNode.join_type)
}

// repeated .baikaldb.pb.Expr conditions = 2;
inline int ApplyNode::_internal_conditions_size() const {
  return conditions_.size();
}
inline int ApplyNode::conditions_size() const {
  return _internal_conditions_size();
}
inline ::baikaldb::pb::Expr* ApplyNode::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ApplyNode.conditions)
  return conditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
ApplyNode::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ApplyNode.conditions)
  return &conditions_;
}
inline const ::baikaldb::pb::Expr& ApplyNode::_internal_conditions(int index) const {
  return conditions_.Get(index);
}
inline const ::baikaldb::pb::Expr& ApplyNode::conditions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ApplyNode.conditions)
  return _internal_conditions(index);
}
inline ::baikaldb::pb::Expr* ApplyNode::_internal_add_conditions() {
  return conditions_.Add();
}
inline ::baikaldb::pb::Expr* ApplyNode::add_conditions() {
  ::baikaldb::pb::Expr* _add = _internal_add_conditions();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ApplyNode.conditions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
ApplyNode::conditions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ApplyNode.conditions)
  return conditions_;
}

// repeated int32 left_tuple_ids = 4;
inline int ApplyNode::_internal_left_tuple_ids_size() const {
  return left_tuple_ids_.size();
}
inline int ApplyNode::left_tuple_ids_size() const {
  return _internal_left_tuple_ids_size();
}
inline void ApplyNode::clear_left_tuple_ids() {
  left_tuple_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApplyNode::_internal_left_tuple_ids(int index) const {
  return left_tuple_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApplyNode::left_tuple_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ApplyNode.left_tuple_ids)
  return _internal_left_tuple_ids(index);
}
inline void ApplyNode::set_left_tuple_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  left_tuple_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ApplyNode.left_tuple_ids)
}
inline void ApplyNode::_internal_add_left_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  left_tuple_ids_.Add(value);
}
inline void ApplyNode::add_left_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_left_tuple_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.ApplyNode.left_tuple_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ApplyNode::_internal_left_tuple_ids() const {
  return left_tuple_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ApplyNode::left_tuple_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ApplyNode.left_tuple_ids)
  return _internal_left_tuple_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ApplyNode::_internal_mutable_left_tuple_ids() {
  return &left_tuple_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ApplyNode::mutable_left_tuple_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ApplyNode.left_tuple_ids)
  return _internal_mutable_left_tuple_ids();
}

// repeated int64 left_table_ids = 5;
inline int ApplyNode::_internal_left_table_ids_size() const {
  return left_table_ids_.size();
}
inline int ApplyNode::left_table_ids_size() const {
  return _internal_left_table_ids_size();
}
inline void ApplyNode::clear_left_table_ids() {
  left_table_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ApplyNode::_internal_left_table_ids(int index) const {
  return left_table_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ApplyNode::left_table_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ApplyNode.left_table_ids)
  return _internal_left_table_ids(index);
}
inline void ApplyNode::set_left_table_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  left_table_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ApplyNode.left_table_ids)
}
inline void ApplyNode::_internal_add_left_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  left_table_ids_.Add(value);
}
inline void ApplyNode::add_left_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_left_table_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.ApplyNode.left_table_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ApplyNode::_internal_left_table_ids() const {
  return left_table_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ApplyNode::left_table_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ApplyNode.left_table_ids)
  return _internal_left_table_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ApplyNode::_internal_mutable_left_table_ids() {
  return &left_table_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ApplyNode::mutable_left_table_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ApplyNode.left_table_ids)
  return _internal_mutable_left_table_ids();
}

// repeated int32 right_tuple_ids = 6;
inline int ApplyNode::_internal_right_tuple_ids_size() const {
  return right_tuple_ids_.size();
}
inline int ApplyNode::right_tuple_ids_size() const {
  return _internal_right_tuple_ids_size();
}
inline void ApplyNode::clear_right_tuple_ids() {
  right_tuple_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApplyNode::_internal_right_tuple_ids(int index) const {
  return right_tuple_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ApplyNode::right_tuple_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ApplyNode.right_tuple_ids)
  return _internal_right_tuple_ids(index);
}
inline void ApplyNode::set_right_tuple_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  right_tuple_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ApplyNode.right_tuple_ids)
}
inline void ApplyNode::_internal_add_right_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  right_tuple_ids_.Add(value);
}
inline void ApplyNode::add_right_tuple_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_right_tuple_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.ApplyNode.right_tuple_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ApplyNode::_internal_right_tuple_ids() const {
  return right_tuple_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
ApplyNode::right_tuple_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ApplyNode.right_tuple_ids)
  return _internal_right_tuple_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ApplyNode::_internal_mutable_right_tuple_ids() {
  return &right_tuple_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
ApplyNode::mutable_right_tuple_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ApplyNode.right_tuple_ids)
  return _internal_mutable_right_tuple_ids();
}

// repeated int64 right_table_ids = 7;
inline int ApplyNode::_internal_right_table_ids_size() const {
  return right_table_ids_.size();
}
inline int ApplyNode::right_table_ids_size() const {
  return _internal_right_table_ids_size();
}
inline void ApplyNode::clear_right_table_ids() {
  right_table_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ApplyNode::_internal_right_table_ids(int index) const {
  return right_table_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ApplyNode::right_table_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ApplyNode.right_table_ids)
  return _internal_right_table_ids(index);
}
inline void ApplyNode::set_right_table_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  right_table_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ApplyNode.right_table_ids)
}
inline void ApplyNode::_internal_add_right_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  right_table_ids_.Add(value);
}
inline void ApplyNode::add_right_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_right_table_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.ApplyNode.right_table_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ApplyNode::_internal_right_table_ids() const {
  return right_table_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ApplyNode::right_table_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ApplyNode.right_table_ids)
  return _internal_right_table_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ApplyNode::_internal_mutable_right_table_ids() {
  return &right_table_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ApplyNode::mutable_right_table_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ApplyNode.right_table_ids)
  return _internal_mutable_right_table_ids();
}

// optional bool max_one_row = 8;
inline bool ApplyNode::_internal_has_max_one_row() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ApplyNode::has_max_one_row() const {
  return _internal_has_max_one_row();
}
inline void ApplyNode::clear_max_one_row() {
  max_one_row_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ApplyNode::_internal_max_one_row() const {
  return max_one_row_;
}
inline bool ApplyNode::max_one_row() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ApplyNode.max_one_row)
  return _internal_max_one_row();
}
inline void ApplyNode::_internal_set_max_one_row(bool value) {
  _has_bits_[0] |= 0x00000004u;
  max_one_row_ = value;
}
inline void ApplyNode::set_max_one_row(bool value) {
  _internal_set_max_one_row(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ApplyNode.max_one_row)
}

// optional .baikaldb.pb.CompareType compare_type = 9;
inline bool ApplyNode::_internal_has_compare_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ApplyNode::has_compare_type() const {
  return _internal_has_compare_type();
}
inline void ApplyNode::clear_compare_type() {
  compare_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::baikaldb::pb::CompareType ApplyNode::_internal_compare_type() const {
  return static_cast< ::baikaldb::pb::CompareType >(compare_type_);
}
inline ::baikaldb::pb::CompareType ApplyNode::compare_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ApplyNode.compare_type)
  return _internal_compare_type();
}
inline void ApplyNode::_internal_set_compare_type(::baikaldb::pb::CompareType value) {
  assert(::baikaldb::pb::CompareType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  compare_type_ = value;
}
inline void ApplyNode::set_compare_type(::baikaldb::pb::CompareType value) {
  _internal_set_compare_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ApplyNode.compare_type)
}

// optional bool is_select_field = 10;
inline bool ApplyNode::_internal_has_is_select_field() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ApplyNode::has_is_select_field() const {
  return _internal_has_is_select_field();
}
inline void ApplyNode::clear_is_select_field() {
  is_select_field_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ApplyNode::_internal_is_select_field() const {
  return is_select_field_;
}
inline bool ApplyNode::is_select_field() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ApplyNode.is_select_field)
  return _internal_is_select_field();
}
inline void ApplyNode::_internal_set_is_select_field(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_select_field_ = value;
}
inline void ApplyNode::set_is_select_field(bool value) {
  _internal_set_is_select_field(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ApplyNode.is_select_field)
}

// -------------------------------------------------------------------

// FetcherNode

// required .baikaldb.pb.OpType op_type = 1;
inline bool FetcherNode::_internal_has_op_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FetcherNode::has_op_type() const {
  return _internal_has_op_type();
}
inline void FetcherNode::clear_op_type() {
  op_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::baikaldb::pb::OpType FetcherNode::_internal_op_type() const {
  return static_cast< ::baikaldb::pb::OpType >(op_type_);
}
inline ::baikaldb::pb::OpType FetcherNode::op_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FetcherNode.op_type)
  return _internal_op_type();
}
inline void FetcherNode::_internal_set_op_type(::baikaldb::pb::OpType value) {
  assert(::baikaldb::pb::OpType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  op_type_ = value;
}
inline void FetcherNode::set_op_type(::baikaldb::pb::OpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FetcherNode.op_type)
}

// repeated .baikaldb.pb.Expr slot_order_exprs = 3;
inline int FetcherNode::_internal_slot_order_exprs_size() const {
  return slot_order_exprs_.size();
}
inline int FetcherNode::slot_order_exprs_size() const {
  return _internal_slot_order_exprs_size();
}
inline ::baikaldb::pb::Expr* FetcherNode::mutable_slot_order_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FetcherNode.slot_order_exprs)
  return slot_order_exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
FetcherNode::mutable_slot_order_exprs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.FetcherNode.slot_order_exprs)
  return &slot_order_exprs_;
}
inline const ::baikaldb::pb::Expr& FetcherNode::_internal_slot_order_exprs(int index) const {
  return slot_order_exprs_.Get(index);
}
inline const ::baikaldb::pb::Expr& FetcherNode::slot_order_exprs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FetcherNode.slot_order_exprs)
  return _internal_slot_order_exprs(index);
}
inline ::baikaldb::pb::Expr* FetcherNode::_internal_add_slot_order_exprs() {
  return slot_order_exprs_.Add();
}
inline ::baikaldb::pb::Expr* FetcherNode::add_slot_order_exprs() {
  ::baikaldb::pb::Expr* _add = _internal_add_slot_order_exprs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.FetcherNode.slot_order_exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
FetcherNode::slot_order_exprs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.FetcherNode.slot_order_exprs)
  return slot_order_exprs_;
}

// repeated bool is_asc = 4;
inline int FetcherNode::_internal_is_asc_size() const {
  return is_asc_.size();
}
inline int FetcherNode::is_asc_size() const {
  return _internal_is_asc_size();
}
inline void FetcherNode::clear_is_asc() {
  is_asc_.Clear();
}
inline bool FetcherNode::_internal_is_asc(int index) const {
  return is_asc_.Get(index);
}
inline bool FetcherNode::is_asc(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FetcherNode.is_asc)
  return _internal_is_asc(index);
}
inline void FetcherNode::set_is_asc(int index, bool value) {
  is_asc_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FetcherNode.is_asc)
}
inline void FetcherNode::_internal_add_is_asc(bool value) {
  is_asc_.Add(value);
}
inline void FetcherNode::add_is_asc(bool value) {
  _internal_add_is_asc(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.FetcherNode.is_asc)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
FetcherNode::_internal_is_asc() const {
  return is_asc_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
FetcherNode::is_asc() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.FetcherNode.is_asc)
  return _internal_is_asc();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
FetcherNode::_internal_mutable_is_asc() {
  return &is_asc_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
FetcherNode::mutable_is_asc() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.FetcherNode.is_asc)
  return _internal_mutable_is_asc();
}

// repeated bool is_null_first = 5;
inline int FetcherNode::_internal_is_null_first_size() const {
  return is_null_first_.size();
}
inline int FetcherNode::is_null_first_size() const {
  return _internal_is_null_first_size();
}
inline void FetcherNode::clear_is_null_first() {
  is_null_first_.Clear();
}
inline bool FetcherNode::_internal_is_null_first(int index) const {
  return is_null_first_.Get(index);
}
inline bool FetcherNode::is_null_first(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FetcherNode.is_null_first)
  return _internal_is_null_first(index);
}
inline void FetcherNode::set_is_null_first(int index, bool value) {
  is_null_first_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FetcherNode.is_null_first)
}
inline void FetcherNode::_internal_add_is_null_first(bool value) {
  is_null_first_.Add(value);
}
inline void FetcherNode::add_is_null_first(bool value) {
  _internal_add_is_null_first(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.FetcherNode.is_null_first)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
FetcherNode::_internal_is_null_first() const {
  return is_null_first_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
FetcherNode::is_null_first() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.FetcherNode.is_null_first)
  return _internal_is_null_first();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
FetcherNode::_internal_mutable_is_null_first() {
  return &is_null_first_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
FetcherNode::mutable_is_null_first() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.FetcherNode.is_null_first)
  return _internal_mutable_is_null_first();
}

// -------------------------------------------------------------------

// InsertNode

// required int64 table_id = 1;
inline bool InsertNode::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InsertNode::has_table_id() const {
  return _internal_has_table_id();
}
inline void InsertNode::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InsertNode::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InsertNode::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InsertNode.table_id)
  return _internal_table_id();
}
inline void InsertNode::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  table_id_ = value;
}
inline void InsertNode::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InsertNode.table_id)
}

// repeated bytes records = 2;
inline int InsertNode::_internal_records_size() const {
  return records_.size();
}
inline int InsertNode::records_size() const {
  return _internal_records_size();
}
inline void InsertNode::clear_records() {
  records_.Clear();
}
inline std::string* InsertNode::add_records() {
  std::string* _s = _internal_add_records();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.InsertNode.records)
  return _s;
}
inline const std::string& InsertNode::_internal_records(int index) const {
  return records_.Get(index);
}
inline const std::string& InsertNode::records(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InsertNode.records)
  return _internal_records(index);
}
inline std::string* InsertNode::mutable_records(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.InsertNode.records)
  return records_.Mutable(index);
}
inline void InsertNode::set_records(int index, const std::string& value) {
  records_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InsertNode.records)
}
inline void InsertNode::set_records(int index, std::string&& value) {
  records_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.InsertNode.records)
}
inline void InsertNode::set_records(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  records_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.InsertNode.records)
}
inline void InsertNode::set_records(int index, const void* value, size_t size) {
  records_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.InsertNode.records)
}
inline std::string* InsertNode::_internal_add_records() {
  return records_.Add();
}
inline void InsertNode::add_records(const std::string& value) {
  records_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.InsertNode.records)
}
inline void InsertNode::add_records(std::string&& value) {
  records_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.InsertNode.records)
}
inline void InsertNode::add_records(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  records_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.InsertNode.records)
}
inline void InsertNode::add_records(const void* value, size_t size) {
  records_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.InsertNode.records)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InsertNode::records() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.InsertNode.records)
  return records_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InsertNode::mutable_records() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.InsertNode.records)
  return &records_;
}

// optional bool need_ignore = 3;
inline bool InsertNode::_internal_has_need_ignore() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool InsertNode::has_need_ignore() const {
  return _internal_has_need_ignore();
}
inline void InsertNode::clear_need_ignore() {
  need_ignore_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool InsertNode::_internal_need_ignore() const {
  return need_ignore_;
}
inline bool InsertNode::need_ignore() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InsertNode.need_ignore)
  return _internal_need_ignore();
}
inline void InsertNode::_internal_set_need_ignore(bool value) {
  _has_bits_[0] |= 0x00000040u;
  need_ignore_ = value;
}
inline void InsertNode::set_need_ignore(bool value) {
  _internal_set_need_ignore(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InsertNode.need_ignore)
}

// repeated .baikaldb.pb.SlotDescriptor update_slots = 4;
inline int InsertNode::_internal_update_slots_size() const {
  return update_slots_.size();
}
inline int InsertNode::update_slots_size() const {
  return _internal_update_slots_size();
}
inline ::baikaldb::pb::SlotDescriptor* InsertNode::mutable_update_slots(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.InsertNode.update_slots)
  return update_slots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >*
InsertNode::mutable_update_slots() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.InsertNode.update_slots)
  return &update_slots_;
}
inline const ::baikaldb::pb::SlotDescriptor& InsertNode::_internal_update_slots(int index) const {
  return update_slots_.Get(index);
}
inline const ::baikaldb::pb::SlotDescriptor& InsertNode::update_slots(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InsertNode.update_slots)
  return _internal_update_slots(index);
}
inline ::baikaldb::pb::SlotDescriptor* InsertNode::_internal_add_update_slots() {
  return update_slots_.Add();
}
inline ::baikaldb::pb::SlotDescriptor* InsertNode::add_update_slots() {
  ::baikaldb::pb::SlotDescriptor* _add = _internal_add_update_slots();
  // @@protoc_insertion_point(field_add:baikaldb.pb.InsertNode.update_slots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >&
InsertNode::update_slots() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.InsertNode.update_slots)
  return update_slots_;
}

// repeated .baikaldb.pb.Expr update_exprs = 5;
inline int InsertNode::_internal_update_exprs_size() const {
  return update_exprs_.size();
}
inline int InsertNode::update_exprs_size() const {
  return _internal_update_exprs_size();
}
inline ::baikaldb::pb::Expr* InsertNode::mutable_update_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.InsertNode.update_exprs)
  return update_exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
InsertNode::mutable_update_exprs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.InsertNode.update_exprs)
  return &update_exprs_;
}
inline const ::baikaldb::pb::Expr& InsertNode::_internal_update_exprs(int index) const {
  return update_exprs_.Get(index);
}
inline const ::baikaldb::pb::Expr& InsertNode::update_exprs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InsertNode.update_exprs)
  return _internal_update_exprs(index);
}
inline ::baikaldb::pb::Expr* InsertNode::_internal_add_update_exprs() {
  return update_exprs_.Add();
}
inline ::baikaldb::pb::Expr* InsertNode::add_update_exprs() {
  ::baikaldb::pb::Expr* _add = _internal_add_update_exprs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.InsertNode.update_exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
InsertNode::update_exprs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.InsertNode.update_exprs)
  return update_exprs_;
}

// optional int32 tuple_id = 6;
inline bool InsertNode::_internal_has_tuple_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InsertNode::has_tuple_id() const {
  return _internal_has_tuple_id();
}
inline void InsertNode::clear_tuple_id() {
  tuple_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertNode::_internal_tuple_id() const {
  return tuple_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertNode::tuple_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InsertNode.tuple_id)
  return _internal_tuple_id();
}
inline void InsertNode::_internal_set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  tuple_id_ = value;
}
inline void InsertNode::set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tuple_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InsertNode.tuple_id)
}

// optional int32 values_tuple_id = 7;
inline bool InsertNode::_internal_has_values_tuple_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InsertNode::has_values_tuple_id() const {
  return _internal_has_values_tuple_id();
}
inline void InsertNode::clear_values_tuple_id() {
  values_tuple_id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertNode::_internal_values_tuple_id() const {
  return values_tuple_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertNode::values_tuple_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InsertNode.values_tuple_id)
  return _internal_values_tuple_id();
}
inline void InsertNode::_internal_set_values_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  values_tuple_id_ = value;
}
inline void InsertNode::set_values_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_values_tuple_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InsertNode.values_tuple_id)
}

// optional bool is_replace = 8;
inline bool InsertNode::_internal_has_is_replace() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool InsertNode::has_is_replace() const {
  return _internal_has_is_replace();
}
inline void InsertNode::clear_is_replace() {
  is_replace_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool InsertNode::_internal_is_replace() const {
  return is_replace_;
}
inline bool InsertNode::is_replace() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InsertNode.is_replace)
  return _internal_is_replace();
}
inline void InsertNode::_internal_set_is_replace(bool value) {
  _has_bits_[0] |= 0x00000080u;
  is_replace_ = value;
}
inline void InsertNode::set_is_replace(bool value) {
  _internal_set_is_replace(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InsertNode.is_replace)
}

// repeated int32 field_ids = 9;
inline int InsertNode::_internal_field_ids_size() const {
  return field_ids_.size();
}
inline int InsertNode::field_ids_size() const {
  return _internal_field_ids_size();
}
inline void InsertNode::clear_field_ids() {
  field_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertNode::_internal_field_ids(int index) const {
  return field_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsertNode::field_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InsertNode.field_ids)
  return _internal_field_ids(index);
}
inline void InsertNode::set_field_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  field_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InsertNode.field_ids)
}
inline void InsertNode::_internal_add_field_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  field_ids_.Add(value);
}
inline void InsertNode::add_field_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_field_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.InsertNode.field_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
InsertNode::_internal_field_ids() const {
  return field_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
InsertNode::field_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.InsertNode.field_ids)
  return _internal_field_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
InsertNode::_internal_mutable_field_ids() {
  return &field_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
InsertNode::mutable_field_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.InsertNode.field_ids)
  return _internal_mutable_field_ids();
}

// repeated .baikaldb.pb.Expr insert_values = 10;
inline int InsertNode::_internal_insert_values_size() const {
  return insert_values_.size();
}
inline int InsertNode::insert_values_size() const {
  return _internal_insert_values_size();
}
inline ::baikaldb::pb::Expr* InsertNode::mutable_insert_values(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.InsertNode.insert_values)
  return insert_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
InsertNode::mutable_insert_values() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.InsertNode.insert_values)
  return &insert_values_;
}
inline const ::baikaldb::pb::Expr& InsertNode::_internal_insert_values(int index) const {
  return insert_values_.Get(index);
}
inline const ::baikaldb::pb::Expr& InsertNode::insert_values(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InsertNode.insert_values)
  return _internal_insert_values(index);
}
inline ::baikaldb::pb::Expr* InsertNode::_internal_add_insert_values() {
  return insert_values_.Add();
}
inline ::baikaldb::pb::Expr* InsertNode::add_insert_values() {
  ::baikaldb::pb::Expr* _add = _internal_add_insert_values();
  // @@protoc_insertion_point(field_add:baikaldb.pb.InsertNode.insert_values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
InsertNode::insert_values() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.InsertNode.insert_values)
  return insert_values_;
}

// optional int64 row_ttl_duration = 11;
inline bool InsertNode::_internal_has_row_ttl_duration() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InsertNode::has_row_ttl_duration() const {
  return _internal_has_row_ttl_duration();
}
inline void InsertNode::clear_row_ttl_duration() {
  row_ttl_duration_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InsertNode::_internal_row_ttl_duration() const {
  return row_ttl_duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InsertNode::row_ttl_duration() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InsertNode.row_ttl_duration)
  return _internal_row_ttl_duration();
}
inline void InsertNode::_internal_set_row_ttl_duration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  row_ttl_duration_ = value;
}
inline void InsertNode::set_row_ttl_duration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_row_ttl_duration(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InsertNode.row_ttl_duration)
}

// optional bool ddl_need_write = 12;
inline bool InsertNode::_internal_has_ddl_need_write() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool InsertNode::has_ddl_need_write() const {
  return _internal_has_ddl_need_write();
}
inline void InsertNode::clear_ddl_need_write() {
  ddl_need_write_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool InsertNode::_internal_ddl_need_write() const {
  return ddl_need_write_;
}
inline bool InsertNode::ddl_need_write() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InsertNode.ddl_need_write)
  return _internal_ddl_need_write();
}
inline void InsertNode::_internal_set_ddl_need_write(bool value) {
  _has_bits_[0] |= 0x00000100u;
  ddl_need_write_ = value;
}
inline void InsertNode::set_ddl_need_write(bool value) {
  _internal_set_ddl_need_write(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InsertNode.ddl_need_write)
}

// optional int64 ddl_index_id = 13;
inline bool InsertNode::_internal_has_ddl_index_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InsertNode::has_ddl_index_id() const {
  return _internal_has_ddl_index_id();
}
inline void InsertNode::clear_ddl_index_id() {
  ddl_index_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InsertNode::_internal_ddl_index_id() const {
  return ddl_index_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InsertNode::ddl_index_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InsertNode.ddl_index_id)
  return _internal_ddl_index_id();
}
inline void InsertNode::_internal_set_ddl_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  ddl_index_id_ = value;
}
inline void InsertNode::set_ddl_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_ddl_index_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InsertNode.ddl_index_id)
}

// optional bool is_merge = 14;
inline bool InsertNode::_internal_has_is_merge() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool InsertNode::has_is_merge() const {
  return _internal_has_is_merge();
}
inline void InsertNode::clear_is_merge() {
  is_merge_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool InsertNode::_internal_is_merge() const {
  return is_merge_;
}
inline bool InsertNode::is_merge() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InsertNode.is_merge)
  return _internal_is_merge();
}
inline void InsertNode::_internal_set_is_merge(bool value) {
  _has_bits_[0] |= 0x00000200u;
  is_merge_ = value;
}
inline void InsertNode::set_is_merge(bool value) {
  _internal_set_is_merge(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InsertNode.is_merge)
}

// optional uint64 watt_stats_version = 15;
inline bool InsertNode::_internal_has_watt_stats_version() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InsertNode::has_watt_stats_version() const {
  return _internal_has_watt_stats_version();
}
inline void InsertNode::clear_watt_stats_version() {
  watt_stats_version_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InsertNode::_internal_watt_stats_version() const {
  return watt_stats_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InsertNode::watt_stats_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InsertNode.watt_stats_version)
  return _internal_watt_stats_version();
}
inline void InsertNode::_internal_set_watt_stats_version(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  watt_stats_version_ = value;
}
inline void InsertNode::set_watt_stats_version(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_watt_stats_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InsertNode.watt_stats_version)
}

// -------------------------------------------------------------------

// LockPrimaryNode

// required int64 table_id = 1;
inline bool LockPrimaryNode::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LockPrimaryNode::has_table_id() const {
  return _internal_has_table_id();
}
inline void LockPrimaryNode::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LockPrimaryNode::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LockPrimaryNode::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LockPrimaryNode.table_id)
  return _internal_table_id();
}
inline void LockPrimaryNode::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  table_id_ = value;
}
inline void LockPrimaryNode::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockPrimaryNode.table_id)
}

// required .baikaldb.pb.LockCmdType lock_type = 2;
inline bool LockPrimaryNode::_internal_has_lock_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LockPrimaryNode::has_lock_type() const {
  return _internal_has_lock_type();
}
inline void LockPrimaryNode::clear_lock_type() {
  lock_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::baikaldb::pb::LockCmdType LockPrimaryNode::_internal_lock_type() const {
  return static_cast< ::baikaldb::pb::LockCmdType >(lock_type_);
}
inline ::baikaldb::pb::LockCmdType LockPrimaryNode::lock_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LockPrimaryNode.lock_type)
  return _internal_lock_type();
}
inline void LockPrimaryNode::_internal_set_lock_type(::baikaldb::pb::LockCmdType value) {
  assert(::baikaldb::pb::LockCmdType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  lock_type_ = value;
}
inline void LockPrimaryNode::set_lock_type(::baikaldb::pb::LockCmdType value) {
  _internal_set_lock_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockPrimaryNode.lock_type)
}

// repeated bytes put_records = 3;
inline int LockPrimaryNode::_internal_put_records_size() const {
  return put_records_.size();
}
inline int LockPrimaryNode::put_records_size() const {
  return _internal_put_records_size();
}
inline void LockPrimaryNode::clear_put_records() {
  put_records_.Clear();
}
inline std::string* LockPrimaryNode::add_put_records() {
  std::string* _s = _internal_add_put_records();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.LockPrimaryNode.put_records)
  return _s;
}
inline const std::string& LockPrimaryNode::_internal_put_records(int index) const {
  return put_records_.Get(index);
}
inline const std::string& LockPrimaryNode::put_records(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LockPrimaryNode.put_records)
  return _internal_put_records(index);
}
inline std::string* LockPrimaryNode::mutable_put_records(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LockPrimaryNode.put_records)
  return put_records_.Mutable(index);
}
inline void LockPrimaryNode::set_put_records(int index, const std::string& value) {
  put_records_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockPrimaryNode.put_records)
}
inline void LockPrimaryNode::set_put_records(int index, std::string&& value) {
  put_records_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockPrimaryNode.put_records)
}
inline void LockPrimaryNode::set_put_records(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  put_records_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.LockPrimaryNode.put_records)
}
inline void LockPrimaryNode::set_put_records(int index, const void* value, size_t size) {
  put_records_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.LockPrimaryNode.put_records)
}
inline std::string* LockPrimaryNode::_internal_add_put_records() {
  return put_records_.Add();
}
inline void LockPrimaryNode::add_put_records(const std::string& value) {
  put_records_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.LockPrimaryNode.put_records)
}
inline void LockPrimaryNode::add_put_records(std::string&& value) {
  put_records_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.LockPrimaryNode.put_records)
}
inline void LockPrimaryNode::add_put_records(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  put_records_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.LockPrimaryNode.put_records)
}
inline void LockPrimaryNode::add_put_records(const void* value, size_t size) {
  put_records_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.LockPrimaryNode.put_records)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LockPrimaryNode::put_records() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.LockPrimaryNode.put_records)
  return put_records_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LockPrimaryNode::mutable_put_records() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.LockPrimaryNode.put_records)
  return &put_records_;
}

// repeated bytes delete_records = 4;
inline int LockPrimaryNode::_internal_delete_records_size() const {
  return delete_records_.size();
}
inline int LockPrimaryNode::delete_records_size() const {
  return _internal_delete_records_size();
}
inline void LockPrimaryNode::clear_delete_records() {
  delete_records_.Clear();
}
inline std::string* LockPrimaryNode::add_delete_records() {
  std::string* _s = _internal_add_delete_records();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.LockPrimaryNode.delete_records)
  return _s;
}
inline const std::string& LockPrimaryNode::_internal_delete_records(int index) const {
  return delete_records_.Get(index);
}
inline const std::string& LockPrimaryNode::delete_records(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LockPrimaryNode.delete_records)
  return _internal_delete_records(index);
}
inline std::string* LockPrimaryNode::mutable_delete_records(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LockPrimaryNode.delete_records)
  return delete_records_.Mutable(index);
}
inline void LockPrimaryNode::set_delete_records(int index, const std::string& value) {
  delete_records_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockPrimaryNode.delete_records)
}
inline void LockPrimaryNode::set_delete_records(int index, std::string&& value) {
  delete_records_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockPrimaryNode.delete_records)
}
inline void LockPrimaryNode::set_delete_records(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  delete_records_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.LockPrimaryNode.delete_records)
}
inline void LockPrimaryNode::set_delete_records(int index, const void* value, size_t size) {
  delete_records_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.LockPrimaryNode.delete_records)
}
inline std::string* LockPrimaryNode::_internal_add_delete_records() {
  return delete_records_.Add();
}
inline void LockPrimaryNode::add_delete_records(const std::string& value) {
  delete_records_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.LockPrimaryNode.delete_records)
}
inline void LockPrimaryNode::add_delete_records(std::string&& value) {
  delete_records_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.LockPrimaryNode.delete_records)
}
inline void LockPrimaryNode::add_delete_records(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  delete_records_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.LockPrimaryNode.delete_records)
}
inline void LockPrimaryNode::add_delete_records(const void* value, size_t size) {
  delete_records_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.LockPrimaryNode.delete_records)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LockPrimaryNode::delete_records() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.LockPrimaryNode.delete_records)
  return delete_records_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LockPrimaryNode::mutable_delete_records() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.LockPrimaryNode.delete_records)
  return &delete_records_;
}

// optional bool affect_primary = 5 [default = true];
inline bool LockPrimaryNode::_internal_has_affect_primary() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LockPrimaryNode::has_affect_primary() const {
  return _internal_has_affect_primary();
}
inline void LockPrimaryNode::clear_affect_primary() {
  affect_primary_ = true;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool LockPrimaryNode::_internal_affect_primary() const {
  return affect_primary_;
}
inline bool LockPrimaryNode::affect_primary() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LockPrimaryNode.affect_primary)
  return _internal_affect_primary();
}
inline void LockPrimaryNode::_internal_set_affect_primary(bool value) {
  _has_bits_[0] |= 0x00000008u;
  affect_primary_ = value;
}
inline void LockPrimaryNode::set_affect_primary(bool value) {
  _internal_set_affect_primary(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockPrimaryNode.affect_primary)
}

// repeated int64 affect_index_ids = 6;
inline int LockPrimaryNode::_internal_affect_index_ids_size() const {
  return affect_index_ids_.size();
}
inline int LockPrimaryNode::affect_index_ids_size() const {
  return _internal_affect_index_ids_size();
}
inline void LockPrimaryNode::clear_affect_index_ids() {
  affect_index_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LockPrimaryNode::_internal_affect_index_ids(int index) const {
  return affect_index_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LockPrimaryNode::affect_index_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LockPrimaryNode.affect_index_ids)
  return _internal_affect_index_ids(index);
}
inline void LockPrimaryNode::set_affect_index_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  affect_index_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockPrimaryNode.affect_index_ids)
}
inline void LockPrimaryNode::_internal_add_affect_index_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  affect_index_ids_.Add(value);
}
inline void LockPrimaryNode::add_affect_index_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_affect_index_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.LockPrimaryNode.affect_index_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
LockPrimaryNode::_internal_affect_index_ids() const {
  return affect_index_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
LockPrimaryNode::affect_index_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.LockPrimaryNode.affect_index_ids)
  return _internal_affect_index_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
LockPrimaryNode::_internal_mutable_affect_index_ids() {
  return &affect_index_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
LockPrimaryNode::mutable_affect_index_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.LockPrimaryNode.affect_index_ids)
  return _internal_mutable_affect_index_ids();
}

// optional int64 row_ttl_duration_s = 7;
inline bool LockPrimaryNode::_internal_has_row_ttl_duration_s() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LockPrimaryNode::has_row_ttl_duration_s() const {
  return _internal_has_row_ttl_duration_s();
}
inline void LockPrimaryNode::clear_row_ttl_duration_s() {
  row_ttl_duration_s_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LockPrimaryNode::_internal_row_ttl_duration_s() const {
  return row_ttl_duration_s_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LockPrimaryNode::row_ttl_duration_s() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LockPrimaryNode.row_ttl_duration_s)
  return _internal_row_ttl_duration_s();
}
inline void LockPrimaryNode::_internal_set_row_ttl_duration_s(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  row_ttl_duration_s_ = value;
}
inline void LockPrimaryNode::set_row_ttl_duration_s(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_row_ttl_duration_s(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockPrimaryNode.row_ttl_duration_s)
}

// repeated .baikaldb.pb.Expr conjuncts = 8;
inline int LockPrimaryNode::_internal_conjuncts_size() const {
  return conjuncts_.size();
}
inline int LockPrimaryNode::conjuncts_size() const {
  return _internal_conjuncts_size();
}
inline ::baikaldb::pb::Expr* LockPrimaryNode::mutable_conjuncts(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LockPrimaryNode.conjuncts)
  return conjuncts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
LockPrimaryNode::mutable_conjuncts() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.LockPrimaryNode.conjuncts)
  return &conjuncts_;
}
inline const ::baikaldb::pb::Expr& LockPrimaryNode::_internal_conjuncts(int index) const {
  return conjuncts_.Get(index);
}
inline const ::baikaldb::pb::Expr& LockPrimaryNode::conjuncts(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LockPrimaryNode.conjuncts)
  return _internal_conjuncts(index);
}
inline ::baikaldb::pb::Expr* LockPrimaryNode::_internal_add_conjuncts() {
  return conjuncts_.Add();
}
inline ::baikaldb::pb::Expr* LockPrimaryNode::add_conjuncts() {
  ::baikaldb::pb::Expr* _add = _internal_add_conjuncts();
  // @@protoc_insertion_point(field_add:baikaldb.pb.LockPrimaryNode.conjuncts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
LockPrimaryNode::conjuncts() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.LockPrimaryNode.conjuncts)
  return conjuncts_;
}

// -------------------------------------------------------------------

// LockSecondaryNode

// required int64 table_id = 1;
inline bool LockSecondaryNode::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LockSecondaryNode::has_table_id() const {
  return _internal_has_table_id();
}
inline void LockSecondaryNode::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LockSecondaryNode::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LockSecondaryNode::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LockSecondaryNode.table_id)
  return _internal_table_id();
}
inline void LockSecondaryNode::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  table_id_ = value;
}
inline void LockSecondaryNode::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockSecondaryNode.table_id)
}

// required int64 global_index_id = 2;
inline bool LockSecondaryNode::_internal_has_global_index_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LockSecondaryNode::has_global_index_id() const {
  return _internal_has_global_index_id();
}
inline void LockSecondaryNode::clear_global_index_id() {
  global_index_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LockSecondaryNode::_internal_global_index_id() const {
  return global_index_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LockSecondaryNode::global_index_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LockSecondaryNode.global_index_id)
  return _internal_global_index_id();
}
inline void LockSecondaryNode::_internal_set_global_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  global_index_id_ = value;
}
inline void LockSecondaryNode::set_global_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_global_index_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockSecondaryNode.global_index_id)
}

// required .baikaldb.pb.LockCmdType lock_type = 3;
inline bool LockSecondaryNode::_internal_has_lock_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LockSecondaryNode::has_lock_type() const {
  return _internal_has_lock_type();
}
inline void LockSecondaryNode::clear_lock_type() {
  lock_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::baikaldb::pb::LockCmdType LockSecondaryNode::_internal_lock_type() const {
  return static_cast< ::baikaldb::pb::LockCmdType >(lock_type_);
}
inline ::baikaldb::pb::LockCmdType LockSecondaryNode::lock_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LockSecondaryNode.lock_type)
  return _internal_lock_type();
}
inline void LockSecondaryNode::_internal_set_lock_type(::baikaldb::pb::LockCmdType value) {
  assert(::baikaldb::pb::LockCmdType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  lock_type_ = value;
}
inline void LockSecondaryNode::set_lock_type(::baikaldb::pb::LockCmdType value) {
  _internal_set_lock_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockSecondaryNode.lock_type)
}

// repeated bytes put_records = 4;
inline int LockSecondaryNode::_internal_put_records_size() const {
  return put_records_.size();
}
inline int LockSecondaryNode::put_records_size() const {
  return _internal_put_records_size();
}
inline void LockSecondaryNode::clear_put_records() {
  put_records_.Clear();
}
inline std::string* LockSecondaryNode::add_put_records() {
  std::string* _s = _internal_add_put_records();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.LockSecondaryNode.put_records)
  return _s;
}
inline const std::string& LockSecondaryNode::_internal_put_records(int index) const {
  return put_records_.Get(index);
}
inline const std::string& LockSecondaryNode::put_records(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LockSecondaryNode.put_records)
  return _internal_put_records(index);
}
inline std::string* LockSecondaryNode::mutable_put_records(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LockSecondaryNode.put_records)
  return put_records_.Mutable(index);
}
inline void LockSecondaryNode::set_put_records(int index, const std::string& value) {
  put_records_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockSecondaryNode.put_records)
}
inline void LockSecondaryNode::set_put_records(int index, std::string&& value) {
  put_records_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockSecondaryNode.put_records)
}
inline void LockSecondaryNode::set_put_records(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  put_records_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.LockSecondaryNode.put_records)
}
inline void LockSecondaryNode::set_put_records(int index, const void* value, size_t size) {
  put_records_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.LockSecondaryNode.put_records)
}
inline std::string* LockSecondaryNode::_internal_add_put_records() {
  return put_records_.Add();
}
inline void LockSecondaryNode::add_put_records(const std::string& value) {
  put_records_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.LockSecondaryNode.put_records)
}
inline void LockSecondaryNode::add_put_records(std::string&& value) {
  put_records_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.LockSecondaryNode.put_records)
}
inline void LockSecondaryNode::add_put_records(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  put_records_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.LockSecondaryNode.put_records)
}
inline void LockSecondaryNode::add_put_records(const void* value, size_t size) {
  put_records_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.LockSecondaryNode.put_records)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LockSecondaryNode::put_records() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.LockSecondaryNode.put_records)
  return put_records_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LockSecondaryNode::mutable_put_records() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.LockSecondaryNode.put_records)
  return &put_records_;
}

// repeated bytes delete_records = 5;
inline int LockSecondaryNode::_internal_delete_records_size() const {
  return delete_records_.size();
}
inline int LockSecondaryNode::delete_records_size() const {
  return _internal_delete_records_size();
}
inline void LockSecondaryNode::clear_delete_records() {
  delete_records_.Clear();
}
inline std::string* LockSecondaryNode::add_delete_records() {
  std::string* _s = _internal_add_delete_records();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.LockSecondaryNode.delete_records)
  return _s;
}
inline const std::string& LockSecondaryNode::_internal_delete_records(int index) const {
  return delete_records_.Get(index);
}
inline const std::string& LockSecondaryNode::delete_records(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LockSecondaryNode.delete_records)
  return _internal_delete_records(index);
}
inline std::string* LockSecondaryNode::mutable_delete_records(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LockSecondaryNode.delete_records)
  return delete_records_.Mutable(index);
}
inline void LockSecondaryNode::set_delete_records(int index, const std::string& value) {
  delete_records_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockSecondaryNode.delete_records)
}
inline void LockSecondaryNode::set_delete_records(int index, std::string&& value) {
  delete_records_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockSecondaryNode.delete_records)
}
inline void LockSecondaryNode::set_delete_records(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  delete_records_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.LockSecondaryNode.delete_records)
}
inline void LockSecondaryNode::set_delete_records(int index, const void* value, size_t size) {
  delete_records_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.LockSecondaryNode.delete_records)
}
inline std::string* LockSecondaryNode::_internal_add_delete_records() {
  return delete_records_.Add();
}
inline void LockSecondaryNode::add_delete_records(const std::string& value) {
  delete_records_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.LockSecondaryNode.delete_records)
}
inline void LockSecondaryNode::add_delete_records(std::string&& value) {
  delete_records_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.LockSecondaryNode.delete_records)
}
inline void LockSecondaryNode::add_delete_records(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  delete_records_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.LockSecondaryNode.delete_records)
}
inline void LockSecondaryNode::add_delete_records(const void* value, size_t size) {
  delete_records_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.LockSecondaryNode.delete_records)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LockSecondaryNode::delete_records() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.LockSecondaryNode.delete_records)
  return delete_records_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LockSecondaryNode::mutable_delete_records() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.LockSecondaryNode.delete_records)
  return &delete_records_;
}

// optional .baikaldb.pb.LockSecondaryType lock_secondary_type = 6;
inline bool LockSecondaryNode::_internal_has_lock_secondary_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LockSecondaryNode::has_lock_secondary_type() const {
  return _internal_has_lock_secondary_type();
}
inline void LockSecondaryNode::clear_lock_secondary_type() {
  lock_secondary_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::baikaldb::pb::LockSecondaryType LockSecondaryNode::_internal_lock_secondary_type() const {
  return static_cast< ::baikaldb::pb::LockSecondaryType >(lock_secondary_type_);
}
inline ::baikaldb::pb::LockSecondaryType LockSecondaryNode::lock_secondary_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LockSecondaryNode.lock_secondary_type)
  return _internal_lock_secondary_type();
}
inline void LockSecondaryNode::_internal_set_lock_secondary_type(::baikaldb::pb::LockSecondaryType value) {
  assert(::baikaldb::pb::LockSecondaryType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  lock_secondary_type_ = value;
}
inline void LockSecondaryNode::set_lock_secondary_type(::baikaldb::pb::LockSecondaryType value) {
  _internal_set_lock_secondary_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockSecondaryNode.lock_secondary_type)
}

// optional int64 row_ttl_duration_s = 7;
inline bool LockSecondaryNode::_internal_has_row_ttl_duration_s() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LockSecondaryNode::has_row_ttl_duration_s() const {
  return _internal_has_row_ttl_duration_s();
}
inline void LockSecondaryNode::clear_row_ttl_duration_s() {
  row_ttl_duration_s_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LockSecondaryNode::_internal_row_ttl_duration_s() const {
  return row_ttl_duration_s_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LockSecondaryNode::row_ttl_duration_s() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LockSecondaryNode.row_ttl_duration_s)
  return _internal_row_ttl_duration_s();
}
inline void LockSecondaryNode::_internal_set_row_ttl_duration_s(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  row_ttl_duration_s_ = value;
}
inline void LockSecondaryNode::set_row_ttl_duration_s(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_row_ttl_duration_s(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockSecondaryNode.row_ttl_duration_s)
}

// repeated int64 global_ddl_ttl_timestamp_us = 8;
inline int LockSecondaryNode::_internal_global_ddl_ttl_timestamp_us_size() const {
  return global_ddl_ttl_timestamp_us_.size();
}
inline int LockSecondaryNode::global_ddl_ttl_timestamp_us_size() const {
  return _internal_global_ddl_ttl_timestamp_us_size();
}
inline void LockSecondaryNode::clear_global_ddl_ttl_timestamp_us() {
  global_ddl_ttl_timestamp_us_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LockSecondaryNode::_internal_global_ddl_ttl_timestamp_us(int index) const {
  return global_ddl_ttl_timestamp_us_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LockSecondaryNode::global_ddl_ttl_timestamp_us(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LockSecondaryNode.global_ddl_ttl_timestamp_us)
  return _internal_global_ddl_ttl_timestamp_us(index);
}
inline void LockSecondaryNode::set_global_ddl_ttl_timestamp_us(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  global_ddl_ttl_timestamp_us_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LockSecondaryNode.global_ddl_ttl_timestamp_us)
}
inline void LockSecondaryNode::_internal_add_global_ddl_ttl_timestamp_us(::PROTOBUF_NAMESPACE_ID::int64 value) {
  global_ddl_ttl_timestamp_us_.Add(value);
}
inline void LockSecondaryNode::add_global_ddl_ttl_timestamp_us(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_global_ddl_ttl_timestamp_us(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.LockSecondaryNode.global_ddl_ttl_timestamp_us)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
LockSecondaryNode::_internal_global_ddl_ttl_timestamp_us() const {
  return global_ddl_ttl_timestamp_us_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
LockSecondaryNode::global_ddl_ttl_timestamp_us() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.LockSecondaryNode.global_ddl_ttl_timestamp_us)
  return _internal_global_ddl_ttl_timestamp_us();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
LockSecondaryNode::_internal_mutable_global_ddl_ttl_timestamp_us() {
  return &global_ddl_ttl_timestamp_us_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
LockSecondaryNode::mutable_global_ddl_ttl_timestamp_us() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.LockSecondaryNode.global_ddl_ttl_timestamp_us)
  return _internal_mutable_global_ddl_ttl_timestamp_us();
}

// -------------------------------------------------------------------

// DeleteNode

// required int64 table_id = 1;
inline bool DeleteNode::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeleteNode::has_table_id() const {
  return _internal_has_table_id();
}
inline void DeleteNode::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DeleteNode::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DeleteNode::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DeleteNode.table_id)
  return _internal_table_id();
}
inline void DeleteNode::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  table_id_ = value;
}
inline void DeleteNode::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DeleteNode.table_id)
}

// repeated .baikaldb.pb.SlotDescriptor primary_slots = 2;
inline int DeleteNode::_internal_primary_slots_size() const {
  return primary_slots_.size();
}
inline int DeleteNode::primary_slots_size() const {
  return _internal_primary_slots_size();
}
inline ::baikaldb::pb::SlotDescriptor* DeleteNode::mutable_primary_slots(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DeleteNode.primary_slots)
  return primary_slots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >*
DeleteNode::mutable_primary_slots() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.DeleteNode.primary_slots)
  return &primary_slots_;
}
inline const ::baikaldb::pb::SlotDescriptor& DeleteNode::_internal_primary_slots(int index) const {
  return primary_slots_.Get(index);
}
inline const ::baikaldb::pb::SlotDescriptor& DeleteNode::primary_slots(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DeleteNode.primary_slots)
  return _internal_primary_slots(index);
}
inline ::baikaldb::pb::SlotDescriptor* DeleteNode::_internal_add_primary_slots() {
  return primary_slots_.Add();
}
inline ::baikaldb::pb::SlotDescriptor* DeleteNode::add_primary_slots() {
  ::baikaldb::pb::SlotDescriptor* _add = _internal_add_primary_slots();
  // @@protoc_insertion_point(field_add:baikaldb.pb.DeleteNode.primary_slots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >&
DeleteNode::primary_slots() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.DeleteNode.primary_slots)
  return primary_slots_;
}

// -------------------------------------------------------------------

// TruncateNode

// required int64 table_id = 1;
inline bool TruncateNode::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TruncateNode::has_table_id() const {
  return _internal_has_table_id();
}
inline void TruncateNode::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TruncateNode::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TruncateNode::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TruncateNode.table_id)
  return _internal_table_id();
}
inline void TruncateNode::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  table_id_ = value;
}
inline void TruncateNode::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TruncateNode.table_id)
}

// -------------------------------------------------------------------

// UpdateNode

// required int64 table_id = 1;
inline bool UpdateNode::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateNode::has_table_id() const {
  return _internal_has_table_id();
}
inline void UpdateNode::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UpdateNode::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UpdateNode::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UpdateNode.table_id)
  return _internal_table_id();
}
inline void UpdateNode::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  table_id_ = value;
}
inline void UpdateNode::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UpdateNode.table_id)
}

// repeated .baikaldb.pb.SlotDescriptor primary_slots = 2;
inline int UpdateNode::_internal_primary_slots_size() const {
  return primary_slots_.size();
}
inline int UpdateNode::primary_slots_size() const {
  return _internal_primary_slots_size();
}
inline ::baikaldb::pb::SlotDescriptor* UpdateNode::mutable_primary_slots(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.UpdateNode.primary_slots)
  return primary_slots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >*
UpdateNode::mutable_primary_slots() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.UpdateNode.primary_slots)
  return &primary_slots_;
}
inline const ::baikaldb::pb::SlotDescriptor& UpdateNode::_internal_primary_slots(int index) const {
  return primary_slots_.Get(index);
}
inline const ::baikaldb::pb::SlotDescriptor& UpdateNode::primary_slots(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UpdateNode.primary_slots)
  return _internal_primary_slots(index);
}
inline ::baikaldb::pb::SlotDescriptor* UpdateNode::_internal_add_primary_slots() {
  return primary_slots_.Add();
}
inline ::baikaldb::pb::SlotDescriptor* UpdateNode::add_primary_slots() {
  ::baikaldb::pb::SlotDescriptor* _add = _internal_add_primary_slots();
  // @@protoc_insertion_point(field_add:baikaldb.pb.UpdateNode.primary_slots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >&
UpdateNode::primary_slots() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.UpdateNode.primary_slots)
  return primary_slots_;
}

// repeated .baikaldb.pb.SlotDescriptor update_slots = 3;
inline int UpdateNode::_internal_update_slots_size() const {
  return update_slots_.size();
}
inline int UpdateNode::update_slots_size() const {
  return _internal_update_slots_size();
}
inline ::baikaldb::pb::SlotDescriptor* UpdateNode::mutable_update_slots(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.UpdateNode.update_slots)
  return update_slots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >*
UpdateNode::mutable_update_slots() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.UpdateNode.update_slots)
  return &update_slots_;
}
inline const ::baikaldb::pb::SlotDescriptor& UpdateNode::_internal_update_slots(int index) const {
  return update_slots_.Get(index);
}
inline const ::baikaldb::pb::SlotDescriptor& UpdateNode::update_slots(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UpdateNode.update_slots)
  return _internal_update_slots(index);
}
inline ::baikaldb::pb::SlotDescriptor* UpdateNode::_internal_add_update_slots() {
  return update_slots_.Add();
}
inline ::baikaldb::pb::SlotDescriptor* UpdateNode::add_update_slots() {
  ::baikaldb::pb::SlotDescriptor* _add = _internal_add_update_slots();
  // @@protoc_insertion_point(field_add:baikaldb.pb.UpdateNode.update_slots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >&
UpdateNode::update_slots() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.UpdateNode.update_slots)
  return update_slots_;
}

// repeated .baikaldb.pb.Expr update_exprs = 4;
inline int UpdateNode::_internal_update_exprs_size() const {
  return update_exprs_.size();
}
inline int UpdateNode::update_exprs_size() const {
  return _internal_update_exprs_size();
}
inline ::baikaldb::pb::Expr* UpdateNode::mutable_update_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.UpdateNode.update_exprs)
  return update_exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
UpdateNode::mutable_update_exprs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.UpdateNode.update_exprs)
  return &update_exprs_;
}
inline const ::baikaldb::pb::Expr& UpdateNode::_internal_update_exprs(int index) const {
  return update_exprs_.Get(index);
}
inline const ::baikaldb::pb::Expr& UpdateNode::update_exprs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UpdateNode.update_exprs)
  return _internal_update_exprs(index);
}
inline ::baikaldb::pb::Expr* UpdateNode::_internal_add_update_exprs() {
  return update_exprs_.Add();
}
inline ::baikaldb::pb::Expr* UpdateNode::add_update_exprs() {
  ::baikaldb::pb::Expr* _add = _internal_add_update_exprs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.UpdateNode.update_exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
UpdateNode::update_exprs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.UpdateNode.update_exprs)
  return update_exprs_;
}

// optional int64 row_ttl_duration = 6;
inline bool UpdateNode::_internal_has_row_ttl_duration() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateNode::has_row_ttl_duration() const {
  return _internal_has_row_ttl_duration();
}
inline void UpdateNode::clear_row_ttl_duration() {
  row_ttl_duration_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UpdateNode::_internal_row_ttl_duration() const {
  return row_ttl_duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UpdateNode::row_ttl_duration() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UpdateNode.row_ttl_duration)
  return _internal_row_ttl_duration();
}
inline void UpdateNode::_internal_set_row_ttl_duration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  row_ttl_duration_ = value;
}
inline void UpdateNode::set_row_ttl_duration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_row_ttl_duration(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UpdateNode.row_ttl_duration)
}

// -------------------------------------------------------------------

// PacketNode

// required .baikaldb.pb.OpType op_type = 1;
inline bool PacketNode::_internal_has_op_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PacketNode::has_op_type() const {
  return _internal_has_op_type();
}
inline void PacketNode::clear_op_type() {
  op_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::baikaldb::pb::OpType PacketNode::_internal_op_type() const {
  return static_cast< ::baikaldb::pb::OpType >(op_type_);
}
inline ::baikaldb::pb::OpType PacketNode::op_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PacketNode.op_type)
  return _internal_op_type();
}
inline void PacketNode::_internal_set_op_type(::baikaldb::pb::OpType value) {
  assert(::baikaldb::pb::OpType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  op_type_ = value;
}
inline void PacketNode::set_op_type(::baikaldb::pb::OpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PacketNode.op_type)
}

// repeated .baikaldb.pb.Expr projections = 2;
inline int PacketNode::_internal_projections_size() const {
  return projections_.size();
}
inline int PacketNode::projections_size() const {
  return _internal_projections_size();
}
inline ::baikaldb::pb::Expr* PacketNode::mutable_projections(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PacketNode.projections)
  return projections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
PacketNode::mutable_projections() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PacketNode.projections)
  return &projections_;
}
inline const ::baikaldb::pb::Expr& PacketNode::_internal_projections(int index) const {
  return projections_.Get(index);
}
inline const ::baikaldb::pb::Expr& PacketNode::projections(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PacketNode.projections)
  return _internal_projections(index);
}
inline ::baikaldb::pb::Expr* PacketNode::_internal_add_projections() {
  return projections_.Add();
}
inline ::baikaldb::pb::Expr* PacketNode::add_projections() {
  ::baikaldb::pb::Expr* _add = _internal_add_projections();
  // @@protoc_insertion_point(field_add:baikaldb.pb.PacketNode.projections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
PacketNode::projections() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PacketNode.projections)
  return projections_;
}

// repeated string col_names = 3;
inline int PacketNode::_internal_col_names_size() const {
  return col_names_.size();
}
inline int PacketNode::col_names_size() const {
  return _internal_col_names_size();
}
inline void PacketNode::clear_col_names() {
  col_names_.Clear();
}
inline std::string* PacketNode::add_col_names() {
  std::string* _s = _internal_add_col_names();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.PacketNode.col_names)
  return _s;
}
inline const std::string& PacketNode::_internal_col_names(int index) const {
  return col_names_.Get(index);
}
inline const std::string& PacketNode::col_names(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PacketNode.col_names)
  return _internal_col_names(index);
}
inline std::string* PacketNode::mutable_col_names(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PacketNode.col_names)
  return col_names_.Mutable(index);
}
inline void PacketNode::set_col_names(int index, const std::string& value) {
  col_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PacketNode.col_names)
}
inline void PacketNode::set_col_names(int index, std::string&& value) {
  col_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.PacketNode.col_names)
}
inline void PacketNode::set_col_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  col_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.PacketNode.col_names)
}
inline void PacketNode::set_col_names(int index, const char* value, size_t size) {
  col_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.PacketNode.col_names)
}
inline std::string* PacketNode::_internal_add_col_names() {
  return col_names_.Add();
}
inline void PacketNode::add_col_names(const std::string& value) {
  col_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.PacketNode.col_names)
}
inline void PacketNode::add_col_names(std::string&& value) {
  col_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.PacketNode.col_names)
}
inline void PacketNode::add_col_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  col_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.PacketNode.col_names)
}
inline void PacketNode::add_col_names(const char* value, size_t size) {
  col_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.PacketNode.col_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PacketNode::col_names() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PacketNode.col_names)
  return col_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PacketNode::mutable_col_names() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PacketNode.col_names)
  return &col_names_;
}

// -------------------------------------------------------------------

// TransactionNode

// required .baikaldb.pb.TxnCmdType txn_cmd = 1;
inline bool TransactionNode::_internal_has_txn_cmd() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TransactionNode::has_txn_cmd() const {
  return _internal_has_txn_cmd();
}
inline void TransactionNode::clear_txn_cmd() {
  txn_cmd_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::baikaldb::pb::TxnCmdType TransactionNode::_internal_txn_cmd() const {
  return static_cast< ::baikaldb::pb::TxnCmdType >(txn_cmd_);
}
inline ::baikaldb::pb::TxnCmdType TransactionNode::txn_cmd() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionNode.txn_cmd)
  return _internal_txn_cmd();
}
inline void TransactionNode::_internal_set_txn_cmd(::baikaldb::pb::TxnCmdType value) {
  assert(::baikaldb::pb::TxnCmdType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  txn_cmd_ = value;
}
inline void TransactionNode::set_txn_cmd(::baikaldb::pb::TxnCmdType value) {
  _internal_set_txn_cmd(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionNode.txn_cmd)
}

// optional int64 txn_timeout = 2;
inline bool TransactionNode::_internal_has_txn_timeout() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TransactionNode::has_txn_timeout() const {
  return _internal_has_txn_timeout();
}
inline void TransactionNode::clear_txn_timeout() {
  txn_timeout_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionNode::_internal_txn_timeout() const {
  return txn_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionNode::txn_timeout() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionNode.txn_timeout)
  return _internal_txn_timeout();
}
inline void TransactionNode::_internal_set_txn_timeout(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  txn_timeout_ = value;
}
inline void TransactionNode::set_txn_timeout(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_txn_timeout(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionNode.txn_timeout)
}

// optional int64 txn_lock_timeout = 3;
inline bool TransactionNode::_internal_has_txn_lock_timeout() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TransactionNode::has_txn_lock_timeout() const {
  return _internal_has_txn_lock_timeout();
}
inline void TransactionNode::clear_txn_lock_timeout() {
  txn_lock_timeout_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionNode::_internal_txn_lock_timeout() const {
  return txn_lock_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransactionNode::txn_lock_timeout() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransactionNode.txn_lock_timeout)
  return _internal_txn_lock_timeout();
}
inline void TransactionNode::_internal_set_txn_lock_timeout(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  txn_lock_timeout_ = value;
}
inline void TransactionNode::set_txn_lock_timeout(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_txn_lock_timeout(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransactionNode.txn_lock_timeout)
}

// -------------------------------------------------------------------

// KillNode

// required uint64 db_conn_id = 1;
inline bool KillNode::_internal_has_db_conn_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KillNode::has_db_conn_id() const {
  return _internal_has_db_conn_id();
}
inline void KillNode::clear_db_conn_id() {
  db_conn_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KillNode::_internal_db_conn_id() const {
  return db_conn_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 KillNode::db_conn_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.KillNode.db_conn_id)
  return _internal_db_conn_id();
}
inline void KillNode::_internal_set_db_conn_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  db_conn_id_ = value;
}
inline void KillNode::set_db_conn_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_db_conn_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.KillNode.db_conn_id)
}

// optional bool is_query = 2;
inline bool KillNode::_internal_has_is_query() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KillNode::has_is_query() const {
  return _internal_has_is_query();
}
inline void KillNode::clear_is_query() {
  is_query_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool KillNode::_internal_is_query() const {
  return is_query_;
}
inline bool KillNode::is_query() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.KillNode.is_query)
  return _internal_is_query();
}
inline void KillNode::_internal_set_is_query(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_query_ = value;
}
inline void KillNode::set_is_query(bool value) {
  _internal_set_is_query(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.KillNode.is_query)
}

// -------------------------------------------------------------------

// UnionNode

// optional int32 union_tuple_id = 1;
inline bool UnionNode::_internal_has_union_tuple_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnionNode::has_union_tuple_id() const {
  return _internal_has_union_tuple_id();
}
inline void UnionNode::clear_union_tuple_id() {
  union_tuple_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UnionNode::_internal_union_tuple_id() const {
  return union_tuple_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UnionNode::union_tuple_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UnionNode.union_tuple_id)
  return _internal_union_tuple_id();
}
inline void UnionNode::_internal_set_union_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  union_tuple_id_ = value;
}
inline void UnionNode::set_union_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_union_tuple_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UnionNode.union_tuple_id)
}

// repeated .baikaldb.pb.Expr slot_order_exprs = 2;
inline int UnionNode::_internal_slot_order_exprs_size() const {
  return slot_order_exprs_.size();
}
inline int UnionNode::slot_order_exprs_size() const {
  return _internal_slot_order_exprs_size();
}
inline ::baikaldb::pb::Expr* UnionNode::mutable_slot_order_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.UnionNode.slot_order_exprs)
  return slot_order_exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
UnionNode::mutable_slot_order_exprs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.UnionNode.slot_order_exprs)
  return &slot_order_exprs_;
}
inline const ::baikaldb::pb::Expr& UnionNode::_internal_slot_order_exprs(int index) const {
  return slot_order_exprs_.Get(index);
}
inline const ::baikaldb::pb::Expr& UnionNode::slot_order_exprs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UnionNode.slot_order_exprs)
  return _internal_slot_order_exprs(index);
}
inline ::baikaldb::pb::Expr* UnionNode::_internal_add_slot_order_exprs() {
  return slot_order_exprs_.Add();
}
inline ::baikaldb::pb::Expr* UnionNode::add_slot_order_exprs() {
  ::baikaldb::pb::Expr* _add = _internal_add_slot_order_exprs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.UnionNode.slot_order_exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
UnionNode::slot_order_exprs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.UnionNode.slot_order_exprs)
  return slot_order_exprs_;
}

// repeated bool is_asc = 3;
inline int UnionNode::_internal_is_asc_size() const {
  return is_asc_.size();
}
inline int UnionNode::is_asc_size() const {
  return _internal_is_asc_size();
}
inline void UnionNode::clear_is_asc() {
  is_asc_.Clear();
}
inline bool UnionNode::_internal_is_asc(int index) const {
  return is_asc_.Get(index);
}
inline bool UnionNode::is_asc(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UnionNode.is_asc)
  return _internal_is_asc(index);
}
inline void UnionNode::set_is_asc(int index, bool value) {
  is_asc_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UnionNode.is_asc)
}
inline void UnionNode::_internal_add_is_asc(bool value) {
  is_asc_.Add(value);
}
inline void UnionNode::add_is_asc(bool value) {
  _internal_add_is_asc(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.UnionNode.is_asc)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
UnionNode::_internal_is_asc() const {
  return is_asc_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
UnionNode::is_asc() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.UnionNode.is_asc)
  return _internal_is_asc();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
UnionNode::_internal_mutable_is_asc() {
  return &is_asc_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
UnionNode::mutable_is_asc() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.UnionNode.is_asc)
  return _internal_mutable_is_asc();
}

// repeated bool is_null_first = 4;
inline int UnionNode::_internal_is_null_first_size() const {
  return is_null_first_.size();
}
inline int UnionNode::is_null_first_size() const {
  return _internal_is_null_first_size();
}
inline void UnionNode::clear_is_null_first() {
  is_null_first_.Clear();
}
inline bool UnionNode::_internal_is_null_first(int index) const {
  return is_null_first_.Get(index);
}
inline bool UnionNode::is_null_first(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UnionNode.is_null_first)
  return _internal_is_null_first(index);
}
inline void UnionNode::set_is_null_first(int index, bool value) {
  is_null_first_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UnionNode.is_null_first)
}
inline void UnionNode::_internal_add_is_null_first(bool value) {
  is_null_first_.Add(value);
}
inline void UnionNode::add_is_null_first(bool value) {
  _internal_add_is_null_first(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.UnionNode.is_null_first)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
UnionNode::_internal_is_null_first() const {
  return is_null_first_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
UnionNode::is_null_first() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.UnionNode.is_null_first)
  return _internal_is_null_first();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
UnionNode::_internal_mutable_is_null_first() {
  return &is_null_first_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
UnionNode::mutable_is_null_first() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.UnionNode.is_null_first)
  return _internal_mutable_is_null_first();
}

// -------------------------------------------------------------------

// LoadNode

// required int64 table_id = 1;
inline bool LoadNode::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LoadNode::has_table_id() const {
  return _internal_has_table_id();
}
inline void LoadNode::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoadNode::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoadNode::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LoadNode.table_id)
  return _internal_table_id();
}
inline void LoadNode::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  table_id_ = value;
}
inline void LoadNode::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LoadNode.table_id)
}

// optional string data_path = 3;
inline bool LoadNode::_internal_has_data_path() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoadNode::has_data_path() const {
  return _internal_has_data_path();
}
inline void LoadNode::clear_data_path() {
  data_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoadNode::data_path() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LoadNode.data_path)
  return _internal_data_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadNode::set_data_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 data_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.LoadNode.data_path)
}
inline std::string* LoadNode::mutable_data_path() {
  std::string* _s = _internal_mutable_data_path();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LoadNode.data_path)
  return _s;
}
inline const std::string& LoadNode::_internal_data_path() const {
  return data_path_.Get();
}
inline void LoadNode::_internal_set_data_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoadNode::_internal_mutable_data_path() {
  _has_bits_[0] |= 0x00000001u;
  return data_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoadNode::release_data_path() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.LoadNode.data_path)
  if (!_internal_has_data_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoadNode::set_allocated_data_path(std::string* data_path) {
  if (data_path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.LoadNode.data_path)
}

// repeated .baikaldb.pb.SlotDescriptor set_slots = 4;
inline int LoadNode::_internal_set_slots_size() const {
  return set_slots_.size();
}
inline int LoadNode::set_slots_size() const {
  return _internal_set_slots_size();
}
inline ::baikaldb::pb::SlotDescriptor* LoadNode::mutable_set_slots(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LoadNode.set_slots)
  return set_slots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >*
LoadNode::mutable_set_slots() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.LoadNode.set_slots)
  return &set_slots_;
}
inline const ::baikaldb::pb::SlotDescriptor& LoadNode::_internal_set_slots(int index) const {
  return set_slots_.Get(index);
}
inline const ::baikaldb::pb::SlotDescriptor& LoadNode::set_slots(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LoadNode.set_slots)
  return _internal_set_slots(index);
}
inline ::baikaldb::pb::SlotDescriptor* LoadNode::_internal_add_set_slots() {
  return set_slots_.Add();
}
inline ::baikaldb::pb::SlotDescriptor* LoadNode::add_set_slots() {
  ::baikaldb::pb::SlotDescriptor* _add = _internal_add_set_slots();
  // @@protoc_insertion_point(field_add:baikaldb.pb.LoadNode.set_slots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >&
LoadNode::set_slots() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.LoadNode.set_slots)
  return set_slots_;
}

// repeated .baikaldb.pb.Expr set_exprs = 5;
inline int LoadNode::_internal_set_exprs_size() const {
  return set_exprs_.size();
}
inline int LoadNode::set_exprs_size() const {
  return _internal_set_exprs_size();
}
inline ::baikaldb::pb::Expr* LoadNode::mutable_set_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LoadNode.set_exprs)
  return set_exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
LoadNode::mutable_set_exprs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.LoadNode.set_exprs)
  return &set_exprs_;
}
inline const ::baikaldb::pb::Expr& LoadNode::_internal_set_exprs(int index) const {
  return set_exprs_.Get(index);
}
inline const ::baikaldb::pb::Expr& LoadNode::set_exprs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LoadNode.set_exprs)
  return _internal_set_exprs(index);
}
inline ::baikaldb::pb::Expr* LoadNode::_internal_add_set_exprs() {
  return set_exprs_.Add();
}
inline ::baikaldb::pb::Expr* LoadNode::add_set_exprs() {
  ::baikaldb::pb::Expr* _add = _internal_add_set_exprs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.LoadNode.set_exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
LoadNode::set_exprs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.LoadNode.set_exprs)
  return set_exprs_;
}

// repeated int32 field_ids = 6;
inline int LoadNode::_internal_field_ids_size() const {
  return field_ids_.size();
}
inline int LoadNode::field_ids_size() const {
  return _internal_field_ids_size();
}
inline void LoadNode::clear_field_ids() {
  field_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoadNode::_internal_field_ids(int index) const {
  return field_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoadNode::field_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LoadNode.field_ids)
  return _internal_field_ids(index);
}
inline void LoadNode::set_field_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  field_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LoadNode.field_ids)
}
inline void LoadNode::_internal_add_field_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  field_ids_.Add(value);
}
inline void LoadNode::add_field_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_field_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.LoadNode.field_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LoadNode::_internal_field_ids() const {
  return field_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LoadNode::field_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.LoadNode.field_ids)
  return _internal_field_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LoadNode::_internal_mutable_field_ids() {
  return &field_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LoadNode::mutable_field_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.LoadNode.field_ids)
  return _internal_mutable_field_ids();
}

// repeated int32 default_field_ids = 7;
inline int LoadNode::_internal_default_field_ids_size() const {
  return default_field_ids_.size();
}
inline int LoadNode::default_field_ids_size() const {
  return _internal_default_field_ids_size();
}
inline void LoadNode::clear_default_field_ids() {
  default_field_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoadNode::_internal_default_field_ids(int index) const {
  return default_field_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoadNode::default_field_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LoadNode.default_field_ids)
  return _internal_default_field_ids(index);
}
inline void LoadNode::set_default_field_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  default_field_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LoadNode.default_field_ids)
}
inline void LoadNode::_internal_add_default_field_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  default_field_ids_.Add(value);
}
inline void LoadNode::add_default_field_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_default_field_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.LoadNode.default_field_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LoadNode::_internal_default_field_ids() const {
  return default_field_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LoadNode::default_field_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.LoadNode.default_field_ids)
  return _internal_default_field_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LoadNode::_internal_mutable_default_field_ids() {
  return &default_field_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LoadNode::mutable_default_field_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.LoadNode.default_field_ids)
  return _internal_mutable_default_field_ids();
}

// repeated int32 ingore_field_indexes = 8;
inline int LoadNode::_internal_ingore_field_indexes_size() const {
  return ingore_field_indexes_.size();
}
inline int LoadNode::ingore_field_indexes_size() const {
  return _internal_ingore_field_indexes_size();
}
inline void LoadNode::clear_ingore_field_indexes() {
  ingore_field_indexes_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoadNode::_internal_ingore_field_indexes(int index) const {
  return ingore_field_indexes_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoadNode::ingore_field_indexes(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LoadNode.ingore_field_indexes)
  return _internal_ingore_field_indexes(index);
}
inline void LoadNode::set_ingore_field_indexes(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  ingore_field_indexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LoadNode.ingore_field_indexes)
}
inline void LoadNode::_internal_add_ingore_field_indexes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  ingore_field_indexes_.Add(value);
}
inline void LoadNode::add_ingore_field_indexes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_ingore_field_indexes(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.LoadNode.ingore_field_indexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LoadNode::_internal_ingore_field_indexes() const {
  return ingore_field_indexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
LoadNode::ingore_field_indexes() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.LoadNode.ingore_field_indexes)
  return _internal_ingore_field_indexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LoadNode::_internal_mutable_ingore_field_indexes() {
  return &ingore_field_indexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
LoadNode::mutable_ingore_field_indexes() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.LoadNode.ingore_field_indexes)
  return _internal_mutable_ingore_field_indexes();
}

// optional int32 ignore_lines = 9;
inline bool LoadNode::_internal_has_ignore_lines() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LoadNode::has_ignore_lines() const {
  return _internal_has_ignore_lines();
}
inline void LoadNode::clear_ignore_lines() {
  ignore_lines_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoadNode::_internal_ignore_lines() const {
  return ignore_lines_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoadNode::ignore_lines() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LoadNode.ignore_lines)
  return _internal_ignore_lines();
}
inline void LoadNode::_internal_set_ignore_lines(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  ignore_lines_ = value;
}
inline void LoadNode::set_ignore_lines(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ignore_lines(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LoadNode.ignore_lines)
}

// optional bytes terminated = 10;
inline bool LoadNode::_internal_has_terminated() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LoadNode::has_terminated() const {
  return _internal_has_terminated();
}
inline void LoadNode::clear_terminated() {
  terminated_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LoadNode::terminated() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LoadNode.terminated)
  return _internal_terminated();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadNode::set_terminated(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 terminated_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.LoadNode.terminated)
}
inline std::string* LoadNode::mutable_terminated() {
  std::string* _s = _internal_mutable_terminated();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LoadNode.terminated)
  return _s;
}
inline const std::string& LoadNode::_internal_terminated() const {
  return terminated_.Get();
}
inline void LoadNode::_internal_set_terminated(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  terminated_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoadNode::_internal_mutable_terminated() {
  _has_bits_[0] |= 0x00000002u;
  return terminated_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoadNode::release_terminated() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.LoadNode.terminated)
  if (!_internal_has_terminated()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return terminated_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoadNode::set_allocated_terminated(std::string* terminated) {
  if (terminated != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  terminated_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), terminated,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.LoadNode.terminated)
}

// optional bytes enclosed = 11;
inline bool LoadNode::_internal_has_enclosed() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LoadNode::has_enclosed() const {
  return _internal_has_enclosed();
}
inline void LoadNode::clear_enclosed() {
  enclosed_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LoadNode::enclosed() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LoadNode.enclosed)
  return _internal_enclosed();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadNode::set_enclosed(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 enclosed_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.LoadNode.enclosed)
}
inline std::string* LoadNode::mutable_enclosed() {
  std::string* _s = _internal_mutable_enclosed();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LoadNode.enclosed)
  return _s;
}
inline const std::string& LoadNode::_internal_enclosed() const {
  return enclosed_.Get();
}
inline void LoadNode::_internal_set_enclosed(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  enclosed_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoadNode::_internal_mutable_enclosed() {
  _has_bits_[0] |= 0x00000004u;
  return enclosed_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoadNode::release_enclosed() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.LoadNode.enclosed)
  if (!_internal_has_enclosed()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return enclosed_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoadNode::set_allocated_enclosed(std::string* enclosed) {
  if (enclosed != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  enclosed_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enclosed,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.LoadNode.enclosed)
}

// optional bytes escaped = 12;
inline bool LoadNode::_internal_has_escaped() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LoadNode::has_escaped() const {
  return _internal_has_escaped();
}
inline void LoadNode::clear_escaped() {
  escaped_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& LoadNode::escaped() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LoadNode.escaped)
  return _internal_escaped();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadNode::set_escaped(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 escaped_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.LoadNode.escaped)
}
inline std::string* LoadNode::mutable_escaped() {
  std::string* _s = _internal_mutable_escaped();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LoadNode.escaped)
  return _s;
}
inline const std::string& LoadNode::_internal_escaped() const {
  return escaped_.Get();
}
inline void LoadNode::_internal_set_escaped(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  escaped_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoadNode::_internal_mutable_escaped() {
  _has_bits_[0] |= 0x00000008u;
  return escaped_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoadNode::release_escaped() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.LoadNode.escaped)
  if (!_internal_has_escaped()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return escaped_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoadNode::set_allocated_escaped(std::string* escaped) {
  if (escaped != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  escaped_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), escaped,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.LoadNode.escaped)
}

// optional bytes line_starting = 13;
inline bool LoadNode::_internal_has_line_starting() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LoadNode::has_line_starting() const {
  return _internal_has_line_starting();
}
inline void LoadNode::clear_line_starting() {
  line_starting_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& LoadNode::line_starting() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LoadNode.line_starting)
  return _internal_line_starting();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadNode::set_line_starting(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 line_starting_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.LoadNode.line_starting)
}
inline std::string* LoadNode::mutable_line_starting() {
  std::string* _s = _internal_mutable_line_starting();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LoadNode.line_starting)
  return _s;
}
inline const std::string& LoadNode::_internal_line_starting() const {
  return line_starting_.Get();
}
inline void LoadNode::_internal_set_line_starting(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  line_starting_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoadNode::_internal_mutable_line_starting() {
  _has_bits_[0] |= 0x00000010u;
  return line_starting_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoadNode::release_line_starting() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.LoadNode.line_starting)
  if (!_internal_has_line_starting()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return line_starting_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoadNode::set_allocated_line_starting(std::string* line_starting) {
  if (line_starting != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  line_starting_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), line_starting,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.LoadNode.line_starting)
}

// optional bytes line_terminated = 14;
inline bool LoadNode::_internal_has_line_terminated() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LoadNode::has_line_terminated() const {
  return _internal_has_line_terminated();
}
inline void LoadNode::clear_line_terminated() {
  line_terminated_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& LoadNode::line_terminated() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LoadNode.line_terminated)
  return _internal_line_terminated();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoadNode::set_line_terminated(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 line_terminated_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.LoadNode.line_terminated)
}
inline std::string* LoadNode::mutable_line_terminated() {
  std::string* _s = _internal_mutable_line_terminated();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LoadNode.line_terminated)
  return _s;
}
inline const std::string& LoadNode::_internal_line_terminated() const {
  return line_terminated_.Get();
}
inline void LoadNode::_internal_set_line_terminated(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  line_terminated_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoadNode::_internal_mutable_line_terminated() {
  _has_bits_[0] |= 0x00000020u;
  return line_terminated_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoadNode::release_line_terminated() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.LoadNode.line_terminated)
  if (!_internal_has_line_terminated()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return line_terminated_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoadNode::set_allocated_line_terminated(std::string* line_terminated) {
  if (line_terminated != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  line_terminated_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), line_terminated,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.LoadNode.line_terminated)
}

// optional bool opt_enclosed = 15;
inline bool LoadNode::_internal_has_opt_enclosed() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool LoadNode::has_opt_enclosed() const {
  return _internal_has_opt_enclosed();
}
inline void LoadNode::clear_opt_enclosed() {
  opt_enclosed_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool LoadNode::_internal_opt_enclosed() const {
  return opt_enclosed_;
}
inline bool LoadNode::opt_enclosed() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LoadNode.opt_enclosed)
  return _internal_opt_enclosed();
}
inline void LoadNode::_internal_set_opt_enclosed(bool value) {
  _has_bits_[0] |= 0x00000100u;
  opt_enclosed_ = value;
}
inline void LoadNode::set_opt_enclosed(bool value) {
  _internal_set_opt_enclosed(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LoadNode.opt_enclosed)
}

// optional int64 file_size = 16;
inline bool LoadNode::_internal_has_file_size() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool LoadNode::has_file_size() const {
  return _internal_has_file_size();
}
inline void LoadNode::clear_file_size() {
  file_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoadNode::_internal_file_size() const {
  return file_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoadNode::file_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LoadNode.file_size)
  return _internal_file_size();
}
inline void LoadNode::_internal_set_file_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  file_size_ = value;
}
inline void LoadNode::set_file_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LoadNode.file_size)
}

// optional .baikaldb.pb.Charset char_set = 17;
inline bool LoadNode::_internal_has_char_set() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool LoadNode::has_char_set() const {
  return _internal_has_char_set();
}
inline void LoadNode::clear_char_set() {
  char_set_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::baikaldb::pb::Charset LoadNode::_internal_char_set() const {
  return static_cast< ::baikaldb::pb::Charset >(char_set_);
}
inline ::baikaldb::pb::Charset LoadNode::char_set() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LoadNode.char_set)
  return _internal_char_set();
}
inline void LoadNode::_internal_set_char_set(::baikaldb::pb::Charset value) {
  assert(::baikaldb::pb::Charset_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  char_set_ = value;
}
inline void LoadNode::set_char_set(::baikaldb::pb::Charset value) {
  _internal_set_char_set(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LoadNode.char_set)
}

// -------------------------------------------------------------------

// PartitionProperty

// required .baikaldb.pb.PartitionPropertyType type = 1;
inline bool PartitionProperty::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PartitionProperty::has_type() const {
  return _internal_has_type();
}
inline void PartitionProperty::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::baikaldb::pb::PartitionPropertyType PartitionProperty::_internal_type() const {
  return static_cast< ::baikaldb::pb::PartitionPropertyType >(type_);
}
inline ::baikaldb::pb::PartitionPropertyType PartitionProperty::type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionProperty.type)
  return _internal_type();
}
inline void PartitionProperty::_internal_set_type(::baikaldb::pb::PartitionPropertyType value) {
  assert(::baikaldb::pb::PartitionPropertyType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void PartitionProperty::set_type(::baikaldb::pb::PartitionPropertyType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionProperty.type)
}

// repeated bytes hash_cols = 2;
inline int PartitionProperty::_internal_hash_cols_size() const {
  return hash_cols_.size();
}
inline int PartitionProperty::hash_cols_size() const {
  return _internal_hash_cols_size();
}
inline void PartitionProperty::clear_hash_cols() {
  hash_cols_.Clear();
}
inline std::string* PartitionProperty::add_hash_cols() {
  std::string* _s = _internal_add_hash_cols();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.PartitionProperty.hash_cols)
  return _s;
}
inline const std::string& PartitionProperty::_internal_hash_cols(int index) const {
  return hash_cols_.Get(index);
}
inline const std::string& PartitionProperty::hash_cols(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionProperty.hash_cols)
  return _internal_hash_cols(index);
}
inline std::string* PartitionProperty::mutable_hash_cols(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PartitionProperty.hash_cols)
  return hash_cols_.Mutable(index);
}
inline void PartitionProperty::set_hash_cols(int index, const std::string& value) {
  hash_cols_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionProperty.hash_cols)
}
inline void PartitionProperty::set_hash_cols(int index, std::string&& value) {
  hash_cols_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionProperty.hash_cols)
}
inline void PartitionProperty::set_hash_cols(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hash_cols_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.PartitionProperty.hash_cols)
}
inline void PartitionProperty::set_hash_cols(int index, const void* value, size_t size) {
  hash_cols_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.PartitionProperty.hash_cols)
}
inline std::string* PartitionProperty::_internal_add_hash_cols() {
  return hash_cols_.Add();
}
inline void PartitionProperty::add_hash_cols(const std::string& value) {
  hash_cols_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.PartitionProperty.hash_cols)
}
inline void PartitionProperty::add_hash_cols(std::string&& value) {
  hash_cols_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.PartitionProperty.hash_cols)
}
inline void PartitionProperty::add_hash_cols(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hash_cols_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.PartitionProperty.hash_cols)
}
inline void PartitionProperty::add_hash_cols(const void* value, size_t size) {
  hash_cols_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.PartitionProperty.hash_cols)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PartitionProperty::hash_cols() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PartitionProperty.hash_cols)
  return hash_cols_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PartitionProperty::mutable_hash_cols() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PartitionProperty.hash_cols)
  return &hash_cols_;
}

// repeated bytes need_cast_string_cols = 3;
inline int PartitionProperty::_internal_need_cast_string_cols_size() const {
  return need_cast_string_cols_.size();
}
inline int PartitionProperty::need_cast_string_cols_size() const {
  return _internal_need_cast_string_cols_size();
}
inline void PartitionProperty::clear_need_cast_string_cols() {
  need_cast_string_cols_.Clear();
}
inline std::string* PartitionProperty::add_need_cast_string_cols() {
  std::string* _s = _internal_add_need_cast_string_cols();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.PartitionProperty.need_cast_string_cols)
  return _s;
}
inline const std::string& PartitionProperty::_internal_need_cast_string_cols(int index) const {
  return need_cast_string_cols_.Get(index);
}
inline const std::string& PartitionProperty::need_cast_string_cols(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionProperty.need_cast_string_cols)
  return _internal_need_cast_string_cols(index);
}
inline std::string* PartitionProperty::mutable_need_cast_string_cols(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PartitionProperty.need_cast_string_cols)
  return need_cast_string_cols_.Mutable(index);
}
inline void PartitionProperty::set_need_cast_string_cols(int index, const std::string& value) {
  need_cast_string_cols_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionProperty.need_cast_string_cols)
}
inline void PartitionProperty::set_need_cast_string_cols(int index, std::string&& value) {
  need_cast_string_cols_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionProperty.need_cast_string_cols)
}
inline void PartitionProperty::set_need_cast_string_cols(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  need_cast_string_cols_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.PartitionProperty.need_cast_string_cols)
}
inline void PartitionProperty::set_need_cast_string_cols(int index, const void* value, size_t size) {
  need_cast_string_cols_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.PartitionProperty.need_cast_string_cols)
}
inline std::string* PartitionProperty::_internal_add_need_cast_string_cols() {
  return need_cast_string_cols_.Add();
}
inline void PartitionProperty::add_need_cast_string_cols(const std::string& value) {
  need_cast_string_cols_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.PartitionProperty.need_cast_string_cols)
}
inline void PartitionProperty::add_need_cast_string_cols(std::string&& value) {
  need_cast_string_cols_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.PartitionProperty.need_cast_string_cols)
}
inline void PartitionProperty::add_need_cast_string_cols(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  need_cast_string_cols_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.PartitionProperty.need_cast_string_cols)
}
inline void PartitionProperty::add_need_cast_string_cols(const void* value, size_t size) {
  need_cast_string_cols_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.PartitionProperty.need_cast_string_cols)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PartitionProperty::need_cast_string_cols() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PartitionProperty.need_cast_string_cols)
  return need_cast_string_cols_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PartitionProperty::mutable_need_cast_string_cols() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PartitionProperty.need_cast_string_cols)
  return &need_cast_string_cols_;
}

// repeated bytes need_project_hash_cols = 4;
inline int PartitionProperty::_internal_need_project_hash_cols_size() const {
  return need_project_hash_cols_.size();
}
inline int PartitionProperty::need_project_hash_cols_size() const {
  return _internal_need_project_hash_cols_size();
}
inline void PartitionProperty::clear_need_project_hash_cols() {
  need_project_hash_cols_.Clear();
}
inline std::string* PartitionProperty::add_need_project_hash_cols() {
  std::string* _s = _internal_add_need_project_hash_cols();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.PartitionProperty.need_project_hash_cols)
  return _s;
}
inline const std::string& PartitionProperty::_internal_need_project_hash_cols(int index) const {
  return need_project_hash_cols_.Get(index);
}
inline const std::string& PartitionProperty::need_project_hash_cols(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionProperty.need_project_hash_cols)
  return _internal_need_project_hash_cols(index);
}
inline std::string* PartitionProperty::mutable_need_project_hash_cols(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PartitionProperty.need_project_hash_cols)
  return need_project_hash_cols_.Mutable(index);
}
inline void PartitionProperty::set_need_project_hash_cols(int index, const std::string& value) {
  need_project_hash_cols_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionProperty.need_project_hash_cols)
}
inline void PartitionProperty::set_need_project_hash_cols(int index, std::string&& value) {
  need_project_hash_cols_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionProperty.need_project_hash_cols)
}
inline void PartitionProperty::set_need_project_hash_cols(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  need_project_hash_cols_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.PartitionProperty.need_project_hash_cols)
}
inline void PartitionProperty::set_need_project_hash_cols(int index, const void* value, size_t size) {
  need_project_hash_cols_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.PartitionProperty.need_project_hash_cols)
}
inline std::string* PartitionProperty::_internal_add_need_project_hash_cols() {
  return need_project_hash_cols_.Add();
}
inline void PartitionProperty::add_need_project_hash_cols(const std::string& value) {
  need_project_hash_cols_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.PartitionProperty.need_project_hash_cols)
}
inline void PartitionProperty::add_need_project_hash_cols(std::string&& value) {
  need_project_hash_cols_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.PartitionProperty.need_project_hash_cols)
}
inline void PartitionProperty::add_need_project_hash_cols(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  need_project_hash_cols_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.PartitionProperty.need_project_hash_cols)
}
inline void PartitionProperty::add_need_project_hash_cols(const void* value, size_t size) {
  need_project_hash_cols_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.PartitionProperty.need_project_hash_cols)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PartitionProperty::need_project_hash_cols() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PartitionProperty.need_project_hash_cols)
  return need_project_hash_cols_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PartitionProperty::mutable_need_project_hash_cols() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PartitionProperty.need_project_hash_cols)
  return &need_project_hash_cols_;
}

// repeated .baikaldb.pb.Expr need_project_hash_exprs = 5;
inline int PartitionProperty::_internal_need_project_hash_exprs_size() const {
  return need_project_hash_exprs_.size();
}
inline int PartitionProperty::need_project_hash_exprs_size() const {
  return _internal_need_project_hash_exprs_size();
}
inline ::baikaldb::pb::Expr* PartitionProperty::mutable_need_project_hash_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PartitionProperty.need_project_hash_exprs)
  return need_project_hash_exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
PartitionProperty::mutable_need_project_hash_exprs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PartitionProperty.need_project_hash_exprs)
  return &need_project_hash_exprs_;
}
inline const ::baikaldb::pb::Expr& PartitionProperty::_internal_need_project_hash_exprs(int index) const {
  return need_project_hash_exprs_.Get(index);
}
inline const ::baikaldb::pb::Expr& PartitionProperty::need_project_hash_exprs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionProperty.need_project_hash_exprs)
  return _internal_need_project_hash_exprs(index);
}
inline ::baikaldb::pb::Expr* PartitionProperty::_internal_add_need_project_hash_exprs() {
  return need_project_hash_exprs_.Add();
}
inline ::baikaldb::pb::Expr* PartitionProperty::add_need_project_hash_exprs() {
  ::baikaldb::pb::Expr* _add = _internal_add_need_project_hash_exprs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.PartitionProperty.need_project_hash_exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
PartitionProperty::need_project_hash_exprs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PartitionProperty.need_project_hash_exprs)
  return need_project_hash_exprs_;
}

// -------------------------------------------------------------------

// ExchangeDestination

// required uint64 fragment_instance_id = 1;
inline bool ExchangeDestination::_internal_has_fragment_instance_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExchangeDestination::has_fragment_instance_id() const {
  return _internal_has_fragment_instance_id();
}
inline void ExchangeDestination::clear_fragment_instance_id() {
  fragment_instance_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExchangeDestination::_internal_fragment_instance_id() const {
  return fragment_instance_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExchangeDestination::fragment_instance_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeDestination.fragment_instance_id)
  return _internal_fragment_instance_id();
}
inline void ExchangeDestination::_internal_set_fragment_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  fragment_instance_id_ = value;
}
inline void ExchangeDestination::set_fragment_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fragment_instance_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeDestination.fragment_instance_id)
}

// required int32 node_id = 2;
inline bool ExchangeDestination::_internal_has_node_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExchangeDestination::has_node_id() const {
  return _internal_has_node_id();
}
inline void ExchangeDestination::clear_node_id() {
  node_id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExchangeDestination::_internal_node_id() const {
  return node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExchangeDestination::node_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeDestination.node_id)
  return _internal_node_id();
}
inline void ExchangeDestination::_internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  node_id_ = value;
}
inline void ExchangeDestination::set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeDestination.node_id)
}

// optional bytes address = 3;
inline bool ExchangeDestination::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExchangeDestination::has_address() const {
  return _internal_has_address();
}
inline void ExchangeDestination::clear_address() {
  address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExchangeDestination::address() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeDestination.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExchangeDestination::set_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeDestination.address)
}
inline std::string* ExchangeDestination::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExchangeDestination.address)
  return _s;
}
inline const std::string& ExchangeDestination::_internal_address() const {
  return address_.Get();
}
inline void ExchangeDestination::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExchangeDestination::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExchangeDestination::release_address() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ExchangeDestination.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExchangeDestination::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ExchangeDestination.address)
}

// -------------------------------------------------------------------

// ExchangeSenderNode

// required uint64 log_id = 1;
inline bool ExchangeSenderNode::_internal_has_log_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExchangeSenderNode::has_log_id() const {
  return _internal_has_log_id();
}
inline void ExchangeSenderNode::clear_log_id() {
  log_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExchangeSenderNode::_internal_log_id() const {
  return log_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExchangeSenderNode::log_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeSenderNode.log_id)
  return _internal_log_id();
}
inline void ExchangeSenderNode::_internal_set_log_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  log_id_ = value;
}
inline void ExchangeSenderNode::set_log_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_log_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeSenderNode.log_id)
}

// required int32 fragment_id = 2;
inline bool ExchangeSenderNode::_internal_has_fragment_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExchangeSenderNode::has_fragment_id() const {
  return _internal_has_fragment_id();
}
inline void ExchangeSenderNode::clear_fragment_id() {
  fragment_id_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExchangeSenderNode::_internal_fragment_id() const {
  return fragment_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExchangeSenderNode::fragment_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeSenderNode.fragment_id)
  return _internal_fragment_id();
}
inline void ExchangeSenderNode::_internal_set_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  fragment_id_ = value;
}
inline void ExchangeSenderNode::set_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_fragment_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeSenderNode.fragment_id)
}

// required int32 receiver_fragment_id = 3;
inline bool ExchangeSenderNode::_internal_has_receiver_fragment_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ExchangeSenderNode::has_receiver_fragment_id() const {
  return _internal_has_receiver_fragment_id();
}
inline void ExchangeSenderNode::clear_receiver_fragment_id() {
  receiver_fragment_id_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExchangeSenderNode::_internal_receiver_fragment_id() const {
  return receiver_fragment_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExchangeSenderNode::receiver_fragment_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeSenderNode.receiver_fragment_id)
  return _internal_receiver_fragment_id();
}
inline void ExchangeSenderNode::_internal_set_receiver_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  receiver_fragment_id_ = value;
}
inline void ExchangeSenderNode::set_receiver_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_receiver_fragment_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeSenderNode.receiver_fragment_id)
}

// required uint64 fragment_instance_id = 4;
inline bool ExchangeSenderNode::_internal_has_fragment_instance_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExchangeSenderNode::has_fragment_instance_id() const {
  return _internal_has_fragment_instance_id();
}
inline void ExchangeSenderNode::clear_fragment_instance_id() {
  fragment_instance_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExchangeSenderNode::_internal_fragment_instance_id() const {
  return fragment_instance_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExchangeSenderNode::fragment_instance_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeSenderNode.fragment_instance_id)
  return _internal_fragment_instance_id();
}
inline void ExchangeSenderNode::_internal_set_fragment_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  fragment_instance_id_ = value;
}
inline void ExchangeSenderNode::set_fragment_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fragment_instance_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeSenderNode.fragment_instance_id)
}

// required int32 node_id = 5;
inline bool ExchangeSenderNode::_internal_has_node_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ExchangeSenderNode::has_node_id() const {
  return _internal_has_node_id();
}
inline void ExchangeSenderNode::clear_node_id() {
  node_id_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExchangeSenderNode::_internal_node_id() const {
  return node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExchangeSenderNode::node_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeSenderNode.node_id)
  return _internal_node_id();
}
inline void ExchangeSenderNode::_internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  node_id_ = value;
}
inline void ExchangeSenderNode::set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeSenderNode.node_id)
}

// repeated .baikaldb.pb.ExchangeDestination receiver_destinations = 6;
inline int ExchangeSenderNode::_internal_receiver_destinations_size() const {
  return receiver_destinations_.size();
}
inline int ExchangeSenderNode::receiver_destinations_size() const {
  return _internal_receiver_destinations_size();
}
inline void ExchangeSenderNode::clear_receiver_destinations() {
  receiver_destinations_.Clear();
}
inline ::baikaldb::pb::ExchangeDestination* ExchangeSenderNode::mutable_receiver_destinations(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExchangeSenderNode.receiver_destinations)
  return receiver_destinations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ExchangeDestination >*
ExchangeSenderNode::mutable_receiver_destinations() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ExchangeSenderNode.receiver_destinations)
  return &receiver_destinations_;
}
inline const ::baikaldb::pb::ExchangeDestination& ExchangeSenderNode::_internal_receiver_destinations(int index) const {
  return receiver_destinations_.Get(index);
}
inline const ::baikaldb::pb::ExchangeDestination& ExchangeSenderNode::receiver_destinations(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeSenderNode.receiver_destinations)
  return _internal_receiver_destinations(index);
}
inline ::baikaldb::pb::ExchangeDestination* ExchangeSenderNode::_internal_add_receiver_destinations() {
  return receiver_destinations_.Add();
}
inline ::baikaldb::pb::ExchangeDestination* ExchangeSenderNode::add_receiver_destinations() {
  ::baikaldb::pb::ExchangeDestination* _add = _internal_add_receiver_destinations();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ExchangeSenderNode.receiver_destinations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ExchangeDestination >&
ExchangeSenderNode::receiver_destinations() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ExchangeSenderNode.receiver_destinations)
  return receiver_destinations_;
}

// repeated .baikaldb.pb.ExchangeDestination fragment_addresses = 7;
inline int ExchangeSenderNode::_internal_fragment_addresses_size() const {
  return fragment_addresses_.size();
}
inline int ExchangeSenderNode::fragment_addresses_size() const {
  return _internal_fragment_addresses_size();
}
inline void ExchangeSenderNode::clear_fragment_addresses() {
  fragment_addresses_.Clear();
}
inline ::baikaldb::pb::ExchangeDestination* ExchangeSenderNode::mutable_fragment_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExchangeSenderNode.fragment_addresses)
  return fragment_addresses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ExchangeDestination >*
ExchangeSenderNode::mutable_fragment_addresses() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ExchangeSenderNode.fragment_addresses)
  return &fragment_addresses_;
}
inline const ::baikaldb::pb::ExchangeDestination& ExchangeSenderNode::_internal_fragment_addresses(int index) const {
  return fragment_addresses_.Get(index);
}
inline const ::baikaldb::pb::ExchangeDestination& ExchangeSenderNode::fragment_addresses(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeSenderNode.fragment_addresses)
  return _internal_fragment_addresses(index);
}
inline ::baikaldb::pb::ExchangeDestination* ExchangeSenderNode::_internal_add_fragment_addresses() {
  return fragment_addresses_.Add();
}
inline ::baikaldb::pb::ExchangeDestination* ExchangeSenderNode::add_fragment_addresses() {
  ::baikaldb::pb::ExchangeDestination* _add = _internal_add_fragment_addresses();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ExchangeSenderNode.fragment_addresses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ExchangeDestination >&
ExchangeSenderNode::fragment_addresses() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ExchangeSenderNode.fragment_addresses)
  return fragment_addresses_;
}

// optional .baikaldb.pb.PartitionProperty partition_property = 8;
inline bool ExchangeSenderNode::_internal_has_partition_property() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || partition_property_ != nullptr);
  return value;
}
inline bool ExchangeSenderNode::has_partition_property() const {
  return _internal_has_partition_property();
}
inline void ExchangeSenderNode::clear_partition_property() {
  if (partition_property_ != nullptr) partition_property_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::baikaldb::pb::PartitionProperty& ExchangeSenderNode::_internal_partition_property() const {
  const ::baikaldb::pb::PartitionProperty* p = partition_property_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::PartitionProperty&>(
      ::baikaldb::pb::_PartitionProperty_default_instance_);
}
inline const ::baikaldb::pb::PartitionProperty& ExchangeSenderNode::partition_property() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeSenderNode.partition_property)
  return _internal_partition_property();
}
inline void ExchangeSenderNode::unsafe_arena_set_allocated_partition_property(
    ::baikaldb::pb::PartitionProperty* partition_property) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(partition_property_);
  }
  partition_property_ = partition_property;
  if (partition_property) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.ExchangeSenderNode.partition_property)
}
inline ::baikaldb::pb::PartitionProperty* ExchangeSenderNode::release_partition_property() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::PartitionProperty* temp = partition_property_;
  partition_property_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::PartitionProperty* ExchangeSenderNode::unsafe_arena_release_partition_property() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ExchangeSenderNode.partition_property)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::PartitionProperty* temp = partition_property_;
  partition_property_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::PartitionProperty* ExchangeSenderNode::_internal_mutable_partition_property() {
  _has_bits_[0] |= 0x00000002u;
  if (partition_property_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::PartitionProperty>(GetArenaForAllocation());
    partition_property_ = p;
  }
  return partition_property_;
}
inline ::baikaldb::pb::PartitionProperty* ExchangeSenderNode::mutable_partition_property() {
  ::baikaldb::pb::PartitionProperty* _msg = _internal_mutable_partition_property();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExchangeSenderNode.partition_property)
  return _msg;
}
inline void ExchangeSenderNode::set_allocated_partition_property(::baikaldb::pb::PartitionProperty* partition_property) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete partition_property_;
  }
  if (partition_property) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::PartitionProperty>::GetOwningArena(partition_property);
    if (message_arena != submessage_arena) {
      partition_property = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition_property, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  partition_property_ = partition_property;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ExchangeSenderNode.partition_property)
}

// optional bytes schema = 9;
inline bool ExchangeSenderNode::_internal_has_schema() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExchangeSenderNode::has_schema() const {
  return _internal_has_schema();
}
inline void ExchangeSenderNode::clear_schema() {
  schema_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExchangeSenderNode::schema() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeSenderNode.schema)
  return _internal_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExchangeSenderNode::set_schema(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 schema_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeSenderNode.schema)
}
inline std::string* ExchangeSenderNode::mutable_schema() {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExchangeSenderNode.schema)
  return _s;
}
inline const std::string& ExchangeSenderNode::_internal_schema() const {
  return schema_.Get();
}
inline void ExchangeSenderNode::_internal_set_schema(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExchangeSenderNode::_internal_mutable_schema() {
  _has_bits_[0] |= 0x00000001u;
  return schema_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExchangeSenderNode::release_schema() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ExchangeSenderNode.schema)
  if (!_internal_has_schema()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return schema_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExchangeSenderNode::set_allocated_schema(std::string* schema) {
  if (schema != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  schema_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ExchangeSenderNode.schema)
}

// -------------------------------------------------------------------

// ExchangeReceiverNode

// required uint64 log_id = 1;
inline bool ExchangeReceiverNode::_internal_has_log_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExchangeReceiverNode::has_log_id() const {
  return _internal_has_log_id();
}
inline void ExchangeReceiverNode::clear_log_id() {
  log_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExchangeReceiverNode::_internal_log_id() const {
  return log_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExchangeReceiverNode::log_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeReceiverNode.log_id)
  return _internal_log_id();
}
inline void ExchangeReceiverNode::_internal_set_log_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  log_id_ = value;
}
inline void ExchangeReceiverNode::set_log_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_log_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeReceiverNode.log_id)
}

// required int32 fragment_id = 2;
inline bool ExchangeReceiverNode::_internal_has_fragment_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExchangeReceiverNode::has_fragment_id() const {
  return _internal_has_fragment_id();
}
inline void ExchangeReceiverNode::clear_fragment_id() {
  fragment_id_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExchangeReceiverNode::_internal_fragment_id() const {
  return fragment_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExchangeReceiverNode::fragment_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeReceiverNode.fragment_id)
  return _internal_fragment_id();
}
inline void ExchangeReceiverNode::_internal_set_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  fragment_id_ = value;
}
inline void ExchangeReceiverNode::set_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_fragment_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeReceiverNode.fragment_id)
}

// required int32 sender_fragment_id = 3;
inline bool ExchangeReceiverNode::_internal_has_sender_fragment_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ExchangeReceiverNode::has_sender_fragment_id() const {
  return _internal_has_sender_fragment_id();
}
inline void ExchangeReceiverNode::clear_sender_fragment_id() {
  sender_fragment_id_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExchangeReceiverNode::_internal_sender_fragment_id() const {
  return sender_fragment_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExchangeReceiverNode::sender_fragment_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeReceiverNode.sender_fragment_id)
  return _internal_sender_fragment_id();
}
inline void ExchangeReceiverNode::_internal_set_sender_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  sender_fragment_id_ = value;
}
inline void ExchangeReceiverNode::set_sender_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sender_fragment_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeReceiverNode.sender_fragment_id)
}

// required uint64 fragment_instance_id = 4;
inline bool ExchangeReceiverNode::_internal_has_fragment_instance_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExchangeReceiverNode::has_fragment_instance_id() const {
  return _internal_has_fragment_instance_id();
}
inline void ExchangeReceiverNode::clear_fragment_instance_id() {
  fragment_instance_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExchangeReceiverNode::_internal_fragment_instance_id() const {
  return fragment_instance_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExchangeReceiverNode::fragment_instance_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeReceiverNode.fragment_instance_id)
  return _internal_fragment_instance_id();
}
inline void ExchangeReceiverNode::_internal_set_fragment_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  fragment_instance_id_ = value;
}
inline void ExchangeReceiverNode::set_fragment_instance_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fragment_instance_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeReceiverNode.fragment_instance_id)
}

// required int32 node_id = 5;
inline bool ExchangeReceiverNode::_internal_has_node_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ExchangeReceiverNode::has_node_id() const {
  return _internal_has_node_id();
}
inline void ExchangeReceiverNode::clear_node_id() {
  node_id_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExchangeReceiverNode::_internal_node_id() const {
  return node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExchangeReceiverNode::node_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeReceiverNode.node_id)
  return _internal_node_id();
}
inline void ExchangeReceiverNode::_internal_set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  node_id_ = value;
}
inline void ExchangeReceiverNode::set_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeReceiverNode.node_id)
}

// repeated .baikaldb.pb.ExchangeDestination sender_destinations = 6;
inline int ExchangeReceiverNode::_internal_sender_destinations_size() const {
  return sender_destinations_.size();
}
inline int ExchangeReceiverNode::sender_destinations_size() const {
  return _internal_sender_destinations_size();
}
inline void ExchangeReceiverNode::clear_sender_destinations() {
  sender_destinations_.Clear();
}
inline ::baikaldb::pb::ExchangeDestination* ExchangeReceiverNode::mutable_sender_destinations(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExchangeReceiverNode.sender_destinations)
  return sender_destinations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ExchangeDestination >*
ExchangeReceiverNode::mutable_sender_destinations() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ExchangeReceiverNode.sender_destinations)
  return &sender_destinations_;
}
inline const ::baikaldb::pb::ExchangeDestination& ExchangeReceiverNode::_internal_sender_destinations(int index) const {
  return sender_destinations_.Get(index);
}
inline const ::baikaldb::pb::ExchangeDestination& ExchangeReceiverNode::sender_destinations(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeReceiverNode.sender_destinations)
  return _internal_sender_destinations(index);
}
inline ::baikaldb::pb::ExchangeDestination* ExchangeReceiverNode::_internal_add_sender_destinations() {
  return sender_destinations_.Add();
}
inline ::baikaldb::pb::ExchangeDestination* ExchangeReceiverNode::add_sender_destinations() {
  ::baikaldb::pb::ExchangeDestination* _add = _internal_add_sender_destinations();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ExchangeReceiverNode.sender_destinations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ExchangeDestination >&
ExchangeReceiverNode::sender_destinations() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ExchangeReceiverNode.sender_destinations)
  return sender_destinations_;
}

// repeated .baikaldb.pb.RegionInfo regions = 7;
inline int ExchangeReceiverNode::_internal_regions_size() const {
  return regions_.size();
}
inline int ExchangeReceiverNode::regions_size() const {
  return _internal_regions_size();
}
inline ::baikaldb::pb::RegionInfo* ExchangeReceiverNode::mutable_regions(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExchangeReceiverNode.regions)
  return regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >*
ExchangeReceiverNode::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ExchangeReceiverNode.regions)
  return &regions_;
}
inline const ::baikaldb::pb::RegionInfo& ExchangeReceiverNode::_internal_regions(int index) const {
  return regions_.Get(index);
}
inline const ::baikaldb::pb::RegionInfo& ExchangeReceiverNode::regions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeReceiverNode.regions)
  return _internal_regions(index);
}
inline ::baikaldb::pb::RegionInfo* ExchangeReceiverNode::_internal_add_regions() {
  return regions_.Add();
}
inline ::baikaldb::pb::RegionInfo* ExchangeReceiverNode::add_regions() {
  ::baikaldb::pb::RegionInfo* _add = _internal_add_regions();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ExchangeReceiverNode.regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >&
ExchangeReceiverNode::regions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ExchangeReceiverNode.regions)
  return regions_;
}

// optional .baikaldb.pb.PartitionProperty partition_property = 8;
inline bool ExchangeReceiverNode::_internal_has_partition_property() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || partition_property_ != nullptr);
  return value;
}
inline bool ExchangeReceiverNode::has_partition_property() const {
  return _internal_has_partition_property();
}
inline void ExchangeReceiverNode::clear_partition_property() {
  if (partition_property_ != nullptr) partition_property_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::baikaldb::pb::PartitionProperty& ExchangeReceiverNode::_internal_partition_property() const {
  const ::baikaldb::pb::PartitionProperty* p = partition_property_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::PartitionProperty&>(
      ::baikaldb::pb::_PartitionProperty_default_instance_);
}
inline const ::baikaldb::pb::PartitionProperty& ExchangeReceiverNode::partition_property() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeReceiverNode.partition_property)
  return _internal_partition_property();
}
inline void ExchangeReceiverNode::unsafe_arena_set_allocated_partition_property(
    ::baikaldb::pb::PartitionProperty* partition_property) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(partition_property_);
  }
  partition_property_ = partition_property;
  if (partition_property) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.ExchangeReceiverNode.partition_property)
}
inline ::baikaldb::pb::PartitionProperty* ExchangeReceiverNode::release_partition_property() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::PartitionProperty* temp = partition_property_;
  partition_property_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::PartitionProperty* ExchangeReceiverNode::unsafe_arena_release_partition_property() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ExchangeReceiverNode.partition_property)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::PartitionProperty* temp = partition_property_;
  partition_property_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::PartitionProperty* ExchangeReceiverNode::_internal_mutable_partition_property() {
  _has_bits_[0] |= 0x00000002u;
  if (partition_property_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::PartitionProperty>(GetArenaForAllocation());
    partition_property_ = p;
  }
  return partition_property_;
}
inline ::baikaldb::pb::PartitionProperty* ExchangeReceiverNode::mutable_partition_property() {
  ::baikaldb::pb::PartitionProperty* _msg = _internal_mutable_partition_property();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExchangeReceiverNode.partition_property)
  return _msg;
}
inline void ExchangeReceiverNode::set_allocated_partition_property(::baikaldb::pb::PartitionProperty* partition_property) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete partition_property_;
  }
  if (partition_property) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::PartitionProperty>::GetOwningArena(partition_property);
    if (message_arena != submessage_arena) {
      partition_property = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition_property, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  partition_property_ = partition_property;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ExchangeReceiverNode.partition_property)
}

// required bytes schema = 9;
inline bool ExchangeReceiverNode::_internal_has_schema() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExchangeReceiverNode::has_schema() const {
  return _internal_has_schema();
}
inline void ExchangeReceiverNode::clear_schema() {
  schema_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExchangeReceiverNode::schema() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeReceiverNode.schema)
  return _internal_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExchangeReceiverNode::set_schema(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 schema_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeReceiverNode.schema)
}
inline std::string* ExchangeReceiverNode::mutable_schema() {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExchangeReceiverNode.schema)
  return _s;
}
inline const std::string& ExchangeReceiverNode::_internal_schema() const {
  return schema_.Get();
}
inline void ExchangeReceiverNode::_internal_set_schema(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExchangeReceiverNode::_internal_mutable_schema() {
  _has_bits_[0] |= 0x00000001u;
  return schema_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExchangeReceiverNode::release_schema() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ExchangeReceiverNode.schema)
  if (!_internal_has_schema()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return schema_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExchangeReceiverNode::set_allocated_schema(std::string* schema) {
  if (schema != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  schema_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ExchangeReceiverNode.schema)
}

// repeated .baikaldb.pb.Expr slot_order_exprs = 10;
inline int ExchangeReceiverNode::_internal_slot_order_exprs_size() const {
  return slot_order_exprs_.size();
}
inline int ExchangeReceiverNode::slot_order_exprs_size() const {
  return _internal_slot_order_exprs_size();
}
inline ::baikaldb::pb::Expr* ExchangeReceiverNode::mutable_slot_order_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExchangeReceiverNode.slot_order_exprs)
  return slot_order_exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
ExchangeReceiverNode::mutable_slot_order_exprs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ExchangeReceiverNode.slot_order_exprs)
  return &slot_order_exprs_;
}
inline const ::baikaldb::pb::Expr& ExchangeReceiverNode::_internal_slot_order_exprs(int index) const {
  return slot_order_exprs_.Get(index);
}
inline const ::baikaldb::pb::Expr& ExchangeReceiverNode::slot_order_exprs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeReceiverNode.slot_order_exprs)
  return _internal_slot_order_exprs(index);
}
inline ::baikaldb::pb::Expr* ExchangeReceiverNode::_internal_add_slot_order_exprs() {
  return slot_order_exprs_.Add();
}
inline ::baikaldb::pb::Expr* ExchangeReceiverNode::add_slot_order_exprs() {
  ::baikaldb::pb::Expr* _add = _internal_add_slot_order_exprs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ExchangeReceiverNode.slot_order_exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
ExchangeReceiverNode::slot_order_exprs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ExchangeReceiverNode.slot_order_exprs)
  return slot_order_exprs_;
}

// repeated bool is_asc = 11;
inline int ExchangeReceiverNode::_internal_is_asc_size() const {
  return is_asc_.size();
}
inline int ExchangeReceiverNode::is_asc_size() const {
  return _internal_is_asc_size();
}
inline void ExchangeReceiverNode::clear_is_asc() {
  is_asc_.Clear();
}
inline bool ExchangeReceiverNode::_internal_is_asc(int index) const {
  return is_asc_.Get(index);
}
inline bool ExchangeReceiverNode::is_asc(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeReceiverNode.is_asc)
  return _internal_is_asc(index);
}
inline void ExchangeReceiverNode::set_is_asc(int index, bool value) {
  is_asc_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeReceiverNode.is_asc)
}
inline void ExchangeReceiverNode::_internal_add_is_asc(bool value) {
  is_asc_.Add(value);
}
inline void ExchangeReceiverNode::add_is_asc(bool value) {
  _internal_add_is_asc(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.ExchangeReceiverNode.is_asc)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
ExchangeReceiverNode::_internal_is_asc() const {
  return is_asc_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
ExchangeReceiverNode::is_asc() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ExchangeReceiverNode.is_asc)
  return _internal_is_asc();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
ExchangeReceiverNode::_internal_mutable_is_asc() {
  return &is_asc_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
ExchangeReceiverNode::mutable_is_asc() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ExchangeReceiverNode.is_asc)
  return _internal_mutable_is_asc();
}

// repeated bool is_null_first = 12;
inline int ExchangeReceiverNode::_internal_is_null_first_size() const {
  return is_null_first_.size();
}
inline int ExchangeReceiverNode::is_null_first_size() const {
  return _internal_is_null_first_size();
}
inline void ExchangeReceiverNode::clear_is_null_first() {
  is_null_first_.Clear();
}
inline bool ExchangeReceiverNode::_internal_is_null_first(int index) const {
  return is_null_first_.Get(index);
}
inline bool ExchangeReceiverNode::is_null_first(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExchangeReceiverNode.is_null_first)
  return _internal_is_null_first(index);
}
inline void ExchangeReceiverNode::set_is_null_first(int index, bool value) {
  is_null_first_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExchangeReceiverNode.is_null_first)
}
inline void ExchangeReceiverNode::_internal_add_is_null_first(bool value) {
  is_null_first_.Add(value);
}
inline void ExchangeReceiverNode::add_is_null_first(bool value) {
  _internal_add_is_null_first(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.ExchangeReceiverNode.is_null_first)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
ExchangeReceiverNode::_internal_is_null_first() const {
  return is_null_first_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
ExchangeReceiverNode::is_null_first() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ExchangeReceiverNode.is_null_first)
  return _internal_is_null_first();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
ExchangeReceiverNode::_internal_mutable_is_null_first() {
  return &is_null_first_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
ExchangeReceiverNode::mutable_is_null_first() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ExchangeReceiverNode.is_null_first)
  return _internal_mutable_is_null_first();
}

// -------------------------------------------------------------------

// FrameBound

// optional .baikaldb.pb.BoundType bound_type = 1;
inline bool FrameBound::_internal_has_bound_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FrameBound::has_bound_type() const {
  return _internal_has_bound_type();
}
inline void FrameBound::clear_bound_type() {
  bound_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::baikaldb::pb::BoundType FrameBound::_internal_bound_type() const {
  return static_cast< ::baikaldb::pb::BoundType >(bound_type_);
}
inline ::baikaldb::pb::BoundType FrameBound::bound_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FrameBound.bound_type)
  return _internal_bound_type();
}
inline void FrameBound::_internal_set_bound_type(::baikaldb::pb::BoundType value) {
  assert(::baikaldb::pb::BoundType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  bound_type_ = value;
}
inline void FrameBound::set_bound_type(::baikaldb::pb::BoundType value) {
  _internal_set_bound_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FrameBound.bound_type)
}

// optional bool is_unbounded = 2;
inline bool FrameBound::_internal_has_is_unbounded() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FrameBound::has_is_unbounded() const {
  return _internal_has_is_unbounded();
}
inline void FrameBound::clear_is_unbounded() {
  is_unbounded_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool FrameBound::_internal_is_unbounded() const {
  return is_unbounded_;
}
inline bool FrameBound::is_unbounded() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FrameBound.is_unbounded)
  return _internal_is_unbounded();
}
inline void FrameBound::_internal_set_is_unbounded(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_unbounded_ = value;
}
inline void FrameBound::set_is_unbounded(bool value) {
  _internal_set_is_unbounded(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FrameBound.is_unbounded)
}

// optional .baikaldb.pb.Expr expr = 3;
inline bool FrameBound::_internal_has_expr() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || expr_ != nullptr);
  return value;
}
inline bool FrameBound::has_expr() const {
  return _internal_has_expr();
}
inline const ::baikaldb::pb::Expr& FrameBound::_internal_expr() const {
  const ::baikaldb::pb::Expr* p = expr_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::Expr&>(
      ::baikaldb::pb::_Expr_default_instance_);
}
inline const ::baikaldb::pb::Expr& FrameBound::expr() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FrameBound.expr)
  return _internal_expr();
}
inline void FrameBound::unsafe_arena_set_allocated_expr(
    ::baikaldb::pb::Expr* expr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expr_);
  }
  expr_ = expr;
  if (expr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.FrameBound.expr)
}
inline ::baikaldb::pb::Expr* FrameBound::release_expr() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::Expr* temp = expr_;
  expr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::Expr* FrameBound::unsafe_arena_release_expr() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.FrameBound.expr)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::Expr* temp = expr_;
  expr_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::Expr* FrameBound::_internal_mutable_expr() {
  _has_bits_[0] |= 0x00000001u;
  if (expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::Expr>(GetArenaForAllocation());
    expr_ = p;
  }
  return expr_;
}
inline ::baikaldb::pb::Expr* FrameBound::mutable_expr() {
  ::baikaldb::pb::Expr* _msg = _internal_mutable_expr();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FrameBound.expr)
  return _msg;
}
inline void FrameBound::set_allocated_expr(::baikaldb::pb::Expr* expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(expr_);
  }
  if (expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expr));
    if (message_arena != submessage_arena) {
      expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.FrameBound.expr)
}

// -------------------------------------------------------------------

// FrameExtent

// optional .baikaldb.pb.FrameBound frame_start = 1;
inline bool FrameExtent::_internal_has_frame_start() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || frame_start_ != nullptr);
  return value;
}
inline bool FrameExtent::has_frame_start() const {
  return _internal_has_frame_start();
}
inline void FrameExtent::clear_frame_start() {
  if (frame_start_ != nullptr) frame_start_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::FrameBound& FrameExtent::_internal_frame_start() const {
  const ::baikaldb::pb::FrameBound* p = frame_start_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::FrameBound&>(
      ::baikaldb::pb::_FrameBound_default_instance_);
}
inline const ::baikaldb::pb::FrameBound& FrameExtent::frame_start() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FrameExtent.frame_start)
  return _internal_frame_start();
}
inline void FrameExtent::unsafe_arena_set_allocated_frame_start(
    ::baikaldb::pb::FrameBound* frame_start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_start_);
  }
  frame_start_ = frame_start;
  if (frame_start) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.FrameExtent.frame_start)
}
inline ::baikaldb::pb::FrameBound* FrameExtent::release_frame_start() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::FrameBound* temp = frame_start_;
  frame_start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::FrameBound* FrameExtent::unsafe_arena_release_frame_start() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.FrameExtent.frame_start)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::FrameBound* temp = frame_start_;
  frame_start_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::FrameBound* FrameExtent::_internal_mutable_frame_start() {
  _has_bits_[0] |= 0x00000001u;
  if (frame_start_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::FrameBound>(GetArenaForAllocation());
    frame_start_ = p;
  }
  return frame_start_;
}
inline ::baikaldb::pb::FrameBound* FrameExtent::mutable_frame_start() {
  ::baikaldb::pb::FrameBound* _msg = _internal_mutable_frame_start();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FrameExtent.frame_start)
  return _msg;
}
inline void FrameExtent::set_allocated_frame_start(::baikaldb::pb::FrameBound* frame_start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete frame_start_;
  }
  if (frame_start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::FrameBound>::GetOwningArena(frame_start);
    if (message_arena != submessage_arena) {
      frame_start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_start, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  frame_start_ = frame_start;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.FrameExtent.frame_start)
}

// optional .baikaldb.pb.FrameBound frame_end = 2;
inline bool FrameExtent::_internal_has_frame_end() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || frame_end_ != nullptr);
  return value;
}
inline bool FrameExtent::has_frame_end() const {
  return _internal_has_frame_end();
}
inline void FrameExtent::clear_frame_end() {
  if (frame_end_ != nullptr) frame_end_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::baikaldb::pb::FrameBound& FrameExtent::_internal_frame_end() const {
  const ::baikaldb::pb::FrameBound* p = frame_end_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::FrameBound&>(
      ::baikaldb::pb::_FrameBound_default_instance_);
}
inline const ::baikaldb::pb::FrameBound& FrameExtent::frame_end() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FrameExtent.frame_end)
  return _internal_frame_end();
}
inline void FrameExtent::unsafe_arena_set_allocated_frame_end(
    ::baikaldb::pb::FrameBound* frame_end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_end_);
  }
  frame_end_ = frame_end;
  if (frame_end) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.FrameExtent.frame_end)
}
inline ::baikaldb::pb::FrameBound* FrameExtent::release_frame_end() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::FrameBound* temp = frame_end_;
  frame_end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::FrameBound* FrameExtent::unsafe_arena_release_frame_end() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.FrameExtent.frame_end)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::FrameBound* temp = frame_end_;
  frame_end_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::FrameBound* FrameExtent::_internal_mutable_frame_end() {
  _has_bits_[0] |= 0x00000002u;
  if (frame_end_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::FrameBound>(GetArenaForAllocation());
    frame_end_ = p;
  }
  return frame_end_;
}
inline ::baikaldb::pb::FrameBound* FrameExtent::mutable_frame_end() {
  ::baikaldb::pb::FrameBound* _msg = _internal_mutable_frame_end();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FrameExtent.frame_end)
  return _msg;
}
inline void FrameExtent::set_allocated_frame_end(::baikaldb::pb::FrameBound* frame_end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete frame_end_;
  }
  if (frame_end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::FrameBound>::GetOwningArena(frame_end);
    if (message_arena != submessage_arena) {
      frame_end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_end, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  frame_end_ = frame_end;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.FrameExtent.frame_end)
}

// -------------------------------------------------------------------

// WindowFrame

// optional .baikaldb.pb.FrameType frame_type = 1;
inline bool WindowFrame::_internal_has_frame_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WindowFrame::has_frame_type() const {
  return _internal_has_frame_type();
}
inline void WindowFrame::clear_frame_type() {
  frame_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::baikaldb::pb::FrameType WindowFrame::_internal_frame_type() const {
  return static_cast< ::baikaldb::pb::FrameType >(frame_type_);
}
inline ::baikaldb::pb::FrameType WindowFrame::frame_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WindowFrame.frame_type)
  return _internal_frame_type();
}
inline void WindowFrame::_internal_set_frame_type(::baikaldb::pb::FrameType value) {
  assert(::baikaldb::pb::FrameType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  frame_type_ = value;
}
inline void WindowFrame::set_frame_type(::baikaldb::pb::FrameType value) {
  _internal_set_frame_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WindowFrame.frame_type)
}

// optional .baikaldb.pb.FrameExtent frame_extent = 2;
inline bool WindowFrame::_internal_has_frame_extent() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || frame_extent_ != nullptr);
  return value;
}
inline bool WindowFrame::has_frame_extent() const {
  return _internal_has_frame_extent();
}
inline void WindowFrame::clear_frame_extent() {
  if (frame_extent_ != nullptr) frame_extent_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::FrameExtent& WindowFrame::_internal_frame_extent() const {
  const ::baikaldb::pb::FrameExtent* p = frame_extent_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::FrameExtent&>(
      ::baikaldb::pb::_FrameExtent_default_instance_);
}
inline const ::baikaldb::pb::FrameExtent& WindowFrame::frame_extent() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WindowFrame.frame_extent)
  return _internal_frame_extent();
}
inline void WindowFrame::unsafe_arena_set_allocated_frame_extent(
    ::baikaldb::pb::FrameExtent* frame_extent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_extent_);
  }
  frame_extent_ = frame_extent;
  if (frame_extent) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.WindowFrame.frame_extent)
}
inline ::baikaldb::pb::FrameExtent* WindowFrame::release_frame_extent() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::FrameExtent* temp = frame_extent_;
  frame_extent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::FrameExtent* WindowFrame::unsafe_arena_release_frame_extent() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WindowFrame.frame_extent)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::FrameExtent* temp = frame_extent_;
  frame_extent_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::FrameExtent* WindowFrame::_internal_mutable_frame_extent() {
  _has_bits_[0] |= 0x00000001u;
  if (frame_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::FrameExtent>(GetArenaForAllocation());
    frame_extent_ = p;
  }
  return frame_extent_;
}
inline ::baikaldb::pb::FrameExtent* WindowFrame::mutable_frame_extent() {
  ::baikaldb::pb::FrameExtent* _msg = _internal_mutable_frame_extent();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WindowFrame.frame_extent)
  return _msg;
}
inline void WindowFrame::set_allocated_frame_extent(::baikaldb::pb::FrameExtent* frame_extent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete frame_extent_;
  }
  if (frame_extent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::FrameExtent>::GetOwningArena(frame_extent);
    if (message_arena != submessage_arena) {
      frame_extent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  frame_extent_ = frame_extent;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WindowFrame.frame_extent)
}

// -------------------------------------------------------------------

// WindowSpec

// repeated .baikaldb.pb.Expr partition_exprs = 1;
inline int WindowSpec::_internal_partition_exprs_size() const {
  return partition_exprs_.size();
}
inline int WindowSpec::partition_exprs_size() const {
  return _internal_partition_exprs_size();
}
inline ::baikaldb::pb::Expr* WindowSpec::mutable_partition_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WindowSpec.partition_exprs)
  return partition_exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
WindowSpec::mutable_partition_exprs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.WindowSpec.partition_exprs)
  return &partition_exprs_;
}
inline const ::baikaldb::pb::Expr& WindowSpec::_internal_partition_exprs(int index) const {
  return partition_exprs_.Get(index);
}
inline const ::baikaldb::pb::Expr& WindowSpec::partition_exprs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WindowSpec.partition_exprs)
  return _internal_partition_exprs(index);
}
inline ::baikaldb::pb::Expr* WindowSpec::_internal_add_partition_exprs() {
  return partition_exprs_.Add();
}
inline ::baikaldb::pb::Expr* WindowSpec::add_partition_exprs() {
  ::baikaldb::pb::Expr* _add = _internal_add_partition_exprs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.WindowSpec.partition_exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
WindowSpec::partition_exprs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.WindowSpec.partition_exprs)
  return partition_exprs_;
}

// repeated .baikaldb.pb.Expr order_exprs = 2;
inline int WindowSpec::_internal_order_exprs_size() const {
  return order_exprs_.size();
}
inline int WindowSpec::order_exprs_size() const {
  return _internal_order_exprs_size();
}
inline ::baikaldb::pb::Expr* WindowSpec::mutable_order_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WindowSpec.order_exprs)
  return order_exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
WindowSpec::mutable_order_exprs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.WindowSpec.order_exprs)
  return &order_exprs_;
}
inline const ::baikaldb::pb::Expr& WindowSpec::_internal_order_exprs(int index) const {
  return order_exprs_.Get(index);
}
inline const ::baikaldb::pb::Expr& WindowSpec::order_exprs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WindowSpec.order_exprs)
  return _internal_order_exprs(index);
}
inline ::baikaldb::pb::Expr* WindowSpec::_internal_add_order_exprs() {
  return order_exprs_.Add();
}
inline ::baikaldb::pb::Expr* WindowSpec::add_order_exprs() {
  ::baikaldb::pb::Expr* _add = _internal_add_order_exprs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.WindowSpec.order_exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
WindowSpec::order_exprs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.WindowSpec.order_exprs)
  return order_exprs_;
}

// repeated bool is_asc = 3;
inline int WindowSpec::_internal_is_asc_size() const {
  return is_asc_.size();
}
inline int WindowSpec::is_asc_size() const {
  return _internal_is_asc_size();
}
inline void WindowSpec::clear_is_asc() {
  is_asc_.Clear();
}
inline bool WindowSpec::_internal_is_asc(int index) const {
  return is_asc_.Get(index);
}
inline bool WindowSpec::is_asc(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WindowSpec.is_asc)
  return _internal_is_asc(index);
}
inline void WindowSpec::set_is_asc(int index, bool value) {
  is_asc_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WindowSpec.is_asc)
}
inline void WindowSpec::_internal_add_is_asc(bool value) {
  is_asc_.Add(value);
}
inline void WindowSpec::add_is_asc(bool value) {
  _internal_add_is_asc(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.WindowSpec.is_asc)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
WindowSpec::_internal_is_asc() const {
  return is_asc_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
WindowSpec::is_asc() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.WindowSpec.is_asc)
  return _internal_is_asc();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
WindowSpec::_internal_mutable_is_asc() {
  return &is_asc_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
WindowSpec::mutable_is_asc() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.WindowSpec.is_asc)
  return _internal_mutable_is_asc();
}

// optional int32 tuple_id = 4;
inline bool WindowSpec::_internal_has_tuple_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WindowSpec::has_tuple_id() const {
  return _internal_has_tuple_id();
}
inline void WindowSpec::clear_tuple_id() {
  tuple_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WindowSpec::_internal_tuple_id() const {
  return tuple_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 WindowSpec::tuple_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WindowSpec.tuple_id)
  return _internal_tuple_id();
}
inline void WindowSpec::_internal_set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  tuple_id_ = value;
}
inline void WindowSpec::set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tuple_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WindowSpec.tuple_id)
}

// optional .baikaldb.pb.WindowFrame window_frame = 5;
inline bool WindowSpec::_internal_has_window_frame() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || window_frame_ != nullptr);
  return value;
}
inline bool WindowSpec::has_window_frame() const {
  return _internal_has_window_frame();
}
inline void WindowSpec::clear_window_frame() {
  if (window_frame_ != nullptr) window_frame_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::WindowFrame& WindowSpec::_internal_window_frame() const {
  const ::baikaldb::pb::WindowFrame* p = window_frame_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::WindowFrame&>(
      ::baikaldb::pb::_WindowFrame_default_instance_);
}
inline const ::baikaldb::pb::WindowFrame& WindowSpec::window_frame() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WindowSpec.window_frame)
  return _internal_window_frame();
}
inline void WindowSpec::unsafe_arena_set_allocated_window_frame(
    ::baikaldb::pb::WindowFrame* window_frame) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(window_frame_);
  }
  window_frame_ = window_frame;
  if (window_frame) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.WindowSpec.window_frame)
}
inline ::baikaldb::pb::WindowFrame* WindowSpec::release_window_frame() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::WindowFrame* temp = window_frame_;
  window_frame_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::WindowFrame* WindowSpec::unsafe_arena_release_window_frame() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WindowSpec.window_frame)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::WindowFrame* temp = window_frame_;
  window_frame_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::WindowFrame* WindowSpec::_internal_mutable_window_frame() {
  _has_bits_[0] |= 0x00000001u;
  if (window_frame_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::WindowFrame>(GetArenaForAllocation());
    window_frame_ = p;
  }
  return window_frame_;
}
inline ::baikaldb::pb::WindowFrame* WindowSpec::mutable_window_frame() {
  ::baikaldb::pb::WindowFrame* _msg = _internal_mutable_window_frame();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WindowSpec.window_frame)
  return _msg;
}
inline void WindowSpec::set_allocated_window_frame(::baikaldb::pb::WindowFrame* window_frame) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete window_frame_;
  }
  if (window_frame) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::WindowFrame>::GetOwningArena(window_frame);
    if (message_arena != submessage_arena) {
      window_frame = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, window_frame, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  window_frame_ = window_frame;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WindowSpec.window_frame)
}

// -------------------------------------------------------------------

// WindowNode

// repeated .baikaldb.pb.Expr func_exprs = 1;
inline int WindowNode::_internal_func_exprs_size() const {
  return func_exprs_.size();
}
inline int WindowNode::func_exprs_size() const {
  return _internal_func_exprs_size();
}
inline ::baikaldb::pb::Expr* WindowNode::mutable_func_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WindowNode.func_exprs)
  return func_exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
WindowNode::mutable_func_exprs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.WindowNode.func_exprs)
  return &func_exprs_;
}
inline const ::baikaldb::pb::Expr& WindowNode::_internal_func_exprs(int index) const {
  return func_exprs_.Get(index);
}
inline const ::baikaldb::pb::Expr& WindowNode::func_exprs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WindowNode.func_exprs)
  return _internal_func_exprs(index);
}
inline ::baikaldb::pb::Expr* WindowNode::_internal_add_func_exprs() {
  return func_exprs_.Add();
}
inline ::baikaldb::pb::Expr* WindowNode::add_func_exprs() {
  ::baikaldb::pb::Expr* _add = _internal_add_func_exprs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.WindowNode.func_exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
WindowNode::func_exprs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.WindowNode.func_exprs)
  return func_exprs_;
}

// optional .baikaldb.pb.WindowSpec window_spec = 2;
inline bool WindowNode::_internal_has_window_spec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || window_spec_ != nullptr);
  return value;
}
inline bool WindowNode::has_window_spec() const {
  return _internal_has_window_spec();
}
inline void WindowNode::clear_window_spec() {
  if (window_spec_ != nullptr) window_spec_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::WindowSpec& WindowNode::_internal_window_spec() const {
  const ::baikaldb::pb::WindowSpec* p = window_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::WindowSpec&>(
      ::baikaldb::pb::_WindowSpec_default_instance_);
}
inline const ::baikaldb::pb::WindowSpec& WindowNode::window_spec() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WindowNode.window_spec)
  return _internal_window_spec();
}
inline void WindowNode::unsafe_arena_set_allocated_window_spec(
    ::baikaldb::pb::WindowSpec* window_spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(window_spec_);
  }
  window_spec_ = window_spec;
  if (window_spec) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.WindowNode.window_spec)
}
inline ::baikaldb::pb::WindowSpec* WindowNode::release_window_spec() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::WindowSpec* temp = window_spec_;
  window_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::WindowSpec* WindowNode::unsafe_arena_release_window_spec() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WindowNode.window_spec)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::WindowSpec* temp = window_spec_;
  window_spec_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::WindowSpec* WindowNode::_internal_mutable_window_spec() {
  _has_bits_[0] |= 0x00000001u;
  if (window_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::WindowSpec>(GetArenaForAllocation());
    window_spec_ = p;
  }
  return window_spec_;
}
inline ::baikaldb::pb::WindowSpec* WindowNode::mutable_window_spec() {
  ::baikaldb::pb::WindowSpec* _msg = _internal_mutable_window_spec();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WindowNode.window_spec)
  return _msg;
}
inline void WindowNode::set_allocated_window_spec(::baikaldb::pb::WindowSpec* window_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete window_spec_;
  }
  if (window_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::WindowSpec>::GetOwningArena(window_spec);
    if (message_arena != submessage_arena) {
      window_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, window_spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  window_spec_ = window_spec;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WindowNode.window_spec)
}

// -------------------------------------------------------------------

// DerivePlanNode

// optional .baikaldb.pb.ScanNode scan_node = 1;
inline bool DerivePlanNode::_internal_has_scan_node() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || scan_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_scan_node() const {
  return _internal_has_scan_node();
}
inline void DerivePlanNode::clear_scan_node() {
  if (scan_node_ != nullptr) scan_node_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::baikaldb::pb::ScanNode& DerivePlanNode::_internal_scan_node() const {
  const ::baikaldb::pb::ScanNode* p = scan_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::ScanNode&>(
      ::baikaldb::pb::_ScanNode_default_instance_);
}
inline const ::baikaldb::pb::ScanNode& DerivePlanNode::scan_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.scan_node)
  return _internal_scan_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_scan_node(
    ::baikaldb::pb::ScanNode* scan_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scan_node_);
  }
  scan_node_ = scan_node;
  if (scan_node) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.scan_node)
}
inline ::baikaldb::pb::ScanNode* DerivePlanNode::release_scan_node() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::ScanNode* temp = scan_node_;
  scan_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::ScanNode* DerivePlanNode::unsafe_arena_release_scan_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.scan_node)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::ScanNode* temp = scan_node_;
  scan_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::ScanNode* DerivePlanNode::_internal_mutable_scan_node() {
  _has_bits_[0] |= 0x00000002u;
  if (scan_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::ScanNode>(GetArenaForAllocation());
    scan_node_ = p;
  }
  return scan_node_;
}
inline ::baikaldb::pb::ScanNode* DerivePlanNode::mutable_scan_node() {
  ::baikaldb::pb::ScanNode* _msg = _internal_mutable_scan_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.scan_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_scan_node(::baikaldb::pb::ScanNode* scan_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete scan_node_;
  }
  if (scan_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::ScanNode>::GetOwningArena(scan_node);
    if (message_arena != submessage_arena) {
      scan_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scan_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  scan_node_ = scan_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.scan_node)
}

// optional .baikaldb.pb.SortNode sort_node = 2;
inline bool DerivePlanNode::_internal_has_sort_node() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || sort_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_sort_node() const {
  return _internal_has_sort_node();
}
inline void DerivePlanNode::clear_sort_node() {
  if (sort_node_ != nullptr) sort_node_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::baikaldb::pb::SortNode& DerivePlanNode::_internal_sort_node() const {
  const ::baikaldb::pb::SortNode* p = sort_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::SortNode&>(
      ::baikaldb::pb::_SortNode_default_instance_);
}
inline const ::baikaldb::pb::SortNode& DerivePlanNode::sort_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.sort_node)
  return _internal_sort_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_sort_node(
    ::baikaldb::pb::SortNode* sort_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sort_node_);
  }
  sort_node_ = sort_node;
  if (sort_node) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.sort_node)
}
inline ::baikaldb::pb::SortNode* DerivePlanNode::release_sort_node() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::SortNode* temp = sort_node_;
  sort_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::SortNode* DerivePlanNode::unsafe_arena_release_sort_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.sort_node)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::SortNode* temp = sort_node_;
  sort_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::SortNode* DerivePlanNode::_internal_mutable_sort_node() {
  _has_bits_[0] |= 0x00000004u;
  if (sort_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::SortNode>(GetArenaForAllocation());
    sort_node_ = p;
  }
  return sort_node_;
}
inline ::baikaldb::pb::SortNode* DerivePlanNode::mutable_sort_node() {
  ::baikaldb::pb::SortNode* _msg = _internal_mutable_sort_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.sort_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_sort_node(::baikaldb::pb::SortNode* sort_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sort_node_;
  }
  if (sort_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::SortNode>::GetOwningArena(sort_node);
    if (message_arena != submessage_arena) {
      sort_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sort_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  sort_node_ = sort_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.sort_node)
}

// optional .baikaldb.pb.AggNode agg_node = 3;
inline bool DerivePlanNode::_internal_has_agg_node() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || agg_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_agg_node() const {
  return _internal_has_agg_node();
}
inline void DerivePlanNode::clear_agg_node() {
  if (agg_node_ != nullptr) agg_node_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::baikaldb::pb::AggNode& DerivePlanNode::_internal_agg_node() const {
  const ::baikaldb::pb::AggNode* p = agg_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::AggNode&>(
      ::baikaldb::pb::_AggNode_default_instance_);
}
inline const ::baikaldb::pb::AggNode& DerivePlanNode::agg_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.agg_node)
  return _internal_agg_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_agg_node(
    ::baikaldb::pb::AggNode* agg_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(agg_node_);
  }
  agg_node_ = agg_node;
  if (agg_node) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.agg_node)
}
inline ::baikaldb::pb::AggNode* DerivePlanNode::release_agg_node() {
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::AggNode* temp = agg_node_;
  agg_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::AggNode* DerivePlanNode::unsafe_arena_release_agg_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.agg_node)
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::AggNode* temp = agg_node_;
  agg_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::AggNode* DerivePlanNode::_internal_mutable_agg_node() {
  _has_bits_[0] |= 0x00000008u;
  if (agg_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::AggNode>(GetArenaForAllocation());
    agg_node_ = p;
  }
  return agg_node_;
}
inline ::baikaldb::pb::AggNode* DerivePlanNode::mutable_agg_node() {
  ::baikaldb::pb::AggNode* _msg = _internal_mutable_agg_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.agg_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_agg_node(::baikaldb::pb::AggNode* agg_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete agg_node_;
  }
  if (agg_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::AggNode>::GetOwningArena(agg_node);
    if (message_arena != submessage_arena) {
      agg_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, agg_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  agg_node_ = agg_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.agg_node)
}

// optional bytes filter_node = 4;
inline bool DerivePlanNode::_internal_has_filter_node() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DerivePlanNode::has_filter_node() const {
  return _internal_has_filter_node();
}
inline void DerivePlanNode::clear_filter_node() {
  filter_node_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DerivePlanNode::filter_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.filter_node)
  return _internal_filter_node();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DerivePlanNode::set_filter_node(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 filter_node_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DerivePlanNode.filter_node)
}
inline std::string* DerivePlanNode::mutable_filter_node() {
  std::string* _s = _internal_mutable_filter_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.filter_node)
  return _s;
}
inline const std::string& DerivePlanNode::_internal_filter_node() const {
  return filter_node_.Get();
}
inline void DerivePlanNode::_internal_set_filter_node(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filter_node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DerivePlanNode::_internal_mutable_filter_node() {
  _has_bits_[0] |= 0x00000001u;
  return filter_node_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DerivePlanNode::release_filter_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.filter_node)
  if (!_internal_has_filter_node()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return filter_node_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DerivePlanNode::set_allocated_filter_node(std::string* filter_node) {
  if (filter_node != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filter_node_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filter_node,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.filter_node)
}

// optional .baikaldb.pb.JoinNode join_node = 5;
inline bool DerivePlanNode::_internal_has_join_node() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || join_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_join_node() const {
  return _internal_has_join_node();
}
inline void DerivePlanNode::clear_join_node() {
  if (join_node_ != nullptr) join_node_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::baikaldb::pb::JoinNode& DerivePlanNode::_internal_join_node() const {
  const ::baikaldb::pb::JoinNode* p = join_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::JoinNode&>(
      ::baikaldb::pb::_JoinNode_default_instance_);
}
inline const ::baikaldb::pb::JoinNode& DerivePlanNode::join_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.join_node)
  return _internal_join_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_join_node(
    ::baikaldb::pb::JoinNode* join_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(join_node_);
  }
  join_node_ = join_node;
  if (join_node) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.join_node)
}
inline ::baikaldb::pb::JoinNode* DerivePlanNode::release_join_node() {
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::JoinNode* temp = join_node_;
  join_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::JoinNode* DerivePlanNode::unsafe_arena_release_join_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.join_node)
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::JoinNode* temp = join_node_;
  join_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::JoinNode* DerivePlanNode::_internal_mutable_join_node() {
  _has_bits_[0] |= 0x00000010u;
  if (join_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::JoinNode>(GetArenaForAllocation());
    join_node_ = p;
  }
  return join_node_;
}
inline ::baikaldb::pb::JoinNode* DerivePlanNode::mutable_join_node() {
  ::baikaldb::pb::JoinNode* _msg = _internal_mutable_join_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.join_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_join_node(::baikaldb::pb::JoinNode* join_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete join_node_;
  }
  if (join_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::JoinNode>::GetOwningArena(join_node);
    if (message_arena != submessage_arena) {
      join_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, join_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  join_node_ = join_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.join_node)
}

// optional .baikaldb.pb.InsertNode insert_node = 6;
inline bool DerivePlanNode::_internal_has_insert_node() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || insert_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_insert_node() const {
  return _internal_has_insert_node();
}
inline void DerivePlanNode::clear_insert_node() {
  if (insert_node_ != nullptr) insert_node_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::baikaldb::pb::InsertNode& DerivePlanNode::_internal_insert_node() const {
  const ::baikaldb::pb::InsertNode* p = insert_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::InsertNode&>(
      ::baikaldb::pb::_InsertNode_default_instance_);
}
inline const ::baikaldb::pb::InsertNode& DerivePlanNode::insert_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.insert_node)
  return _internal_insert_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_insert_node(
    ::baikaldb::pb::InsertNode* insert_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(insert_node_);
  }
  insert_node_ = insert_node;
  if (insert_node) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.insert_node)
}
inline ::baikaldb::pb::InsertNode* DerivePlanNode::release_insert_node() {
  _has_bits_[0] &= ~0x00000020u;
  ::baikaldb::pb::InsertNode* temp = insert_node_;
  insert_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::InsertNode* DerivePlanNode::unsafe_arena_release_insert_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.insert_node)
  _has_bits_[0] &= ~0x00000020u;
  ::baikaldb::pb::InsertNode* temp = insert_node_;
  insert_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::InsertNode* DerivePlanNode::_internal_mutable_insert_node() {
  _has_bits_[0] |= 0x00000020u;
  if (insert_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::InsertNode>(GetArenaForAllocation());
    insert_node_ = p;
  }
  return insert_node_;
}
inline ::baikaldb::pb::InsertNode* DerivePlanNode::mutable_insert_node() {
  ::baikaldb::pb::InsertNode* _msg = _internal_mutable_insert_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.insert_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_insert_node(::baikaldb::pb::InsertNode* insert_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete insert_node_;
  }
  if (insert_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::InsertNode>::GetOwningArena(insert_node);
    if (message_arena != submessage_arena) {
      insert_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, insert_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  insert_node_ = insert_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.insert_node)
}

// optional .baikaldb.pb.DeleteNode delete_node = 7;
inline bool DerivePlanNode::_internal_has_delete_node() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || delete_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_delete_node() const {
  return _internal_has_delete_node();
}
inline void DerivePlanNode::clear_delete_node() {
  if (delete_node_ != nullptr) delete_node_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::baikaldb::pb::DeleteNode& DerivePlanNode::_internal_delete_node() const {
  const ::baikaldb::pb::DeleteNode* p = delete_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::DeleteNode&>(
      ::baikaldb::pb::_DeleteNode_default_instance_);
}
inline const ::baikaldb::pb::DeleteNode& DerivePlanNode::delete_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.delete_node)
  return _internal_delete_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_delete_node(
    ::baikaldb::pb::DeleteNode* delete_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(delete_node_);
  }
  delete_node_ = delete_node;
  if (delete_node) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.delete_node)
}
inline ::baikaldb::pb::DeleteNode* DerivePlanNode::release_delete_node() {
  _has_bits_[0] &= ~0x00000040u;
  ::baikaldb::pb::DeleteNode* temp = delete_node_;
  delete_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::DeleteNode* DerivePlanNode::unsafe_arena_release_delete_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.delete_node)
  _has_bits_[0] &= ~0x00000040u;
  ::baikaldb::pb::DeleteNode* temp = delete_node_;
  delete_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::DeleteNode* DerivePlanNode::_internal_mutable_delete_node() {
  _has_bits_[0] |= 0x00000040u;
  if (delete_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::DeleteNode>(GetArenaForAllocation());
    delete_node_ = p;
  }
  return delete_node_;
}
inline ::baikaldb::pb::DeleteNode* DerivePlanNode::mutable_delete_node() {
  ::baikaldb::pb::DeleteNode* _msg = _internal_mutable_delete_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.delete_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_delete_node(::baikaldb::pb::DeleteNode* delete_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete delete_node_;
  }
  if (delete_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::DeleteNode>::GetOwningArena(delete_node);
    if (message_arena != submessage_arena) {
      delete_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delete_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  delete_node_ = delete_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.delete_node)
}

// optional .baikaldb.pb.UpdateNode update_node = 8;
inline bool DerivePlanNode::_internal_has_update_node() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || update_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_update_node() const {
  return _internal_has_update_node();
}
inline void DerivePlanNode::clear_update_node() {
  if (update_node_ != nullptr) update_node_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::baikaldb::pb::UpdateNode& DerivePlanNode::_internal_update_node() const {
  const ::baikaldb::pb::UpdateNode* p = update_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::UpdateNode&>(
      ::baikaldb::pb::_UpdateNode_default_instance_);
}
inline const ::baikaldb::pb::UpdateNode& DerivePlanNode::update_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.update_node)
  return _internal_update_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_update_node(
    ::baikaldb::pb::UpdateNode* update_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_node_);
  }
  update_node_ = update_node;
  if (update_node) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.update_node)
}
inline ::baikaldb::pb::UpdateNode* DerivePlanNode::release_update_node() {
  _has_bits_[0] &= ~0x00000080u;
  ::baikaldb::pb::UpdateNode* temp = update_node_;
  update_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::UpdateNode* DerivePlanNode::unsafe_arena_release_update_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.update_node)
  _has_bits_[0] &= ~0x00000080u;
  ::baikaldb::pb::UpdateNode* temp = update_node_;
  update_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::UpdateNode* DerivePlanNode::_internal_mutable_update_node() {
  _has_bits_[0] |= 0x00000080u;
  if (update_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::UpdateNode>(GetArenaForAllocation());
    update_node_ = p;
  }
  return update_node_;
}
inline ::baikaldb::pb::UpdateNode* DerivePlanNode::mutable_update_node() {
  ::baikaldb::pb::UpdateNode* _msg = _internal_mutable_update_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.update_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_update_node(::baikaldb::pb::UpdateNode* update_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete update_node_;
  }
  if (update_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::UpdateNode>::GetOwningArena(update_node);
    if (message_arena != submessage_arena) {
      update_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  update_node_ = update_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.update_node)
}

// optional .baikaldb.pb.FetcherNode fetcher_node = 9;
inline bool DerivePlanNode::_internal_has_fetcher_node() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || fetcher_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_fetcher_node() const {
  return _internal_has_fetcher_node();
}
inline void DerivePlanNode::clear_fetcher_node() {
  if (fetcher_node_ != nullptr) fetcher_node_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::baikaldb::pb::FetcherNode& DerivePlanNode::_internal_fetcher_node() const {
  const ::baikaldb::pb::FetcherNode* p = fetcher_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::FetcherNode&>(
      ::baikaldb::pb::_FetcherNode_default_instance_);
}
inline const ::baikaldb::pb::FetcherNode& DerivePlanNode::fetcher_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.fetcher_node)
  return _internal_fetcher_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_fetcher_node(
    ::baikaldb::pb::FetcherNode* fetcher_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fetcher_node_);
  }
  fetcher_node_ = fetcher_node;
  if (fetcher_node) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.fetcher_node)
}
inline ::baikaldb::pb::FetcherNode* DerivePlanNode::release_fetcher_node() {
  _has_bits_[0] &= ~0x00000100u;
  ::baikaldb::pb::FetcherNode* temp = fetcher_node_;
  fetcher_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::FetcherNode* DerivePlanNode::unsafe_arena_release_fetcher_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.fetcher_node)
  _has_bits_[0] &= ~0x00000100u;
  ::baikaldb::pb::FetcherNode* temp = fetcher_node_;
  fetcher_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::FetcherNode* DerivePlanNode::_internal_mutable_fetcher_node() {
  _has_bits_[0] |= 0x00000100u;
  if (fetcher_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::FetcherNode>(GetArenaForAllocation());
    fetcher_node_ = p;
  }
  return fetcher_node_;
}
inline ::baikaldb::pb::FetcherNode* DerivePlanNode::mutable_fetcher_node() {
  ::baikaldb::pb::FetcherNode* _msg = _internal_mutable_fetcher_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.fetcher_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_fetcher_node(::baikaldb::pb::FetcherNode* fetcher_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fetcher_node_;
  }
  if (fetcher_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::FetcherNode>::GetOwningArena(fetcher_node);
    if (message_arena != submessage_arena) {
      fetcher_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fetcher_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  fetcher_node_ = fetcher_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.fetcher_node)
}

// optional .baikaldb.pb.LimitNode limit_node = 10;
inline bool DerivePlanNode::_internal_has_limit_node() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || limit_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_limit_node() const {
  return _internal_has_limit_node();
}
inline void DerivePlanNode::clear_limit_node() {
  if (limit_node_ != nullptr) limit_node_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::baikaldb::pb::LimitNode& DerivePlanNode::_internal_limit_node() const {
  const ::baikaldb::pb::LimitNode* p = limit_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::LimitNode&>(
      ::baikaldb::pb::_LimitNode_default_instance_);
}
inline const ::baikaldb::pb::LimitNode& DerivePlanNode::limit_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.limit_node)
  return _internal_limit_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_limit_node(
    ::baikaldb::pb::LimitNode* limit_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(limit_node_);
  }
  limit_node_ = limit_node;
  if (limit_node) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.limit_node)
}
inline ::baikaldb::pb::LimitNode* DerivePlanNode::release_limit_node() {
  _has_bits_[0] &= ~0x00000200u;
  ::baikaldb::pb::LimitNode* temp = limit_node_;
  limit_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::LimitNode* DerivePlanNode::unsafe_arena_release_limit_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.limit_node)
  _has_bits_[0] &= ~0x00000200u;
  ::baikaldb::pb::LimitNode* temp = limit_node_;
  limit_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::LimitNode* DerivePlanNode::_internal_mutable_limit_node() {
  _has_bits_[0] |= 0x00000200u;
  if (limit_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::LimitNode>(GetArenaForAllocation());
    limit_node_ = p;
  }
  return limit_node_;
}
inline ::baikaldb::pb::LimitNode* DerivePlanNode::mutable_limit_node() {
  ::baikaldb::pb::LimitNode* _msg = _internal_mutable_limit_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.limit_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_limit_node(::baikaldb::pb::LimitNode* limit_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete limit_node_;
  }
  if (limit_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::LimitNode>::GetOwningArena(limit_node);
    if (message_arena != submessage_arena) {
      limit_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limit_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  limit_node_ = limit_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.limit_node)
}

// optional .baikaldb.pb.PacketNode packet_node = 11;
inline bool DerivePlanNode::_internal_has_packet_node() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || packet_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_packet_node() const {
  return _internal_has_packet_node();
}
inline void DerivePlanNode::clear_packet_node() {
  if (packet_node_ != nullptr) packet_node_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::baikaldb::pb::PacketNode& DerivePlanNode::_internal_packet_node() const {
  const ::baikaldb::pb::PacketNode* p = packet_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::PacketNode&>(
      ::baikaldb::pb::_PacketNode_default_instance_);
}
inline const ::baikaldb::pb::PacketNode& DerivePlanNode::packet_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.packet_node)
  return _internal_packet_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_packet_node(
    ::baikaldb::pb::PacketNode* packet_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(packet_node_);
  }
  packet_node_ = packet_node;
  if (packet_node) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.packet_node)
}
inline ::baikaldb::pb::PacketNode* DerivePlanNode::release_packet_node() {
  _has_bits_[0] &= ~0x00000400u;
  ::baikaldb::pb::PacketNode* temp = packet_node_;
  packet_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::PacketNode* DerivePlanNode::unsafe_arena_release_packet_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.packet_node)
  _has_bits_[0] &= ~0x00000400u;
  ::baikaldb::pb::PacketNode* temp = packet_node_;
  packet_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::PacketNode* DerivePlanNode::_internal_mutable_packet_node() {
  _has_bits_[0] |= 0x00000400u;
  if (packet_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::PacketNode>(GetArenaForAllocation());
    packet_node_ = p;
  }
  return packet_node_;
}
inline ::baikaldb::pb::PacketNode* DerivePlanNode::mutable_packet_node() {
  ::baikaldb::pb::PacketNode* _msg = _internal_mutable_packet_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.packet_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_packet_node(::baikaldb::pb::PacketNode* packet_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete packet_node_;
  }
  if (packet_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::PacketNode>::GetOwningArena(packet_node);
    if (message_arena != submessage_arena) {
      packet_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, packet_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  packet_node_ = packet_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.packet_node)
}

// optional .baikaldb.pb.TruncateNode truncate_node = 12;
inline bool DerivePlanNode::_internal_has_truncate_node() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || truncate_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_truncate_node() const {
  return _internal_has_truncate_node();
}
inline void DerivePlanNode::clear_truncate_node() {
  if (truncate_node_ != nullptr) truncate_node_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::baikaldb::pb::TruncateNode& DerivePlanNode::_internal_truncate_node() const {
  const ::baikaldb::pb::TruncateNode* p = truncate_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::TruncateNode&>(
      ::baikaldb::pb::_TruncateNode_default_instance_);
}
inline const ::baikaldb::pb::TruncateNode& DerivePlanNode::truncate_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.truncate_node)
  return _internal_truncate_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_truncate_node(
    ::baikaldb::pb::TruncateNode* truncate_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(truncate_node_);
  }
  truncate_node_ = truncate_node;
  if (truncate_node) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.truncate_node)
}
inline ::baikaldb::pb::TruncateNode* DerivePlanNode::release_truncate_node() {
  _has_bits_[0] &= ~0x00000800u;
  ::baikaldb::pb::TruncateNode* temp = truncate_node_;
  truncate_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::TruncateNode* DerivePlanNode::unsafe_arena_release_truncate_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.truncate_node)
  _has_bits_[0] &= ~0x00000800u;
  ::baikaldb::pb::TruncateNode* temp = truncate_node_;
  truncate_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::TruncateNode* DerivePlanNode::_internal_mutable_truncate_node() {
  _has_bits_[0] |= 0x00000800u;
  if (truncate_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::TruncateNode>(GetArenaForAllocation());
    truncate_node_ = p;
  }
  return truncate_node_;
}
inline ::baikaldb::pb::TruncateNode* DerivePlanNode::mutable_truncate_node() {
  ::baikaldb::pb::TruncateNode* _msg = _internal_mutable_truncate_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.truncate_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_truncate_node(::baikaldb::pb::TruncateNode* truncate_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete truncate_node_;
  }
  if (truncate_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::TruncateNode>::GetOwningArena(truncate_node);
    if (message_arena != submessage_arena) {
      truncate_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, truncate_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  truncate_node_ = truncate_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.truncate_node)
}

// optional .baikaldb.pb.TransactionNode transaction_node = 13;
inline bool DerivePlanNode::_internal_has_transaction_node() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || transaction_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_transaction_node() const {
  return _internal_has_transaction_node();
}
inline void DerivePlanNode::clear_transaction_node() {
  if (transaction_node_ != nullptr) transaction_node_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::baikaldb::pb::TransactionNode& DerivePlanNode::_internal_transaction_node() const {
  const ::baikaldb::pb::TransactionNode* p = transaction_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::TransactionNode&>(
      ::baikaldb::pb::_TransactionNode_default_instance_);
}
inline const ::baikaldb::pb::TransactionNode& DerivePlanNode::transaction_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.transaction_node)
  return _internal_transaction_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_transaction_node(
    ::baikaldb::pb::TransactionNode* transaction_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_node_);
  }
  transaction_node_ = transaction_node;
  if (transaction_node) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.transaction_node)
}
inline ::baikaldb::pb::TransactionNode* DerivePlanNode::release_transaction_node() {
  _has_bits_[0] &= ~0x00001000u;
  ::baikaldb::pb::TransactionNode* temp = transaction_node_;
  transaction_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::TransactionNode* DerivePlanNode::unsafe_arena_release_transaction_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.transaction_node)
  _has_bits_[0] &= ~0x00001000u;
  ::baikaldb::pb::TransactionNode* temp = transaction_node_;
  transaction_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::TransactionNode* DerivePlanNode::_internal_mutable_transaction_node() {
  _has_bits_[0] |= 0x00001000u;
  if (transaction_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::TransactionNode>(GetArenaForAllocation());
    transaction_node_ = p;
  }
  return transaction_node_;
}
inline ::baikaldb::pb::TransactionNode* DerivePlanNode::mutable_transaction_node() {
  ::baikaldb::pb::TransactionNode* _msg = _internal_mutable_transaction_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.transaction_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_transaction_node(::baikaldb::pb::TransactionNode* transaction_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transaction_node_;
  }
  if (transaction_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::TransactionNode>::GetOwningArena(transaction_node);
    if (message_arena != submessage_arena) {
      transaction_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  transaction_node_ = transaction_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.transaction_node)
}

// optional .baikaldb.pb.KillNode kill_node = 14;
inline bool DerivePlanNode::_internal_has_kill_node() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || kill_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_kill_node() const {
  return _internal_has_kill_node();
}
inline void DerivePlanNode::clear_kill_node() {
  if (kill_node_ != nullptr) kill_node_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::baikaldb::pb::KillNode& DerivePlanNode::_internal_kill_node() const {
  const ::baikaldb::pb::KillNode* p = kill_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::KillNode&>(
      ::baikaldb::pb::_KillNode_default_instance_);
}
inline const ::baikaldb::pb::KillNode& DerivePlanNode::kill_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.kill_node)
  return _internal_kill_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_kill_node(
    ::baikaldb::pb::KillNode* kill_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kill_node_);
  }
  kill_node_ = kill_node;
  if (kill_node) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.kill_node)
}
inline ::baikaldb::pb::KillNode* DerivePlanNode::release_kill_node() {
  _has_bits_[0] &= ~0x00002000u;
  ::baikaldb::pb::KillNode* temp = kill_node_;
  kill_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::KillNode* DerivePlanNode::unsafe_arena_release_kill_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.kill_node)
  _has_bits_[0] &= ~0x00002000u;
  ::baikaldb::pb::KillNode* temp = kill_node_;
  kill_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::KillNode* DerivePlanNode::_internal_mutable_kill_node() {
  _has_bits_[0] |= 0x00002000u;
  if (kill_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::KillNode>(GetArenaForAllocation());
    kill_node_ = p;
  }
  return kill_node_;
}
inline ::baikaldb::pb::KillNode* DerivePlanNode::mutable_kill_node() {
  ::baikaldb::pb::KillNode* _msg = _internal_mutable_kill_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.kill_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_kill_node(::baikaldb::pb::KillNode* kill_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kill_node_;
  }
  if (kill_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::KillNode>::GetOwningArena(kill_node);
    if (message_arena != submessage_arena) {
      kill_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kill_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  kill_node_ = kill_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.kill_node)
}

// optional .baikaldb.pb.LockPrimaryNode lock_primary_node = 15;
inline bool DerivePlanNode::_internal_has_lock_primary_node() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || lock_primary_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_lock_primary_node() const {
  return _internal_has_lock_primary_node();
}
inline void DerivePlanNode::clear_lock_primary_node() {
  if (lock_primary_node_ != nullptr) lock_primary_node_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::baikaldb::pb::LockPrimaryNode& DerivePlanNode::_internal_lock_primary_node() const {
  const ::baikaldb::pb::LockPrimaryNode* p = lock_primary_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::LockPrimaryNode&>(
      ::baikaldb::pb::_LockPrimaryNode_default_instance_);
}
inline const ::baikaldb::pb::LockPrimaryNode& DerivePlanNode::lock_primary_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.lock_primary_node)
  return _internal_lock_primary_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_lock_primary_node(
    ::baikaldb::pb::LockPrimaryNode* lock_primary_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lock_primary_node_);
  }
  lock_primary_node_ = lock_primary_node;
  if (lock_primary_node) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.lock_primary_node)
}
inline ::baikaldb::pb::LockPrimaryNode* DerivePlanNode::release_lock_primary_node() {
  _has_bits_[0] &= ~0x00004000u;
  ::baikaldb::pb::LockPrimaryNode* temp = lock_primary_node_;
  lock_primary_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::LockPrimaryNode* DerivePlanNode::unsafe_arena_release_lock_primary_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.lock_primary_node)
  _has_bits_[0] &= ~0x00004000u;
  ::baikaldb::pb::LockPrimaryNode* temp = lock_primary_node_;
  lock_primary_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::LockPrimaryNode* DerivePlanNode::_internal_mutable_lock_primary_node() {
  _has_bits_[0] |= 0x00004000u;
  if (lock_primary_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::LockPrimaryNode>(GetArenaForAllocation());
    lock_primary_node_ = p;
  }
  return lock_primary_node_;
}
inline ::baikaldb::pb::LockPrimaryNode* DerivePlanNode::mutable_lock_primary_node() {
  ::baikaldb::pb::LockPrimaryNode* _msg = _internal_mutable_lock_primary_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.lock_primary_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_lock_primary_node(::baikaldb::pb::LockPrimaryNode* lock_primary_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lock_primary_node_;
  }
  if (lock_primary_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::LockPrimaryNode>::GetOwningArena(lock_primary_node);
    if (message_arena != submessage_arena) {
      lock_primary_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lock_primary_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  lock_primary_node_ = lock_primary_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.lock_primary_node)
}

// optional .baikaldb.pb.LockSecondaryNode lock_secondary_node = 16;
inline bool DerivePlanNode::_internal_has_lock_secondary_node() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || lock_secondary_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_lock_secondary_node() const {
  return _internal_has_lock_secondary_node();
}
inline void DerivePlanNode::clear_lock_secondary_node() {
  if (lock_secondary_node_ != nullptr) lock_secondary_node_->Clear();
  _has_bits_[0] &= ~0x00008000u;
}
inline const ::baikaldb::pb::LockSecondaryNode& DerivePlanNode::_internal_lock_secondary_node() const {
  const ::baikaldb::pb::LockSecondaryNode* p = lock_secondary_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::LockSecondaryNode&>(
      ::baikaldb::pb::_LockSecondaryNode_default_instance_);
}
inline const ::baikaldb::pb::LockSecondaryNode& DerivePlanNode::lock_secondary_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.lock_secondary_node)
  return _internal_lock_secondary_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_lock_secondary_node(
    ::baikaldb::pb::LockSecondaryNode* lock_secondary_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lock_secondary_node_);
  }
  lock_secondary_node_ = lock_secondary_node;
  if (lock_secondary_node) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.lock_secondary_node)
}
inline ::baikaldb::pb::LockSecondaryNode* DerivePlanNode::release_lock_secondary_node() {
  _has_bits_[0] &= ~0x00008000u;
  ::baikaldb::pb::LockSecondaryNode* temp = lock_secondary_node_;
  lock_secondary_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::LockSecondaryNode* DerivePlanNode::unsafe_arena_release_lock_secondary_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.lock_secondary_node)
  _has_bits_[0] &= ~0x00008000u;
  ::baikaldb::pb::LockSecondaryNode* temp = lock_secondary_node_;
  lock_secondary_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::LockSecondaryNode* DerivePlanNode::_internal_mutable_lock_secondary_node() {
  _has_bits_[0] |= 0x00008000u;
  if (lock_secondary_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::LockSecondaryNode>(GetArenaForAllocation());
    lock_secondary_node_ = p;
  }
  return lock_secondary_node_;
}
inline ::baikaldb::pb::LockSecondaryNode* DerivePlanNode::mutable_lock_secondary_node() {
  ::baikaldb::pb::LockSecondaryNode* _msg = _internal_mutable_lock_secondary_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.lock_secondary_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_lock_secondary_node(::baikaldb::pb::LockSecondaryNode* lock_secondary_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lock_secondary_node_;
  }
  if (lock_secondary_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::LockSecondaryNode>::GetOwningArena(lock_secondary_node);
    if (message_arena != submessage_arena) {
      lock_secondary_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lock_secondary_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  lock_secondary_node_ = lock_secondary_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.lock_secondary_node)
}

// optional .baikaldb.pb.UnionNode union_node = 17;
inline bool DerivePlanNode::_internal_has_union_node() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || union_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_union_node() const {
  return _internal_has_union_node();
}
inline void DerivePlanNode::clear_union_node() {
  if (union_node_ != nullptr) union_node_->Clear();
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::baikaldb::pb::UnionNode& DerivePlanNode::_internal_union_node() const {
  const ::baikaldb::pb::UnionNode* p = union_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::UnionNode&>(
      ::baikaldb::pb::_UnionNode_default_instance_);
}
inline const ::baikaldb::pb::UnionNode& DerivePlanNode::union_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.union_node)
  return _internal_union_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_union_node(
    ::baikaldb::pb::UnionNode* union_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(union_node_);
  }
  union_node_ = union_node;
  if (union_node) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.union_node)
}
inline ::baikaldb::pb::UnionNode* DerivePlanNode::release_union_node() {
  _has_bits_[0] &= ~0x00010000u;
  ::baikaldb::pb::UnionNode* temp = union_node_;
  union_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::UnionNode* DerivePlanNode::unsafe_arena_release_union_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.union_node)
  _has_bits_[0] &= ~0x00010000u;
  ::baikaldb::pb::UnionNode* temp = union_node_;
  union_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::UnionNode* DerivePlanNode::_internal_mutable_union_node() {
  _has_bits_[0] |= 0x00010000u;
  if (union_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::UnionNode>(GetArenaForAllocation());
    union_node_ = p;
  }
  return union_node_;
}
inline ::baikaldb::pb::UnionNode* DerivePlanNode::mutable_union_node() {
  ::baikaldb::pb::UnionNode* _msg = _internal_mutable_union_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.union_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_union_node(::baikaldb::pb::UnionNode* union_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete union_node_;
  }
  if (union_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::UnionNode>::GetOwningArena(union_node);
    if (message_arena != submessage_arena) {
      union_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, union_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  union_node_ = union_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.union_node)
}

// optional .baikaldb.pb.ApplyNode apply_node = 18;
inline bool DerivePlanNode::_internal_has_apply_node() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || apply_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_apply_node() const {
  return _internal_has_apply_node();
}
inline void DerivePlanNode::clear_apply_node() {
  if (apply_node_ != nullptr) apply_node_->Clear();
  _has_bits_[0] &= ~0x00020000u;
}
inline const ::baikaldb::pb::ApplyNode& DerivePlanNode::_internal_apply_node() const {
  const ::baikaldb::pb::ApplyNode* p = apply_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::ApplyNode&>(
      ::baikaldb::pb::_ApplyNode_default_instance_);
}
inline const ::baikaldb::pb::ApplyNode& DerivePlanNode::apply_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.apply_node)
  return _internal_apply_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_apply_node(
    ::baikaldb::pb::ApplyNode* apply_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(apply_node_);
  }
  apply_node_ = apply_node;
  if (apply_node) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.apply_node)
}
inline ::baikaldb::pb::ApplyNode* DerivePlanNode::release_apply_node() {
  _has_bits_[0] &= ~0x00020000u;
  ::baikaldb::pb::ApplyNode* temp = apply_node_;
  apply_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::ApplyNode* DerivePlanNode::unsafe_arena_release_apply_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.apply_node)
  _has_bits_[0] &= ~0x00020000u;
  ::baikaldb::pb::ApplyNode* temp = apply_node_;
  apply_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::ApplyNode* DerivePlanNode::_internal_mutable_apply_node() {
  _has_bits_[0] |= 0x00020000u;
  if (apply_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::ApplyNode>(GetArenaForAllocation());
    apply_node_ = p;
  }
  return apply_node_;
}
inline ::baikaldb::pb::ApplyNode* DerivePlanNode::mutable_apply_node() {
  ::baikaldb::pb::ApplyNode* _msg = _internal_mutable_apply_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.apply_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_apply_node(::baikaldb::pb::ApplyNode* apply_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete apply_node_;
  }
  if (apply_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::ApplyNode>::GetOwningArena(apply_node);
    if (message_arena != submessage_arena) {
      apply_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, apply_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  apply_node_ = apply_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.apply_node)
}

// optional .baikaldb.pb.LoadNode load_node = 19;
inline bool DerivePlanNode::_internal_has_load_node() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || load_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_load_node() const {
  return _internal_has_load_node();
}
inline void DerivePlanNode::clear_load_node() {
  if (load_node_ != nullptr) load_node_->Clear();
  _has_bits_[0] &= ~0x00040000u;
}
inline const ::baikaldb::pb::LoadNode& DerivePlanNode::_internal_load_node() const {
  const ::baikaldb::pb::LoadNode* p = load_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::LoadNode&>(
      ::baikaldb::pb::_LoadNode_default_instance_);
}
inline const ::baikaldb::pb::LoadNode& DerivePlanNode::load_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.load_node)
  return _internal_load_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_load_node(
    ::baikaldb::pb::LoadNode* load_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(load_node_);
  }
  load_node_ = load_node;
  if (load_node) {
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.load_node)
}
inline ::baikaldb::pb::LoadNode* DerivePlanNode::release_load_node() {
  _has_bits_[0] &= ~0x00040000u;
  ::baikaldb::pb::LoadNode* temp = load_node_;
  load_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::LoadNode* DerivePlanNode::unsafe_arena_release_load_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.load_node)
  _has_bits_[0] &= ~0x00040000u;
  ::baikaldb::pb::LoadNode* temp = load_node_;
  load_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::LoadNode* DerivePlanNode::_internal_mutable_load_node() {
  _has_bits_[0] |= 0x00040000u;
  if (load_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::LoadNode>(GetArenaForAllocation());
    load_node_ = p;
  }
  return load_node_;
}
inline ::baikaldb::pb::LoadNode* DerivePlanNode::mutable_load_node() {
  ::baikaldb::pb::LoadNode* _msg = _internal_mutable_load_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.load_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_load_node(::baikaldb::pb::LoadNode* load_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete load_node_;
  }
  if (load_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::LoadNode>::GetOwningArena(load_node);
    if (message_arena != submessage_arena) {
      load_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, load_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  load_node_ = load_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.load_node)
}

// optional .baikaldb.pb.FilterNode raw_filter_node = 20;
inline bool DerivePlanNode::_internal_has_raw_filter_node() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || raw_filter_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_raw_filter_node() const {
  return _internal_has_raw_filter_node();
}
inline void DerivePlanNode::clear_raw_filter_node() {
  if (raw_filter_node_ != nullptr) raw_filter_node_->Clear();
  _has_bits_[0] &= ~0x00080000u;
}
inline const ::baikaldb::pb::FilterNode& DerivePlanNode::_internal_raw_filter_node() const {
  const ::baikaldb::pb::FilterNode* p = raw_filter_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::FilterNode&>(
      ::baikaldb::pb::_FilterNode_default_instance_);
}
inline const ::baikaldb::pb::FilterNode& DerivePlanNode::raw_filter_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.raw_filter_node)
  return _internal_raw_filter_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_raw_filter_node(
    ::baikaldb::pb::FilterNode* raw_filter_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(raw_filter_node_);
  }
  raw_filter_node_ = raw_filter_node;
  if (raw_filter_node) {
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.raw_filter_node)
}
inline ::baikaldb::pb::FilterNode* DerivePlanNode::release_raw_filter_node() {
  _has_bits_[0] &= ~0x00080000u;
  ::baikaldb::pb::FilterNode* temp = raw_filter_node_;
  raw_filter_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::FilterNode* DerivePlanNode::unsafe_arena_release_raw_filter_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.raw_filter_node)
  _has_bits_[0] &= ~0x00080000u;
  ::baikaldb::pb::FilterNode* temp = raw_filter_node_;
  raw_filter_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::FilterNode* DerivePlanNode::_internal_mutable_raw_filter_node() {
  _has_bits_[0] |= 0x00080000u;
  if (raw_filter_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::FilterNode>(GetArenaForAllocation());
    raw_filter_node_ = p;
  }
  return raw_filter_node_;
}
inline ::baikaldb::pb::FilterNode* DerivePlanNode::mutable_raw_filter_node() {
  ::baikaldb::pb::FilterNode* _msg = _internal_mutable_raw_filter_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.raw_filter_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_raw_filter_node(::baikaldb::pb::FilterNode* raw_filter_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete raw_filter_node_;
  }
  if (raw_filter_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::FilterNode>::GetOwningArena(raw_filter_node);
    if (message_arena != submessage_arena) {
      raw_filter_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, raw_filter_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  raw_filter_node_ = raw_filter_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.raw_filter_node)
}

// optional .baikaldb.pb.ExchangeSenderNode exchange_sender_node = 21;
inline bool DerivePlanNode::_internal_has_exchange_sender_node() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || exchange_sender_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_exchange_sender_node() const {
  return _internal_has_exchange_sender_node();
}
inline void DerivePlanNode::clear_exchange_sender_node() {
  if (exchange_sender_node_ != nullptr) exchange_sender_node_->Clear();
  _has_bits_[0] &= ~0x00100000u;
}
inline const ::baikaldb::pb::ExchangeSenderNode& DerivePlanNode::_internal_exchange_sender_node() const {
  const ::baikaldb::pb::ExchangeSenderNode* p = exchange_sender_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::ExchangeSenderNode&>(
      ::baikaldb::pb::_ExchangeSenderNode_default_instance_);
}
inline const ::baikaldb::pb::ExchangeSenderNode& DerivePlanNode::exchange_sender_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.exchange_sender_node)
  return _internal_exchange_sender_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_exchange_sender_node(
    ::baikaldb::pb::ExchangeSenderNode* exchange_sender_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(exchange_sender_node_);
  }
  exchange_sender_node_ = exchange_sender_node;
  if (exchange_sender_node) {
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.exchange_sender_node)
}
inline ::baikaldb::pb::ExchangeSenderNode* DerivePlanNode::release_exchange_sender_node() {
  _has_bits_[0] &= ~0x00100000u;
  ::baikaldb::pb::ExchangeSenderNode* temp = exchange_sender_node_;
  exchange_sender_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::ExchangeSenderNode* DerivePlanNode::unsafe_arena_release_exchange_sender_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.exchange_sender_node)
  _has_bits_[0] &= ~0x00100000u;
  ::baikaldb::pb::ExchangeSenderNode* temp = exchange_sender_node_;
  exchange_sender_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::ExchangeSenderNode* DerivePlanNode::_internal_mutable_exchange_sender_node() {
  _has_bits_[0] |= 0x00100000u;
  if (exchange_sender_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::ExchangeSenderNode>(GetArenaForAllocation());
    exchange_sender_node_ = p;
  }
  return exchange_sender_node_;
}
inline ::baikaldb::pb::ExchangeSenderNode* DerivePlanNode::mutable_exchange_sender_node() {
  ::baikaldb::pb::ExchangeSenderNode* _msg = _internal_mutable_exchange_sender_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.exchange_sender_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_exchange_sender_node(::baikaldb::pb::ExchangeSenderNode* exchange_sender_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete exchange_sender_node_;
  }
  if (exchange_sender_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::ExchangeSenderNode>::GetOwningArena(exchange_sender_node);
    if (message_arena != submessage_arena) {
      exchange_sender_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exchange_sender_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  exchange_sender_node_ = exchange_sender_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.exchange_sender_node)
}

// optional .baikaldb.pb.ExchangeReceiverNode exchange_receiver_node = 22;
inline bool DerivePlanNode::_internal_has_exchange_receiver_node() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  PROTOBUF_ASSUME(!value || exchange_receiver_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_exchange_receiver_node() const {
  return _internal_has_exchange_receiver_node();
}
inline void DerivePlanNode::clear_exchange_receiver_node() {
  if (exchange_receiver_node_ != nullptr) exchange_receiver_node_->Clear();
  _has_bits_[0] &= ~0x00200000u;
}
inline const ::baikaldb::pb::ExchangeReceiverNode& DerivePlanNode::_internal_exchange_receiver_node() const {
  const ::baikaldb::pb::ExchangeReceiverNode* p = exchange_receiver_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::ExchangeReceiverNode&>(
      ::baikaldb::pb::_ExchangeReceiverNode_default_instance_);
}
inline const ::baikaldb::pb::ExchangeReceiverNode& DerivePlanNode::exchange_receiver_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.exchange_receiver_node)
  return _internal_exchange_receiver_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_exchange_receiver_node(
    ::baikaldb::pb::ExchangeReceiverNode* exchange_receiver_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(exchange_receiver_node_);
  }
  exchange_receiver_node_ = exchange_receiver_node;
  if (exchange_receiver_node) {
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.exchange_receiver_node)
}
inline ::baikaldb::pb::ExchangeReceiverNode* DerivePlanNode::release_exchange_receiver_node() {
  _has_bits_[0] &= ~0x00200000u;
  ::baikaldb::pb::ExchangeReceiverNode* temp = exchange_receiver_node_;
  exchange_receiver_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::ExchangeReceiverNode* DerivePlanNode::unsafe_arena_release_exchange_receiver_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.exchange_receiver_node)
  _has_bits_[0] &= ~0x00200000u;
  ::baikaldb::pb::ExchangeReceiverNode* temp = exchange_receiver_node_;
  exchange_receiver_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::ExchangeReceiverNode* DerivePlanNode::_internal_mutable_exchange_receiver_node() {
  _has_bits_[0] |= 0x00200000u;
  if (exchange_receiver_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::ExchangeReceiverNode>(GetArenaForAllocation());
    exchange_receiver_node_ = p;
  }
  return exchange_receiver_node_;
}
inline ::baikaldb::pb::ExchangeReceiverNode* DerivePlanNode::mutable_exchange_receiver_node() {
  ::baikaldb::pb::ExchangeReceiverNode* _msg = _internal_mutable_exchange_receiver_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.exchange_receiver_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_exchange_receiver_node(::baikaldb::pb::ExchangeReceiverNode* exchange_receiver_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete exchange_receiver_node_;
  }
  if (exchange_receiver_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::ExchangeReceiverNode>::GetOwningArena(exchange_receiver_node);
    if (message_arena != submessage_arena) {
      exchange_receiver_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exchange_receiver_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  exchange_receiver_node_ = exchange_receiver_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.exchange_receiver_node)
}

// optional .baikaldb.pb.SelectManagerNode select_manager_node = 23;
inline bool DerivePlanNode::_internal_has_select_manager_node() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  PROTOBUF_ASSUME(!value || select_manager_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_select_manager_node() const {
  return _internal_has_select_manager_node();
}
inline void DerivePlanNode::clear_select_manager_node() {
  if (select_manager_node_ != nullptr) select_manager_node_->Clear();
  _has_bits_[0] &= ~0x00400000u;
}
inline const ::baikaldb::pb::SelectManagerNode& DerivePlanNode::_internal_select_manager_node() const {
  const ::baikaldb::pb::SelectManagerNode* p = select_manager_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::SelectManagerNode&>(
      ::baikaldb::pb::_SelectManagerNode_default_instance_);
}
inline const ::baikaldb::pb::SelectManagerNode& DerivePlanNode::select_manager_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.select_manager_node)
  return _internal_select_manager_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_select_manager_node(
    ::baikaldb::pb::SelectManagerNode* select_manager_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(select_manager_node_);
  }
  select_manager_node_ = select_manager_node;
  if (select_manager_node) {
    _has_bits_[0] |= 0x00400000u;
  } else {
    _has_bits_[0] &= ~0x00400000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.select_manager_node)
}
inline ::baikaldb::pb::SelectManagerNode* DerivePlanNode::release_select_manager_node() {
  _has_bits_[0] &= ~0x00400000u;
  ::baikaldb::pb::SelectManagerNode* temp = select_manager_node_;
  select_manager_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::SelectManagerNode* DerivePlanNode::unsafe_arena_release_select_manager_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.select_manager_node)
  _has_bits_[0] &= ~0x00400000u;
  ::baikaldb::pb::SelectManagerNode* temp = select_manager_node_;
  select_manager_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::SelectManagerNode* DerivePlanNode::_internal_mutable_select_manager_node() {
  _has_bits_[0] |= 0x00400000u;
  if (select_manager_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::SelectManagerNode>(GetArenaForAllocation());
    select_manager_node_ = p;
  }
  return select_manager_node_;
}
inline ::baikaldb::pb::SelectManagerNode* DerivePlanNode::mutable_select_manager_node() {
  ::baikaldb::pb::SelectManagerNode* _msg = _internal_mutable_select_manager_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.select_manager_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_select_manager_node(::baikaldb::pb::SelectManagerNode* select_manager_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete select_manager_node_;
  }
  if (select_manager_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::SelectManagerNode>::GetOwningArena(select_manager_node);
    if (message_arena != submessage_arena) {
      select_manager_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, select_manager_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00400000u;
  } else {
    _has_bits_[0] &= ~0x00400000u;
  }
  select_manager_node_ = select_manager_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.select_manager_node)
}

// optional .baikaldb.pb.DualScanNode dual_scan_node = 24;
inline bool DerivePlanNode::_internal_has_dual_scan_node() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  PROTOBUF_ASSUME(!value || dual_scan_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_dual_scan_node() const {
  return _internal_has_dual_scan_node();
}
inline void DerivePlanNode::clear_dual_scan_node() {
  if (dual_scan_node_ != nullptr) dual_scan_node_->Clear();
  _has_bits_[0] &= ~0x00800000u;
}
inline const ::baikaldb::pb::DualScanNode& DerivePlanNode::_internal_dual_scan_node() const {
  const ::baikaldb::pb::DualScanNode* p = dual_scan_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::DualScanNode&>(
      ::baikaldb::pb::_DualScanNode_default_instance_);
}
inline const ::baikaldb::pb::DualScanNode& DerivePlanNode::dual_scan_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.dual_scan_node)
  return _internal_dual_scan_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_dual_scan_node(
    ::baikaldb::pb::DualScanNode* dual_scan_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dual_scan_node_);
  }
  dual_scan_node_ = dual_scan_node;
  if (dual_scan_node) {
    _has_bits_[0] |= 0x00800000u;
  } else {
    _has_bits_[0] &= ~0x00800000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.dual_scan_node)
}
inline ::baikaldb::pb::DualScanNode* DerivePlanNode::release_dual_scan_node() {
  _has_bits_[0] &= ~0x00800000u;
  ::baikaldb::pb::DualScanNode* temp = dual_scan_node_;
  dual_scan_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::DualScanNode* DerivePlanNode::unsafe_arena_release_dual_scan_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.dual_scan_node)
  _has_bits_[0] &= ~0x00800000u;
  ::baikaldb::pb::DualScanNode* temp = dual_scan_node_;
  dual_scan_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::DualScanNode* DerivePlanNode::_internal_mutable_dual_scan_node() {
  _has_bits_[0] |= 0x00800000u;
  if (dual_scan_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::DualScanNode>(GetArenaForAllocation());
    dual_scan_node_ = p;
  }
  return dual_scan_node_;
}
inline ::baikaldb::pb::DualScanNode* DerivePlanNode::mutable_dual_scan_node() {
  ::baikaldb::pb::DualScanNode* _msg = _internal_mutable_dual_scan_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.dual_scan_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_dual_scan_node(::baikaldb::pb::DualScanNode* dual_scan_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dual_scan_node_;
  }
  if (dual_scan_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::DualScanNode>::GetOwningArena(dual_scan_node);
    if (message_arena != submessage_arena) {
      dual_scan_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dual_scan_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00800000u;
  } else {
    _has_bits_[0] &= ~0x00800000u;
  }
  dual_scan_node_ = dual_scan_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.dual_scan_node)
}

// optional .baikaldb.pb.WindowNode window_node = 25;
inline bool DerivePlanNode::_internal_has_window_node() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  PROTOBUF_ASSUME(!value || window_node_ != nullptr);
  return value;
}
inline bool DerivePlanNode::has_window_node() const {
  return _internal_has_window_node();
}
inline void DerivePlanNode::clear_window_node() {
  if (window_node_ != nullptr) window_node_->Clear();
  _has_bits_[0] &= ~0x01000000u;
}
inline const ::baikaldb::pb::WindowNode& DerivePlanNode::_internal_window_node() const {
  const ::baikaldb::pb::WindowNode* p = window_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::WindowNode&>(
      ::baikaldb::pb::_WindowNode_default_instance_);
}
inline const ::baikaldb::pb::WindowNode& DerivePlanNode::window_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DerivePlanNode.window_node)
  return _internal_window_node();
}
inline void DerivePlanNode::unsafe_arena_set_allocated_window_node(
    ::baikaldb::pb::WindowNode* window_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(window_node_);
  }
  window_node_ = window_node;
  if (window_node) {
    _has_bits_[0] |= 0x01000000u;
  } else {
    _has_bits_[0] &= ~0x01000000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DerivePlanNode.window_node)
}
inline ::baikaldb::pb::WindowNode* DerivePlanNode::release_window_node() {
  _has_bits_[0] &= ~0x01000000u;
  ::baikaldb::pb::WindowNode* temp = window_node_;
  window_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::WindowNode* DerivePlanNode::unsafe_arena_release_window_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DerivePlanNode.window_node)
  _has_bits_[0] &= ~0x01000000u;
  ::baikaldb::pb::WindowNode* temp = window_node_;
  window_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::WindowNode* DerivePlanNode::_internal_mutable_window_node() {
  _has_bits_[0] |= 0x01000000u;
  if (window_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::WindowNode>(GetArenaForAllocation());
    window_node_ = p;
  }
  return window_node_;
}
inline ::baikaldb::pb::WindowNode* DerivePlanNode::mutable_window_node() {
  ::baikaldb::pb::WindowNode* _msg = _internal_mutable_window_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DerivePlanNode.window_node)
  return _msg;
}
inline void DerivePlanNode::set_allocated_window_node(::baikaldb::pb::WindowNode* window_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete window_node_;
  }
  if (window_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::WindowNode>::GetOwningArena(window_node);
    if (message_arena != submessage_arena) {
      window_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, window_node, submessage_arena);
    }
    _has_bits_[0] |= 0x01000000u;
  } else {
    _has_bits_[0] &= ~0x01000000u;
  }
  window_node_ = window_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DerivePlanNode.window_node)
}

// -------------------------------------------------------------------

// PlanNode

// required .baikaldb.pb.PlanNodeType node_type = 2;
inline bool PlanNode::_internal_has_node_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PlanNode::has_node_type() const {
  return _internal_has_node_type();
}
inline void PlanNode::clear_node_type() {
  node_type_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::baikaldb::pb::PlanNodeType PlanNode::_internal_node_type() const {
  return static_cast< ::baikaldb::pb::PlanNodeType >(node_type_);
}
inline ::baikaldb::pb::PlanNodeType PlanNode::node_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PlanNode.node_type)
  return _internal_node_type();
}
inline void PlanNode::_internal_set_node_type(::baikaldb::pb::PlanNodeType value) {
  assert(::baikaldb::pb::PlanNodeType_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  node_type_ = value;
}
inline void PlanNode::set_node_type(::baikaldb::pb::PlanNodeType value) {
  _internal_set_node_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PlanNode.node_type)
}

// required int32 num_children = 3;
inline bool PlanNode::_internal_has_num_children() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PlanNode::has_num_children() const {
  return _internal_has_num_children();
}
inline void PlanNode::clear_num_children() {
  num_children_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlanNode::_internal_num_children() const {
  return num_children_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlanNode::num_children() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PlanNode.num_children)
  return _internal_num_children();
}
inline void PlanNode::_internal_set_num_children(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  num_children_ = value;
}
inline void PlanNode::set_num_children(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_children(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PlanNode.num_children)
}

// optional int64 limit = 5;
inline bool PlanNode::_internal_has_limit() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlanNode::has_limit() const {
  return _internal_has_limit();
}
inline void PlanNode::clear_limit() {
  limit_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlanNode::_internal_limit() const {
  return limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlanNode::limit() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PlanNode.limit)
  return _internal_limit();
}
inline void PlanNode::_internal_set_limit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  limit_ = value;
}
inline void PlanNode::set_limit(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PlanNode.limit)
}

// optional .baikaldb.pb.DerivePlanNode derive_node = 6;
inline bool PlanNode::_internal_has_derive_node() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || derive_node_ != nullptr);
  return value;
}
inline bool PlanNode::has_derive_node() const {
  return _internal_has_derive_node();
}
inline void PlanNode::clear_derive_node() {
  if (derive_node_ != nullptr) derive_node_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::DerivePlanNode& PlanNode::_internal_derive_node() const {
  const ::baikaldb::pb::DerivePlanNode* p = derive_node_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::DerivePlanNode&>(
      ::baikaldb::pb::_DerivePlanNode_default_instance_);
}
inline const ::baikaldb::pb::DerivePlanNode& PlanNode::derive_node() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PlanNode.derive_node)
  return _internal_derive_node();
}
inline void PlanNode::unsafe_arena_set_allocated_derive_node(
    ::baikaldb::pb::DerivePlanNode* derive_node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(derive_node_);
  }
  derive_node_ = derive_node;
  if (derive_node) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.PlanNode.derive_node)
}
inline ::baikaldb::pb::DerivePlanNode* PlanNode::release_derive_node() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::DerivePlanNode* temp = derive_node_;
  derive_node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::DerivePlanNode* PlanNode::unsafe_arena_release_derive_node() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PlanNode.derive_node)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::DerivePlanNode* temp = derive_node_;
  derive_node_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::DerivePlanNode* PlanNode::_internal_mutable_derive_node() {
  _has_bits_[0] |= 0x00000001u;
  if (derive_node_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::DerivePlanNode>(GetArenaForAllocation());
    derive_node_ = p;
  }
  return derive_node_;
}
inline ::baikaldb::pb::DerivePlanNode* PlanNode::mutable_derive_node() {
  ::baikaldb::pb::DerivePlanNode* _msg = _internal_mutable_derive_node();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PlanNode.derive_node)
  return _msg;
}
inline void PlanNode::set_allocated_derive_node(::baikaldb::pb::DerivePlanNode* derive_node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete derive_node_;
  }
  if (derive_node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::DerivePlanNode>::GetOwningArena(derive_node);
    if (message_arena != submessage_arena) {
      derive_node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, derive_node, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  derive_node_ = derive_node;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PlanNode.derive_node)
}

// optional bool is_explain = 7;
inline bool PlanNode::_internal_has_is_explain() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PlanNode::has_is_explain() const {
  return _internal_has_is_explain();
}
inline void PlanNode::clear_is_explain() {
  is_explain_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool PlanNode::_internal_is_explain() const {
  return is_explain_;
}
inline bool PlanNode::is_explain() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PlanNode.is_explain)
  return _internal_is_explain();
}
inline void PlanNode::_internal_set_is_explain(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_explain_ = value;
}
inline void PlanNode::set_is_explain(bool value) {
  _internal_set_is_explain(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PlanNode.is_explain)
}

// optional bool local_index_binlog = 8;
inline bool PlanNode::_internal_has_local_index_binlog() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PlanNode::has_local_index_binlog() const {
  return _internal_has_local_index_binlog();
}
inline void PlanNode::clear_local_index_binlog() {
  local_index_binlog_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool PlanNode::_internal_local_index_binlog() const {
  return local_index_binlog_;
}
inline bool PlanNode::local_index_binlog() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PlanNode.local_index_binlog)
  return _internal_local_index_binlog();
}
inline void PlanNode::_internal_set_local_index_binlog(bool value) {
  _has_bits_[0] |= 0x00000010u;
  local_index_binlog_ = value;
}
inline void PlanNode::set_local_index_binlog(bool value) {
  _internal_set_local_index_binlog(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PlanNode.local_index_binlog)
}

// repeated int64 partitions = 9;
inline int PlanNode::_internal_partitions_size() const {
  return partitions_.size();
}
inline int PlanNode::partitions_size() const {
  return _internal_partitions_size();
}
inline void PlanNode::clear_partitions() {
  partitions_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlanNode::_internal_partitions(int index) const {
  return partitions_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlanNode::partitions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PlanNode.partitions)
  return _internal_partitions(index);
}
inline void PlanNode::set_partitions(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  partitions_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PlanNode.partitions)
}
inline void PlanNode::_internal_add_partitions(::PROTOBUF_NAMESPACE_ID::int64 value) {
  partitions_.Add(value);
}
inline void PlanNode::add_partitions(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_partitions(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.PlanNode.partitions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
PlanNode::_internal_partitions() const {
  return partitions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
PlanNode::partitions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PlanNode.partitions)
  return _internal_partitions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
PlanNode::_internal_mutable_partitions() {
  return &partitions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
PlanNode::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PlanNode.partitions)
  return _internal_mutable_partitions();
}

// optional bool is_get_keypoint = 10;
inline bool PlanNode::_internal_has_is_get_keypoint() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PlanNode::has_is_get_keypoint() const {
  return _internal_has_is_get_keypoint();
}
inline void PlanNode::clear_is_get_keypoint() {
  is_get_keypoint_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool PlanNode::_internal_is_get_keypoint() const {
  return is_get_keypoint_;
}
inline bool PlanNode::is_get_keypoint() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PlanNode.is_get_keypoint)
  return _internal_is_get_keypoint();
}
inline void PlanNode::_internal_set_is_get_keypoint(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_get_keypoint_ = value;
}
inline void PlanNode::set_is_get_keypoint(bool value) {
  _internal_set_is_get_keypoint(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PlanNode.is_get_keypoint)
}

// -------------------------------------------------------------------

// Plan

// repeated .baikaldb.pb.PlanNode nodes = 1;
inline int Plan::_internal_nodes_size() const {
  return nodes_.size();
}
inline int Plan::nodes_size() const {
  return _internal_nodes_size();
}
inline void Plan::clear_nodes() {
  nodes_.Clear();
}
inline ::baikaldb::pb::PlanNode* Plan::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.Plan.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PlanNode >*
Plan::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.Plan.nodes)
  return &nodes_;
}
inline const ::baikaldb::pb::PlanNode& Plan::_internal_nodes(int index) const {
  return nodes_.Get(index);
}
inline const ::baikaldb::pb::PlanNode& Plan::nodes(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.Plan.nodes)
  return _internal_nodes(index);
}
inline ::baikaldb::pb::PlanNode* Plan::_internal_add_nodes() {
  return nodes_.Add();
}
inline ::baikaldb::pb::PlanNode* Plan::add_nodes() {
  ::baikaldb::pb::PlanNode* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:baikaldb.pb.Plan.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PlanNode >&
Plan::nodes() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.Plan.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// LocalTraceNode

// optional int64 time_cost_us = 1;
inline bool LocalTraceNode::_internal_has_time_cost_us() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LocalTraceNode::has_time_cost_us() const {
  return _internal_has_time_cost_us();
}
inline void LocalTraceNode::clear_time_cost_us() {
  time_cost_us_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LocalTraceNode::_internal_time_cost_us() const {
  return time_cost_us_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LocalTraceNode::time_cost_us() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LocalTraceNode.time_cost_us)
  return _internal_time_cost_us();
}
inline void LocalTraceNode::_internal_set_time_cost_us(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  time_cost_us_ = value;
}
inline void LocalTraceNode::set_time_cost_us(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_time_cost_us(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LocalTraceNode.time_cost_us)
}

// optional int64 sort_time = 2;
inline bool LocalTraceNode::_internal_has_sort_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LocalTraceNode::has_sort_time() const {
  return _internal_has_sort_time();
}
inline void LocalTraceNode::clear_sort_time() {
  sort_time_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LocalTraceNode::_internal_sort_time() const {
  return sort_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LocalTraceNode::sort_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LocalTraceNode.sort_time)
  return _internal_sort_time();
}
inline void LocalTraceNode::_internal_set_sort_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  sort_time_ = value;
}
inline void LocalTraceNode::set_sort_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_sort_time(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LocalTraceNode.sort_time)
}

// optional int64 affect_rows = 3;
inline bool LocalTraceNode::_internal_has_affect_rows() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LocalTraceNode::has_affect_rows() const {
  return _internal_has_affect_rows();
}
inline void LocalTraceNode::clear_affect_rows() {
  affect_rows_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LocalTraceNode::_internal_affect_rows() const {
  return affect_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LocalTraceNode::affect_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LocalTraceNode.affect_rows)
  return _internal_affect_rows();
}
inline void LocalTraceNode::_internal_set_affect_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  affect_rows_ = value;
}
inline void LocalTraceNode::set_affect_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_affect_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LocalTraceNode.affect_rows)
}

// optional int64 scan_rows = 4;
inline bool LocalTraceNode::_internal_has_scan_rows() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool LocalTraceNode::has_scan_rows() const {
  return _internal_has_scan_rows();
}
inline void LocalTraceNode::clear_scan_rows() {
  scan_rows_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LocalTraceNode::_internal_scan_rows() const {
  return scan_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LocalTraceNode::scan_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LocalTraceNode.scan_rows)
  return _internal_scan_rows();
}
inline void LocalTraceNode::_internal_set_scan_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  scan_rows_ = value;
}
inline void LocalTraceNode::set_scan_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_scan_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LocalTraceNode.scan_rows)
}

// optional int64 index_filter_rows = 5;
inline bool LocalTraceNode::_internal_has_index_filter_rows() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool LocalTraceNode::has_index_filter_rows() const {
  return _internal_has_index_filter_rows();
}
inline void LocalTraceNode::clear_index_filter_rows() {
  index_filter_rows_ = int64_t{0};
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LocalTraceNode::_internal_index_filter_rows() const {
  return index_filter_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LocalTraceNode::index_filter_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LocalTraceNode.index_filter_rows)
  return _internal_index_filter_rows();
}
inline void LocalTraceNode::_internal_set_index_filter_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  index_filter_rows_ = value;
}
inline void LocalTraceNode::set_index_filter_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_index_filter_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LocalTraceNode.index_filter_rows)
}

// optional int64 get_primary_rows = 6;
inline bool LocalTraceNode::_internal_has_get_primary_rows() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool LocalTraceNode::has_get_primary_rows() const {
  return _internal_has_get_primary_rows();
}
inline void LocalTraceNode::clear_get_primary_rows() {
  get_primary_rows_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LocalTraceNode::_internal_get_primary_rows() const {
  return get_primary_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LocalTraceNode::get_primary_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LocalTraceNode.get_primary_rows)
  return _internal_get_primary_rows();
}
inline void LocalTraceNode::_internal_set_get_primary_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  get_primary_rows_ = value;
}
inline void LocalTraceNode::set_get_primary_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_get_primary_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LocalTraceNode.get_primary_rows)
}

// optional string description = 8;
inline bool LocalTraceNode::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LocalTraceNode::has_description() const {
  return _internal_has_description();
}
inline void LocalTraceNode::clear_description() {
  description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LocalTraceNode::description() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LocalTraceNode.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalTraceNode::set_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.LocalTraceNode.description)
}
inline std::string* LocalTraceNode::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LocalTraceNode.description)
  return _s;
}
inline const std::string& LocalTraceNode::_internal_description() const {
  return description_.Get();
}
inline void LocalTraceNode::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LocalTraceNode::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000001u;
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LocalTraceNode::release_description() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.LocalTraceNode.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LocalTraceNode::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.LocalTraceNode.description)
}

// optional int64 where_filter_rows = 9;
inline bool LocalTraceNode::_internal_has_where_filter_rows() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool LocalTraceNode::has_where_filter_rows() const {
  return _internal_has_where_filter_rows();
}
inline void LocalTraceNode::clear_where_filter_rows() {
  where_filter_rows_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LocalTraceNode::_internal_where_filter_rows() const {
  return where_filter_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LocalTraceNode::where_filter_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LocalTraceNode.where_filter_rows)
  return _internal_where_filter_rows();
}
inline void LocalTraceNode::_internal_set_where_filter_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  where_filter_rows_ = value;
}
inline void LocalTraceNode::set_where_filter_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_where_filter_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LocalTraceNode.where_filter_rows)
}

// optional string index_name = 10;
inline bool LocalTraceNode::_internal_has_index_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LocalTraceNode::has_index_name() const {
  return _internal_has_index_name();
}
inline void LocalTraceNode::clear_index_name() {
  index_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LocalTraceNode::index_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LocalTraceNode.index_name)
  return _internal_index_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalTraceNode::set_index_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.LocalTraceNode.index_name)
}
inline std::string* LocalTraceNode::mutable_index_name() {
  std::string* _s = _internal_mutable_index_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LocalTraceNode.index_name)
  return _s;
}
inline const std::string& LocalTraceNode::_internal_index_name() const {
  return index_name_.Get();
}
inline void LocalTraceNode::_internal_set_index_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LocalTraceNode::_internal_mutable_index_name() {
  _has_bits_[0] |= 0x00000002u;
  return index_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LocalTraceNode::release_index_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.LocalTraceNode.index_name)
  if (!_internal_has_index_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return index_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LocalTraceNode::set_allocated_index_name(std::string* index_name) {
  if (index_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  index_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.LocalTraceNode.index_name)
}

// repeated string arrow_plan = 11;
inline int LocalTraceNode::_internal_arrow_plan_size() const {
  return arrow_plan_.size();
}
inline int LocalTraceNode::arrow_plan_size() const {
  return _internal_arrow_plan_size();
}
inline void LocalTraceNode::clear_arrow_plan() {
  arrow_plan_.Clear();
}
inline std::string* LocalTraceNode::add_arrow_plan() {
  std::string* _s = _internal_add_arrow_plan();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.LocalTraceNode.arrow_plan)
  return _s;
}
inline const std::string& LocalTraceNode::_internal_arrow_plan(int index) const {
  return arrow_plan_.Get(index);
}
inline const std::string& LocalTraceNode::arrow_plan(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LocalTraceNode.arrow_plan)
  return _internal_arrow_plan(index);
}
inline std::string* LocalTraceNode::mutable_arrow_plan(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LocalTraceNode.arrow_plan)
  return arrow_plan_.Mutable(index);
}
inline void LocalTraceNode::set_arrow_plan(int index, const std::string& value) {
  arrow_plan_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LocalTraceNode.arrow_plan)
}
inline void LocalTraceNode::set_arrow_plan(int index, std::string&& value) {
  arrow_plan_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.LocalTraceNode.arrow_plan)
}
inline void LocalTraceNode::set_arrow_plan(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  arrow_plan_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.LocalTraceNode.arrow_plan)
}
inline void LocalTraceNode::set_arrow_plan(int index, const char* value, size_t size) {
  arrow_plan_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.LocalTraceNode.arrow_plan)
}
inline std::string* LocalTraceNode::_internal_add_arrow_plan() {
  return arrow_plan_.Add();
}
inline void LocalTraceNode::add_arrow_plan(const std::string& value) {
  arrow_plan_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.LocalTraceNode.arrow_plan)
}
inline void LocalTraceNode::add_arrow_plan(std::string&& value) {
  arrow_plan_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.LocalTraceNode.arrow_plan)
}
inline void LocalTraceNode::add_arrow_plan(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  arrow_plan_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.LocalTraceNode.arrow_plan)
}
inline void LocalTraceNode::add_arrow_plan(const char* value, size_t size) {
  arrow_plan_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.LocalTraceNode.arrow_plan)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LocalTraceNode::arrow_plan() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.LocalTraceNode.arrow_plan)
  return arrow_plan_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LocalTraceNode::mutable_arrow_plan() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.LocalTraceNode.arrow_plan)
  return &arrow_plan_;
}

// optional string mpp_property = 12;
inline bool LocalTraceNode::_internal_has_mpp_property() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LocalTraceNode::has_mpp_property() const {
  return _internal_has_mpp_property();
}
inline void LocalTraceNode::clear_mpp_property() {
  mpp_property_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LocalTraceNode::mpp_property() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LocalTraceNode.mpp_property)
  return _internal_mpp_property();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LocalTraceNode::set_mpp_property(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 mpp_property_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.LocalTraceNode.mpp_property)
}
inline std::string* LocalTraceNode::mutable_mpp_property() {
  std::string* _s = _internal_mutable_mpp_property();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LocalTraceNode.mpp_property)
  return _s;
}
inline const std::string& LocalTraceNode::_internal_mpp_property() const {
  return mpp_property_.Get();
}
inline void LocalTraceNode::_internal_set_mpp_property(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  mpp_property_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LocalTraceNode::_internal_mutable_mpp_property() {
  _has_bits_[0] |= 0x00000004u;
  return mpp_property_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LocalTraceNode::release_mpp_property() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.LocalTraceNode.mpp_property)
  if (!_internal_has_mpp_property()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return mpp_property_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LocalTraceNode::set_allocated_mpp_property(std::string* mpp_property) {
  if (mpp_property != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  mpp_property_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mpp_property,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.LocalTraceNode.mpp_property)
}

// -------------------------------------------------------------------

// TraceNode

// optional .baikaldb.pb.PlanNodeType node_type = 1;
inline bool TraceNode::_internal_has_node_type() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool TraceNode::has_node_type() const {
  return _internal_has_node_type();
}
inline void TraceNode::clear_node_type() {
  node_type_ = 1;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::baikaldb::pb::PlanNodeType TraceNode::_internal_node_type() const {
  return static_cast< ::baikaldb::pb::PlanNodeType >(node_type_);
}
inline ::baikaldb::pb::PlanNodeType TraceNode::node_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TraceNode.node_type)
  return _internal_node_type();
}
inline void TraceNode::_internal_set_node_type(::baikaldb::pb::PlanNodeType value) {
  assert(::baikaldb::pb::PlanNodeType_IsValid(value));
  _has_bits_[0] |= 0x00002000u;
  node_type_ = value;
}
inline void TraceNode::set_node_type(::baikaldb::pb::PlanNodeType value) {
  _internal_set_node_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TraceNode.node_type)
}

// optional string description = 2;
inline bool TraceNode::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TraceNode::has_description() const {
  return _internal_has_description();
}
inline void TraceNode::clear_description() {
  description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TraceNode::description() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TraceNode.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceNode::set_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.TraceNode.description)
}
inline std::string* TraceNode::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TraceNode.description)
  return _s;
}
inline const std::string& TraceNode::_internal_description() const {
  return description_.Get();
}
inline void TraceNode::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TraceNode::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000001u;
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TraceNode::release_description() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TraceNode.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TraceNode::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TraceNode.description)
}

// optional string instance = 3;
inline bool TraceNode::_internal_has_instance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TraceNode::has_instance() const {
  return _internal_has_instance();
}
inline void TraceNode::clear_instance() {
  instance_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TraceNode::instance() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TraceNode.instance)
  return _internal_instance();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TraceNode::set_instance(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 instance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.TraceNode.instance)
}
inline std::string* TraceNode::mutable_instance() {
  std::string* _s = _internal_mutable_instance();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TraceNode.instance)
  return _s;
}
inline const std::string& TraceNode::_internal_instance() const {
  return instance_.Get();
}
inline void TraceNode::_internal_set_instance(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  instance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TraceNode::_internal_mutable_instance() {
  _has_bits_[0] |= 0x00000002u;
  return instance_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TraceNode::release_instance() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TraceNode.instance)
  if (!_internal_has_instance()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return instance_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TraceNode::set_allocated_instance(std::string* instance) {
  if (instance != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  instance_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), instance,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TraceNode.instance)
}

// optional int64 region_id = 4;
inline bool TraceNode::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TraceNode::has_region_id() const {
  return _internal_has_region_id();
}
inline void TraceNode::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TraceNode::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TraceNode::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TraceNode.region_id)
  return _internal_region_id();
}
inline void TraceNode::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  region_id_ = value;
}
inline void TraceNode::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TraceNode.region_id)
}

// optional int64 total_time = 5;
inline bool TraceNode::_internal_has_total_time() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TraceNode::has_total_time() const {
  return _internal_has_total_time();
}
inline void TraceNode::clear_total_time() {
  total_time_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TraceNode::_internal_total_time() const {
  return total_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TraceNode::total_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TraceNode.total_time)
  return _internal_total_time();
}
inline void TraceNode::_internal_set_total_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  total_time_ = value;
}
inline void TraceNode::set_total_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_total_time(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TraceNode.total_time)
}

// optional int64 affect_rows = 6;
inline bool TraceNode::_internal_has_affect_rows() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TraceNode::has_affect_rows() const {
  return _internal_has_affect_rows();
}
inline void TraceNode::clear_affect_rows() {
  affect_rows_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TraceNode::_internal_affect_rows() const {
  return affect_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TraceNode::affect_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TraceNode.affect_rows)
  return _internal_affect_rows();
}
inline void TraceNode::_internal_set_affect_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  affect_rows_ = value;
}
inline void TraceNode::set_affect_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_affect_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TraceNode.affect_rows)
}

// optional .baikaldb.pb.LocalTraceNode open_trace = 7;
inline bool TraceNode::_internal_has_open_trace() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || open_trace_ != nullptr);
  return value;
}
inline bool TraceNode::has_open_trace() const {
  return _internal_has_open_trace();
}
inline void TraceNode::clear_open_trace() {
  if (open_trace_ != nullptr) open_trace_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::baikaldb::pb::LocalTraceNode& TraceNode::_internal_open_trace() const {
  const ::baikaldb::pb::LocalTraceNode* p = open_trace_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::LocalTraceNode&>(
      ::baikaldb::pb::_LocalTraceNode_default_instance_);
}
inline const ::baikaldb::pb::LocalTraceNode& TraceNode::open_trace() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TraceNode.open_trace)
  return _internal_open_trace();
}
inline void TraceNode::unsafe_arena_set_allocated_open_trace(
    ::baikaldb::pb::LocalTraceNode* open_trace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(open_trace_);
  }
  open_trace_ = open_trace;
  if (open_trace) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.TraceNode.open_trace)
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::release_open_trace() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::LocalTraceNode* temp = open_trace_;
  open_trace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::unsafe_arena_release_open_trace() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TraceNode.open_trace)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::LocalTraceNode* temp = open_trace_;
  open_trace_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::_internal_mutable_open_trace() {
  _has_bits_[0] |= 0x00000004u;
  if (open_trace_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::LocalTraceNode>(GetArenaForAllocation());
    open_trace_ = p;
  }
  return open_trace_;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::mutable_open_trace() {
  ::baikaldb::pb::LocalTraceNode* _msg = _internal_mutable_open_trace();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TraceNode.open_trace)
  return _msg;
}
inline void TraceNode::set_allocated_open_trace(::baikaldb::pb::LocalTraceNode* open_trace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete open_trace_;
  }
  if (open_trace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::LocalTraceNode>::GetOwningArena(open_trace);
    if (message_arena != submessage_arena) {
      open_trace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, open_trace, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  open_trace_ = open_trace;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TraceNode.open_trace)
}

// optional .baikaldb.pb.LocalTraceNode get_next_trace = 8;
inline bool TraceNode::_internal_has_get_next_trace() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || get_next_trace_ != nullptr);
  return value;
}
inline bool TraceNode::has_get_next_trace() const {
  return _internal_has_get_next_trace();
}
inline void TraceNode::clear_get_next_trace() {
  if (get_next_trace_ != nullptr) get_next_trace_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::baikaldb::pb::LocalTraceNode& TraceNode::_internal_get_next_trace() const {
  const ::baikaldb::pb::LocalTraceNode* p = get_next_trace_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::LocalTraceNode&>(
      ::baikaldb::pb::_LocalTraceNode_default_instance_);
}
inline const ::baikaldb::pb::LocalTraceNode& TraceNode::get_next_trace() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TraceNode.get_next_trace)
  return _internal_get_next_trace();
}
inline void TraceNode::unsafe_arena_set_allocated_get_next_trace(
    ::baikaldb::pb::LocalTraceNode* get_next_trace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(get_next_trace_);
  }
  get_next_trace_ = get_next_trace;
  if (get_next_trace) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.TraceNode.get_next_trace)
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::release_get_next_trace() {
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::LocalTraceNode* temp = get_next_trace_;
  get_next_trace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::unsafe_arena_release_get_next_trace() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TraceNode.get_next_trace)
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::LocalTraceNode* temp = get_next_trace_;
  get_next_trace_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::_internal_mutable_get_next_trace() {
  _has_bits_[0] |= 0x00000008u;
  if (get_next_trace_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::LocalTraceNode>(GetArenaForAllocation());
    get_next_trace_ = p;
  }
  return get_next_trace_;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::mutable_get_next_trace() {
  ::baikaldb::pb::LocalTraceNode* _msg = _internal_mutable_get_next_trace();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TraceNode.get_next_trace)
  return _msg;
}
inline void TraceNode::set_allocated_get_next_trace(::baikaldb::pb::LocalTraceNode* get_next_trace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete get_next_trace_;
  }
  if (get_next_trace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::LocalTraceNode>::GetOwningArena(get_next_trace);
    if (message_arena != submessage_arena) {
      get_next_trace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_next_trace, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  get_next_trace_ = get_next_trace;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TraceNode.get_next_trace)
}

// optional .baikaldb.pb.LocalTraceNode txn_get_trace = 9;
inline bool TraceNode::_internal_has_txn_get_trace() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || txn_get_trace_ != nullptr);
  return value;
}
inline bool TraceNode::has_txn_get_trace() const {
  return _internal_has_txn_get_trace();
}
inline void TraceNode::clear_txn_get_trace() {
  if (txn_get_trace_ != nullptr) txn_get_trace_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::baikaldb::pb::LocalTraceNode& TraceNode::_internal_txn_get_trace() const {
  const ::baikaldb::pb::LocalTraceNode* p = txn_get_trace_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::LocalTraceNode&>(
      ::baikaldb::pb::_LocalTraceNode_default_instance_);
}
inline const ::baikaldb::pb::LocalTraceNode& TraceNode::txn_get_trace() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TraceNode.txn_get_trace)
  return _internal_txn_get_trace();
}
inline void TraceNode::unsafe_arena_set_allocated_txn_get_trace(
    ::baikaldb::pb::LocalTraceNode* txn_get_trace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(txn_get_trace_);
  }
  txn_get_trace_ = txn_get_trace;
  if (txn_get_trace) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.TraceNode.txn_get_trace)
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::release_txn_get_trace() {
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::LocalTraceNode* temp = txn_get_trace_;
  txn_get_trace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::unsafe_arena_release_txn_get_trace() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TraceNode.txn_get_trace)
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::LocalTraceNode* temp = txn_get_trace_;
  txn_get_trace_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::_internal_mutable_txn_get_trace() {
  _has_bits_[0] |= 0x00000010u;
  if (txn_get_trace_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::LocalTraceNode>(GetArenaForAllocation());
    txn_get_trace_ = p;
  }
  return txn_get_trace_;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::mutable_txn_get_trace() {
  ::baikaldb::pb::LocalTraceNode* _msg = _internal_mutable_txn_get_trace();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TraceNode.txn_get_trace)
  return _msg;
}
inline void TraceNode::set_allocated_txn_get_trace(::baikaldb::pb::LocalTraceNode* txn_get_trace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete txn_get_trace_;
  }
  if (txn_get_trace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::LocalTraceNode>::GetOwningArena(txn_get_trace);
    if (message_arena != submessage_arena) {
      txn_get_trace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, txn_get_trace, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  txn_get_trace_ = txn_get_trace;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TraceNode.txn_get_trace)
}

// optional .baikaldb.pb.LocalTraceNode txn_put_trace = 10;
inline bool TraceNode::_internal_has_txn_put_trace() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || txn_put_trace_ != nullptr);
  return value;
}
inline bool TraceNode::has_txn_put_trace() const {
  return _internal_has_txn_put_trace();
}
inline void TraceNode::clear_txn_put_trace() {
  if (txn_put_trace_ != nullptr) txn_put_trace_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::baikaldb::pb::LocalTraceNode& TraceNode::_internal_txn_put_trace() const {
  const ::baikaldb::pb::LocalTraceNode* p = txn_put_trace_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::LocalTraceNode&>(
      ::baikaldb::pb::_LocalTraceNode_default_instance_);
}
inline const ::baikaldb::pb::LocalTraceNode& TraceNode::txn_put_trace() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TraceNode.txn_put_trace)
  return _internal_txn_put_trace();
}
inline void TraceNode::unsafe_arena_set_allocated_txn_put_trace(
    ::baikaldb::pb::LocalTraceNode* txn_put_trace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(txn_put_trace_);
  }
  txn_put_trace_ = txn_put_trace;
  if (txn_put_trace) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.TraceNode.txn_put_trace)
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::release_txn_put_trace() {
  _has_bits_[0] &= ~0x00000020u;
  ::baikaldb::pb::LocalTraceNode* temp = txn_put_trace_;
  txn_put_trace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::unsafe_arena_release_txn_put_trace() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TraceNode.txn_put_trace)
  _has_bits_[0] &= ~0x00000020u;
  ::baikaldb::pb::LocalTraceNode* temp = txn_put_trace_;
  txn_put_trace_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::_internal_mutable_txn_put_trace() {
  _has_bits_[0] |= 0x00000020u;
  if (txn_put_trace_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::LocalTraceNode>(GetArenaForAllocation());
    txn_put_trace_ = p;
  }
  return txn_put_trace_;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::mutable_txn_put_trace() {
  ::baikaldb::pb::LocalTraceNode* _msg = _internal_mutable_txn_put_trace();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TraceNode.txn_put_trace)
  return _msg;
}
inline void TraceNode::set_allocated_txn_put_trace(::baikaldb::pb::LocalTraceNode* txn_put_trace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete txn_put_trace_;
  }
  if (txn_put_trace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::LocalTraceNode>::GetOwningArena(txn_put_trace);
    if (message_arena != submessage_arena) {
      txn_put_trace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, txn_put_trace, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  txn_put_trace_ = txn_put_trace;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TraceNode.txn_put_trace)
}

// optional .baikaldb.pb.LocalTraceNode txn_delete_trace = 11;
inline bool TraceNode::_internal_has_txn_delete_trace() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || txn_delete_trace_ != nullptr);
  return value;
}
inline bool TraceNode::has_txn_delete_trace() const {
  return _internal_has_txn_delete_trace();
}
inline void TraceNode::clear_txn_delete_trace() {
  if (txn_delete_trace_ != nullptr) txn_delete_trace_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::baikaldb::pb::LocalTraceNode& TraceNode::_internal_txn_delete_trace() const {
  const ::baikaldb::pb::LocalTraceNode* p = txn_delete_trace_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::LocalTraceNode&>(
      ::baikaldb::pb::_LocalTraceNode_default_instance_);
}
inline const ::baikaldb::pb::LocalTraceNode& TraceNode::txn_delete_trace() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TraceNode.txn_delete_trace)
  return _internal_txn_delete_trace();
}
inline void TraceNode::unsafe_arena_set_allocated_txn_delete_trace(
    ::baikaldb::pb::LocalTraceNode* txn_delete_trace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(txn_delete_trace_);
  }
  txn_delete_trace_ = txn_delete_trace;
  if (txn_delete_trace) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.TraceNode.txn_delete_trace)
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::release_txn_delete_trace() {
  _has_bits_[0] &= ~0x00000040u;
  ::baikaldb::pb::LocalTraceNode* temp = txn_delete_trace_;
  txn_delete_trace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::unsafe_arena_release_txn_delete_trace() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TraceNode.txn_delete_trace)
  _has_bits_[0] &= ~0x00000040u;
  ::baikaldb::pb::LocalTraceNode* temp = txn_delete_trace_;
  txn_delete_trace_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::_internal_mutable_txn_delete_trace() {
  _has_bits_[0] |= 0x00000040u;
  if (txn_delete_trace_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::LocalTraceNode>(GetArenaForAllocation());
    txn_delete_trace_ = p;
  }
  return txn_delete_trace_;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::mutable_txn_delete_trace() {
  ::baikaldb::pb::LocalTraceNode* _msg = _internal_mutable_txn_delete_trace();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TraceNode.txn_delete_trace)
  return _msg;
}
inline void TraceNode::set_allocated_txn_delete_trace(::baikaldb::pb::LocalTraceNode* txn_delete_trace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete txn_delete_trace_;
  }
  if (txn_delete_trace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::LocalTraceNode>::GetOwningArena(txn_delete_trace);
    if (message_arena != submessage_arena) {
      txn_delete_trace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, txn_delete_trace, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  txn_delete_trace_ = txn_delete_trace;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TraceNode.txn_delete_trace)
}

// optional .baikaldb.pb.LocalTraceNode txn_commit_trace = 12;
inline bool TraceNode::_internal_has_txn_commit_trace() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || txn_commit_trace_ != nullptr);
  return value;
}
inline bool TraceNode::has_txn_commit_trace() const {
  return _internal_has_txn_commit_trace();
}
inline void TraceNode::clear_txn_commit_trace() {
  if (txn_commit_trace_ != nullptr) txn_commit_trace_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::baikaldb::pb::LocalTraceNode& TraceNode::_internal_txn_commit_trace() const {
  const ::baikaldb::pb::LocalTraceNode* p = txn_commit_trace_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::LocalTraceNode&>(
      ::baikaldb::pb::_LocalTraceNode_default_instance_);
}
inline const ::baikaldb::pb::LocalTraceNode& TraceNode::txn_commit_trace() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TraceNode.txn_commit_trace)
  return _internal_txn_commit_trace();
}
inline void TraceNode::unsafe_arena_set_allocated_txn_commit_trace(
    ::baikaldb::pb::LocalTraceNode* txn_commit_trace) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(txn_commit_trace_);
  }
  txn_commit_trace_ = txn_commit_trace;
  if (txn_commit_trace) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.TraceNode.txn_commit_trace)
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::release_txn_commit_trace() {
  _has_bits_[0] &= ~0x00000080u;
  ::baikaldb::pb::LocalTraceNode* temp = txn_commit_trace_;
  txn_commit_trace_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::unsafe_arena_release_txn_commit_trace() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TraceNode.txn_commit_trace)
  _has_bits_[0] &= ~0x00000080u;
  ::baikaldb::pb::LocalTraceNode* temp = txn_commit_trace_;
  txn_commit_trace_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::_internal_mutable_txn_commit_trace() {
  _has_bits_[0] |= 0x00000080u;
  if (txn_commit_trace_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::LocalTraceNode>(GetArenaForAllocation());
    txn_commit_trace_ = p;
  }
  return txn_commit_trace_;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::mutable_txn_commit_trace() {
  ::baikaldb::pb::LocalTraceNode* _msg = _internal_mutable_txn_commit_trace();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TraceNode.txn_commit_trace)
  return _msg;
}
inline void TraceNode::set_allocated_txn_commit_trace(::baikaldb::pb::LocalTraceNode* txn_commit_trace) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete txn_commit_trace_;
  }
  if (txn_commit_trace) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::LocalTraceNode>::GetOwningArena(txn_commit_trace);
    if (message_arena != submessage_arena) {
      txn_commit_trace = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, txn_commit_trace, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  txn_commit_trace_ = txn_commit_trace;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TraceNode.txn_commit_trace)
}

// optional .baikaldb.pb.LocalTraceNode store_agg = 13;
inline bool TraceNode::_internal_has_store_agg() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || store_agg_ != nullptr);
  return value;
}
inline bool TraceNode::has_store_agg() const {
  return _internal_has_store_agg();
}
inline void TraceNode::clear_store_agg() {
  if (store_agg_ != nullptr) store_agg_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::baikaldb::pb::LocalTraceNode& TraceNode::_internal_store_agg() const {
  const ::baikaldb::pb::LocalTraceNode* p = store_agg_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::LocalTraceNode&>(
      ::baikaldb::pb::_LocalTraceNode_default_instance_);
}
inline const ::baikaldb::pb::LocalTraceNode& TraceNode::store_agg() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TraceNode.store_agg)
  return _internal_store_agg();
}
inline void TraceNode::unsafe_arena_set_allocated_store_agg(
    ::baikaldb::pb::LocalTraceNode* store_agg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(store_agg_);
  }
  store_agg_ = store_agg;
  if (store_agg) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.TraceNode.store_agg)
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::release_store_agg() {
  _has_bits_[0] &= ~0x00000100u;
  ::baikaldb::pb::LocalTraceNode* temp = store_agg_;
  store_agg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::unsafe_arena_release_store_agg() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TraceNode.store_agg)
  _has_bits_[0] &= ~0x00000100u;
  ::baikaldb::pb::LocalTraceNode* temp = store_agg_;
  store_agg_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::_internal_mutable_store_agg() {
  _has_bits_[0] |= 0x00000100u;
  if (store_agg_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::LocalTraceNode>(GetArenaForAllocation());
    store_agg_ = p;
  }
  return store_agg_;
}
inline ::baikaldb::pb::LocalTraceNode* TraceNode::mutable_store_agg() {
  ::baikaldb::pb::LocalTraceNode* _msg = _internal_mutable_store_agg();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TraceNode.store_agg)
  return _msg;
}
inline void TraceNode::set_allocated_store_agg(::baikaldb::pb::LocalTraceNode* store_agg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete store_agg_;
  }
  if (store_agg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::LocalTraceNode>::GetOwningArena(store_agg);
    if (message_arena != submessage_arena) {
      store_agg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, store_agg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  store_agg_ = store_agg;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TraceNode.store_agg)
}

// repeated .baikaldb.pb.TraceNode child_nodes = 14;
inline int TraceNode::_internal_child_nodes_size() const {
  return child_nodes_.size();
}
inline int TraceNode::child_nodes_size() const {
  return _internal_child_nodes_size();
}
inline void TraceNode::clear_child_nodes() {
  child_nodes_.Clear();
}
inline ::baikaldb::pb::TraceNode* TraceNode::mutable_child_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TraceNode.child_nodes)
  return child_nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TraceNode >*
TraceNode::mutable_child_nodes() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.TraceNode.child_nodes)
  return &child_nodes_;
}
inline const ::baikaldb::pb::TraceNode& TraceNode::_internal_child_nodes(int index) const {
  return child_nodes_.Get(index);
}
inline const ::baikaldb::pb::TraceNode& TraceNode::child_nodes(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TraceNode.child_nodes)
  return _internal_child_nodes(index);
}
inline ::baikaldb::pb::TraceNode* TraceNode::_internal_add_child_nodes() {
  return child_nodes_.Add();
}
inline ::baikaldb::pb::TraceNode* TraceNode::add_child_nodes() {
  ::baikaldb::pb::TraceNode* _add = _internal_add_child_nodes();
  // @@protoc_insertion_point(field_add:baikaldb.pb.TraceNode.child_nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TraceNode >&
TraceNode::child_nodes() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.TraceNode.child_nodes)
  return child_nodes_;
}

// optional int64 partition_id = 15;
inline bool TraceNode::_internal_has_partition_id() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TraceNode::has_partition_id() const {
  return _internal_has_partition_id();
}
inline void TraceNode::clear_partition_id() {
  partition_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TraceNode::_internal_partition_id() const {
  return partition_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TraceNode::partition_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TraceNode.partition_id)
  return _internal_partition_id();
}
inline void TraceNode::_internal_set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00001000u;
  partition_id_ = value;
}
inline void TraceNode::set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_partition_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TraceNode.partition_id)
}

// -------------------------------------------------------------------

// FragmentInfo

// required int32 fragment_id = 1;
inline bool FragmentInfo::_internal_has_fragment_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FragmentInfo::has_fragment_id() const {
  return _internal_has_fragment_id();
}
inline void FragmentInfo::clear_fragment_id() {
  fragment_id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FragmentInfo::_internal_fragment_id() const {
  return fragment_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FragmentInfo::fragment_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FragmentInfo.fragment_id)
  return _internal_fragment_id();
}
inline void FragmentInfo::_internal_set_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  fragment_id_ = value;
}
inline void FragmentInfo::set_fragment_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_fragment_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FragmentInfo.fragment_id)
}

// required .baikaldb.pb.Plan plan = 2;
inline bool FragmentInfo::_internal_has_plan() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || plan_ != nullptr);
  return value;
}
inline bool FragmentInfo::has_plan() const {
  return _internal_has_plan();
}
inline void FragmentInfo::clear_plan() {
  if (plan_ != nullptr) plan_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::Plan& FragmentInfo::_internal_plan() const {
  const ::baikaldb::pb::Plan* p = plan_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::Plan&>(
      ::baikaldb::pb::_Plan_default_instance_);
}
inline const ::baikaldb::pb::Plan& FragmentInfo::plan() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FragmentInfo.plan)
  return _internal_plan();
}
inline void FragmentInfo::unsafe_arena_set_allocated_plan(
    ::baikaldb::pb::Plan* plan) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(plan_);
  }
  plan_ = plan;
  if (plan) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.FragmentInfo.plan)
}
inline ::baikaldb::pb::Plan* FragmentInfo::release_plan() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::Plan* temp = plan_;
  plan_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::Plan* FragmentInfo::unsafe_arena_release_plan() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.FragmentInfo.plan)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::Plan* temp = plan_;
  plan_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::Plan* FragmentInfo::_internal_mutable_plan() {
  _has_bits_[0] |= 0x00000001u;
  if (plan_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::Plan>(GetArenaForAllocation());
    plan_ = p;
  }
  return plan_;
}
inline ::baikaldb::pb::Plan* FragmentInfo::mutable_plan() {
  ::baikaldb::pb::Plan* _msg = _internal_mutable_plan();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FragmentInfo.plan)
  return _msg;
}
inline void FragmentInfo::set_allocated_plan(::baikaldb::pb::Plan* plan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete plan_;
  }
  if (plan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::Plan>::GetOwningArena(plan);
    if (message_arena != submessage_arena) {
      plan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, plan, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  plan_ = plan;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.FragmentInfo.plan)
}

// optional .baikaldb.pb.RuntimeState runtime_state = 3;
inline bool FragmentInfo::_internal_has_runtime_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || runtime_state_ != nullptr);
  return value;
}
inline bool FragmentInfo::has_runtime_state() const {
  return _internal_has_runtime_state();
}
inline const ::baikaldb::pb::RuntimeState& FragmentInfo::_internal_runtime_state() const {
  const ::baikaldb::pb::RuntimeState* p = runtime_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RuntimeState&>(
      ::baikaldb::pb::_RuntimeState_default_instance_);
}
inline const ::baikaldb::pb::RuntimeState& FragmentInfo::runtime_state() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FragmentInfo.runtime_state)
  return _internal_runtime_state();
}
inline void FragmentInfo::unsafe_arena_set_allocated_runtime_state(
    ::baikaldb::pb::RuntimeState* runtime_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_state_);
  }
  runtime_state_ = runtime_state;
  if (runtime_state) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.FragmentInfo.runtime_state)
}
inline ::baikaldb::pb::RuntimeState* FragmentInfo::release_runtime_state() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::RuntimeState* temp = runtime_state_;
  runtime_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RuntimeState* FragmentInfo::unsafe_arena_release_runtime_state() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.FragmentInfo.runtime_state)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::RuntimeState* temp = runtime_state_;
  runtime_state_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RuntimeState* FragmentInfo::_internal_mutable_runtime_state() {
  _has_bits_[0] |= 0x00000002u;
  if (runtime_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RuntimeState>(GetArenaForAllocation());
    runtime_state_ = p;
  }
  return runtime_state_;
}
inline ::baikaldb::pb::RuntimeState* FragmentInfo::mutable_runtime_state() {
  ::baikaldb::pb::RuntimeState* _msg = _internal_mutable_runtime_state();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FragmentInfo.runtime_state)
  return _msg;
}
inline void FragmentInfo::set_allocated_runtime_state(::baikaldb::pb::RuntimeState* runtime_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_state_);
  }
  if (runtime_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(runtime_state));
    if (message_arena != submessage_arena) {
      runtime_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, runtime_state, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  runtime_state_ = runtime_state;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.FragmentInfo.runtime_state)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace baikaldb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::baikaldb::pb::PlanNodeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::PlanNodeType>() {
  return ::baikaldb::pb::PlanNodeType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::TxnCmdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::TxnCmdType>() {
  return ::baikaldb::pb::TxnCmdType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::LockCmdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::LockCmdType>() {
  return ::baikaldb::pb::LockCmdType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::MatchMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::MatchMode>() {
  return ::baikaldb::pb::MatchMode_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::FulltextNodeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::FulltextNodeType>() {
  return ::baikaldb::pb::FulltextNodeType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::DDLType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::DDLType>() {
  return ::baikaldb::pb::DDLType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::JoinType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::JoinType>() {
  return ::baikaldb::pb::JoinType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::CompareType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::CompareType>() {
  return ::baikaldb::pb::CompareType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::LockSecondaryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::LockSecondaryType>() {
  return ::baikaldb::pb::LockSecondaryType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::PartitionPropertyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::PartitionPropertyType>() {
  return ::baikaldb::pb::PartitionPropertyType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::FrameType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::FrameType>() {
  return ::baikaldb::pb::FrameType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::BoundType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::BoundType>() {
  return ::baikaldb::pb::BoundType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_plan_2eproto
