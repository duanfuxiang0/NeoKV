// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dms.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dms_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dms_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "optype.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dms_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dms_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dms_2eproto;
namespace baikaldb {
namespace pb {
class BacktrackImporterTaskInfo;
struct BacktrackImporterTaskInfoDefaultTypeInternal;
extern BacktrackImporterTaskInfoDefaultTypeInternal _BacktrackImporterTaskInfo_default_instance_;
class DBArgs;
struct DBArgsDefaultTypeInternal;
extern DBArgsDefaultTypeInternal _DBArgs_default_instance_;
class DMSRequest;
struct DMSRequestDefaultTypeInternal;
extern DMSRequestDefaultTypeInternal _DMSRequest_default_instance_;
class DMSResponse;
struct DMSResponseDefaultTypeInternal;
extern DMSResponseDefaultTypeInternal _DMSResponse_default_instance_;
class ImporterTaskInfo;
struct ImporterTaskInfoDefaultTypeInternal;
extern ImporterTaskInfoDefaultTypeInternal _ImporterTaskInfo_default_instance_;
class SqlDetail;
struct SqlDetailDefaultTypeInternal;
extern SqlDetailDefaultTypeInternal _SqlDetail_default_instance_;
class TaskConfig;
struct TaskConfigDefaultTypeInternal;
extern TaskConfigDefaultTypeInternal _TaskConfig_default_instance_;
class TaskDetail;
struct TaskDetailDefaultTypeInternal;
extern TaskDetailDefaultTypeInternal _TaskDetail_default_instance_;
class TroubleShootingRequest;
struct TroubleShootingRequestDefaultTypeInternal;
extern TroubleShootingRequestDefaultTypeInternal _TroubleShootingRequest_default_instance_;
class TroubleShootingResponse;
struct TroubleShootingResponseDefaultTypeInternal;
extern TroubleShootingResponseDefaultTypeInternal _TroubleShootingResponse_default_instance_;
}  // namespace pb
}  // namespace baikaldb
PROTOBUF_NAMESPACE_OPEN
template<> ::baikaldb::pb::BacktrackImporterTaskInfo* Arena::CreateMaybeMessage<::baikaldb::pb::BacktrackImporterTaskInfo>(Arena*);
template<> ::baikaldb::pb::DBArgs* Arena::CreateMaybeMessage<::baikaldb::pb::DBArgs>(Arena*);
template<> ::baikaldb::pb::DMSRequest* Arena::CreateMaybeMessage<::baikaldb::pb::DMSRequest>(Arena*);
template<> ::baikaldb::pb::DMSResponse* Arena::CreateMaybeMessage<::baikaldb::pb::DMSResponse>(Arena*);
template<> ::baikaldb::pb::ImporterTaskInfo* Arena::CreateMaybeMessage<::baikaldb::pb::ImporterTaskInfo>(Arena*);
template<> ::baikaldb::pb::SqlDetail* Arena::CreateMaybeMessage<::baikaldb::pb::SqlDetail>(Arena*);
template<> ::baikaldb::pb::TaskConfig* Arena::CreateMaybeMessage<::baikaldb::pb::TaskConfig>(Arena*);
template<> ::baikaldb::pb::TaskDetail* Arena::CreateMaybeMessage<::baikaldb::pb::TaskDetail>(Arena*);
template<> ::baikaldb::pb::TroubleShootingRequest* Arena::CreateMaybeMessage<::baikaldb::pb::TroubleShootingRequest>(Arena*);
template<> ::baikaldb::pb::TroubleShootingResponse* Arena::CreateMaybeMessage<::baikaldb::pb::TroubleShootingResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace baikaldb {
namespace pb {

enum DMSErrCode : int {
  DMS_SUCCESS = 0,
  DMS_FAILED = 1,
  DMS_SYNTAX_CHECK_FAILED = 2,
  DMS_IMPORTER_TASK_INPUT_PARAM_ILLEGAL = 1001,
  DMS_IMPORTER_TASK_ALREADY_EXIST = 1002,
  DMS_IMPORTER_TASK_NOT_EXIST = 1003,
  DMS_IMPORTER_TASK_CONFIG_ILLEGAL = 1004,
  DMS_IMPORTER_TASK_DONE_PATH_ILLEGAL = 1005,
  DMS_IMPORTER_TASK_MORE_THAN_ONE = 1006
};
bool DMSErrCode_IsValid(int value);
constexpr DMSErrCode DMSErrCode_MIN = DMS_SUCCESS;
constexpr DMSErrCode DMSErrCode_MAX = DMS_IMPORTER_TASK_MORE_THAN_ONE;
constexpr int DMSErrCode_ARRAYSIZE = DMSErrCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DMSErrCode_descriptor();
template<typename T>
inline const std::string& DMSErrCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DMSErrCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DMSErrCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DMSErrCode_descriptor(), enum_t_value);
}
inline bool DMSErrCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DMSErrCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DMSErrCode>(
    DMSErrCode_descriptor(), name, value);
}
enum DMSOpType : int {
  OP_CREATE_TASK = 1,
  OP_START_TASK = 2,
  OP_STOP_TASK = 3,
  OP_QUERY_ESTIMATE_TASK = 4,
  OP_QUERY_EXECUTE_TASK = 5,
  OP_ADD_IMPORTER_TASK = 6,
  OP_DELETE_IMPORTER_TASK = 7,
  OP_START_IMPORTER_TASK = 8,
  OP_STOP_IMPORTER_TASK = 9,
  OP_QUERY_IMPORTER_TASK = 10,
  OP_ADD_BACKTRACK_IMPORTER_TASK = 11,
  OP_DELETE_BACKTRACK_IMPORTER_TASK = 12,
  OP_QUERY_BACKTRACK_IMPORTER_TASK = 13,
  OP_ADD_TMP_TABLE_TASK = 14,
  OP_QUERY_TMP_TABLE_TASK = 15,
  OP_QUERY_BNS = 16
};
bool DMSOpType_IsValid(int value);
constexpr DMSOpType DMSOpType_MIN = OP_CREATE_TASK;
constexpr DMSOpType DMSOpType_MAX = OP_QUERY_BNS;
constexpr int DMSOpType_ARRAYSIZE = DMSOpType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DMSOpType_descriptor();
template<typename T>
inline const std::string& DMSOpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DMSOpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DMSOpType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DMSOpType_descriptor(), enum_t_value);
}
inline bool DMSOpType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DMSOpType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DMSOpType>(
    DMSOpType_descriptor(), name, value);
}
enum SqlStatus : int {
  SQL_SUCCESS = 0,
  SQL_FAILED = 1,
  SQL_DOING = 2
};
bool SqlStatus_IsValid(int value);
constexpr SqlStatus SqlStatus_MIN = SQL_SUCCESS;
constexpr SqlStatus SqlStatus_MAX = SQL_DOING;
constexpr int SqlStatus_ARRAYSIZE = SqlStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SqlStatus_descriptor();
template<typename T>
inline const std::string& SqlStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SqlStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SqlStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SqlStatus_descriptor(), enum_t_value);
}
inline bool SqlStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SqlStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SqlStatus>(
    SqlStatus_descriptor(), name, value);
}
enum TaskStatus : int {
  TS_SUCCESS = 0,
  TS_RUNNING = 1,
  TS_STOPPED = 2,
  TS_FAILED = 3,
  TS_ESTIMATE_RUNNING = 4,
  TS_ESTIMATE_SUCCESS = 5,
  TS_NOT_EXIST = 6,
  TS_IDLE = 7,
  TS_LORENTZ = 8,
  TS_INITED = 9,
  TS_UNKNOWN = 1001
};
bool TaskStatus_IsValid(int value);
constexpr TaskStatus TaskStatus_MIN = TS_SUCCESS;
constexpr TaskStatus TaskStatus_MAX = TS_UNKNOWN;
constexpr int TaskStatus_ARRAYSIZE = TaskStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskStatus_descriptor();
template<typename T>
inline const std::string& TaskStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskStatus_descriptor(), enum_t_value);
}
inline bool TaskStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskStatus>(
    TaskStatus_descriptor(), name, value);
}
// ===================================================================

class DBArgs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.DBArgs) */ {
 public:
  inline DBArgs() : DBArgs(nullptr) {}
  ~DBArgs() override;
  explicit constexpr DBArgs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DBArgs(const DBArgs& from);
  DBArgs(DBArgs&& from) noexcept
    : DBArgs() {
    *this = ::std::move(from);
  }

  inline DBArgs& operator=(const DBArgs& from) {
    CopyFrom(from);
    return *this;
  }
  inline DBArgs& operator=(DBArgs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DBArgs& default_instance() {
    return *internal_default_instance();
  }
  static inline const DBArgs* internal_default_instance() {
    return reinterpret_cast<const DBArgs*>(
               &_DBArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DBArgs& a, DBArgs& b) {
    a.Swap(&b);
  }
  inline void Swap(DBArgs* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DBArgs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DBArgs* New() const final {
    return new DBArgs();
  }

  DBArgs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DBArgs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DBArgs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DBArgs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DBArgs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.DBArgs";
  }
  protected:
  explicit DBArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaikalMetaFieldNumber = 1,
    kBaikalNamespaceFieldNumber = 2,
    kBaikalCurrentDbFieldNumber = 3,
  };
  // optional bytes baikal_meta = 1;
  bool has_baikal_meta() const;
  private:
  bool _internal_has_baikal_meta() const;
  public:
  void clear_baikal_meta();
  const std::string& baikal_meta() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_baikal_meta(ArgT0&& arg0, ArgT... args);
  std::string* mutable_baikal_meta();
  PROTOBUF_MUST_USE_RESULT std::string* release_baikal_meta();
  void set_allocated_baikal_meta(std::string* baikal_meta);
  private:
  const std::string& _internal_baikal_meta() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_baikal_meta(const std::string& value);
  std::string* _internal_mutable_baikal_meta();
  public:

  // optional bytes baikal_namespace = 2;
  bool has_baikal_namespace() const;
  private:
  bool _internal_has_baikal_namespace() const;
  public:
  void clear_baikal_namespace();
  const std::string& baikal_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_baikal_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_baikal_namespace();
  PROTOBUF_MUST_USE_RESULT std::string* release_baikal_namespace();
  void set_allocated_baikal_namespace(std::string* baikal_namespace);
  private:
  const std::string& _internal_baikal_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_baikal_namespace(const std::string& value);
  std::string* _internal_mutable_baikal_namespace();
  public:

  // optional bytes baikal_current_db = 3;
  bool has_baikal_current_db() const;
  private:
  bool _internal_has_baikal_current_db() const;
  public:
  void clear_baikal_current_db();
  const std::string& baikal_current_db() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_baikal_current_db(ArgT0&& arg0, ArgT... args);
  std::string* mutable_baikal_current_db();
  PROTOBUF_MUST_USE_RESULT std::string* release_baikal_current_db();
  void set_allocated_baikal_current_db(std::string* baikal_current_db);
  private:
  const std::string& _internal_baikal_current_db() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_baikal_current_db(const std::string& value);
  std::string* _internal_mutable_baikal_current_db();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.DBArgs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr baikal_meta_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr baikal_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr baikal_current_db_;
  friend struct ::TableStruct_dms_2eproto;
};
// -------------------------------------------------------------------

class SqlDetail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.SqlDetail) */ {
 public:
  inline SqlDetail() : SqlDetail(nullptr) {}
  ~SqlDetail() override;
  explicit constexpr SqlDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SqlDetail(const SqlDetail& from);
  SqlDetail(SqlDetail&& from) noexcept
    : SqlDetail() {
    *this = ::std::move(from);
  }

  inline SqlDetail& operator=(const SqlDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline SqlDetail& operator=(SqlDetail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SqlDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const SqlDetail* internal_default_instance() {
    return reinterpret_cast<const SqlDetail*>(
               &_SqlDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SqlDetail& a, SqlDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(SqlDetail* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SqlDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SqlDetail* New() const final {
    return new SqlDetail();
  }

  SqlDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SqlDetail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SqlDetail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SqlDetail& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SqlDetail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.SqlDetail";
  }
  protected:
  explicit SqlDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrmsgFieldNumber = 3,
    kSqlFieldNumber = 5,
    kIdFieldNumber = 1,
    kAffectedRowFieldNumber = 4,
    kStatusFieldNumber = 2,
  };
  // optional bytes errmsg = 3;
  bool has_errmsg() const;
  private:
  bool _internal_has_errmsg() const;
  public:
  void clear_errmsg();
  const std::string& errmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errmsg();
  PROTOBUF_MUST_USE_RESULT std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // optional bytes sql = 5;
  bool has_sql() const;
  private:
  bool _internal_has_sql() const;
  public:
  void clear_sql();
  const std::string& sql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sql();
  PROTOBUF_MUST_USE_RESULT std::string* release_sql();
  void set_allocated_sql(std::string* sql);
  private:
  const std::string& _internal_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql(const std::string& value);
  std::string* _internal_mutable_sql();
  public:

  // optional int64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 affected_row = 4;
  bool has_affected_row() const;
  private:
  bool _internal_has_affected_row() const;
  public:
  void clear_affected_row();
  ::PROTOBUF_NAMESPACE_ID::int64 affected_row() const;
  void set_affected_row(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_affected_row() const;
  void _internal_set_affected_row(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.SqlStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::baikaldb::pb::SqlStatus status() const;
  void set_status(::baikaldb::pb::SqlStatus value);
  private:
  ::baikaldb::pb::SqlStatus _internal_status() const;
  void _internal_set_status(::baikaldb::pb::SqlStatus value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.SqlDetail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sql_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  ::PROTOBUF_NAMESPACE_ID::int64 affected_row_;
  int status_;
  friend struct ::TableStruct_dms_2eproto;
};
// -------------------------------------------------------------------

class TaskDetail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TaskDetail) */ {
 public:
  inline TaskDetail() : TaskDetail(nullptr) {}
  ~TaskDetail() override;
  explicit constexpr TaskDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskDetail(const TaskDetail& from);
  TaskDetail(TaskDetail&& from) noexcept
    : TaskDetail() {
    *this = ::std::move(from);
  }

  inline TaskDetail& operator=(const TaskDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskDetail& operator=(TaskDetail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskDetail* internal_default_instance() {
    return reinterpret_cast<const TaskDetail*>(
               &_TaskDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TaskDetail& a, TaskDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskDetail* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskDetail* New() const final {
    return new TaskDetail();
  }

  TaskDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskDetail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskDetail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskDetail& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskDetail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TaskDetail";
  }
  protected:
  explicit TaskDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSqlDetailsFieldNumber = 6,
    kErrmsgFieldNumber = 3,
    kTaskIdFieldNumber = 1,
    kTotalSqlNumFieldNumber = 4,
    kDoneSqlNumFieldNumber = 5,
    kStatusFieldNumber = 2,
  };
  // repeated .baikaldb.pb.SqlDetail sql_details = 6;
  int sql_details_size() const;
  private:
  int _internal_sql_details_size() const;
  public:
  void clear_sql_details();
  ::baikaldb::pb::SqlDetail* mutable_sql_details(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SqlDetail >*
      mutable_sql_details();
  private:
  const ::baikaldb::pb::SqlDetail& _internal_sql_details(int index) const;
  ::baikaldb::pb::SqlDetail* _internal_add_sql_details();
  public:
  const ::baikaldb::pb::SqlDetail& sql_details(int index) const;
  ::baikaldb::pb::SqlDetail* add_sql_details();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SqlDetail >&
      sql_details() const;

  // optional bytes errmsg = 3;
  bool has_errmsg() const;
  private:
  bool _internal_has_errmsg() const;
  public:
  void clear_errmsg();
  const std::string& errmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errmsg();
  PROTOBUF_MUST_USE_RESULT std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // optional uint64 task_id = 1;
  bool has_task_id() const;
  private:
  bool _internal_has_task_id() const;
  public:
  void clear_task_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id() const;
  void set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_task_id() const;
  void _internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int64 total_sql_num = 4;
  bool has_total_sql_num() const;
  private:
  bool _internal_has_total_sql_num() const;
  public:
  void clear_total_sql_num();
  ::PROTOBUF_NAMESPACE_ID::int64 total_sql_num() const;
  void set_total_sql_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_total_sql_num() const;
  void _internal_set_total_sql_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 done_sql_num = 5;
  bool has_done_sql_num() const;
  private:
  bool _internal_has_done_sql_num() const;
  public:
  void clear_done_sql_num();
  ::PROTOBUF_NAMESPACE_ID::int64 done_sql_num() const;
  void set_done_sql_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_done_sql_num() const;
  void _internal_set_done_sql_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.TaskStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::baikaldb::pb::TaskStatus status() const;
  void set_status(::baikaldb::pb::TaskStatus value);
  private:
  ::baikaldb::pb::TaskStatus _internal_status() const;
  void _internal_set_status(::baikaldb::pb::TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TaskDetail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SqlDetail > sql_details_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_sql_num_;
  ::PROTOBUF_NAMESPACE_ID::int64 done_sql_num_;
  int status_;
  friend struct ::TableStruct_dms_2eproto;
};
// -------------------------------------------------------------------

class ImporterTaskInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ImporterTaskInfo) */ {
 public:
  inline ImporterTaskInfo() : ImporterTaskInfo(nullptr) {}
  ~ImporterTaskInfo() override;
  explicit constexpr ImporterTaskInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImporterTaskInfo(const ImporterTaskInfo& from);
  ImporterTaskInfo(ImporterTaskInfo&& from) noexcept
    : ImporterTaskInfo() {
    *this = ::std::move(from);
  }

  inline ImporterTaskInfo& operator=(const ImporterTaskInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImporterTaskInfo& operator=(ImporterTaskInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImporterTaskInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImporterTaskInfo* internal_default_instance() {
    return reinterpret_cast<const ImporterTaskInfo*>(
               &_ImporterTaskInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ImporterTaskInfo& a, ImporterTaskInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ImporterTaskInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImporterTaskInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImporterTaskInfo* New() const final {
    return new ImporterTaskInfo();
  }

  ImporterTaskInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImporterTaskInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImporterTaskInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ImporterTaskInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImporterTaskInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ImporterTaskInfo";
  }
  protected:
  explicit ImporterTaskInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskSuffixFieldNumber = 1,
    kStatusFieldNumber = 2,
    kBaikalMetaFieldNumber = 3,
    kBaikalNamespaceFieldNumber = 4,
    kDatabaseNameFieldNumber = 5,
    kTableNameFieldNumber = 6,
    kAfsClusterFieldNumber = 7,
    kAfsUsernameFieldNumber = 8,
    kAfsPasswordFieldNumber = 9,
    kDoneFileFieldNumber = 10,
    kModelFieldNumber = 11,
    kTableCharsetFieldNumber = 13,
    kDataCharsetFieldNumber = 14,
    kConfigFieldNumber = 15,
    kOwnerFieldNumber = 17,
    kRemarkFieldNumber = 18,
    kBaikaldbBnsFieldNumber = 19,
    kBaikaldbUsernameFieldNumber = 20,
    kBaikaldbPasswordFieldNumber = 21,
    kLorentzDoneJsonFieldNumber = 22,
    kVersionFieldNumber = 12,
    kBrokenPointContinuingFieldNumber = 16,
  };
  // optional bytes task_suffix = 1;
  bool has_task_suffix() const;
  private:
  bool _internal_has_task_suffix() const;
  public:
  void clear_task_suffix();
  const std::string& task_suffix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_suffix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_suffix();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_suffix();
  void set_allocated_task_suffix(std::string* task_suffix);
  private:
  const std::string& _internal_task_suffix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_suffix(const std::string& value);
  std::string* _internal_mutable_task_suffix();
  public:

  // optional bytes status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional bytes baikal_meta = 3;
  bool has_baikal_meta() const;
  private:
  bool _internal_has_baikal_meta() const;
  public:
  void clear_baikal_meta();
  const std::string& baikal_meta() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_baikal_meta(ArgT0&& arg0, ArgT... args);
  std::string* mutable_baikal_meta();
  PROTOBUF_MUST_USE_RESULT std::string* release_baikal_meta();
  void set_allocated_baikal_meta(std::string* baikal_meta);
  private:
  const std::string& _internal_baikal_meta() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_baikal_meta(const std::string& value);
  std::string* _internal_mutable_baikal_meta();
  public:

  // optional bytes baikal_namespace = 4;
  bool has_baikal_namespace() const;
  private:
  bool _internal_has_baikal_namespace() const;
  public:
  void clear_baikal_namespace();
  const std::string& baikal_namespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_baikal_namespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_baikal_namespace();
  PROTOBUF_MUST_USE_RESULT std::string* release_baikal_namespace();
  void set_allocated_baikal_namespace(std::string* baikal_namespace);
  private:
  const std::string& _internal_baikal_namespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_baikal_namespace(const std::string& value);
  std::string* _internal_mutable_baikal_namespace();
  public:

  // optional bytes database_name = 5;
  bool has_database_name() const;
  private:
  bool _internal_has_database_name() const;
  public:
  void clear_database_name();
  const std::string& database_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_database_name();
  void set_allocated_database_name(std::string* database_name);
  private:
  const std::string& _internal_database_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database_name(const std::string& value);
  std::string* _internal_mutable_database_name();
  public:

  // optional bytes table_name = 6;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional bytes afs_cluster = 7;
  bool has_afs_cluster() const;
  private:
  bool _internal_has_afs_cluster() const;
  public:
  void clear_afs_cluster();
  const std::string& afs_cluster() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_afs_cluster(ArgT0&& arg0, ArgT... args);
  std::string* mutable_afs_cluster();
  PROTOBUF_MUST_USE_RESULT std::string* release_afs_cluster();
  void set_allocated_afs_cluster(std::string* afs_cluster);
  private:
  const std::string& _internal_afs_cluster() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_afs_cluster(const std::string& value);
  std::string* _internal_mutable_afs_cluster();
  public:

  // optional bytes afs_username = 8;
  bool has_afs_username() const;
  private:
  bool _internal_has_afs_username() const;
  public:
  void clear_afs_username();
  const std::string& afs_username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_afs_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_afs_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_afs_username();
  void set_allocated_afs_username(std::string* afs_username);
  private:
  const std::string& _internal_afs_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_afs_username(const std::string& value);
  std::string* _internal_mutable_afs_username();
  public:

  // optional bytes afs_password = 9;
  bool has_afs_password() const;
  private:
  bool _internal_has_afs_password() const;
  public:
  void clear_afs_password();
  const std::string& afs_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_afs_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_afs_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_afs_password();
  void set_allocated_afs_password(std::string* afs_password);
  private:
  const std::string& _internal_afs_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_afs_password(const std::string& value);
  std::string* _internal_mutable_afs_password();
  public:

  // optional bytes done_file = 10;
  bool has_done_file() const;
  private:
  bool _internal_has_done_file() const;
  public:
  void clear_done_file();
  const std::string& done_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_done_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_done_file();
  PROTOBUF_MUST_USE_RESULT std::string* release_done_file();
  void set_allocated_done_file(std::string* done_file);
  private:
  const std::string& _internal_done_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_done_file(const std::string& value);
  std::string* _internal_mutable_done_file();
  public:

  // optional bytes model = 11;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_MUST_USE_RESULT std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // optional bytes table_charset = 13;
  bool has_table_charset() const;
  private:
  bool _internal_has_table_charset() const;
  public:
  void clear_table_charset();
  const std::string& table_charset() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_charset(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_charset();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_charset();
  void set_allocated_table_charset(std::string* table_charset);
  private:
  const std::string& _internal_table_charset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_charset(const std::string& value);
  std::string* _internal_mutable_table_charset();
  public:

  // optional bytes data_charset = 14;
  bool has_data_charset() const;
  private:
  bool _internal_has_data_charset() const;
  public:
  void clear_data_charset();
  const std::string& data_charset() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_charset(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_charset();
  PROTOBUF_MUST_USE_RESULT std::string* release_data_charset();
  void set_allocated_data_charset(std::string* data_charset);
  private:
  const std::string& _internal_data_charset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_charset(const std::string& value);
  std::string* _internal_mutable_data_charset();
  public:

  // optional bytes config = 15;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const std::string& config() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config();
  PROTOBUF_MUST_USE_RESULT std::string* release_config();
  void set_allocated_config(std::string* config);
  private:
  const std::string& _internal_config() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config(const std::string& value);
  std::string* _internal_mutable_config();
  public:

  // optional bytes owner = 17;
  bool has_owner() const;
  private:
  bool _internal_has_owner() const;
  public:
  void clear_owner();
  const std::string& owner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_owner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_owner();
  PROTOBUF_MUST_USE_RESULT std::string* release_owner();
  void set_allocated_owner(std::string* owner);
  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(const std::string& value);
  std::string* _internal_mutable_owner();
  public:

  // optional bytes remark = 18;
  bool has_remark() const;
  private:
  bool _internal_has_remark() const;
  public:
  void clear_remark();
  const std::string& remark() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remark(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remark();
  PROTOBUF_MUST_USE_RESULT std::string* release_remark();
  void set_allocated_remark(std::string* remark);
  private:
  const std::string& _internal_remark() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remark(const std::string& value);
  std::string* _internal_mutable_remark();
  public:

  // optional bytes baikaldb_bns = 19;
  bool has_baikaldb_bns() const;
  private:
  bool _internal_has_baikaldb_bns() const;
  public:
  void clear_baikaldb_bns();
  const std::string& baikaldb_bns() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_baikaldb_bns(ArgT0&& arg0, ArgT... args);
  std::string* mutable_baikaldb_bns();
  PROTOBUF_MUST_USE_RESULT std::string* release_baikaldb_bns();
  void set_allocated_baikaldb_bns(std::string* baikaldb_bns);
  private:
  const std::string& _internal_baikaldb_bns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_baikaldb_bns(const std::string& value);
  std::string* _internal_mutable_baikaldb_bns();
  public:

  // optional bytes baikaldb_username = 20;
  bool has_baikaldb_username() const;
  private:
  bool _internal_has_baikaldb_username() const;
  public:
  void clear_baikaldb_username();
  const std::string& baikaldb_username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_baikaldb_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_baikaldb_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_baikaldb_username();
  void set_allocated_baikaldb_username(std::string* baikaldb_username);
  private:
  const std::string& _internal_baikaldb_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_baikaldb_username(const std::string& value);
  std::string* _internal_mutable_baikaldb_username();
  public:

  // optional bytes baikaldb_password = 21;
  bool has_baikaldb_password() const;
  private:
  bool _internal_has_baikaldb_password() const;
  public:
  void clear_baikaldb_password();
  const std::string& baikaldb_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_baikaldb_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_baikaldb_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_baikaldb_password();
  void set_allocated_baikaldb_password(std::string* baikaldb_password);
  private:
  const std::string& _internal_baikaldb_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_baikaldb_password(const std::string& value);
  std::string* _internal_mutable_baikaldb_password();
  public:

  // optional bytes lorentz_done_json = 22;
  bool has_lorentz_done_json() const;
  private:
  bool _internal_has_lorentz_done_json() const;
  public:
  void clear_lorentz_done_json();
  const std::string& lorentz_done_json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lorentz_done_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lorentz_done_json();
  PROTOBUF_MUST_USE_RESULT std::string* release_lorentz_done_json();
  void set_allocated_lorentz_done_json(std::string* lorentz_done_json);
  private:
  const std::string& _internal_lorentz_done_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lorentz_done_json(const std::string& value);
  std::string* _internal_mutable_lorentz_done_json();
  public:

  // optional int64 version = 12;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 broken_point_continuing = 16;
  bool has_broken_point_continuing() const;
  private:
  bool _internal_has_broken_point_continuing() const;
  public:
  void clear_broken_point_continuing();
  ::PROTOBUF_NAMESPACE_ID::int32 broken_point_continuing() const;
  void set_broken_point_continuing(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_broken_point_continuing() const;
  void _internal_set_broken_point_continuing(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ImporterTaskInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_suffix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr baikal_meta_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr baikal_namespace_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr afs_cluster_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr afs_username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr afs_password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr done_file_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_charset_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_charset_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remark_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr baikaldb_bns_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr baikaldb_username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr baikaldb_password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lorentz_done_json_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  ::PROTOBUF_NAMESPACE_ID::int32 broken_point_continuing_;
  friend struct ::TableStruct_dms_2eproto;
};
// -------------------------------------------------------------------

class BacktrackImporterTaskInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BacktrackImporterTaskInfo) */ {
 public:
  inline BacktrackImporterTaskInfo() : BacktrackImporterTaskInfo(nullptr) {}
  ~BacktrackImporterTaskInfo() override;
  explicit constexpr BacktrackImporterTaskInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BacktrackImporterTaskInfo(const BacktrackImporterTaskInfo& from);
  BacktrackImporterTaskInfo(BacktrackImporterTaskInfo&& from) noexcept
    : BacktrackImporterTaskInfo() {
    *this = ::std::move(from);
  }

  inline BacktrackImporterTaskInfo& operator=(const BacktrackImporterTaskInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BacktrackImporterTaskInfo& operator=(BacktrackImporterTaskInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BacktrackImporterTaskInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BacktrackImporterTaskInfo* internal_default_instance() {
    return reinterpret_cast<const BacktrackImporterTaskInfo*>(
               &_BacktrackImporterTaskInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BacktrackImporterTaskInfo& a, BacktrackImporterTaskInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BacktrackImporterTaskInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BacktrackImporterTaskInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BacktrackImporterTaskInfo* New() const final {
    return new BacktrackImporterTaskInfo();
  }

  BacktrackImporterTaskInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BacktrackImporterTaskInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BacktrackImporterTaskInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BacktrackImporterTaskInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BacktrackImporterTaskInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BacktrackImporterTaskInfo";
  }
  protected:
  explicit BacktrackImporterTaskInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBacktrackDoneFilesFieldNumber = 5,
    kBacktrackVersionsFieldNumber = 6,
    kDatabaseNameFieldNumber = 1,
    kTableNameFieldNumber = 2,
    kAfsClusterFieldNumber = 3,
    kTaskDonePathFieldNumber = 4,
    kBacktrackStartVersionFieldNumber = 7,
    kIsRoutineTaskFieldNumber = 8,
  };
  // repeated bytes backtrack_done_files = 5;
  int backtrack_done_files_size() const;
  private:
  int _internal_backtrack_done_files_size() const;
  public:
  void clear_backtrack_done_files();
  const std::string& backtrack_done_files(int index) const;
  std::string* mutable_backtrack_done_files(int index);
  void set_backtrack_done_files(int index, const std::string& value);
  void set_backtrack_done_files(int index, std::string&& value);
  void set_backtrack_done_files(int index, const char* value);
  void set_backtrack_done_files(int index, const void* value, size_t size);
  std::string* add_backtrack_done_files();
  void add_backtrack_done_files(const std::string& value);
  void add_backtrack_done_files(std::string&& value);
  void add_backtrack_done_files(const char* value);
  void add_backtrack_done_files(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& backtrack_done_files() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_backtrack_done_files();
  private:
  const std::string& _internal_backtrack_done_files(int index) const;
  std::string* _internal_add_backtrack_done_files();
  public:

  // repeated int64 backtrack_versions = 6;
  int backtrack_versions_size() const;
  private:
  int _internal_backtrack_versions_size() const;
  public:
  void clear_backtrack_versions();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_backtrack_versions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_backtrack_versions() const;
  void _internal_add_backtrack_versions(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_backtrack_versions();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 backtrack_versions(int index) const;
  void set_backtrack_versions(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_backtrack_versions(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      backtrack_versions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_backtrack_versions();

  // optional bytes database_name = 1;
  bool has_database_name() const;
  private:
  bool _internal_has_database_name() const;
  public:
  void clear_database_name();
  const std::string& database_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_database_name();
  void set_allocated_database_name(std::string* database_name);
  private:
  const std::string& _internal_database_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database_name(const std::string& value);
  std::string* _internal_mutable_database_name();
  public:

  // optional bytes table_name = 2;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional bytes afs_cluster = 3;
  bool has_afs_cluster() const;
  private:
  bool _internal_has_afs_cluster() const;
  public:
  void clear_afs_cluster();
  const std::string& afs_cluster() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_afs_cluster(ArgT0&& arg0, ArgT... args);
  std::string* mutable_afs_cluster();
  PROTOBUF_MUST_USE_RESULT std::string* release_afs_cluster();
  void set_allocated_afs_cluster(std::string* afs_cluster);
  private:
  const std::string& _internal_afs_cluster() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_afs_cluster(const std::string& value);
  std::string* _internal_mutable_afs_cluster();
  public:

  // optional bytes task_done_path = 4;
  bool has_task_done_path() const;
  private:
  bool _internal_has_task_done_path() const;
  public:
  void clear_task_done_path();
  const std::string& task_done_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_done_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_done_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_done_path();
  void set_allocated_task_done_path(std::string* task_done_path);
  private:
  const std::string& _internal_task_done_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_done_path(const std::string& value);
  std::string* _internal_mutable_task_done_path();
  public:

  // optional int64 backtrack_start_version = 7;
  bool has_backtrack_start_version() const;
  private:
  bool _internal_has_backtrack_start_version() const;
  public:
  void clear_backtrack_start_version();
  ::PROTOBUF_NAMESPACE_ID::int64 backtrack_start_version() const;
  void set_backtrack_start_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_backtrack_start_version() const;
  void _internal_set_backtrack_start_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool is_routine_task = 8;
  bool has_is_routine_task() const;
  private:
  bool _internal_has_is_routine_task() const;
  public:
  void clear_is_routine_task();
  bool is_routine_task() const;
  void set_is_routine_task(bool value);
  private:
  bool _internal_is_routine_task() const;
  void _internal_set_is_routine_task(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BacktrackImporterTaskInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> backtrack_done_files_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > backtrack_versions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr afs_cluster_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_done_path_;
  ::PROTOBUF_NAMESPACE_ID::int64 backtrack_start_version_;
  bool is_routine_task_;
  friend struct ::TableStruct_dms_2eproto;
};
// -------------------------------------------------------------------

class TroubleShootingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TroubleShootingRequest) */ {
 public:
  inline TroubleShootingRequest() : TroubleShootingRequest(nullptr) {}
  ~TroubleShootingRequest() override;
  explicit constexpr TroubleShootingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TroubleShootingRequest(const TroubleShootingRequest& from);
  TroubleShootingRequest(TroubleShootingRequest&& from) noexcept
    : TroubleShootingRequest() {
    *this = ::std::move(from);
  }

  inline TroubleShootingRequest& operator=(const TroubleShootingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TroubleShootingRequest& operator=(TroubleShootingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TroubleShootingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TroubleShootingRequest* internal_default_instance() {
    return reinterpret_cast<const TroubleShootingRequest*>(
               &_TroubleShootingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TroubleShootingRequest& a, TroubleShootingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TroubleShootingRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TroubleShootingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TroubleShootingRequest* New() const final {
    return new TroubleShootingRequest();
  }

  TroubleShootingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TroubleShootingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TroubleShootingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TroubleShootingRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TroubleShootingRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TroubleShootingRequest";
  }
  protected:
  explicit TroubleShootingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaikalBnsFieldNumber = 1,
    kBaikaldbBnsFieldNumber = 2,
    kDbNameFieldNumber = 3,
    kTableNameFieldNumber = 4,
    kIsOfflineFieldNumber = 5,
  };
  // optional bytes baikal_bns = 1;
  bool has_baikal_bns() const;
  private:
  bool _internal_has_baikal_bns() const;
  public:
  void clear_baikal_bns();
  const std::string& baikal_bns() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_baikal_bns(ArgT0&& arg0, ArgT... args);
  std::string* mutable_baikal_bns();
  PROTOBUF_MUST_USE_RESULT std::string* release_baikal_bns();
  void set_allocated_baikal_bns(std::string* baikal_bns);
  private:
  const std::string& _internal_baikal_bns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_baikal_bns(const std::string& value);
  std::string* _internal_mutable_baikal_bns();
  public:

  // optional bytes baikaldb_bns = 2;
  bool has_baikaldb_bns() const;
  private:
  bool _internal_has_baikaldb_bns() const;
  public:
  void clear_baikaldb_bns();
  const std::string& baikaldb_bns() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_baikaldb_bns(ArgT0&& arg0, ArgT... args);
  std::string* mutable_baikaldb_bns();
  PROTOBUF_MUST_USE_RESULT std::string* release_baikaldb_bns();
  void set_allocated_baikaldb_bns(std::string* baikaldb_bns);
  private:
  const std::string& _internal_baikaldb_bns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_baikaldb_bns(const std::string& value);
  std::string* _internal_mutable_baikaldb_bns();
  public:

  // optional bytes db_name = 3;
  bool has_db_name() const;
  private:
  bool _internal_has_db_name() const;
  public:
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // optional bytes table_name = 4;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional bool is_offline = 5;
  bool has_is_offline() const;
  private:
  bool _internal_has_is_offline() const;
  public:
  void clear_is_offline();
  bool is_offline() const;
  void set_is_offline(bool value);
  private:
  bool _internal_is_offline() const;
  void _internal_set_is_offline(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TroubleShootingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr baikal_bns_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr baikaldb_bns_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  bool is_offline_;
  friend struct ::TableStruct_dms_2eproto;
};
// -------------------------------------------------------------------

class TroubleShootingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TroubleShootingResponse) */ {
 public:
  inline TroubleShootingResponse() : TroubleShootingResponse(nullptr) {}
  ~TroubleShootingResponse() override;
  explicit constexpr TroubleShootingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TroubleShootingResponse(const TroubleShootingResponse& from);
  TroubleShootingResponse(TroubleShootingResponse&& from) noexcept
    : TroubleShootingResponse() {
    *this = ::std::move(from);
  }

  inline TroubleShootingResponse& operator=(const TroubleShootingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TroubleShootingResponse& operator=(TroubleShootingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TroubleShootingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TroubleShootingResponse* internal_default_instance() {
    return reinterpret_cast<const TroubleShootingResponse*>(
               &_TroubleShootingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TroubleShootingResponse& a, TroubleShootingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TroubleShootingResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TroubleShootingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TroubleShootingResponse* New() const final {
    return new TroubleShootingResponse();
  }

  TroubleShootingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TroubleShootingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TroubleShootingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TroubleShootingResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TroubleShootingResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TroubleShootingResponse";
  }
  protected:
  explicit TroubleShootingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaikaldbBnsFieldNumber = 1,
    kBaikalstoreBnsFieldNumber = 2,
  };
  // repeated bytes baikaldb_bns = 1;
  int baikaldb_bns_size() const;
  private:
  int _internal_baikaldb_bns_size() const;
  public:
  void clear_baikaldb_bns();
  const std::string& baikaldb_bns(int index) const;
  std::string* mutable_baikaldb_bns(int index);
  void set_baikaldb_bns(int index, const std::string& value);
  void set_baikaldb_bns(int index, std::string&& value);
  void set_baikaldb_bns(int index, const char* value);
  void set_baikaldb_bns(int index, const void* value, size_t size);
  std::string* add_baikaldb_bns();
  void add_baikaldb_bns(const std::string& value);
  void add_baikaldb_bns(std::string&& value);
  void add_baikaldb_bns(const char* value);
  void add_baikaldb_bns(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& baikaldb_bns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_baikaldb_bns();
  private:
  const std::string& _internal_baikaldb_bns(int index) const;
  std::string* _internal_add_baikaldb_bns();
  public:

  // repeated bytes baikalstore_bns = 2;
  int baikalstore_bns_size() const;
  private:
  int _internal_baikalstore_bns_size() const;
  public:
  void clear_baikalstore_bns();
  const std::string& baikalstore_bns(int index) const;
  std::string* mutable_baikalstore_bns(int index);
  void set_baikalstore_bns(int index, const std::string& value);
  void set_baikalstore_bns(int index, std::string&& value);
  void set_baikalstore_bns(int index, const char* value);
  void set_baikalstore_bns(int index, const void* value, size_t size);
  std::string* add_baikalstore_bns();
  void add_baikalstore_bns(const std::string& value);
  void add_baikalstore_bns(std::string&& value);
  void add_baikalstore_bns(const char* value);
  void add_baikalstore_bns(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& baikalstore_bns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_baikalstore_bns();
  private:
  const std::string& _internal_baikalstore_bns(int index) const;
  std::string* _internal_add_baikalstore_bns();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TroubleShootingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> baikaldb_bns_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> baikalstore_bns_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_dms_2eproto;
};
// -------------------------------------------------------------------

class TaskConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TaskConfig) */ {
 public:
  inline TaskConfig() : TaskConfig(nullptr) {}
  ~TaskConfig() override;
  explicit constexpr TaskConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskConfig(const TaskConfig& from);
  TaskConfig(TaskConfig&& from) noexcept
    : TaskConfig() {
    *this = ::std::move(from);
  }

  inline TaskConfig& operator=(const TaskConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskConfig& operator=(TaskConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskConfig* internal_default_instance() {
    return reinterpret_cast<const TaskConfig*>(
               &_TaskConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TaskConfig& a, TaskConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TaskConfig* New() const final {
    return new TaskConfig();
  }

  TaskConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TaskConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TaskConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TaskConfig";
  }
  protected:
  explicit TaskConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNeedBackupFieldNumber = 1,
    kNeedParallelFieldNumber = 2,
  };
  // optional bool need_backup = 1;
  bool has_need_backup() const;
  private:
  bool _internal_has_need_backup() const;
  public:
  void clear_need_backup();
  bool need_backup() const;
  void set_need_backup(bool value);
  private:
  bool _internal_need_backup() const;
  void _internal_set_need_backup(bool value);
  public:

  // optional bool need_parallel = 2;
  bool has_need_parallel() const;
  private:
  bool _internal_has_need_parallel() const;
  public:
  void clear_need_parallel();
  bool need_parallel() const;
  void set_need_parallel(bool value);
  private:
  bool _internal_need_parallel() const;
  void _internal_set_need_parallel(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TaskConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool need_backup_;
  bool need_parallel_;
  friend struct ::TableStruct_dms_2eproto;
};
// -------------------------------------------------------------------

class DMSRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.DMSRequest) */ {
 public:
  inline DMSRequest() : DMSRequest(nullptr) {}
  ~DMSRequest() override;
  explicit constexpr DMSRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DMSRequest(const DMSRequest& from);
  DMSRequest(DMSRequest&& from) noexcept
    : DMSRequest() {
    *this = ::std::move(from);
  }

  inline DMSRequest& operator=(const DMSRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DMSRequest& operator=(DMSRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DMSRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DMSRequest* internal_default_instance() {
    return reinterpret_cast<const DMSRequest*>(
               &_DMSRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DMSRequest& a, DMSRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DMSRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DMSRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DMSRequest* New() const final {
    return new DMSRequest();
  }

  DMSRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DMSRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DMSRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DMSRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DMSRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.DMSRequest";
  }
  protected:
  explicit DMSRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskNameFieldNumber = 3,
    kRawSqlFieldNumber = 4,
    kDbArgsFieldNumber = 5,
    kTaskConfigFieldNumber = 6,
    kImporterTaskInfoFieldNumber = 7,
    kBacktrackImporterTaskInfoFieldNumber = 8,
    kTroubleShootingRequestFieldNumber = 9,
    kTaskIdFieldNumber = 2,
    kOpTypeFieldNumber = 1,
  };
  // optional bytes task_name = 3;
  bool has_task_name() const;
  private:
  bool _internal_has_task_name() const;
  public:
  void clear_task_name();
  const std::string& task_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_name();
  void set_allocated_task_name(std::string* task_name);
  private:
  const std::string& _internal_task_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_name(const std::string& value);
  std::string* _internal_mutable_task_name();
  public:

  // optional bytes raw_sql = 4;
  bool has_raw_sql() const;
  private:
  bool _internal_has_raw_sql() const;
  public:
  void clear_raw_sql();
  const std::string& raw_sql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw_sql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw_sql();
  PROTOBUF_MUST_USE_RESULT std::string* release_raw_sql();
  void set_allocated_raw_sql(std::string* raw_sql);
  private:
  const std::string& _internal_raw_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_sql(const std::string& value);
  std::string* _internal_mutable_raw_sql();
  public:

  // optional .baikaldb.pb.DBArgs db_args = 5;
  bool has_db_args() const;
  private:
  bool _internal_has_db_args() const;
  public:
  void clear_db_args();
  const ::baikaldb::pb::DBArgs& db_args() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::DBArgs* release_db_args();
  ::baikaldb::pb::DBArgs* mutable_db_args();
  void set_allocated_db_args(::baikaldb::pb::DBArgs* db_args);
  private:
  const ::baikaldb::pb::DBArgs& _internal_db_args() const;
  ::baikaldb::pb::DBArgs* _internal_mutable_db_args();
  public:
  void unsafe_arena_set_allocated_db_args(
      ::baikaldb::pb::DBArgs* db_args);
  ::baikaldb::pb::DBArgs* unsafe_arena_release_db_args();

  // optional .baikaldb.pb.TaskConfig task_config = 6;
  bool has_task_config() const;
  private:
  bool _internal_has_task_config() const;
  public:
  void clear_task_config();
  const ::baikaldb::pb::TaskConfig& task_config() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::TaskConfig* release_task_config();
  ::baikaldb::pb::TaskConfig* mutable_task_config();
  void set_allocated_task_config(::baikaldb::pb::TaskConfig* task_config);
  private:
  const ::baikaldb::pb::TaskConfig& _internal_task_config() const;
  ::baikaldb::pb::TaskConfig* _internal_mutable_task_config();
  public:
  void unsafe_arena_set_allocated_task_config(
      ::baikaldb::pb::TaskConfig* task_config);
  ::baikaldb::pb::TaskConfig* unsafe_arena_release_task_config();

  // optional .baikaldb.pb.ImporterTaskInfo importer_task_info = 7;
  bool has_importer_task_info() const;
  private:
  bool _internal_has_importer_task_info() const;
  public:
  void clear_importer_task_info();
  const ::baikaldb::pb::ImporterTaskInfo& importer_task_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::ImporterTaskInfo* release_importer_task_info();
  ::baikaldb::pb::ImporterTaskInfo* mutable_importer_task_info();
  void set_allocated_importer_task_info(::baikaldb::pb::ImporterTaskInfo* importer_task_info);
  private:
  const ::baikaldb::pb::ImporterTaskInfo& _internal_importer_task_info() const;
  ::baikaldb::pb::ImporterTaskInfo* _internal_mutable_importer_task_info();
  public:
  void unsafe_arena_set_allocated_importer_task_info(
      ::baikaldb::pb::ImporterTaskInfo* importer_task_info);
  ::baikaldb::pb::ImporterTaskInfo* unsafe_arena_release_importer_task_info();

  // optional .baikaldb.pb.BacktrackImporterTaskInfo backtrack_importer_task_info = 8;
  bool has_backtrack_importer_task_info() const;
  private:
  bool _internal_has_backtrack_importer_task_info() const;
  public:
  void clear_backtrack_importer_task_info();
  const ::baikaldb::pb::BacktrackImporterTaskInfo& backtrack_importer_task_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::BacktrackImporterTaskInfo* release_backtrack_importer_task_info();
  ::baikaldb::pb::BacktrackImporterTaskInfo* mutable_backtrack_importer_task_info();
  void set_allocated_backtrack_importer_task_info(::baikaldb::pb::BacktrackImporterTaskInfo* backtrack_importer_task_info);
  private:
  const ::baikaldb::pb::BacktrackImporterTaskInfo& _internal_backtrack_importer_task_info() const;
  ::baikaldb::pb::BacktrackImporterTaskInfo* _internal_mutable_backtrack_importer_task_info();
  public:
  void unsafe_arena_set_allocated_backtrack_importer_task_info(
      ::baikaldb::pb::BacktrackImporterTaskInfo* backtrack_importer_task_info);
  ::baikaldb::pb::BacktrackImporterTaskInfo* unsafe_arena_release_backtrack_importer_task_info();

  // optional .baikaldb.pb.TroubleShootingRequest trouble_shooting_request = 9;
  bool has_trouble_shooting_request() const;
  private:
  bool _internal_has_trouble_shooting_request() const;
  public:
  void clear_trouble_shooting_request();
  const ::baikaldb::pb::TroubleShootingRequest& trouble_shooting_request() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::TroubleShootingRequest* release_trouble_shooting_request();
  ::baikaldb::pb::TroubleShootingRequest* mutable_trouble_shooting_request();
  void set_allocated_trouble_shooting_request(::baikaldb::pb::TroubleShootingRequest* trouble_shooting_request);
  private:
  const ::baikaldb::pb::TroubleShootingRequest& _internal_trouble_shooting_request() const;
  ::baikaldb::pb::TroubleShootingRequest* _internal_mutable_trouble_shooting_request();
  public:
  void unsafe_arena_set_allocated_trouble_shooting_request(
      ::baikaldb::pb::TroubleShootingRequest* trouble_shooting_request);
  ::baikaldb::pb::TroubleShootingRequest* unsafe_arena_release_trouble_shooting_request();

  // optional uint64 task_id = 2;
  bool has_task_id() const;
  private:
  bool _internal_has_task_id() const;
  public:
  void clear_task_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id() const;
  void set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_task_id() const;
  void _internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required .baikaldb.pb.DMSOpType op_type = 1;
  bool has_op_type() const;
  private:
  bool _internal_has_op_type() const;
  public:
  void clear_op_type();
  ::baikaldb::pb::DMSOpType op_type() const;
  void set_op_type(::baikaldb::pb::DMSOpType value);
  private:
  ::baikaldb::pb::DMSOpType _internal_op_type() const;
  void _internal_set_op_type(::baikaldb::pb::DMSOpType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.DMSRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_sql_;
  ::baikaldb::pb::DBArgs* db_args_;
  ::baikaldb::pb::TaskConfig* task_config_;
  ::baikaldb::pb::ImporterTaskInfo* importer_task_info_;
  ::baikaldb::pb::BacktrackImporterTaskInfo* backtrack_importer_task_info_;
  ::baikaldb::pb::TroubleShootingRequest* trouble_shooting_request_;
  ::PROTOBUF_NAMESPACE_ID::uint64 task_id_;
  int op_type_;
  friend struct ::TableStruct_dms_2eproto;
};
// -------------------------------------------------------------------

class DMSResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.DMSResponse) */ {
 public:
  inline DMSResponse() : DMSResponse(nullptr) {}
  ~DMSResponse() override;
  explicit constexpr DMSResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DMSResponse(const DMSResponse& from);
  DMSResponse(DMSResponse&& from) noexcept
    : DMSResponse() {
    *this = ::std::move(from);
  }

  inline DMSResponse& operator=(const DMSResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DMSResponse& operator=(DMSResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DMSResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DMSResponse* internal_default_instance() {
    return reinterpret_cast<const DMSResponse*>(
               &_DMSResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DMSResponse& a, DMSResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DMSResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DMSResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DMSResponse* New() const final {
    return new DMSResponse();
  }

  DMSResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DMSResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DMSResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DMSResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DMSResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.DMSResponse";
  }
  protected:
  explicit DMSResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrmsgFieldNumber = 2,
    kTaskDetailsFieldNumber = 3,
    kTroubleShootingResponseFieldNumber = 4,
    kErrcodeFieldNumber = 1,
  };
  // optional bytes errmsg = 2;
  bool has_errmsg() const;
  private:
  bool _internal_has_errmsg() const;
  public:
  void clear_errmsg();
  const std::string& errmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errmsg();
  PROTOBUF_MUST_USE_RESULT std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // optional .baikaldb.pb.TaskDetail task_details = 3;
  bool has_task_details() const;
  private:
  bool _internal_has_task_details() const;
  public:
  void clear_task_details();
  const ::baikaldb::pb::TaskDetail& task_details() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::TaskDetail* release_task_details();
  ::baikaldb::pb::TaskDetail* mutable_task_details();
  void set_allocated_task_details(::baikaldb::pb::TaskDetail* task_details);
  private:
  const ::baikaldb::pb::TaskDetail& _internal_task_details() const;
  ::baikaldb::pb::TaskDetail* _internal_mutable_task_details();
  public:
  void unsafe_arena_set_allocated_task_details(
      ::baikaldb::pb::TaskDetail* task_details);
  ::baikaldb::pb::TaskDetail* unsafe_arena_release_task_details();

  // optional .baikaldb.pb.TroubleShootingResponse trouble_shooting_response = 4;
  bool has_trouble_shooting_response() const;
  private:
  bool _internal_has_trouble_shooting_response() const;
  public:
  void clear_trouble_shooting_response();
  const ::baikaldb::pb::TroubleShootingResponse& trouble_shooting_response() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::TroubleShootingResponse* release_trouble_shooting_response();
  ::baikaldb::pb::TroubleShootingResponse* mutable_trouble_shooting_response();
  void set_allocated_trouble_shooting_response(::baikaldb::pb::TroubleShootingResponse* trouble_shooting_response);
  private:
  const ::baikaldb::pb::TroubleShootingResponse& _internal_trouble_shooting_response() const;
  ::baikaldb::pb::TroubleShootingResponse* _internal_mutable_trouble_shooting_response();
  public:
  void unsafe_arena_set_allocated_trouble_shooting_response(
      ::baikaldb::pb::TroubleShootingResponse* trouble_shooting_response);
  ::baikaldb::pb::TroubleShootingResponse* unsafe_arena_release_trouble_shooting_response();

  // required .baikaldb.pb.DMSErrCode errcode = 1;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::DMSErrCode errcode() const;
  void set_errcode(::baikaldb::pb::DMSErrCode value);
  private:
  ::baikaldb::pb::DMSErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::DMSErrCode value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.DMSResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  ::baikaldb::pb::TaskDetail* task_details_;
  ::baikaldb::pb::TroubleShootingResponse* trouble_shooting_response_;
  int errcode_;
  friend struct ::TableStruct_dms_2eproto;
};
// ===================================================================

class DMSService_Stub;

class DMSService : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline DMSService() {};
 public:
  virtual ~DMSService();

  typedef DMSService_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void query(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::DMSRequest* request,
                       ::baikaldb::pb::DMSResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(DMSService);
};

class DMSService_Stub : public DMSService {
 public:
  DMSService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  DMSService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~DMSService_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements DMSService ------------------------------------------

  void query(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::DMSRequest* request,
                       ::baikaldb::pb::DMSResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(DMSService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DBArgs

// optional bytes baikal_meta = 1;
inline bool DBArgs::_internal_has_baikal_meta() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DBArgs::has_baikal_meta() const {
  return _internal_has_baikal_meta();
}
inline void DBArgs::clear_baikal_meta() {
  baikal_meta_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DBArgs::baikal_meta() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DBArgs.baikal_meta)
  return _internal_baikal_meta();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DBArgs::set_baikal_meta(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 baikal_meta_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DBArgs.baikal_meta)
}
inline std::string* DBArgs::mutable_baikal_meta() {
  std::string* _s = _internal_mutable_baikal_meta();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DBArgs.baikal_meta)
  return _s;
}
inline const std::string& DBArgs::_internal_baikal_meta() const {
  return baikal_meta_.Get();
}
inline void DBArgs::_internal_set_baikal_meta(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  baikal_meta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DBArgs::_internal_mutable_baikal_meta() {
  _has_bits_[0] |= 0x00000001u;
  return baikal_meta_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DBArgs::release_baikal_meta() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DBArgs.baikal_meta)
  if (!_internal_has_baikal_meta()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return baikal_meta_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DBArgs::set_allocated_baikal_meta(std::string* baikal_meta) {
  if (baikal_meta != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  baikal_meta_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), baikal_meta,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DBArgs.baikal_meta)
}

// optional bytes baikal_namespace = 2;
inline bool DBArgs::_internal_has_baikal_namespace() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DBArgs::has_baikal_namespace() const {
  return _internal_has_baikal_namespace();
}
inline void DBArgs::clear_baikal_namespace() {
  baikal_namespace_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DBArgs::baikal_namespace() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DBArgs.baikal_namespace)
  return _internal_baikal_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DBArgs::set_baikal_namespace(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 baikal_namespace_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DBArgs.baikal_namespace)
}
inline std::string* DBArgs::mutable_baikal_namespace() {
  std::string* _s = _internal_mutable_baikal_namespace();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DBArgs.baikal_namespace)
  return _s;
}
inline const std::string& DBArgs::_internal_baikal_namespace() const {
  return baikal_namespace_.Get();
}
inline void DBArgs::_internal_set_baikal_namespace(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  baikal_namespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DBArgs::_internal_mutable_baikal_namespace() {
  _has_bits_[0] |= 0x00000002u;
  return baikal_namespace_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DBArgs::release_baikal_namespace() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DBArgs.baikal_namespace)
  if (!_internal_has_baikal_namespace()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return baikal_namespace_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DBArgs::set_allocated_baikal_namespace(std::string* baikal_namespace) {
  if (baikal_namespace != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  baikal_namespace_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), baikal_namespace,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DBArgs.baikal_namespace)
}

// optional bytes baikal_current_db = 3;
inline bool DBArgs::_internal_has_baikal_current_db() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DBArgs::has_baikal_current_db() const {
  return _internal_has_baikal_current_db();
}
inline void DBArgs::clear_baikal_current_db() {
  baikal_current_db_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DBArgs::baikal_current_db() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DBArgs.baikal_current_db)
  return _internal_baikal_current_db();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DBArgs::set_baikal_current_db(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 baikal_current_db_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DBArgs.baikal_current_db)
}
inline std::string* DBArgs::mutable_baikal_current_db() {
  std::string* _s = _internal_mutable_baikal_current_db();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DBArgs.baikal_current_db)
  return _s;
}
inline const std::string& DBArgs::_internal_baikal_current_db() const {
  return baikal_current_db_.Get();
}
inline void DBArgs::_internal_set_baikal_current_db(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  baikal_current_db_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DBArgs::_internal_mutable_baikal_current_db() {
  _has_bits_[0] |= 0x00000004u;
  return baikal_current_db_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DBArgs::release_baikal_current_db() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DBArgs.baikal_current_db)
  if (!_internal_has_baikal_current_db()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return baikal_current_db_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DBArgs::set_allocated_baikal_current_db(std::string* baikal_current_db) {
  if (baikal_current_db != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  baikal_current_db_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), baikal_current_db,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DBArgs.baikal_current_db)
}

// -------------------------------------------------------------------

// SqlDetail

// optional int64 id = 1;
inline bool SqlDetail::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SqlDetail::has_id() const {
  return _internal_has_id();
}
inline void SqlDetail::clear_id() {
  id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SqlDetail::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SqlDetail::id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SqlDetail.id)
  return _internal_id();
}
inline void SqlDetail::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  id_ = value;
}
inline void SqlDetail::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SqlDetail.id)
}

// optional .baikaldb.pb.SqlStatus status = 2;
inline bool SqlDetail::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SqlDetail::has_status() const {
  return _internal_has_status();
}
inline void SqlDetail::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::baikaldb::pb::SqlStatus SqlDetail::_internal_status() const {
  return static_cast< ::baikaldb::pb::SqlStatus >(status_);
}
inline ::baikaldb::pb::SqlStatus SqlDetail::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SqlDetail.status)
  return _internal_status();
}
inline void SqlDetail::_internal_set_status(::baikaldb::pb::SqlStatus value) {
  assert(::baikaldb::pb::SqlStatus_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  status_ = value;
}
inline void SqlDetail::set_status(::baikaldb::pb::SqlStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SqlDetail.status)
}

// optional bytes errmsg = 3;
inline bool SqlDetail::_internal_has_errmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SqlDetail::has_errmsg() const {
  return _internal_has_errmsg();
}
inline void SqlDetail::clear_errmsg() {
  errmsg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SqlDetail::errmsg() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SqlDetail.errmsg)
  return _internal_errmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SqlDetail::set_errmsg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 errmsg_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SqlDetail.errmsg)
}
inline std::string* SqlDetail::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SqlDetail.errmsg)
  return _s;
}
inline const std::string& SqlDetail::_internal_errmsg() const {
  return errmsg_.Get();
}
inline void SqlDetail::_internal_set_errmsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SqlDetail::_internal_mutable_errmsg() {
  _has_bits_[0] |= 0x00000001u;
  return errmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SqlDetail::release_errmsg() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SqlDetail.errmsg)
  if (!_internal_has_errmsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return errmsg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SqlDetail::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SqlDetail.errmsg)
}

// optional int64 affected_row = 4;
inline bool SqlDetail::_internal_has_affected_row() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SqlDetail::has_affected_row() const {
  return _internal_has_affected_row();
}
inline void SqlDetail::clear_affected_row() {
  affected_row_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SqlDetail::_internal_affected_row() const {
  return affected_row_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SqlDetail::affected_row() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SqlDetail.affected_row)
  return _internal_affected_row();
}
inline void SqlDetail::_internal_set_affected_row(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  affected_row_ = value;
}
inline void SqlDetail::set_affected_row(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_affected_row(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SqlDetail.affected_row)
}

// optional bytes sql = 5;
inline bool SqlDetail::_internal_has_sql() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SqlDetail::has_sql() const {
  return _internal_has_sql();
}
inline void SqlDetail::clear_sql() {
  sql_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SqlDetail::sql() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SqlDetail.sql)
  return _internal_sql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SqlDetail::set_sql(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 sql_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SqlDetail.sql)
}
inline std::string* SqlDetail::mutable_sql() {
  std::string* _s = _internal_mutable_sql();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SqlDetail.sql)
  return _s;
}
inline const std::string& SqlDetail::_internal_sql() const {
  return sql_.Get();
}
inline void SqlDetail::_internal_set_sql(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SqlDetail::_internal_mutable_sql() {
  _has_bits_[0] |= 0x00000002u;
  return sql_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SqlDetail::release_sql() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SqlDetail.sql)
  if (!_internal_has_sql()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return sql_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SqlDetail::set_allocated_sql(std::string* sql) {
  if (sql != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sql_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sql,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SqlDetail.sql)
}

// -------------------------------------------------------------------

// TaskDetail

// optional uint64 task_id = 1;
inline bool TaskDetail::_internal_has_task_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TaskDetail::has_task_id() const {
  return _internal_has_task_id();
}
inline void TaskDetail::clear_task_id() {
  task_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaskDetail::_internal_task_id() const {
  return task_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TaskDetail::task_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TaskDetail.task_id)
  return _internal_task_id();
}
inline void TaskDetail::_internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  task_id_ = value;
}
inline void TaskDetail::set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TaskDetail.task_id)
}

// optional .baikaldb.pb.TaskStatus status = 2;
inline bool TaskDetail::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TaskDetail::has_status() const {
  return _internal_has_status();
}
inline void TaskDetail::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::baikaldb::pb::TaskStatus TaskDetail::_internal_status() const {
  return static_cast< ::baikaldb::pb::TaskStatus >(status_);
}
inline ::baikaldb::pb::TaskStatus TaskDetail::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TaskDetail.status)
  return _internal_status();
}
inline void TaskDetail::_internal_set_status(::baikaldb::pb::TaskStatus value) {
  assert(::baikaldb::pb::TaskStatus_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  status_ = value;
}
inline void TaskDetail::set_status(::baikaldb::pb::TaskStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TaskDetail.status)
}

// optional bytes errmsg = 3;
inline bool TaskDetail::_internal_has_errmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TaskDetail::has_errmsg() const {
  return _internal_has_errmsg();
}
inline void TaskDetail::clear_errmsg() {
  errmsg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TaskDetail::errmsg() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TaskDetail.errmsg)
  return _internal_errmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskDetail::set_errmsg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 errmsg_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.TaskDetail.errmsg)
}
inline std::string* TaskDetail::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TaskDetail.errmsg)
  return _s;
}
inline const std::string& TaskDetail::_internal_errmsg() const {
  return errmsg_.Get();
}
inline void TaskDetail::_internal_set_errmsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TaskDetail::_internal_mutable_errmsg() {
  _has_bits_[0] |= 0x00000001u;
  return errmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TaskDetail::release_errmsg() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TaskDetail.errmsg)
  if (!_internal_has_errmsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return errmsg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TaskDetail::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TaskDetail.errmsg)
}

// optional int64 total_sql_num = 4;
inline bool TaskDetail::_internal_has_total_sql_num() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TaskDetail::has_total_sql_num() const {
  return _internal_has_total_sql_num();
}
inline void TaskDetail::clear_total_sql_num() {
  total_sql_num_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskDetail::_internal_total_sql_num() const {
  return total_sql_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskDetail::total_sql_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TaskDetail.total_sql_num)
  return _internal_total_sql_num();
}
inline void TaskDetail::_internal_set_total_sql_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  total_sql_num_ = value;
}
inline void TaskDetail::set_total_sql_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_total_sql_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TaskDetail.total_sql_num)
}

// optional int64 done_sql_num = 5;
inline bool TaskDetail::_internal_has_done_sql_num() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TaskDetail::has_done_sql_num() const {
  return _internal_has_done_sql_num();
}
inline void TaskDetail::clear_done_sql_num() {
  done_sql_num_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskDetail::_internal_done_sql_num() const {
  return done_sql_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TaskDetail::done_sql_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TaskDetail.done_sql_num)
  return _internal_done_sql_num();
}
inline void TaskDetail::_internal_set_done_sql_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  done_sql_num_ = value;
}
inline void TaskDetail::set_done_sql_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_done_sql_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TaskDetail.done_sql_num)
}

// repeated .baikaldb.pb.SqlDetail sql_details = 6;
inline int TaskDetail::_internal_sql_details_size() const {
  return sql_details_.size();
}
inline int TaskDetail::sql_details_size() const {
  return _internal_sql_details_size();
}
inline void TaskDetail::clear_sql_details() {
  sql_details_.Clear();
}
inline ::baikaldb::pb::SqlDetail* TaskDetail::mutable_sql_details(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TaskDetail.sql_details)
  return sql_details_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SqlDetail >*
TaskDetail::mutable_sql_details() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.TaskDetail.sql_details)
  return &sql_details_;
}
inline const ::baikaldb::pb::SqlDetail& TaskDetail::_internal_sql_details(int index) const {
  return sql_details_.Get(index);
}
inline const ::baikaldb::pb::SqlDetail& TaskDetail::sql_details(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TaskDetail.sql_details)
  return _internal_sql_details(index);
}
inline ::baikaldb::pb::SqlDetail* TaskDetail::_internal_add_sql_details() {
  return sql_details_.Add();
}
inline ::baikaldb::pb::SqlDetail* TaskDetail::add_sql_details() {
  ::baikaldb::pb::SqlDetail* _add = _internal_add_sql_details();
  // @@protoc_insertion_point(field_add:baikaldb.pb.TaskDetail.sql_details)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SqlDetail >&
TaskDetail::sql_details() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.TaskDetail.sql_details)
  return sql_details_;
}

// -------------------------------------------------------------------

// ImporterTaskInfo

// optional bytes task_suffix = 1;
inline bool ImporterTaskInfo::_internal_has_task_suffix() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_task_suffix() const {
  return _internal_has_task_suffix();
}
inline void ImporterTaskInfo::clear_task_suffix() {
  task_suffix_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ImporterTaskInfo::task_suffix() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.task_suffix)
  return _internal_task_suffix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_task_suffix(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 task_suffix_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.task_suffix)
}
inline std::string* ImporterTaskInfo::mutable_task_suffix() {
  std::string* _s = _internal_mutable_task_suffix();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.task_suffix)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_task_suffix() const {
  return task_suffix_.Get();
}
inline void ImporterTaskInfo::_internal_set_task_suffix(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  task_suffix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_task_suffix() {
  _has_bits_[0] |= 0x00000001u;
  return task_suffix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_task_suffix() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.task_suffix)
  if (!_internal_has_task_suffix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return task_suffix_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_task_suffix(std::string* task_suffix) {
  if (task_suffix != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  task_suffix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_suffix,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.task_suffix)
}

// optional bytes status = 2;
inline bool ImporterTaskInfo::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_status() const {
  return _internal_has_status();
}
inline void ImporterTaskInfo::clear_status() {
  status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ImporterTaskInfo::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_status(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 status_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.status)
}
inline std::string* ImporterTaskInfo::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.status)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_status() const {
  return status_.Get();
}
inline void ImporterTaskInfo::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000002u;
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_status() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.status)
}

// optional bytes baikal_meta = 3;
inline bool ImporterTaskInfo::_internal_has_baikal_meta() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_baikal_meta() const {
  return _internal_has_baikal_meta();
}
inline void ImporterTaskInfo::clear_baikal_meta() {
  baikal_meta_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ImporterTaskInfo::baikal_meta() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.baikal_meta)
  return _internal_baikal_meta();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_baikal_meta(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 baikal_meta_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.baikal_meta)
}
inline std::string* ImporterTaskInfo::mutable_baikal_meta() {
  std::string* _s = _internal_mutable_baikal_meta();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.baikal_meta)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_baikal_meta() const {
  return baikal_meta_.Get();
}
inline void ImporterTaskInfo::_internal_set_baikal_meta(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  baikal_meta_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_baikal_meta() {
  _has_bits_[0] |= 0x00000004u;
  return baikal_meta_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_baikal_meta() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.baikal_meta)
  if (!_internal_has_baikal_meta()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return baikal_meta_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_baikal_meta(std::string* baikal_meta) {
  if (baikal_meta != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  baikal_meta_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), baikal_meta,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.baikal_meta)
}

// optional bytes baikal_namespace = 4;
inline bool ImporterTaskInfo::_internal_has_baikal_namespace() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_baikal_namespace() const {
  return _internal_has_baikal_namespace();
}
inline void ImporterTaskInfo::clear_baikal_namespace() {
  baikal_namespace_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ImporterTaskInfo::baikal_namespace() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.baikal_namespace)
  return _internal_baikal_namespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_baikal_namespace(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 baikal_namespace_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.baikal_namespace)
}
inline std::string* ImporterTaskInfo::mutable_baikal_namespace() {
  std::string* _s = _internal_mutable_baikal_namespace();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.baikal_namespace)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_baikal_namespace() const {
  return baikal_namespace_.Get();
}
inline void ImporterTaskInfo::_internal_set_baikal_namespace(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  baikal_namespace_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_baikal_namespace() {
  _has_bits_[0] |= 0x00000008u;
  return baikal_namespace_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_baikal_namespace() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.baikal_namespace)
  if (!_internal_has_baikal_namespace()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return baikal_namespace_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_baikal_namespace(std::string* baikal_namespace) {
  if (baikal_namespace != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  baikal_namespace_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), baikal_namespace,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.baikal_namespace)
}

// optional bytes database_name = 5;
inline bool ImporterTaskInfo::_internal_has_database_name() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_database_name() const {
  return _internal_has_database_name();
}
inline void ImporterTaskInfo::clear_database_name() {
  database_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ImporterTaskInfo::database_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.database_name)
  return _internal_database_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_database_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 database_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.database_name)
}
inline std::string* ImporterTaskInfo::mutable_database_name() {
  std::string* _s = _internal_mutable_database_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.database_name)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_database_name() const {
  return database_name_.Get();
}
inline void ImporterTaskInfo::_internal_set_database_name(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  database_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_database_name() {
  _has_bits_[0] |= 0x00000010u;
  return database_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_database_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.database_name)
  if (!_internal_has_database_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return database_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_database_name(std::string* database_name) {
  if (database_name != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  database_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.database_name)
}

// optional bytes table_name = 6;
inline bool ImporterTaskInfo::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_table_name() const {
  return _internal_has_table_name();
}
inline void ImporterTaskInfo::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ImporterTaskInfo::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 table_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.table_name)
}
inline std::string* ImporterTaskInfo::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.table_name)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_table_name() const {
  return table_name_.Get();
}
inline void ImporterTaskInfo::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000020u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.table_name)
}

// optional bytes afs_cluster = 7;
inline bool ImporterTaskInfo::_internal_has_afs_cluster() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_afs_cluster() const {
  return _internal_has_afs_cluster();
}
inline void ImporterTaskInfo::clear_afs_cluster() {
  afs_cluster_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ImporterTaskInfo::afs_cluster() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.afs_cluster)
  return _internal_afs_cluster();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_afs_cluster(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 afs_cluster_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.afs_cluster)
}
inline std::string* ImporterTaskInfo::mutable_afs_cluster() {
  std::string* _s = _internal_mutable_afs_cluster();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.afs_cluster)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_afs_cluster() const {
  return afs_cluster_.Get();
}
inline void ImporterTaskInfo::_internal_set_afs_cluster(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  afs_cluster_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_afs_cluster() {
  _has_bits_[0] |= 0x00000040u;
  return afs_cluster_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_afs_cluster() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.afs_cluster)
  if (!_internal_has_afs_cluster()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return afs_cluster_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_afs_cluster(std::string* afs_cluster) {
  if (afs_cluster != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  afs_cluster_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), afs_cluster,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.afs_cluster)
}

// optional bytes afs_username = 8;
inline bool ImporterTaskInfo::_internal_has_afs_username() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_afs_username() const {
  return _internal_has_afs_username();
}
inline void ImporterTaskInfo::clear_afs_username() {
  afs_username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ImporterTaskInfo::afs_username() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.afs_username)
  return _internal_afs_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_afs_username(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 afs_username_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.afs_username)
}
inline std::string* ImporterTaskInfo::mutable_afs_username() {
  std::string* _s = _internal_mutable_afs_username();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.afs_username)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_afs_username() const {
  return afs_username_.Get();
}
inline void ImporterTaskInfo::_internal_set_afs_username(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  afs_username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_afs_username() {
  _has_bits_[0] |= 0x00000080u;
  return afs_username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_afs_username() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.afs_username)
  if (!_internal_has_afs_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return afs_username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_afs_username(std::string* afs_username) {
  if (afs_username != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  afs_username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), afs_username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.afs_username)
}

// optional bytes afs_password = 9;
inline bool ImporterTaskInfo::_internal_has_afs_password() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_afs_password() const {
  return _internal_has_afs_password();
}
inline void ImporterTaskInfo::clear_afs_password() {
  afs_password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& ImporterTaskInfo::afs_password() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.afs_password)
  return _internal_afs_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_afs_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 afs_password_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.afs_password)
}
inline std::string* ImporterTaskInfo::mutable_afs_password() {
  std::string* _s = _internal_mutable_afs_password();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.afs_password)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_afs_password() const {
  return afs_password_.Get();
}
inline void ImporterTaskInfo::_internal_set_afs_password(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  afs_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_afs_password() {
  _has_bits_[0] |= 0x00000100u;
  return afs_password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_afs_password() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.afs_password)
  if (!_internal_has_afs_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  return afs_password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_afs_password(std::string* afs_password) {
  if (afs_password != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  afs_password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), afs_password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.afs_password)
}

// optional bytes done_file = 10;
inline bool ImporterTaskInfo::_internal_has_done_file() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_done_file() const {
  return _internal_has_done_file();
}
inline void ImporterTaskInfo::clear_done_file() {
  done_file_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& ImporterTaskInfo::done_file() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.done_file)
  return _internal_done_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_done_file(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 done_file_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.done_file)
}
inline std::string* ImporterTaskInfo::mutable_done_file() {
  std::string* _s = _internal_mutable_done_file();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.done_file)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_done_file() const {
  return done_file_.Get();
}
inline void ImporterTaskInfo::_internal_set_done_file(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  done_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_done_file() {
  _has_bits_[0] |= 0x00000200u;
  return done_file_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_done_file() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.done_file)
  if (!_internal_has_done_file()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  return done_file_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_done_file(std::string* done_file) {
  if (done_file != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  done_file_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), done_file,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.done_file)
}

// optional bytes model = 11;
inline bool ImporterTaskInfo::_internal_has_model() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_model() const {
  return _internal_has_model();
}
inline void ImporterTaskInfo::clear_model() {
  model_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& ImporterTaskInfo::model() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_model(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 model_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.model)
}
inline std::string* ImporterTaskInfo::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.model)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_model() const {
  return model_.Get();
}
inline void ImporterTaskInfo::_internal_set_model(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_model() {
  _has_bits_[0] |= 0x00000400u;
  return model_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_model() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.model)
  if (!_internal_has_model()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  return model_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.model)
}

// optional int64 version = 12;
inline bool ImporterTaskInfo::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_version() const {
  return _internal_has_version();
}
inline void ImporterTaskInfo::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ImporterTaskInfo::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ImporterTaskInfo::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.version)
  return _internal_version();
}
inline void ImporterTaskInfo::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00100000u;
  version_ = value;
}
inline void ImporterTaskInfo::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.version)
}

// optional bytes table_charset = 13;
inline bool ImporterTaskInfo::_internal_has_table_charset() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_table_charset() const {
  return _internal_has_table_charset();
}
inline void ImporterTaskInfo::clear_table_charset() {
  table_charset_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000800u;
}
inline const std::string& ImporterTaskInfo::table_charset() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.table_charset)
  return _internal_table_charset();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_table_charset(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000800u;
 table_charset_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.table_charset)
}
inline std::string* ImporterTaskInfo::mutable_table_charset() {
  std::string* _s = _internal_mutable_table_charset();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.table_charset)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_table_charset() const {
  return table_charset_.Get();
}
inline void ImporterTaskInfo::_internal_set_table_charset(const std::string& value) {
  _has_bits_[0] |= 0x00000800u;
  table_charset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_table_charset() {
  _has_bits_[0] |= 0x00000800u;
  return table_charset_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_table_charset() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.table_charset)
  if (!_internal_has_table_charset()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000800u;
  return table_charset_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_table_charset(std::string* table_charset) {
  if (table_charset != nullptr) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  table_charset_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_charset,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.table_charset)
}

// optional bytes data_charset = 14;
inline bool ImporterTaskInfo::_internal_has_data_charset() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_data_charset() const {
  return _internal_has_data_charset();
}
inline void ImporterTaskInfo::clear_data_charset() {
  data_charset_.ClearToEmpty();
  _has_bits_[0] &= ~0x00001000u;
}
inline const std::string& ImporterTaskInfo::data_charset() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.data_charset)
  return _internal_data_charset();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_data_charset(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00001000u;
 data_charset_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.data_charset)
}
inline std::string* ImporterTaskInfo::mutable_data_charset() {
  std::string* _s = _internal_mutable_data_charset();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.data_charset)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_data_charset() const {
  return data_charset_.Get();
}
inline void ImporterTaskInfo::_internal_set_data_charset(const std::string& value) {
  _has_bits_[0] |= 0x00001000u;
  data_charset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_data_charset() {
  _has_bits_[0] |= 0x00001000u;
  return data_charset_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_data_charset() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.data_charset)
  if (!_internal_has_data_charset()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00001000u;
  return data_charset_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_data_charset(std::string* data_charset) {
  if (data_charset != nullptr) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  data_charset_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_charset,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.data_charset)
}

// optional bytes config = 15;
inline bool ImporterTaskInfo::_internal_has_config() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_config() const {
  return _internal_has_config();
}
inline void ImporterTaskInfo::clear_config() {
  config_.ClearToEmpty();
  _has_bits_[0] &= ~0x00002000u;
}
inline const std::string& ImporterTaskInfo::config() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.config)
  return _internal_config();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_config(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00002000u;
 config_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.config)
}
inline std::string* ImporterTaskInfo::mutable_config() {
  std::string* _s = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.config)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_config() const {
  return config_.Get();
}
inline void ImporterTaskInfo::_internal_set_config(const std::string& value) {
  _has_bits_[0] |= 0x00002000u;
  config_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_config() {
  _has_bits_[0] |= 0x00002000u;
  return config_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_config() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.config)
  if (!_internal_has_config()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00002000u;
  return config_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_config(std::string* config) {
  if (config != nullptr) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  config_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), config,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.config)
}

// optional int32 broken_point_continuing = 16;
inline bool ImporterTaskInfo::_internal_has_broken_point_continuing() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_broken_point_continuing() const {
  return _internal_has_broken_point_continuing();
}
inline void ImporterTaskInfo::clear_broken_point_continuing() {
  broken_point_continuing_ = 0;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImporterTaskInfo::_internal_broken_point_continuing() const {
  return broken_point_continuing_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ImporterTaskInfo::broken_point_continuing() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.broken_point_continuing)
  return _internal_broken_point_continuing();
}
inline void ImporterTaskInfo::_internal_set_broken_point_continuing(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00200000u;
  broken_point_continuing_ = value;
}
inline void ImporterTaskInfo::set_broken_point_continuing(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_broken_point_continuing(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.broken_point_continuing)
}

// optional bytes owner = 17;
inline bool ImporterTaskInfo::_internal_has_owner() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_owner() const {
  return _internal_has_owner();
}
inline void ImporterTaskInfo::clear_owner() {
  owner_.ClearToEmpty();
  _has_bits_[0] &= ~0x00004000u;
}
inline const std::string& ImporterTaskInfo::owner() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.owner)
  return _internal_owner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_owner(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00004000u;
 owner_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.owner)
}
inline std::string* ImporterTaskInfo::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.owner)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_owner() const {
  return owner_.Get();
}
inline void ImporterTaskInfo::_internal_set_owner(const std::string& value) {
  _has_bits_[0] |= 0x00004000u;
  owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_owner() {
  _has_bits_[0] |= 0x00004000u;
  return owner_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_owner() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.owner)
  if (!_internal_has_owner()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00004000u;
  return owner_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  owner_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.owner)
}

// optional bytes remark = 18;
inline bool ImporterTaskInfo::_internal_has_remark() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_remark() const {
  return _internal_has_remark();
}
inline void ImporterTaskInfo::clear_remark() {
  remark_.ClearToEmpty();
  _has_bits_[0] &= ~0x00008000u;
}
inline const std::string& ImporterTaskInfo::remark() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.remark)
  return _internal_remark();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_remark(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00008000u;
 remark_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.remark)
}
inline std::string* ImporterTaskInfo::mutable_remark() {
  std::string* _s = _internal_mutable_remark();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.remark)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_remark() const {
  return remark_.Get();
}
inline void ImporterTaskInfo::_internal_set_remark(const std::string& value) {
  _has_bits_[0] |= 0x00008000u;
  remark_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_remark() {
  _has_bits_[0] |= 0x00008000u;
  return remark_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_remark() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.remark)
  if (!_internal_has_remark()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00008000u;
  return remark_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_remark(std::string* remark) {
  if (remark != nullptr) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  remark_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remark,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.remark)
}

// optional bytes baikaldb_bns = 19;
inline bool ImporterTaskInfo::_internal_has_baikaldb_bns() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_baikaldb_bns() const {
  return _internal_has_baikaldb_bns();
}
inline void ImporterTaskInfo::clear_baikaldb_bns() {
  baikaldb_bns_.ClearToEmpty();
  _has_bits_[0] &= ~0x00010000u;
}
inline const std::string& ImporterTaskInfo::baikaldb_bns() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.baikaldb_bns)
  return _internal_baikaldb_bns();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_baikaldb_bns(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00010000u;
 baikaldb_bns_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.baikaldb_bns)
}
inline std::string* ImporterTaskInfo::mutable_baikaldb_bns() {
  std::string* _s = _internal_mutable_baikaldb_bns();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.baikaldb_bns)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_baikaldb_bns() const {
  return baikaldb_bns_.Get();
}
inline void ImporterTaskInfo::_internal_set_baikaldb_bns(const std::string& value) {
  _has_bits_[0] |= 0x00010000u;
  baikaldb_bns_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_baikaldb_bns() {
  _has_bits_[0] |= 0x00010000u;
  return baikaldb_bns_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_baikaldb_bns() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.baikaldb_bns)
  if (!_internal_has_baikaldb_bns()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00010000u;
  return baikaldb_bns_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_baikaldb_bns(std::string* baikaldb_bns) {
  if (baikaldb_bns != nullptr) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  baikaldb_bns_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), baikaldb_bns,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.baikaldb_bns)
}

// optional bytes baikaldb_username = 20;
inline bool ImporterTaskInfo::_internal_has_baikaldb_username() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_baikaldb_username() const {
  return _internal_has_baikaldb_username();
}
inline void ImporterTaskInfo::clear_baikaldb_username() {
  baikaldb_username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00020000u;
}
inline const std::string& ImporterTaskInfo::baikaldb_username() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.baikaldb_username)
  return _internal_baikaldb_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_baikaldb_username(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00020000u;
 baikaldb_username_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.baikaldb_username)
}
inline std::string* ImporterTaskInfo::mutable_baikaldb_username() {
  std::string* _s = _internal_mutable_baikaldb_username();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.baikaldb_username)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_baikaldb_username() const {
  return baikaldb_username_.Get();
}
inline void ImporterTaskInfo::_internal_set_baikaldb_username(const std::string& value) {
  _has_bits_[0] |= 0x00020000u;
  baikaldb_username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_baikaldb_username() {
  _has_bits_[0] |= 0x00020000u;
  return baikaldb_username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_baikaldb_username() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.baikaldb_username)
  if (!_internal_has_baikaldb_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00020000u;
  return baikaldb_username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_baikaldb_username(std::string* baikaldb_username) {
  if (baikaldb_username != nullptr) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  baikaldb_username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), baikaldb_username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.baikaldb_username)
}

// optional bytes baikaldb_password = 21;
inline bool ImporterTaskInfo::_internal_has_baikaldb_password() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_baikaldb_password() const {
  return _internal_has_baikaldb_password();
}
inline void ImporterTaskInfo::clear_baikaldb_password() {
  baikaldb_password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00040000u;
}
inline const std::string& ImporterTaskInfo::baikaldb_password() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.baikaldb_password)
  return _internal_baikaldb_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_baikaldb_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00040000u;
 baikaldb_password_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.baikaldb_password)
}
inline std::string* ImporterTaskInfo::mutable_baikaldb_password() {
  std::string* _s = _internal_mutable_baikaldb_password();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.baikaldb_password)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_baikaldb_password() const {
  return baikaldb_password_.Get();
}
inline void ImporterTaskInfo::_internal_set_baikaldb_password(const std::string& value) {
  _has_bits_[0] |= 0x00040000u;
  baikaldb_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_baikaldb_password() {
  _has_bits_[0] |= 0x00040000u;
  return baikaldb_password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_baikaldb_password() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.baikaldb_password)
  if (!_internal_has_baikaldb_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00040000u;
  return baikaldb_password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_baikaldb_password(std::string* baikaldb_password) {
  if (baikaldb_password != nullptr) {
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  baikaldb_password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), baikaldb_password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.baikaldb_password)
}

// optional bytes lorentz_done_json = 22;
inline bool ImporterTaskInfo::_internal_has_lorentz_done_json() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool ImporterTaskInfo::has_lorentz_done_json() const {
  return _internal_has_lorentz_done_json();
}
inline void ImporterTaskInfo::clear_lorentz_done_json() {
  lorentz_done_json_.ClearToEmpty();
  _has_bits_[0] &= ~0x00080000u;
}
inline const std::string& ImporterTaskInfo::lorentz_done_json() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ImporterTaskInfo.lorentz_done_json)
  return _internal_lorentz_done_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImporterTaskInfo::set_lorentz_done_json(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00080000u;
 lorentz_done_json_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ImporterTaskInfo.lorentz_done_json)
}
inline std::string* ImporterTaskInfo::mutable_lorentz_done_json() {
  std::string* _s = _internal_mutable_lorentz_done_json();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ImporterTaskInfo.lorentz_done_json)
  return _s;
}
inline const std::string& ImporterTaskInfo::_internal_lorentz_done_json() const {
  return lorentz_done_json_.Get();
}
inline void ImporterTaskInfo::_internal_set_lorentz_done_json(const std::string& value) {
  _has_bits_[0] |= 0x00080000u;
  lorentz_done_json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::_internal_mutable_lorentz_done_json() {
  _has_bits_[0] |= 0x00080000u;
  return lorentz_done_json_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImporterTaskInfo::release_lorentz_done_json() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ImporterTaskInfo.lorentz_done_json)
  if (!_internal_has_lorentz_done_json()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00080000u;
  return lorentz_done_json_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImporterTaskInfo::set_allocated_lorentz_done_json(std::string* lorentz_done_json) {
  if (lorentz_done_json != nullptr) {
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  lorentz_done_json_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lorentz_done_json,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ImporterTaskInfo.lorentz_done_json)
}

// -------------------------------------------------------------------

// BacktrackImporterTaskInfo

// optional bytes database_name = 1;
inline bool BacktrackImporterTaskInfo::_internal_has_database_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BacktrackImporterTaskInfo::has_database_name() const {
  return _internal_has_database_name();
}
inline void BacktrackImporterTaskInfo::clear_database_name() {
  database_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BacktrackImporterTaskInfo::database_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BacktrackImporterTaskInfo.database_name)
  return _internal_database_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BacktrackImporterTaskInfo::set_database_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 database_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BacktrackImporterTaskInfo.database_name)
}
inline std::string* BacktrackImporterTaskInfo::mutable_database_name() {
  std::string* _s = _internal_mutable_database_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BacktrackImporterTaskInfo.database_name)
  return _s;
}
inline const std::string& BacktrackImporterTaskInfo::_internal_database_name() const {
  return database_name_.Get();
}
inline void BacktrackImporterTaskInfo::_internal_set_database_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  database_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BacktrackImporterTaskInfo::_internal_mutable_database_name() {
  _has_bits_[0] |= 0x00000001u;
  return database_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BacktrackImporterTaskInfo::release_database_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BacktrackImporterTaskInfo.database_name)
  if (!_internal_has_database_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return database_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BacktrackImporterTaskInfo::set_allocated_database_name(std::string* database_name) {
  if (database_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  database_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BacktrackImporterTaskInfo.database_name)
}

// optional bytes table_name = 2;
inline bool BacktrackImporterTaskInfo::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BacktrackImporterTaskInfo::has_table_name() const {
  return _internal_has_table_name();
}
inline void BacktrackImporterTaskInfo::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BacktrackImporterTaskInfo::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BacktrackImporterTaskInfo.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BacktrackImporterTaskInfo::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 table_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BacktrackImporterTaskInfo.table_name)
}
inline std::string* BacktrackImporterTaskInfo::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BacktrackImporterTaskInfo.table_name)
  return _s;
}
inline const std::string& BacktrackImporterTaskInfo::_internal_table_name() const {
  return table_name_.Get();
}
inline void BacktrackImporterTaskInfo::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BacktrackImporterTaskInfo::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000002u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BacktrackImporterTaskInfo::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BacktrackImporterTaskInfo.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BacktrackImporterTaskInfo::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BacktrackImporterTaskInfo.table_name)
}

// optional bytes afs_cluster = 3;
inline bool BacktrackImporterTaskInfo::_internal_has_afs_cluster() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BacktrackImporterTaskInfo::has_afs_cluster() const {
  return _internal_has_afs_cluster();
}
inline void BacktrackImporterTaskInfo::clear_afs_cluster() {
  afs_cluster_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BacktrackImporterTaskInfo::afs_cluster() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BacktrackImporterTaskInfo.afs_cluster)
  return _internal_afs_cluster();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BacktrackImporterTaskInfo::set_afs_cluster(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 afs_cluster_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BacktrackImporterTaskInfo.afs_cluster)
}
inline std::string* BacktrackImporterTaskInfo::mutable_afs_cluster() {
  std::string* _s = _internal_mutable_afs_cluster();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BacktrackImporterTaskInfo.afs_cluster)
  return _s;
}
inline const std::string& BacktrackImporterTaskInfo::_internal_afs_cluster() const {
  return afs_cluster_.Get();
}
inline void BacktrackImporterTaskInfo::_internal_set_afs_cluster(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  afs_cluster_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BacktrackImporterTaskInfo::_internal_mutable_afs_cluster() {
  _has_bits_[0] |= 0x00000004u;
  return afs_cluster_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BacktrackImporterTaskInfo::release_afs_cluster() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BacktrackImporterTaskInfo.afs_cluster)
  if (!_internal_has_afs_cluster()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return afs_cluster_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BacktrackImporterTaskInfo::set_allocated_afs_cluster(std::string* afs_cluster) {
  if (afs_cluster != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  afs_cluster_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), afs_cluster,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BacktrackImporterTaskInfo.afs_cluster)
}

// optional bytes task_done_path = 4;
inline bool BacktrackImporterTaskInfo::_internal_has_task_done_path() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BacktrackImporterTaskInfo::has_task_done_path() const {
  return _internal_has_task_done_path();
}
inline void BacktrackImporterTaskInfo::clear_task_done_path() {
  task_done_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& BacktrackImporterTaskInfo::task_done_path() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BacktrackImporterTaskInfo.task_done_path)
  return _internal_task_done_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BacktrackImporterTaskInfo::set_task_done_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 task_done_path_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BacktrackImporterTaskInfo.task_done_path)
}
inline std::string* BacktrackImporterTaskInfo::mutable_task_done_path() {
  std::string* _s = _internal_mutable_task_done_path();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BacktrackImporterTaskInfo.task_done_path)
  return _s;
}
inline const std::string& BacktrackImporterTaskInfo::_internal_task_done_path() const {
  return task_done_path_.Get();
}
inline void BacktrackImporterTaskInfo::_internal_set_task_done_path(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  task_done_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BacktrackImporterTaskInfo::_internal_mutable_task_done_path() {
  _has_bits_[0] |= 0x00000008u;
  return task_done_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BacktrackImporterTaskInfo::release_task_done_path() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BacktrackImporterTaskInfo.task_done_path)
  if (!_internal_has_task_done_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return task_done_path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BacktrackImporterTaskInfo::set_allocated_task_done_path(std::string* task_done_path) {
  if (task_done_path != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  task_done_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_done_path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BacktrackImporterTaskInfo.task_done_path)
}

// repeated bytes backtrack_done_files = 5;
inline int BacktrackImporterTaskInfo::_internal_backtrack_done_files_size() const {
  return backtrack_done_files_.size();
}
inline int BacktrackImporterTaskInfo::backtrack_done_files_size() const {
  return _internal_backtrack_done_files_size();
}
inline void BacktrackImporterTaskInfo::clear_backtrack_done_files() {
  backtrack_done_files_.Clear();
}
inline std::string* BacktrackImporterTaskInfo::add_backtrack_done_files() {
  std::string* _s = _internal_add_backtrack_done_files();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_done_files)
  return _s;
}
inline const std::string& BacktrackImporterTaskInfo::_internal_backtrack_done_files(int index) const {
  return backtrack_done_files_.Get(index);
}
inline const std::string& BacktrackImporterTaskInfo::backtrack_done_files(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_done_files)
  return _internal_backtrack_done_files(index);
}
inline std::string* BacktrackImporterTaskInfo::mutable_backtrack_done_files(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_done_files)
  return backtrack_done_files_.Mutable(index);
}
inline void BacktrackImporterTaskInfo::set_backtrack_done_files(int index, const std::string& value) {
  backtrack_done_files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_done_files)
}
inline void BacktrackImporterTaskInfo::set_backtrack_done_files(int index, std::string&& value) {
  backtrack_done_files_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_done_files)
}
inline void BacktrackImporterTaskInfo::set_backtrack_done_files(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  backtrack_done_files_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_done_files)
}
inline void BacktrackImporterTaskInfo::set_backtrack_done_files(int index, const void* value, size_t size) {
  backtrack_done_files_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_done_files)
}
inline std::string* BacktrackImporterTaskInfo::_internal_add_backtrack_done_files() {
  return backtrack_done_files_.Add();
}
inline void BacktrackImporterTaskInfo::add_backtrack_done_files(const std::string& value) {
  backtrack_done_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_done_files)
}
inline void BacktrackImporterTaskInfo::add_backtrack_done_files(std::string&& value) {
  backtrack_done_files_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_done_files)
}
inline void BacktrackImporterTaskInfo::add_backtrack_done_files(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  backtrack_done_files_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_done_files)
}
inline void BacktrackImporterTaskInfo::add_backtrack_done_files(const void* value, size_t size) {
  backtrack_done_files_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_done_files)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BacktrackImporterTaskInfo::backtrack_done_files() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_done_files)
  return backtrack_done_files_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BacktrackImporterTaskInfo::mutable_backtrack_done_files() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_done_files)
  return &backtrack_done_files_;
}

// repeated int64 backtrack_versions = 6;
inline int BacktrackImporterTaskInfo::_internal_backtrack_versions_size() const {
  return backtrack_versions_.size();
}
inline int BacktrackImporterTaskInfo::backtrack_versions_size() const {
  return _internal_backtrack_versions_size();
}
inline void BacktrackImporterTaskInfo::clear_backtrack_versions() {
  backtrack_versions_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BacktrackImporterTaskInfo::_internal_backtrack_versions(int index) const {
  return backtrack_versions_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BacktrackImporterTaskInfo::backtrack_versions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_versions)
  return _internal_backtrack_versions(index);
}
inline void BacktrackImporterTaskInfo::set_backtrack_versions(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  backtrack_versions_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_versions)
}
inline void BacktrackImporterTaskInfo::_internal_add_backtrack_versions(::PROTOBUF_NAMESPACE_ID::int64 value) {
  backtrack_versions_.Add(value);
}
inline void BacktrackImporterTaskInfo::add_backtrack_versions(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_backtrack_versions(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
BacktrackImporterTaskInfo::_internal_backtrack_versions() const {
  return backtrack_versions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
BacktrackImporterTaskInfo::backtrack_versions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_versions)
  return _internal_backtrack_versions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
BacktrackImporterTaskInfo::_internal_mutable_backtrack_versions() {
  return &backtrack_versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
BacktrackImporterTaskInfo::mutable_backtrack_versions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_versions)
  return _internal_mutable_backtrack_versions();
}

// optional int64 backtrack_start_version = 7;
inline bool BacktrackImporterTaskInfo::_internal_has_backtrack_start_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BacktrackImporterTaskInfo::has_backtrack_start_version() const {
  return _internal_has_backtrack_start_version();
}
inline void BacktrackImporterTaskInfo::clear_backtrack_start_version() {
  backtrack_start_version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BacktrackImporterTaskInfo::_internal_backtrack_start_version() const {
  return backtrack_start_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BacktrackImporterTaskInfo::backtrack_start_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_start_version)
  return _internal_backtrack_start_version();
}
inline void BacktrackImporterTaskInfo::_internal_set_backtrack_start_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  backtrack_start_version_ = value;
}
inline void BacktrackImporterTaskInfo::set_backtrack_start_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_backtrack_start_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BacktrackImporterTaskInfo.backtrack_start_version)
}

// optional bool is_routine_task = 8;
inline bool BacktrackImporterTaskInfo::_internal_has_is_routine_task() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BacktrackImporterTaskInfo::has_is_routine_task() const {
  return _internal_has_is_routine_task();
}
inline void BacktrackImporterTaskInfo::clear_is_routine_task() {
  is_routine_task_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool BacktrackImporterTaskInfo::_internal_is_routine_task() const {
  return is_routine_task_;
}
inline bool BacktrackImporterTaskInfo::is_routine_task() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BacktrackImporterTaskInfo.is_routine_task)
  return _internal_is_routine_task();
}
inline void BacktrackImporterTaskInfo::_internal_set_is_routine_task(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_routine_task_ = value;
}
inline void BacktrackImporterTaskInfo::set_is_routine_task(bool value) {
  _internal_set_is_routine_task(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BacktrackImporterTaskInfo.is_routine_task)
}

// -------------------------------------------------------------------

// TroubleShootingRequest

// optional bytes baikal_bns = 1;
inline bool TroubleShootingRequest::_internal_has_baikal_bns() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TroubleShootingRequest::has_baikal_bns() const {
  return _internal_has_baikal_bns();
}
inline void TroubleShootingRequest::clear_baikal_bns() {
  baikal_bns_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TroubleShootingRequest::baikal_bns() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TroubleShootingRequest.baikal_bns)
  return _internal_baikal_bns();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TroubleShootingRequest::set_baikal_bns(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 baikal_bns_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.TroubleShootingRequest.baikal_bns)
}
inline std::string* TroubleShootingRequest::mutable_baikal_bns() {
  std::string* _s = _internal_mutable_baikal_bns();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TroubleShootingRequest.baikal_bns)
  return _s;
}
inline const std::string& TroubleShootingRequest::_internal_baikal_bns() const {
  return baikal_bns_.Get();
}
inline void TroubleShootingRequest::_internal_set_baikal_bns(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  baikal_bns_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TroubleShootingRequest::_internal_mutable_baikal_bns() {
  _has_bits_[0] |= 0x00000001u;
  return baikal_bns_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TroubleShootingRequest::release_baikal_bns() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TroubleShootingRequest.baikal_bns)
  if (!_internal_has_baikal_bns()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return baikal_bns_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TroubleShootingRequest::set_allocated_baikal_bns(std::string* baikal_bns) {
  if (baikal_bns != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  baikal_bns_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), baikal_bns,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TroubleShootingRequest.baikal_bns)
}

// optional bytes baikaldb_bns = 2;
inline bool TroubleShootingRequest::_internal_has_baikaldb_bns() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TroubleShootingRequest::has_baikaldb_bns() const {
  return _internal_has_baikaldb_bns();
}
inline void TroubleShootingRequest::clear_baikaldb_bns() {
  baikaldb_bns_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TroubleShootingRequest::baikaldb_bns() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TroubleShootingRequest.baikaldb_bns)
  return _internal_baikaldb_bns();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TroubleShootingRequest::set_baikaldb_bns(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 baikaldb_bns_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.TroubleShootingRequest.baikaldb_bns)
}
inline std::string* TroubleShootingRequest::mutable_baikaldb_bns() {
  std::string* _s = _internal_mutable_baikaldb_bns();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TroubleShootingRequest.baikaldb_bns)
  return _s;
}
inline const std::string& TroubleShootingRequest::_internal_baikaldb_bns() const {
  return baikaldb_bns_.Get();
}
inline void TroubleShootingRequest::_internal_set_baikaldb_bns(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  baikaldb_bns_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TroubleShootingRequest::_internal_mutable_baikaldb_bns() {
  _has_bits_[0] |= 0x00000002u;
  return baikaldb_bns_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TroubleShootingRequest::release_baikaldb_bns() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TroubleShootingRequest.baikaldb_bns)
  if (!_internal_has_baikaldb_bns()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return baikaldb_bns_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TroubleShootingRequest::set_allocated_baikaldb_bns(std::string* baikaldb_bns) {
  if (baikaldb_bns != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  baikaldb_bns_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), baikaldb_bns,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TroubleShootingRequest.baikaldb_bns)
}

// optional bytes db_name = 3;
inline bool TroubleShootingRequest::_internal_has_db_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TroubleShootingRequest::has_db_name() const {
  return _internal_has_db_name();
}
inline void TroubleShootingRequest::clear_db_name() {
  db_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TroubleShootingRequest::db_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TroubleShootingRequest.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TroubleShootingRequest::set_db_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 db_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.TroubleShootingRequest.db_name)
}
inline std::string* TroubleShootingRequest::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TroubleShootingRequest.db_name)
  return _s;
}
inline const std::string& TroubleShootingRequest::_internal_db_name() const {
  return db_name_.Get();
}
inline void TroubleShootingRequest::_internal_set_db_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  db_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TroubleShootingRequest::_internal_mutable_db_name() {
  _has_bits_[0] |= 0x00000004u;
  return db_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TroubleShootingRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TroubleShootingRequest.db_name)
  if (!_internal_has_db_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return db_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TroubleShootingRequest::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  db_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), db_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TroubleShootingRequest.db_name)
}

// optional bytes table_name = 4;
inline bool TroubleShootingRequest::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TroubleShootingRequest::has_table_name() const {
  return _internal_has_table_name();
}
inline void TroubleShootingRequest::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TroubleShootingRequest::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TroubleShootingRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TroubleShootingRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 table_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.TroubleShootingRequest.table_name)
}
inline std::string* TroubleShootingRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TroubleShootingRequest.table_name)
  return _s;
}
inline const std::string& TroubleShootingRequest::_internal_table_name() const {
  return table_name_.Get();
}
inline void TroubleShootingRequest::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TroubleShootingRequest::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000008u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TroubleShootingRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TroubleShootingRequest.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TroubleShootingRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TroubleShootingRequest.table_name)
}

// optional bool is_offline = 5;
inline bool TroubleShootingRequest::_internal_has_is_offline() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TroubleShootingRequest::has_is_offline() const {
  return _internal_has_is_offline();
}
inline void TroubleShootingRequest::clear_is_offline() {
  is_offline_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool TroubleShootingRequest::_internal_is_offline() const {
  return is_offline_;
}
inline bool TroubleShootingRequest::is_offline() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TroubleShootingRequest.is_offline)
  return _internal_is_offline();
}
inline void TroubleShootingRequest::_internal_set_is_offline(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_offline_ = value;
}
inline void TroubleShootingRequest::set_is_offline(bool value) {
  _internal_set_is_offline(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TroubleShootingRequest.is_offline)
}

// -------------------------------------------------------------------

// TroubleShootingResponse

// repeated bytes baikaldb_bns = 1;
inline int TroubleShootingResponse::_internal_baikaldb_bns_size() const {
  return baikaldb_bns_.size();
}
inline int TroubleShootingResponse::baikaldb_bns_size() const {
  return _internal_baikaldb_bns_size();
}
inline void TroubleShootingResponse::clear_baikaldb_bns() {
  baikaldb_bns_.Clear();
}
inline std::string* TroubleShootingResponse::add_baikaldb_bns() {
  std::string* _s = _internal_add_baikaldb_bns();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.TroubleShootingResponse.baikaldb_bns)
  return _s;
}
inline const std::string& TroubleShootingResponse::_internal_baikaldb_bns(int index) const {
  return baikaldb_bns_.Get(index);
}
inline const std::string& TroubleShootingResponse::baikaldb_bns(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TroubleShootingResponse.baikaldb_bns)
  return _internal_baikaldb_bns(index);
}
inline std::string* TroubleShootingResponse::mutable_baikaldb_bns(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TroubleShootingResponse.baikaldb_bns)
  return baikaldb_bns_.Mutable(index);
}
inline void TroubleShootingResponse::set_baikaldb_bns(int index, const std::string& value) {
  baikaldb_bns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TroubleShootingResponse.baikaldb_bns)
}
inline void TroubleShootingResponse::set_baikaldb_bns(int index, std::string&& value) {
  baikaldb_bns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.TroubleShootingResponse.baikaldb_bns)
}
inline void TroubleShootingResponse::set_baikaldb_bns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  baikaldb_bns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.TroubleShootingResponse.baikaldb_bns)
}
inline void TroubleShootingResponse::set_baikaldb_bns(int index, const void* value, size_t size) {
  baikaldb_bns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.TroubleShootingResponse.baikaldb_bns)
}
inline std::string* TroubleShootingResponse::_internal_add_baikaldb_bns() {
  return baikaldb_bns_.Add();
}
inline void TroubleShootingResponse::add_baikaldb_bns(const std::string& value) {
  baikaldb_bns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.TroubleShootingResponse.baikaldb_bns)
}
inline void TroubleShootingResponse::add_baikaldb_bns(std::string&& value) {
  baikaldb_bns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.TroubleShootingResponse.baikaldb_bns)
}
inline void TroubleShootingResponse::add_baikaldb_bns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  baikaldb_bns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.TroubleShootingResponse.baikaldb_bns)
}
inline void TroubleShootingResponse::add_baikaldb_bns(const void* value, size_t size) {
  baikaldb_bns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.TroubleShootingResponse.baikaldb_bns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TroubleShootingResponse::baikaldb_bns() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.TroubleShootingResponse.baikaldb_bns)
  return baikaldb_bns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TroubleShootingResponse::mutable_baikaldb_bns() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.TroubleShootingResponse.baikaldb_bns)
  return &baikaldb_bns_;
}

// repeated bytes baikalstore_bns = 2;
inline int TroubleShootingResponse::_internal_baikalstore_bns_size() const {
  return baikalstore_bns_.size();
}
inline int TroubleShootingResponse::baikalstore_bns_size() const {
  return _internal_baikalstore_bns_size();
}
inline void TroubleShootingResponse::clear_baikalstore_bns() {
  baikalstore_bns_.Clear();
}
inline std::string* TroubleShootingResponse::add_baikalstore_bns() {
  std::string* _s = _internal_add_baikalstore_bns();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.TroubleShootingResponse.baikalstore_bns)
  return _s;
}
inline const std::string& TroubleShootingResponse::_internal_baikalstore_bns(int index) const {
  return baikalstore_bns_.Get(index);
}
inline const std::string& TroubleShootingResponse::baikalstore_bns(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TroubleShootingResponse.baikalstore_bns)
  return _internal_baikalstore_bns(index);
}
inline std::string* TroubleShootingResponse::mutable_baikalstore_bns(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TroubleShootingResponse.baikalstore_bns)
  return baikalstore_bns_.Mutable(index);
}
inline void TroubleShootingResponse::set_baikalstore_bns(int index, const std::string& value) {
  baikalstore_bns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TroubleShootingResponse.baikalstore_bns)
}
inline void TroubleShootingResponse::set_baikalstore_bns(int index, std::string&& value) {
  baikalstore_bns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.TroubleShootingResponse.baikalstore_bns)
}
inline void TroubleShootingResponse::set_baikalstore_bns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  baikalstore_bns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.TroubleShootingResponse.baikalstore_bns)
}
inline void TroubleShootingResponse::set_baikalstore_bns(int index, const void* value, size_t size) {
  baikalstore_bns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.TroubleShootingResponse.baikalstore_bns)
}
inline std::string* TroubleShootingResponse::_internal_add_baikalstore_bns() {
  return baikalstore_bns_.Add();
}
inline void TroubleShootingResponse::add_baikalstore_bns(const std::string& value) {
  baikalstore_bns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.TroubleShootingResponse.baikalstore_bns)
}
inline void TroubleShootingResponse::add_baikalstore_bns(std::string&& value) {
  baikalstore_bns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.TroubleShootingResponse.baikalstore_bns)
}
inline void TroubleShootingResponse::add_baikalstore_bns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  baikalstore_bns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.TroubleShootingResponse.baikalstore_bns)
}
inline void TroubleShootingResponse::add_baikalstore_bns(const void* value, size_t size) {
  baikalstore_bns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.TroubleShootingResponse.baikalstore_bns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TroubleShootingResponse::baikalstore_bns() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.TroubleShootingResponse.baikalstore_bns)
  return baikalstore_bns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TroubleShootingResponse::mutable_baikalstore_bns() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.TroubleShootingResponse.baikalstore_bns)
  return &baikalstore_bns_;
}

// -------------------------------------------------------------------

// TaskConfig

// optional bool need_backup = 1;
inline bool TaskConfig::_internal_has_need_backup() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TaskConfig::has_need_backup() const {
  return _internal_has_need_backup();
}
inline void TaskConfig::clear_need_backup() {
  need_backup_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool TaskConfig::_internal_need_backup() const {
  return need_backup_;
}
inline bool TaskConfig::need_backup() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TaskConfig.need_backup)
  return _internal_need_backup();
}
inline void TaskConfig::_internal_set_need_backup(bool value) {
  _has_bits_[0] |= 0x00000001u;
  need_backup_ = value;
}
inline void TaskConfig::set_need_backup(bool value) {
  _internal_set_need_backup(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TaskConfig.need_backup)
}

// optional bool need_parallel = 2;
inline bool TaskConfig::_internal_has_need_parallel() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TaskConfig::has_need_parallel() const {
  return _internal_has_need_parallel();
}
inline void TaskConfig::clear_need_parallel() {
  need_parallel_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool TaskConfig::_internal_need_parallel() const {
  return need_parallel_;
}
inline bool TaskConfig::need_parallel() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TaskConfig.need_parallel)
  return _internal_need_parallel();
}
inline void TaskConfig::_internal_set_need_parallel(bool value) {
  _has_bits_[0] |= 0x00000002u;
  need_parallel_ = value;
}
inline void TaskConfig::set_need_parallel(bool value) {
  _internal_set_need_parallel(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TaskConfig.need_parallel)
}

// -------------------------------------------------------------------

// DMSRequest

// required .baikaldb.pb.DMSOpType op_type = 1;
inline bool DMSRequest::_internal_has_op_type() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DMSRequest::has_op_type() const {
  return _internal_has_op_type();
}
inline void DMSRequest::clear_op_type() {
  op_type_ = 1;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::baikaldb::pb::DMSOpType DMSRequest::_internal_op_type() const {
  return static_cast< ::baikaldb::pb::DMSOpType >(op_type_);
}
inline ::baikaldb::pb::DMSOpType DMSRequest::op_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DMSRequest.op_type)
  return _internal_op_type();
}
inline void DMSRequest::_internal_set_op_type(::baikaldb::pb::DMSOpType value) {
  assert(::baikaldb::pb::DMSOpType_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  op_type_ = value;
}
inline void DMSRequest::set_op_type(::baikaldb::pb::DMSOpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DMSRequest.op_type)
}

// optional uint64 task_id = 2;
inline bool DMSRequest::_internal_has_task_id() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DMSRequest::has_task_id() const {
  return _internal_has_task_id();
}
inline void DMSRequest::clear_task_id() {
  task_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DMSRequest::_internal_task_id() const {
  return task_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DMSRequest::task_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DMSRequest.task_id)
  return _internal_task_id();
}
inline void DMSRequest::_internal_set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  task_id_ = value;
}
inline void DMSRequest::set_task_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DMSRequest.task_id)
}

// optional bytes task_name = 3;
inline bool DMSRequest::_internal_has_task_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DMSRequest::has_task_name() const {
  return _internal_has_task_name();
}
inline void DMSRequest::clear_task_name() {
  task_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DMSRequest::task_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DMSRequest.task_name)
  return _internal_task_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DMSRequest::set_task_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 task_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DMSRequest.task_name)
}
inline std::string* DMSRequest::mutable_task_name() {
  std::string* _s = _internal_mutable_task_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DMSRequest.task_name)
  return _s;
}
inline const std::string& DMSRequest::_internal_task_name() const {
  return task_name_.Get();
}
inline void DMSRequest::_internal_set_task_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  task_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DMSRequest::_internal_mutable_task_name() {
  _has_bits_[0] |= 0x00000001u;
  return task_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DMSRequest::release_task_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DMSRequest.task_name)
  if (!_internal_has_task_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return task_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DMSRequest::set_allocated_task_name(std::string* task_name) {
  if (task_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  task_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DMSRequest.task_name)
}

// optional bytes raw_sql = 4;
inline bool DMSRequest::_internal_has_raw_sql() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DMSRequest::has_raw_sql() const {
  return _internal_has_raw_sql();
}
inline void DMSRequest::clear_raw_sql() {
  raw_sql_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DMSRequest::raw_sql() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DMSRequest.raw_sql)
  return _internal_raw_sql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DMSRequest::set_raw_sql(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 raw_sql_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DMSRequest.raw_sql)
}
inline std::string* DMSRequest::mutable_raw_sql() {
  std::string* _s = _internal_mutable_raw_sql();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DMSRequest.raw_sql)
  return _s;
}
inline const std::string& DMSRequest::_internal_raw_sql() const {
  return raw_sql_.Get();
}
inline void DMSRequest::_internal_set_raw_sql(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  raw_sql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DMSRequest::_internal_mutable_raw_sql() {
  _has_bits_[0] |= 0x00000002u;
  return raw_sql_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DMSRequest::release_raw_sql() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DMSRequest.raw_sql)
  if (!_internal_has_raw_sql()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return raw_sql_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DMSRequest::set_allocated_raw_sql(std::string* raw_sql) {
  if (raw_sql != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  raw_sql_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), raw_sql,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DMSRequest.raw_sql)
}

// optional .baikaldb.pb.DBArgs db_args = 5;
inline bool DMSRequest::_internal_has_db_args() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || db_args_ != nullptr);
  return value;
}
inline bool DMSRequest::has_db_args() const {
  return _internal_has_db_args();
}
inline void DMSRequest::clear_db_args() {
  if (db_args_ != nullptr) db_args_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::baikaldb::pb::DBArgs& DMSRequest::_internal_db_args() const {
  const ::baikaldb::pb::DBArgs* p = db_args_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::DBArgs&>(
      ::baikaldb::pb::_DBArgs_default_instance_);
}
inline const ::baikaldb::pb::DBArgs& DMSRequest::db_args() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DMSRequest.db_args)
  return _internal_db_args();
}
inline void DMSRequest::unsafe_arena_set_allocated_db_args(
    ::baikaldb::pb::DBArgs* db_args) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(db_args_);
  }
  db_args_ = db_args;
  if (db_args) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DMSRequest.db_args)
}
inline ::baikaldb::pb::DBArgs* DMSRequest::release_db_args() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::DBArgs* temp = db_args_;
  db_args_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::DBArgs* DMSRequest::unsafe_arena_release_db_args() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DMSRequest.db_args)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::DBArgs* temp = db_args_;
  db_args_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::DBArgs* DMSRequest::_internal_mutable_db_args() {
  _has_bits_[0] |= 0x00000004u;
  if (db_args_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::DBArgs>(GetArenaForAllocation());
    db_args_ = p;
  }
  return db_args_;
}
inline ::baikaldb::pb::DBArgs* DMSRequest::mutable_db_args() {
  ::baikaldb::pb::DBArgs* _msg = _internal_mutable_db_args();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DMSRequest.db_args)
  return _msg;
}
inline void DMSRequest::set_allocated_db_args(::baikaldb::pb::DBArgs* db_args) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete db_args_;
  }
  if (db_args) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::DBArgs>::GetOwningArena(db_args);
    if (message_arena != submessage_arena) {
      db_args = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, db_args, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  db_args_ = db_args;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DMSRequest.db_args)
}

// optional .baikaldb.pb.TaskConfig task_config = 6;
inline bool DMSRequest::_internal_has_task_config() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || task_config_ != nullptr);
  return value;
}
inline bool DMSRequest::has_task_config() const {
  return _internal_has_task_config();
}
inline void DMSRequest::clear_task_config() {
  if (task_config_ != nullptr) task_config_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::baikaldb::pb::TaskConfig& DMSRequest::_internal_task_config() const {
  const ::baikaldb::pb::TaskConfig* p = task_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::TaskConfig&>(
      ::baikaldb::pb::_TaskConfig_default_instance_);
}
inline const ::baikaldb::pb::TaskConfig& DMSRequest::task_config() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DMSRequest.task_config)
  return _internal_task_config();
}
inline void DMSRequest::unsafe_arena_set_allocated_task_config(
    ::baikaldb::pb::TaskConfig* task_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_config_);
  }
  task_config_ = task_config;
  if (task_config) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DMSRequest.task_config)
}
inline ::baikaldb::pb::TaskConfig* DMSRequest::release_task_config() {
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::TaskConfig* temp = task_config_;
  task_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::TaskConfig* DMSRequest::unsafe_arena_release_task_config() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DMSRequest.task_config)
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::TaskConfig* temp = task_config_;
  task_config_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::TaskConfig* DMSRequest::_internal_mutable_task_config() {
  _has_bits_[0] |= 0x00000008u;
  if (task_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::TaskConfig>(GetArenaForAllocation());
    task_config_ = p;
  }
  return task_config_;
}
inline ::baikaldb::pb::TaskConfig* DMSRequest::mutable_task_config() {
  ::baikaldb::pb::TaskConfig* _msg = _internal_mutable_task_config();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DMSRequest.task_config)
  return _msg;
}
inline void DMSRequest::set_allocated_task_config(::baikaldb::pb::TaskConfig* task_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_config_;
  }
  if (task_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::TaskConfig>::GetOwningArena(task_config);
    if (message_arena != submessage_arena) {
      task_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  task_config_ = task_config;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DMSRequest.task_config)
}

// optional .baikaldb.pb.ImporterTaskInfo importer_task_info = 7;
inline bool DMSRequest::_internal_has_importer_task_info() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || importer_task_info_ != nullptr);
  return value;
}
inline bool DMSRequest::has_importer_task_info() const {
  return _internal_has_importer_task_info();
}
inline void DMSRequest::clear_importer_task_info() {
  if (importer_task_info_ != nullptr) importer_task_info_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::baikaldb::pb::ImporterTaskInfo& DMSRequest::_internal_importer_task_info() const {
  const ::baikaldb::pb::ImporterTaskInfo* p = importer_task_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::ImporterTaskInfo&>(
      ::baikaldb::pb::_ImporterTaskInfo_default_instance_);
}
inline const ::baikaldb::pb::ImporterTaskInfo& DMSRequest::importer_task_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DMSRequest.importer_task_info)
  return _internal_importer_task_info();
}
inline void DMSRequest::unsafe_arena_set_allocated_importer_task_info(
    ::baikaldb::pb::ImporterTaskInfo* importer_task_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(importer_task_info_);
  }
  importer_task_info_ = importer_task_info;
  if (importer_task_info) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DMSRequest.importer_task_info)
}
inline ::baikaldb::pb::ImporterTaskInfo* DMSRequest::release_importer_task_info() {
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::ImporterTaskInfo* temp = importer_task_info_;
  importer_task_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::ImporterTaskInfo* DMSRequest::unsafe_arena_release_importer_task_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DMSRequest.importer_task_info)
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::ImporterTaskInfo* temp = importer_task_info_;
  importer_task_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::ImporterTaskInfo* DMSRequest::_internal_mutable_importer_task_info() {
  _has_bits_[0] |= 0x00000010u;
  if (importer_task_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::ImporterTaskInfo>(GetArenaForAllocation());
    importer_task_info_ = p;
  }
  return importer_task_info_;
}
inline ::baikaldb::pb::ImporterTaskInfo* DMSRequest::mutable_importer_task_info() {
  ::baikaldb::pb::ImporterTaskInfo* _msg = _internal_mutable_importer_task_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DMSRequest.importer_task_info)
  return _msg;
}
inline void DMSRequest::set_allocated_importer_task_info(::baikaldb::pb::ImporterTaskInfo* importer_task_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete importer_task_info_;
  }
  if (importer_task_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::ImporterTaskInfo>::GetOwningArena(importer_task_info);
    if (message_arena != submessage_arena) {
      importer_task_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, importer_task_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  importer_task_info_ = importer_task_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DMSRequest.importer_task_info)
}

// optional .baikaldb.pb.BacktrackImporterTaskInfo backtrack_importer_task_info = 8;
inline bool DMSRequest::_internal_has_backtrack_importer_task_info() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || backtrack_importer_task_info_ != nullptr);
  return value;
}
inline bool DMSRequest::has_backtrack_importer_task_info() const {
  return _internal_has_backtrack_importer_task_info();
}
inline void DMSRequest::clear_backtrack_importer_task_info() {
  if (backtrack_importer_task_info_ != nullptr) backtrack_importer_task_info_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::baikaldb::pb::BacktrackImporterTaskInfo& DMSRequest::_internal_backtrack_importer_task_info() const {
  const ::baikaldb::pb::BacktrackImporterTaskInfo* p = backtrack_importer_task_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::BacktrackImporterTaskInfo&>(
      ::baikaldb::pb::_BacktrackImporterTaskInfo_default_instance_);
}
inline const ::baikaldb::pb::BacktrackImporterTaskInfo& DMSRequest::backtrack_importer_task_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DMSRequest.backtrack_importer_task_info)
  return _internal_backtrack_importer_task_info();
}
inline void DMSRequest::unsafe_arena_set_allocated_backtrack_importer_task_info(
    ::baikaldb::pb::BacktrackImporterTaskInfo* backtrack_importer_task_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(backtrack_importer_task_info_);
  }
  backtrack_importer_task_info_ = backtrack_importer_task_info;
  if (backtrack_importer_task_info) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DMSRequest.backtrack_importer_task_info)
}
inline ::baikaldb::pb::BacktrackImporterTaskInfo* DMSRequest::release_backtrack_importer_task_info() {
  _has_bits_[0] &= ~0x00000020u;
  ::baikaldb::pb::BacktrackImporterTaskInfo* temp = backtrack_importer_task_info_;
  backtrack_importer_task_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::BacktrackImporterTaskInfo* DMSRequest::unsafe_arena_release_backtrack_importer_task_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DMSRequest.backtrack_importer_task_info)
  _has_bits_[0] &= ~0x00000020u;
  ::baikaldb::pb::BacktrackImporterTaskInfo* temp = backtrack_importer_task_info_;
  backtrack_importer_task_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::BacktrackImporterTaskInfo* DMSRequest::_internal_mutable_backtrack_importer_task_info() {
  _has_bits_[0] |= 0x00000020u;
  if (backtrack_importer_task_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::BacktrackImporterTaskInfo>(GetArenaForAllocation());
    backtrack_importer_task_info_ = p;
  }
  return backtrack_importer_task_info_;
}
inline ::baikaldb::pb::BacktrackImporterTaskInfo* DMSRequest::mutable_backtrack_importer_task_info() {
  ::baikaldb::pb::BacktrackImporterTaskInfo* _msg = _internal_mutable_backtrack_importer_task_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DMSRequest.backtrack_importer_task_info)
  return _msg;
}
inline void DMSRequest::set_allocated_backtrack_importer_task_info(::baikaldb::pb::BacktrackImporterTaskInfo* backtrack_importer_task_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete backtrack_importer_task_info_;
  }
  if (backtrack_importer_task_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::BacktrackImporterTaskInfo>::GetOwningArena(backtrack_importer_task_info);
    if (message_arena != submessage_arena) {
      backtrack_importer_task_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, backtrack_importer_task_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  backtrack_importer_task_info_ = backtrack_importer_task_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DMSRequest.backtrack_importer_task_info)
}

// optional .baikaldb.pb.TroubleShootingRequest trouble_shooting_request = 9;
inline bool DMSRequest::_internal_has_trouble_shooting_request() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || trouble_shooting_request_ != nullptr);
  return value;
}
inline bool DMSRequest::has_trouble_shooting_request() const {
  return _internal_has_trouble_shooting_request();
}
inline void DMSRequest::clear_trouble_shooting_request() {
  if (trouble_shooting_request_ != nullptr) trouble_shooting_request_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::baikaldb::pb::TroubleShootingRequest& DMSRequest::_internal_trouble_shooting_request() const {
  const ::baikaldb::pb::TroubleShootingRequest* p = trouble_shooting_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::TroubleShootingRequest&>(
      ::baikaldb::pb::_TroubleShootingRequest_default_instance_);
}
inline const ::baikaldb::pb::TroubleShootingRequest& DMSRequest::trouble_shooting_request() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DMSRequest.trouble_shooting_request)
  return _internal_trouble_shooting_request();
}
inline void DMSRequest::unsafe_arena_set_allocated_trouble_shooting_request(
    ::baikaldb::pb::TroubleShootingRequest* trouble_shooting_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trouble_shooting_request_);
  }
  trouble_shooting_request_ = trouble_shooting_request;
  if (trouble_shooting_request) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DMSRequest.trouble_shooting_request)
}
inline ::baikaldb::pb::TroubleShootingRequest* DMSRequest::release_trouble_shooting_request() {
  _has_bits_[0] &= ~0x00000040u;
  ::baikaldb::pb::TroubleShootingRequest* temp = trouble_shooting_request_;
  trouble_shooting_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::TroubleShootingRequest* DMSRequest::unsafe_arena_release_trouble_shooting_request() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DMSRequest.trouble_shooting_request)
  _has_bits_[0] &= ~0x00000040u;
  ::baikaldb::pb::TroubleShootingRequest* temp = trouble_shooting_request_;
  trouble_shooting_request_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::TroubleShootingRequest* DMSRequest::_internal_mutable_trouble_shooting_request() {
  _has_bits_[0] |= 0x00000040u;
  if (trouble_shooting_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::TroubleShootingRequest>(GetArenaForAllocation());
    trouble_shooting_request_ = p;
  }
  return trouble_shooting_request_;
}
inline ::baikaldb::pb::TroubleShootingRequest* DMSRequest::mutable_trouble_shooting_request() {
  ::baikaldb::pb::TroubleShootingRequest* _msg = _internal_mutable_trouble_shooting_request();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DMSRequest.trouble_shooting_request)
  return _msg;
}
inline void DMSRequest::set_allocated_trouble_shooting_request(::baikaldb::pb::TroubleShootingRequest* trouble_shooting_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete trouble_shooting_request_;
  }
  if (trouble_shooting_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::TroubleShootingRequest>::GetOwningArena(trouble_shooting_request);
    if (message_arena != submessage_arena) {
      trouble_shooting_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trouble_shooting_request, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  trouble_shooting_request_ = trouble_shooting_request;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DMSRequest.trouble_shooting_request)
}

// -------------------------------------------------------------------

// DMSResponse

// required .baikaldb.pb.DMSErrCode errcode = 1;
inline bool DMSResponse::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DMSResponse::has_errcode() const {
  return _internal_has_errcode();
}
inline void DMSResponse::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::baikaldb::pb::DMSErrCode DMSResponse::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::DMSErrCode >(errcode_);
}
inline ::baikaldb::pb::DMSErrCode DMSResponse::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DMSResponse.errcode)
  return _internal_errcode();
}
inline void DMSResponse::_internal_set_errcode(::baikaldb::pb::DMSErrCode value) {
  assert(::baikaldb::pb::DMSErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  errcode_ = value;
}
inline void DMSResponse::set_errcode(::baikaldb::pb::DMSErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DMSResponse.errcode)
}

// optional bytes errmsg = 2;
inline bool DMSResponse::_internal_has_errmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DMSResponse::has_errmsg() const {
  return _internal_has_errmsg();
}
inline void DMSResponse::clear_errmsg() {
  errmsg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DMSResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DMSResponse.errmsg)
  return _internal_errmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DMSResponse::set_errmsg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 errmsg_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DMSResponse.errmsg)
}
inline std::string* DMSResponse::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DMSResponse.errmsg)
  return _s;
}
inline const std::string& DMSResponse::_internal_errmsg() const {
  return errmsg_.Get();
}
inline void DMSResponse::_internal_set_errmsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DMSResponse::_internal_mutable_errmsg() {
  _has_bits_[0] |= 0x00000001u;
  return errmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DMSResponse::release_errmsg() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DMSResponse.errmsg)
  if (!_internal_has_errmsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return errmsg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DMSResponse::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DMSResponse.errmsg)
}

// optional .baikaldb.pb.TaskDetail task_details = 3;
inline bool DMSResponse::_internal_has_task_details() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || task_details_ != nullptr);
  return value;
}
inline bool DMSResponse::has_task_details() const {
  return _internal_has_task_details();
}
inline void DMSResponse::clear_task_details() {
  if (task_details_ != nullptr) task_details_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::baikaldb::pb::TaskDetail& DMSResponse::_internal_task_details() const {
  const ::baikaldb::pb::TaskDetail* p = task_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::TaskDetail&>(
      ::baikaldb::pb::_TaskDetail_default_instance_);
}
inline const ::baikaldb::pb::TaskDetail& DMSResponse::task_details() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DMSResponse.task_details)
  return _internal_task_details();
}
inline void DMSResponse::unsafe_arena_set_allocated_task_details(
    ::baikaldb::pb::TaskDetail* task_details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(task_details_);
  }
  task_details_ = task_details;
  if (task_details) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DMSResponse.task_details)
}
inline ::baikaldb::pb::TaskDetail* DMSResponse::release_task_details() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::TaskDetail* temp = task_details_;
  task_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::TaskDetail* DMSResponse::unsafe_arena_release_task_details() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DMSResponse.task_details)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::TaskDetail* temp = task_details_;
  task_details_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::TaskDetail* DMSResponse::_internal_mutable_task_details() {
  _has_bits_[0] |= 0x00000002u;
  if (task_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::TaskDetail>(GetArenaForAllocation());
    task_details_ = p;
  }
  return task_details_;
}
inline ::baikaldb::pb::TaskDetail* DMSResponse::mutable_task_details() {
  ::baikaldb::pb::TaskDetail* _msg = _internal_mutable_task_details();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DMSResponse.task_details)
  return _msg;
}
inline void DMSResponse::set_allocated_task_details(::baikaldb::pb::TaskDetail* task_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete task_details_;
  }
  if (task_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::TaskDetail>::GetOwningArena(task_details);
    if (message_arena != submessage_arena) {
      task_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task_details, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  task_details_ = task_details;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DMSResponse.task_details)
}

// optional .baikaldb.pb.TroubleShootingResponse trouble_shooting_response = 4;
inline bool DMSResponse::_internal_has_trouble_shooting_response() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || trouble_shooting_response_ != nullptr);
  return value;
}
inline bool DMSResponse::has_trouble_shooting_response() const {
  return _internal_has_trouble_shooting_response();
}
inline void DMSResponse::clear_trouble_shooting_response() {
  if (trouble_shooting_response_ != nullptr) trouble_shooting_response_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::baikaldb::pb::TroubleShootingResponse& DMSResponse::_internal_trouble_shooting_response() const {
  const ::baikaldb::pb::TroubleShootingResponse* p = trouble_shooting_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::TroubleShootingResponse&>(
      ::baikaldb::pb::_TroubleShootingResponse_default_instance_);
}
inline const ::baikaldb::pb::TroubleShootingResponse& DMSResponse::trouble_shooting_response() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DMSResponse.trouble_shooting_response)
  return _internal_trouble_shooting_response();
}
inline void DMSResponse::unsafe_arena_set_allocated_trouble_shooting_response(
    ::baikaldb::pb::TroubleShootingResponse* trouble_shooting_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trouble_shooting_response_);
  }
  trouble_shooting_response_ = trouble_shooting_response;
  if (trouble_shooting_response) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DMSResponse.trouble_shooting_response)
}
inline ::baikaldb::pb::TroubleShootingResponse* DMSResponse::release_trouble_shooting_response() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::TroubleShootingResponse* temp = trouble_shooting_response_;
  trouble_shooting_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::TroubleShootingResponse* DMSResponse::unsafe_arena_release_trouble_shooting_response() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DMSResponse.trouble_shooting_response)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::TroubleShootingResponse* temp = trouble_shooting_response_;
  trouble_shooting_response_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::TroubleShootingResponse* DMSResponse::_internal_mutable_trouble_shooting_response() {
  _has_bits_[0] |= 0x00000004u;
  if (trouble_shooting_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::TroubleShootingResponse>(GetArenaForAllocation());
    trouble_shooting_response_ = p;
  }
  return trouble_shooting_response_;
}
inline ::baikaldb::pb::TroubleShootingResponse* DMSResponse::mutable_trouble_shooting_response() {
  ::baikaldb::pb::TroubleShootingResponse* _msg = _internal_mutable_trouble_shooting_response();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DMSResponse.trouble_shooting_response)
  return _msg;
}
inline void DMSResponse::set_allocated_trouble_shooting_response(::baikaldb::pb::TroubleShootingResponse* trouble_shooting_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete trouble_shooting_response_;
  }
  if (trouble_shooting_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::TroubleShootingResponse>::GetOwningArena(trouble_shooting_response);
    if (message_arena != submessage_arena) {
      trouble_shooting_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trouble_shooting_response, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  trouble_shooting_response_ = trouble_shooting_response;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DMSResponse.trouble_shooting_response)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace baikaldb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::baikaldb::pb::DMSErrCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::DMSErrCode>() {
  return ::baikaldb::pb::DMSErrCode_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::DMSOpType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::DMSOpType>() {
  return ::baikaldb::pb::DMSOpType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::SqlStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::SqlStatus>() {
  return ::baikaldb::pb::SqlStatus_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::TaskStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::TaskStatus>() {
  return ::baikaldb::pb::TaskStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dms_2eproto
