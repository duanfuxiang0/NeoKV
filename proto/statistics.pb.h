// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: statistics.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_statistics_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_statistics_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_statistics_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_statistics_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_statistics_2eproto;
namespace baikaldb {
namespace pb {
class BucketInfo;
struct BucketInfoDefaultTypeInternal;
extern BucketInfoDefaultTypeInternal _BucketInfo_default_instance_;
class CMsketch;
struct CMsketchDefaultTypeInternal;
extern CMsketchDefaultTypeInternal _CMsketch_default_instance_;
class CMsketchColumn;
struct CMsketchColumnDefaultTypeInternal;
extern CMsketchColumnDefaultTypeInternal _CMsketchColumn_default_instance_;
class CMsketchItem;
struct CMsketchItemDefaultTypeInternal;
extern CMsketchItemDefaultTypeInternal _CMsketchItem_default_instance_;
class ColumnInfo;
struct ColumnInfoDefaultTypeInternal;
extern ColumnInfoDefaultTypeInternal _ColumnInfo_default_instance_;
class Histogram;
struct HistogramDefaultTypeInternal;
extern HistogramDefaultTypeInternal _Histogram_default_instance_;
class HyperLogLog;
struct HyperLogLogDefaultTypeInternal;
extern HyperLogLogDefaultTypeInternal _HyperLogLog_default_instance_;
class HyperLogLogColumn;
struct HyperLogLogColumnDefaultTypeInternal;
extern HyperLogLogColumnDefaultTypeInternal _HyperLogLogColumn_default_instance_;
class Statistics;
struct StatisticsDefaultTypeInternal;
extern StatisticsDefaultTypeInternal _Statistics_default_instance_;
}  // namespace pb
}  // namespace baikaldb
PROTOBUF_NAMESPACE_OPEN
template<> ::baikaldb::pb::BucketInfo* Arena::CreateMaybeMessage<::baikaldb::pb::BucketInfo>(Arena*);
template<> ::baikaldb::pb::CMsketch* Arena::CreateMaybeMessage<::baikaldb::pb::CMsketch>(Arena*);
template<> ::baikaldb::pb::CMsketchColumn* Arena::CreateMaybeMessage<::baikaldb::pb::CMsketchColumn>(Arena*);
template<> ::baikaldb::pb::CMsketchItem* Arena::CreateMaybeMessage<::baikaldb::pb::CMsketchItem>(Arena*);
template<> ::baikaldb::pb::ColumnInfo* Arena::CreateMaybeMessage<::baikaldb::pb::ColumnInfo>(Arena*);
template<> ::baikaldb::pb::Histogram* Arena::CreateMaybeMessage<::baikaldb::pb::Histogram>(Arena*);
template<> ::baikaldb::pb::HyperLogLog* Arena::CreateMaybeMessage<::baikaldb::pb::HyperLogLog>(Arena*);
template<> ::baikaldb::pb::HyperLogLogColumn* Arena::CreateMaybeMessage<::baikaldb::pb::HyperLogLogColumn>(Arena*);
template<> ::baikaldb::pb::Statistics* Arena::CreateMaybeMessage<::baikaldb::pb::Statistics>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace baikaldb {
namespace pb {

// ===================================================================

class BucketInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BucketInfo) */ {
 public:
  inline BucketInfo() : BucketInfo(nullptr) {}
  ~BucketInfo() override;
  explicit constexpr BucketInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BucketInfo(const BucketInfo& from);
  BucketInfo(BucketInfo&& from) noexcept
    : BucketInfo() {
    *this = ::std::move(from);
  }

  inline BucketInfo& operator=(const BucketInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BucketInfo& operator=(BucketInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BucketInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BucketInfo* internal_default_instance() {
    return reinterpret_cast<const BucketInfo*>(
               &_BucketInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BucketInfo& a, BucketInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BucketInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BucketInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BucketInfo* New() const final {
    return new BucketInfo();
  }

  BucketInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BucketInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BucketInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BucketInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BucketInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BucketInfo";
  }
  protected:
  explicit BucketInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
    kDistinctCntFieldNumber = 1,
    kBucketSizeFieldNumber = 2,
  };
  // required .baikaldb.pb.ExprValue start = 3;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::baikaldb::pb::ExprValue& start() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::ExprValue* release_start();
  ::baikaldb::pb::ExprValue* mutable_start();
  void set_allocated_start(::baikaldb::pb::ExprValue* start);
  private:
  const ::baikaldb::pb::ExprValue& _internal_start() const;
  ::baikaldb::pb::ExprValue* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::baikaldb::pb::ExprValue* start);
  ::baikaldb::pb::ExprValue* unsafe_arena_release_start();

  // required .baikaldb.pb.ExprValue end = 4;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::baikaldb::pb::ExprValue& end() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::ExprValue* release_end();
  ::baikaldb::pb::ExprValue* mutable_end();
  void set_allocated_end(::baikaldb::pb::ExprValue* end);
  private:
  const ::baikaldb::pb::ExprValue& _internal_end() const;
  ::baikaldb::pb::ExprValue* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::baikaldb::pb::ExprValue* end);
  ::baikaldb::pb::ExprValue* unsafe_arena_release_end();

  // required int32 distinct_cnt = 1;
  bool has_distinct_cnt() const;
  private:
  bool _internal_has_distinct_cnt() const;
  public:
  void clear_distinct_cnt();
  ::PROTOBUF_NAMESPACE_ID::int32 distinct_cnt() const;
  void set_distinct_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_distinct_cnt() const;
  void _internal_set_distinct_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 bucket_size = 2;
  bool has_bucket_size() const;
  private:
  bool _internal_has_bucket_size() const;
  public:
  void clear_bucket_size();
  ::PROTOBUF_NAMESPACE_ID::int32 bucket_size() const;
  void set_bucket_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_bucket_size() const;
  void _internal_set_bucket_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BucketInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::ExprValue* start_;
  ::baikaldb::pb::ExprValue* end_;
  ::PROTOBUF_NAMESPACE_ID::int32 distinct_cnt_;
  ::PROTOBUF_NAMESPACE_ID::int32 bucket_size_;
  friend struct ::TableStruct_statistics_2eproto;
};
// -------------------------------------------------------------------

class ColumnInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ColumnInfo) */ {
 public:
  inline ColumnInfo() : ColumnInfo(nullptr) {}
  ~ColumnInfo() override;
  explicit constexpr ColumnInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnInfo(const ColumnInfo& from);
  ColumnInfo(ColumnInfo&& from) noexcept
    : ColumnInfo() {
    *this = ::std::move(from);
  }

  inline ColumnInfo& operator=(const ColumnInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnInfo& operator=(ColumnInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnInfo* internal_default_instance() {
    return reinterpret_cast<const ColumnInfo*>(
               &_ColumnInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ColumnInfo& a, ColumnInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColumnInfo* New() const final {
    return new ColumnInfo();
  }

  ColumnInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColumnInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ColumnInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ColumnInfo";
  }
  protected:
  explicit ColumnInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketInfosFieldNumber = 5,
    kColTypeFieldNumber = 1,
    kFieldIdFieldNumber = 2,
    kDistinctCntFieldNumber = 3,
    kNullValueCntFieldNumber = 4,
  };
  // repeated .baikaldb.pb.BucketInfo bucket_infos = 5;
  int bucket_infos_size() const;
  private:
  int _internal_bucket_infos_size() const;
  public:
  void clear_bucket_infos();
  ::baikaldb::pb::BucketInfo* mutable_bucket_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BucketInfo >*
      mutable_bucket_infos();
  private:
  const ::baikaldb::pb::BucketInfo& _internal_bucket_infos(int index) const;
  ::baikaldb::pb::BucketInfo* _internal_add_bucket_infos();
  public:
  const ::baikaldb::pb::BucketInfo& bucket_infos(int index) const;
  ::baikaldb::pb::BucketInfo* add_bucket_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BucketInfo >&
      bucket_infos() const;

  // required .baikaldb.pb.PrimitiveType col_type = 1;
  bool has_col_type() const;
  private:
  bool _internal_has_col_type() const;
  public:
  void clear_col_type();
  ::baikaldb::pb::PrimitiveType col_type() const;
  void set_col_type(::baikaldb::pb::PrimitiveType value);
  private:
  ::baikaldb::pb::PrimitiveType _internal_col_type() const;
  void _internal_set_col_type(::baikaldb::pb::PrimitiveType value);
  public:

  // required int32 field_id = 2;
  bool has_field_id() const;
  private:
  bool _internal_has_field_id() const;
  public:
  void clear_field_id();
  ::PROTOBUF_NAMESPACE_ID::int32 field_id() const;
  void set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_field_id() const;
  void _internal_set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 distinct_cnt = 3;
  bool has_distinct_cnt() const;
  private:
  bool _internal_has_distinct_cnt() const;
  public:
  void clear_distinct_cnt();
  ::PROTOBUF_NAMESPACE_ID::int32 distinct_cnt() const;
  void set_distinct_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_distinct_cnt() const;
  void _internal_set_distinct_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 null_value_cnt = 4;
  bool has_null_value_cnt() const;
  private:
  bool _internal_has_null_value_cnt() const;
  public:
  void clear_null_value_cnt();
  ::PROTOBUF_NAMESPACE_ID::int32 null_value_cnt() const;
  void set_null_value_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_null_value_cnt() const;
  void _internal_set_null_value_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ColumnInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BucketInfo > bucket_infos_;
  int col_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 field_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 distinct_cnt_;
  ::PROTOBUF_NAMESPACE_ID::int32 null_value_cnt_;
  friend struct ::TableStruct_statistics_2eproto;
};
// -------------------------------------------------------------------

class Histogram final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.Histogram) */ {
 public:
  inline Histogram() : Histogram(nullptr) {}
  ~Histogram() override;
  explicit constexpr Histogram(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Histogram(const Histogram& from);
  Histogram(Histogram&& from) noexcept
    : Histogram() {
    *this = ::std::move(from);
  }

  inline Histogram& operator=(const Histogram& from) {
    CopyFrom(from);
    return *this;
  }
  inline Histogram& operator=(Histogram&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Histogram& default_instance() {
    return *internal_default_instance();
  }
  static inline const Histogram* internal_default_instance() {
    return reinterpret_cast<const Histogram*>(
               &_Histogram_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Histogram& a, Histogram& b) {
    a.Swap(&b);
  }
  inline void Swap(Histogram* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Histogram* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Histogram* New() const final {
    return new Histogram();
  }

  Histogram* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Histogram>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Histogram& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Histogram& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Histogram* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.Histogram";
  }
  protected:
  explicit Histogram(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnInfosFieldNumber = 3,
    kSampleRowsFieldNumber = 1,
    kTotalRowsFieldNumber = 2,
  };
  // repeated .baikaldb.pb.ColumnInfo column_infos = 3;
  int column_infos_size() const;
  private:
  int _internal_column_infos_size() const;
  public:
  void clear_column_infos();
  ::baikaldb::pb::ColumnInfo* mutable_column_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ColumnInfo >*
      mutable_column_infos();
  private:
  const ::baikaldb::pb::ColumnInfo& _internal_column_infos(int index) const;
  ::baikaldb::pb::ColumnInfo* _internal_add_column_infos();
  public:
  const ::baikaldb::pb::ColumnInfo& column_infos(int index) const;
  ::baikaldb::pb::ColumnInfo* add_column_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ColumnInfo >&
      column_infos() const;

  // required int64 sample_rows = 1;
  bool has_sample_rows() const;
  private:
  bool _internal_has_sample_rows() const;
  public:
  void clear_sample_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 sample_rows() const;
  void set_sample_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_sample_rows() const;
  void _internal_set_sample_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 total_rows = 2;
  bool has_total_rows() const;
  private:
  bool _internal_has_total_rows() const;
  public:
  void clear_total_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 total_rows() const;
  void set_total_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_total_rows() const;
  void _internal_set_total_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.Histogram)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ColumnInfo > column_infos_;
  ::PROTOBUF_NAMESPACE_ID::int64 sample_rows_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_rows_;
  friend struct ::TableStruct_statistics_2eproto;
};
// -------------------------------------------------------------------

class CMsketchItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.CMsketchItem) */ {
 public:
  inline CMsketchItem() : CMsketchItem(nullptr) {}
  ~CMsketchItem() override;
  explicit constexpr CMsketchItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsketchItem(const CMsketchItem& from);
  CMsketchItem(CMsketchItem&& from) noexcept
    : CMsketchItem() {
    *this = ::std::move(from);
  }

  inline CMsketchItem& operator=(const CMsketchItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsketchItem& operator=(CMsketchItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsketchItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsketchItem* internal_default_instance() {
    return reinterpret_cast<const CMsketchItem*>(
               &_CMsketchItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CMsketchItem& a, CMsketchItem& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsketchItem* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsketchItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CMsketchItem* New() const final {
    return new CMsketchItem();
  }

  CMsketchItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CMsketchItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsketchItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsketchItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsketchItem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.CMsketchItem";
  }
  protected:
  explicit CMsketchItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDepthFieldNumber = 1,
    kWidthFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // required int32 depth = 1;
  bool has_depth() const;
  private:
  bool _internal_has_depth() const;
  public:
  void clear_depth();
  ::PROTOBUF_NAMESPACE_ID::int32 depth() const;
  void set_depth(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_depth() const;
  void _internal_set_depth(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 width = 2;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.CMsketchItem)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 depth_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  friend struct ::TableStruct_statistics_2eproto;
};
// -------------------------------------------------------------------

class CMsketchColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.CMsketchColumn) */ {
 public:
  inline CMsketchColumn() : CMsketchColumn(nullptr) {}
  ~CMsketchColumn() override;
  explicit constexpr CMsketchColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsketchColumn(const CMsketchColumn& from);
  CMsketchColumn(CMsketchColumn&& from) noexcept
    : CMsketchColumn() {
    *this = ::std::move(from);
  }

  inline CMsketchColumn& operator=(const CMsketchColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsketchColumn& operator=(CMsketchColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsketchColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsketchColumn* internal_default_instance() {
    return reinterpret_cast<const CMsketchColumn*>(
               &_CMsketchColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CMsketchColumn& a, CMsketchColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsketchColumn* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsketchColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CMsketchColumn* New() const final {
    return new CMsketchColumn();
  }

  CMsketchColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CMsketchColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsketchColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsketchColumn& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsketchColumn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.CMsketchColumn";
  }
  protected:
  explicit CMsketchColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmitemsFieldNumber = 2,
    kFieldIdFieldNumber = 1,
  };
  // repeated .baikaldb.pb.CMsketchItem cmitems = 2;
  int cmitems_size() const;
  private:
  int _internal_cmitems_size() const;
  public:
  void clear_cmitems();
  ::baikaldb::pb::CMsketchItem* mutable_cmitems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CMsketchItem >*
      mutable_cmitems();
  private:
  const ::baikaldb::pb::CMsketchItem& _internal_cmitems(int index) const;
  ::baikaldb::pb::CMsketchItem* _internal_add_cmitems();
  public:
  const ::baikaldb::pb::CMsketchItem& cmitems(int index) const;
  ::baikaldb::pb::CMsketchItem* add_cmitems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CMsketchItem >&
      cmitems() const;

  // required int32 field_id = 1;
  bool has_field_id() const;
  private:
  bool _internal_has_field_id() const;
  public:
  void clear_field_id();
  ::PROTOBUF_NAMESPACE_ID::int32 field_id() const;
  void set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_field_id() const;
  void _internal_set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.CMsketchColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CMsketchItem > cmitems_;
  ::PROTOBUF_NAMESPACE_ID::int32 field_id_;
  friend struct ::TableStruct_statistics_2eproto;
};
// -------------------------------------------------------------------

class CMsketch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.CMsketch) */ {
 public:
  inline CMsketch() : CMsketch(nullptr) {}
  ~CMsketch() override;
  explicit constexpr CMsketch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsketch(const CMsketch& from);
  CMsketch(CMsketch&& from) noexcept
    : CMsketch() {
    *this = ::std::move(from);
  }

  inline CMsketch& operator=(const CMsketch& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsketch& operator=(CMsketch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsketch& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsketch* internal_default_instance() {
    return reinterpret_cast<const CMsketch*>(
               &_CMsketch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CMsketch& a, CMsketch& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsketch* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsketch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CMsketch* New() const final {
    return new CMsketch();
  }

  CMsketch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CMsketch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsketch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsketch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsketch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.CMsketch";
  }
  protected:
  explicit CMsketch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCmcolumnsFieldNumber = 3,
    kDepthFieldNumber = 1,
    kWidthFieldNumber = 2,
  };
  // repeated .baikaldb.pb.CMsketchColumn cmcolumns = 3;
  int cmcolumns_size() const;
  private:
  int _internal_cmcolumns_size() const;
  public:
  void clear_cmcolumns();
  ::baikaldb::pb::CMsketchColumn* mutable_cmcolumns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CMsketchColumn >*
      mutable_cmcolumns();
  private:
  const ::baikaldb::pb::CMsketchColumn& _internal_cmcolumns(int index) const;
  ::baikaldb::pb::CMsketchColumn* _internal_add_cmcolumns();
  public:
  const ::baikaldb::pb::CMsketchColumn& cmcolumns(int index) const;
  ::baikaldb::pb::CMsketchColumn* add_cmcolumns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CMsketchColumn >&
      cmcolumns() const;

  // required int32 depth = 1;
  bool has_depth() const;
  private:
  bool _internal_has_depth() const;
  public:
  void clear_depth();
  ::PROTOBUF_NAMESPACE_ID::int32 depth() const;
  void set_depth(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_depth() const;
  void _internal_set_depth(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 width = 2;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.CMsketch)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CMsketchColumn > cmcolumns_;
  ::PROTOBUF_NAMESPACE_ID::int32 depth_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  friend struct ::TableStruct_statistics_2eproto;
};
// -------------------------------------------------------------------

class HyperLogLogColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.HyperLogLogColumn) */ {
 public:
  inline HyperLogLogColumn() : HyperLogLogColumn(nullptr) {}
  ~HyperLogLogColumn() override;
  explicit constexpr HyperLogLogColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HyperLogLogColumn(const HyperLogLogColumn& from);
  HyperLogLogColumn(HyperLogLogColumn&& from) noexcept
    : HyperLogLogColumn() {
    *this = ::std::move(from);
  }

  inline HyperLogLogColumn& operator=(const HyperLogLogColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline HyperLogLogColumn& operator=(HyperLogLogColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HyperLogLogColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const HyperLogLogColumn* internal_default_instance() {
    return reinterpret_cast<const HyperLogLogColumn*>(
               &_HyperLogLogColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(HyperLogLogColumn& a, HyperLogLogColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(HyperLogLogColumn* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HyperLogLogColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HyperLogLogColumn* New() const final {
    return new HyperLogLogColumn();
  }

  HyperLogLogColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HyperLogLogColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HyperLogLogColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HyperLogLogColumn& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HyperLogLogColumn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.HyperLogLogColumn";
  }
  protected:
  explicit HyperLogLogColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHllFieldNumber = 2,
    kEstimateCountFieldNumber = 3,
    kFieldIdFieldNumber = 1,
  };
  // optional bytes hll = 2;
  bool has_hll() const;
  private:
  bool _internal_has_hll() const;
  public:
  void clear_hll();
  const std::string& hll() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hll(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hll();
  PROTOBUF_MUST_USE_RESULT std::string* release_hll();
  void set_allocated_hll(std::string* hll);
  private:
  const std::string& _internal_hll() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hll(const std::string& value);
  std::string* _internal_mutable_hll();
  public:

  // optional uint64 estimate_count = 3;
  bool has_estimate_count() const;
  private:
  bool _internal_has_estimate_count() const;
  public:
  void clear_estimate_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 estimate_count() const;
  void set_estimate_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_estimate_count() const;
  void _internal_set_estimate_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int32 field_id = 1;
  bool has_field_id() const;
  private:
  bool _internal_has_field_id() const;
  public:
  void clear_field_id();
  ::PROTOBUF_NAMESPACE_ID::int32 field_id() const;
  void set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_field_id() const;
  void _internal_set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.HyperLogLogColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hll_;
  ::PROTOBUF_NAMESPACE_ID::uint64 estimate_count_;
  ::PROTOBUF_NAMESPACE_ID::int32 field_id_;
  friend struct ::TableStruct_statistics_2eproto;
};
// -------------------------------------------------------------------

class HyperLogLog final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.HyperLogLog) */ {
 public:
  inline HyperLogLog() : HyperLogLog(nullptr) {}
  ~HyperLogLog() override;
  explicit constexpr HyperLogLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HyperLogLog(const HyperLogLog& from);
  HyperLogLog(HyperLogLog&& from) noexcept
    : HyperLogLog() {
    *this = ::std::move(from);
  }

  inline HyperLogLog& operator=(const HyperLogLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline HyperLogLog& operator=(HyperLogLog&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HyperLogLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const HyperLogLog* internal_default_instance() {
    return reinterpret_cast<const HyperLogLog*>(
               &_HyperLogLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(HyperLogLog& a, HyperLogLog& b) {
    a.Swap(&b);
  }
  inline void Swap(HyperLogLog* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HyperLogLog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HyperLogLog* New() const final {
    return new HyperLogLog();
  }

  HyperLogLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HyperLogLog>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HyperLogLog& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HyperLogLog& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HyperLogLog* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.HyperLogLog";
  }
  protected:
  explicit HyperLogLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHllcolumnsFieldNumber = 1,
  };
  // repeated .baikaldb.pb.HyperLogLogColumn hllcolumns = 1;
  int hllcolumns_size() const;
  private:
  int _internal_hllcolumns_size() const;
  public:
  void clear_hllcolumns();
  ::baikaldb::pb::HyperLogLogColumn* mutable_hllcolumns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::HyperLogLogColumn >*
      mutable_hllcolumns();
  private:
  const ::baikaldb::pb::HyperLogLogColumn& _internal_hllcolumns(int index) const;
  ::baikaldb::pb::HyperLogLogColumn* _internal_add_hllcolumns();
  public:
  const ::baikaldb::pb::HyperLogLogColumn& hllcolumns(int index) const;
  ::baikaldb::pb::HyperLogLogColumn* add_hllcolumns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::HyperLogLogColumn >&
      hllcolumns() const;

  // @@protoc_insertion_point(class_scope:baikaldb.pb.HyperLogLog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::HyperLogLogColumn > hllcolumns_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_statistics_2eproto;
};
// -------------------------------------------------------------------

class Statistics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.Statistics) */ {
 public:
  inline Statistics() : Statistics(nullptr) {}
  ~Statistics() override;
  explicit constexpr Statistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Statistics(const Statistics& from);
  Statistics(Statistics&& from) noexcept
    : Statistics() {
    *this = ::std::move(from);
  }

  inline Statistics& operator=(const Statistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statistics& operator=(Statistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Statistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const Statistics* internal_default_instance() {
    return reinterpret_cast<const Statistics*>(
               &_Statistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Statistics& a, Statistics& b) {
    a.Swap(&b);
  }
  inline void Swap(Statistics* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Statistics* New() const final {
    return new Statistics();
  }

  Statistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Statistics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Statistics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Statistics& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Statistics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.Statistics";
  }
  protected:
  explicit Statistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHistogramFieldNumber = 3,
    kCmsketchFieldNumber = 4,
    kHllFieldNumber = 5,
    kTableIdFieldNumber = 1,
    kVersionFieldNumber = 2,
    kTotalRowsFieldNumber = 6,
  };
  // optional .baikaldb.pb.Histogram histogram = 3;
  bool has_histogram() const;
  private:
  bool _internal_has_histogram() const;
  public:
  void clear_histogram();
  const ::baikaldb::pb::Histogram& histogram() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::Histogram* release_histogram();
  ::baikaldb::pb::Histogram* mutable_histogram();
  void set_allocated_histogram(::baikaldb::pb::Histogram* histogram);
  private:
  const ::baikaldb::pb::Histogram& _internal_histogram() const;
  ::baikaldb::pb::Histogram* _internal_mutable_histogram();
  public:
  void unsafe_arena_set_allocated_histogram(
      ::baikaldb::pb::Histogram* histogram);
  ::baikaldb::pb::Histogram* unsafe_arena_release_histogram();

  // optional .baikaldb.pb.CMsketch cmsketch = 4;
  bool has_cmsketch() const;
  private:
  bool _internal_has_cmsketch() const;
  public:
  void clear_cmsketch();
  const ::baikaldb::pb::CMsketch& cmsketch() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::CMsketch* release_cmsketch();
  ::baikaldb::pb::CMsketch* mutable_cmsketch();
  void set_allocated_cmsketch(::baikaldb::pb::CMsketch* cmsketch);
  private:
  const ::baikaldb::pb::CMsketch& _internal_cmsketch() const;
  ::baikaldb::pb::CMsketch* _internal_mutable_cmsketch();
  public:
  void unsafe_arena_set_allocated_cmsketch(
      ::baikaldb::pb::CMsketch* cmsketch);
  ::baikaldb::pb::CMsketch* unsafe_arena_release_cmsketch();

  // optional .baikaldb.pb.HyperLogLog hll = 5;
  bool has_hll() const;
  private:
  bool _internal_has_hll() const;
  public:
  void clear_hll();
  const ::baikaldb::pb::HyperLogLog& hll() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::HyperLogLog* release_hll();
  ::baikaldb::pb::HyperLogLog* mutable_hll();
  void set_allocated_hll(::baikaldb::pb::HyperLogLog* hll);
  private:
  const ::baikaldb::pb::HyperLogLog& _internal_hll() const;
  ::baikaldb::pb::HyperLogLog* _internal_mutable_hll();
  public:
  void unsafe_arena_set_allocated_hll(
      ::baikaldb::pb::HyperLogLog* hll);
  ::baikaldb::pb::HyperLogLog* unsafe_arena_release_hll();

  // required int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 total_rows = 6;
  bool has_total_rows() const;
  private:
  bool _internal_has_total_rows() const;
  public:
  void clear_total_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 total_rows() const;
  void set_total_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_total_rows() const;
  void _internal_set_total_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.Statistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::Histogram* histogram_;
  ::baikaldb::pb::CMsketch* cmsketch_;
  ::baikaldb::pb::HyperLogLog* hll_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_rows_;
  friend struct ::TableStruct_statistics_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BucketInfo

// required int32 distinct_cnt = 1;
inline bool BucketInfo::_internal_has_distinct_cnt() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BucketInfo::has_distinct_cnt() const {
  return _internal_has_distinct_cnt();
}
inline void BucketInfo::clear_distinct_cnt() {
  distinct_cnt_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketInfo::_internal_distinct_cnt() const {
  return distinct_cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketInfo::distinct_cnt() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BucketInfo.distinct_cnt)
  return _internal_distinct_cnt();
}
inline void BucketInfo::_internal_set_distinct_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  distinct_cnt_ = value;
}
inline void BucketInfo::set_distinct_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_distinct_cnt(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BucketInfo.distinct_cnt)
}

// required int32 bucket_size = 2;
inline bool BucketInfo::_internal_has_bucket_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BucketInfo::has_bucket_size() const {
  return _internal_has_bucket_size();
}
inline void BucketInfo::clear_bucket_size() {
  bucket_size_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketInfo::_internal_bucket_size() const {
  return bucket_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BucketInfo::bucket_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BucketInfo.bucket_size)
  return _internal_bucket_size();
}
inline void BucketInfo::_internal_set_bucket_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  bucket_size_ = value;
}
inline void BucketInfo::set_bucket_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_bucket_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BucketInfo.bucket_size)
}

// required .baikaldb.pb.ExprValue start = 3;
inline bool BucketInfo::_internal_has_start() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || start_ != nullptr);
  return value;
}
inline bool BucketInfo::has_start() const {
  return _internal_has_start();
}
inline const ::baikaldb::pb::ExprValue& BucketInfo::_internal_start() const {
  const ::baikaldb::pb::ExprValue* p = start_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::ExprValue&>(
      ::baikaldb::pb::_ExprValue_default_instance_);
}
inline const ::baikaldb::pb::ExprValue& BucketInfo::start() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BucketInfo.start)
  return _internal_start();
}
inline void BucketInfo::unsafe_arena_set_allocated_start(
    ::baikaldb::pb::ExprValue* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  start_ = start;
  if (start) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.BucketInfo.start)
}
inline ::baikaldb::pb::ExprValue* BucketInfo::release_start() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::ExprValue* temp = start_;
  start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::ExprValue* BucketInfo::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BucketInfo.start)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::ExprValue* temp = start_;
  start_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::ExprValue* BucketInfo::_internal_mutable_start() {
  _has_bits_[0] |= 0x00000001u;
  if (start_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::ExprValue>(GetArenaForAllocation());
    start_ = p;
  }
  return start_;
}
inline ::baikaldb::pb::ExprValue* BucketInfo::mutable_start() {
  ::baikaldb::pb::ExprValue* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BucketInfo.start)
  return _msg;
}
inline void BucketInfo::set_allocated_start(::baikaldb::pb::ExprValue* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start));
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BucketInfo.start)
}

// required .baikaldb.pb.ExprValue end = 4;
inline bool BucketInfo::_internal_has_end() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || end_ != nullptr);
  return value;
}
inline bool BucketInfo::has_end() const {
  return _internal_has_end();
}
inline const ::baikaldb::pb::ExprValue& BucketInfo::_internal_end() const {
  const ::baikaldb::pb::ExprValue* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::ExprValue&>(
      ::baikaldb::pb::_ExprValue_default_instance_);
}
inline const ::baikaldb::pb::ExprValue& BucketInfo::end() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BucketInfo.end)
  return _internal_end();
}
inline void BucketInfo::unsafe_arena_set_allocated_end(
    ::baikaldb::pb::ExprValue* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.BucketInfo.end)
}
inline ::baikaldb::pb::ExprValue* BucketInfo::release_end() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::ExprValue* temp = end_;
  end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::ExprValue* BucketInfo::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BucketInfo.end)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::ExprValue* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::ExprValue* BucketInfo::_internal_mutable_end() {
  _has_bits_[0] |= 0x00000002u;
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::ExprValue>(GetArenaForAllocation());
    end_ = p;
  }
  return end_;
}
inline ::baikaldb::pb::ExprValue* BucketInfo::mutable_end() {
  ::baikaldb::pb::ExprValue* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BucketInfo.end)
  return _msg;
}
inline void BucketInfo::set_allocated_end(::baikaldb::pb::ExprValue* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end));
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BucketInfo.end)
}

// -------------------------------------------------------------------

// ColumnInfo

// required .baikaldb.pb.PrimitiveType col_type = 1;
inline bool ColumnInfo::_internal_has_col_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ColumnInfo::has_col_type() const {
  return _internal_has_col_type();
}
inline void ColumnInfo::clear_col_type() {
  col_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::baikaldb::pb::PrimitiveType ColumnInfo::_internal_col_type() const {
  return static_cast< ::baikaldb::pb::PrimitiveType >(col_type_);
}
inline ::baikaldb::pb::PrimitiveType ColumnInfo::col_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ColumnInfo.col_type)
  return _internal_col_type();
}
inline void ColumnInfo::_internal_set_col_type(::baikaldb::pb::PrimitiveType value) {
  assert(::baikaldb::pb::PrimitiveType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  col_type_ = value;
}
inline void ColumnInfo::set_col_type(::baikaldb::pb::PrimitiveType value) {
  _internal_set_col_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ColumnInfo.col_type)
}

// required int32 field_id = 2;
inline bool ColumnInfo::_internal_has_field_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ColumnInfo::has_field_id() const {
  return _internal_has_field_id();
}
inline void ColumnInfo::clear_field_id() {
  field_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ColumnInfo::_internal_field_id() const {
  return field_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ColumnInfo::field_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ColumnInfo.field_id)
  return _internal_field_id();
}
inline void ColumnInfo::_internal_set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  field_id_ = value;
}
inline void ColumnInfo::set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_field_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ColumnInfo.field_id)
}

// required int32 distinct_cnt = 3;
inline bool ColumnInfo::_internal_has_distinct_cnt() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ColumnInfo::has_distinct_cnt() const {
  return _internal_has_distinct_cnt();
}
inline void ColumnInfo::clear_distinct_cnt() {
  distinct_cnt_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ColumnInfo::_internal_distinct_cnt() const {
  return distinct_cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ColumnInfo::distinct_cnt() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ColumnInfo.distinct_cnt)
  return _internal_distinct_cnt();
}
inline void ColumnInfo::_internal_set_distinct_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  distinct_cnt_ = value;
}
inline void ColumnInfo::set_distinct_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_distinct_cnt(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ColumnInfo.distinct_cnt)
}

// required int32 null_value_cnt = 4;
inline bool ColumnInfo::_internal_has_null_value_cnt() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ColumnInfo::has_null_value_cnt() const {
  return _internal_has_null_value_cnt();
}
inline void ColumnInfo::clear_null_value_cnt() {
  null_value_cnt_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ColumnInfo::_internal_null_value_cnt() const {
  return null_value_cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ColumnInfo::null_value_cnt() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ColumnInfo.null_value_cnt)
  return _internal_null_value_cnt();
}
inline void ColumnInfo::_internal_set_null_value_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  null_value_cnt_ = value;
}
inline void ColumnInfo::set_null_value_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_null_value_cnt(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ColumnInfo.null_value_cnt)
}

// repeated .baikaldb.pb.BucketInfo bucket_infos = 5;
inline int ColumnInfo::_internal_bucket_infos_size() const {
  return bucket_infos_.size();
}
inline int ColumnInfo::bucket_infos_size() const {
  return _internal_bucket_infos_size();
}
inline void ColumnInfo::clear_bucket_infos() {
  bucket_infos_.Clear();
}
inline ::baikaldb::pb::BucketInfo* ColumnInfo::mutable_bucket_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ColumnInfo.bucket_infos)
  return bucket_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BucketInfo >*
ColumnInfo::mutable_bucket_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ColumnInfo.bucket_infos)
  return &bucket_infos_;
}
inline const ::baikaldb::pb::BucketInfo& ColumnInfo::_internal_bucket_infos(int index) const {
  return bucket_infos_.Get(index);
}
inline const ::baikaldb::pb::BucketInfo& ColumnInfo::bucket_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ColumnInfo.bucket_infos)
  return _internal_bucket_infos(index);
}
inline ::baikaldb::pb::BucketInfo* ColumnInfo::_internal_add_bucket_infos() {
  return bucket_infos_.Add();
}
inline ::baikaldb::pb::BucketInfo* ColumnInfo::add_bucket_infos() {
  ::baikaldb::pb::BucketInfo* _add = _internal_add_bucket_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ColumnInfo.bucket_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BucketInfo >&
ColumnInfo::bucket_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ColumnInfo.bucket_infos)
  return bucket_infos_;
}

// -------------------------------------------------------------------

// Histogram

// required int64 sample_rows = 1;
inline bool Histogram::_internal_has_sample_rows() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Histogram::has_sample_rows() const {
  return _internal_has_sample_rows();
}
inline void Histogram::clear_sample_rows() {
  sample_rows_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Histogram::_internal_sample_rows() const {
  return sample_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Histogram::sample_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.Histogram.sample_rows)
  return _internal_sample_rows();
}
inline void Histogram::_internal_set_sample_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  sample_rows_ = value;
}
inline void Histogram::set_sample_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_sample_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.Histogram.sample_rows)
}

// required int64 total_rows = 2;
inline bool Histogram::_internal_has_total_rows() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Histogram::has_total_rows() const {
  return _internal_has_total_rows();
}
inline void Histogram::clear_total_rows() {
  total_rows_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Histogram::_internal_total_rows() const {
  return total_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Histogram::total_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.Histogram.total_rows)
  return _internal_total_rows();
}
inline void Histogram::_internal_set_total_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  total_rows_ = value;
}
inline void Histogram::set_total_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_total_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.Histogram.total_rows)
}

// repeated .baikaldb.pb.ColumnInfo column_infos = 3;
inline int Histogram::_internal_column_infos_size() const {
  return column_infos_.size();
}
inline int Histogram::column_infos_size() const {
  return _internal_column_infos_size();
}
inline void Histogram::clear_column_infos() {
  column_infos_.Clear();
}
inline ::baikaldb::pb::ColumnInfo* Histogram::mutable_column_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.Histogram.column_infos)
  return column_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ColumnInfo >*
Histogram::mutable_column_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.Histogram.column_infos)
  return &column_infos_;
}
inline const ::baikaldb::pb::ColumnInfo& Histogram::_internal_column_infos(int index) const {
  return column_infos_.Get(index);
}
inline const ::baikaldb::pb::ColumnInfo& Histogram::column_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.Histogram.column_infos)
  return _internal_column_infos(index);
}
inline ::baikaldb::pb::ColumnInfo* Histogram::_internal_add_column_infos() {
  return column_infos_.Add();
}
inline ::baikaldb::pb::ColumnInfo* Histogram::add_column_infos() {
  ::baikaldb::pb::ColumnInfo* _add = _internal_add_column_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.Histogram.column_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ColumnInfo >&
Histogram::column_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.Histogram.column_infos)
  return column_infos_;
}

// -------------------------------------------------------------------

// CMsketchItem

// required int32 depth = 1;
inline bool CMsketchItem::_internal_has_depth() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsketchItem::has_depth() const {
  return _internal_has_depth();
}
inline void CMsketchItem::clear_depth() {
  depth_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMsketchItem::_internal_depth() const {
  return depth_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMsketchItem::depth() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CMsketchItem.depth)
  return _internal_depth();
}
inline void CMsketchItem::_internal_set_depth(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  depth_ = value;
}
inline void CMsketchItem::set_depth(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CMsketchItem.depth)
}

// required int32 width = 2;
inline bool CMsketchItem::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsketchItem::has_width() const {
  return _internal_has_width();
}
inline void CMsketchItem::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMsketchItem::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMsketchItem::width() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CMsketchItem.width)
  return _internal_width();
}
inline void CMsketchItem::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  width_ = value;
}
inline void CMsketchItem::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CMsketchItem.width)
}

// required int32 value = 3;
inline bool CMsketchItem::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsketchItem::has_value() const {
  return _internal_has_value();
}
inline void CMsketchItem::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMsketchItem::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMsketchItem::value() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CMsketchItem.value)
  return _internal_value();
}
inline void CMsketchItem::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  value_ = value;
}
inline void CMsketchItem::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CMsketchItem.value)
}

// -------------------------------------------------------------------

// CMsketchColumn

// required int32 field_id = 1;
inline bool CMsketchColumn::_internal_has_field_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsketchColumn::has_field_id() const {
  return _internal_has_field_id();
}
inline void CMsketchColumn::clear_field_id() {
  field_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMsketchColumn::_internal_field_id() const {
  return field_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMsketchColumn::field_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CMsketchColumn.field_id)
  return _internal_field_id();
}
inline void CMsketchColumn::_internal_set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  field_id_ = value;
}
inline void CMsketchColumn::set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_field_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CMsketchColumn.field_id)
}

// repeated .baikaldb.pb.CMsketchItem cmitems = 2;
inline int CMsketchColumn::_internal_cmitems_size() const {
  return cmitems_.size();
}
inline int CMsketchColumn::cmitems_size() const {
  return _internal_cmitems_size();
}
inline void CMsketchColumn::clear_cmitems() {
  cmitems_.Clear();
}
inline ::baikaldb::pb::CMsketchItem* CMsketchColumn::mutable_cmitems(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.CMsketchColumn.cmitems)
  return cmitems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CMsketchItem >*
CMsketchColumn::mutable_cmitems() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.CMsketchColumn.cmitems)
  return &cmitems_;
}
inline const ::baikaldb::pb::CMsketchItem& CMsketchColumn::_internal_cmitems(int index) const {
  return cmitems_.Get(index);
}
inline const ::baikaldb::pb::CMsketchItem& CMsketchColumn::cmitems(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CMsketchColumn.cmitems)
  return _internal_cmitems(index);
}
inline ::baikaldb::pb::CMsketchItem* CMsketchColumn::_internal_add_cmitems() {
  return cmitems_.Add();
}
inline ::baikaldb::pb::CMsketchItem* CMsketchColumn::add_cmitems() {
  ::baikaldb::pb::CMsketchItem* _add = _internal_add_cmitems();
  // @@protoc_insertion_point(field_add:baikaldb.pb.CMsketchColumn.cmitems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CMsketchItem >&
CMsketchColumn::cmitems() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.CMsketchColumn.cmitems)
  return cmitems_;
}

// -------------------------------------------------------------------

// CMsketch

// required int32 depth = 1;
inline bool CMsketch::_internal_has_depth() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsketch::has_depth() const {
  return _internal_has_depth();
}
inline void CMsketch::clear_depth() {
  depth_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMsketch::_internal_depth() const {
  return depth_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMsketch::depth() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CMsketch.depth)
  return _internal_depth();
}
inline void CMsketch::_internal_set_depth(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  depth_ = value;
}
inline void CMsketch::set_depth(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CMsketch.depth)
}

// required int32 width = 2;
inline bool CMsketch::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsketch::has_width() const {
  return _internal_has_width();
}
inline void CMsketch::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMsketch::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CMsketch::width() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CMsketch.width)
  return _internal_width();
}
inline void CMsketch::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  width_ = value;
}
inline void CMsketch::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CMsketch.width)
}

// repeated .baikaldb.pb.CMsketchColumn cmcolumns = 3;
inline int CMsketch::_internal_cmcolumns_size() const {
  return cmcolumns_.size();
}
inline int CMsketch::cmcolumns_size() const {
  return _internal_cmcolumns_size();
}
inline void CMsketch::clear_cmcolumns() {
  cmcolumns_.Clear();
}
inline ::baikaldb::pb::CMsketchColumn* CMsketch::mutable_cmcolumns(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.CMsketch.cmcolumns)
  return cmcolumns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CMsketchColumn >*
CMsketch::mutable_cmcolumns() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.CMsketch.cmcolumns)
  return &cmcolumns_;
}
inline const ::baikaldb::pb::CMsketchColumn& CMsketch::_internal_cmcolumns(int index) const {
  return cmcolumns_.Get(index);
}
inline const ::baikaldb::pb::CMsketchColumn& CMsketch::cmcolumns(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CMsketch.cmcolumns)
  return _internal_cmcolumns(index);
}
inline ::baikaldb::pb::CMsketchColumn* CMsketch::_internal_add_cmcolumns() {
  return cmcolumns_.Add();
}
inline ::baikaldb::pb::CMsketchColumn* CMsketch::add_cmcolumns() {
  ::baikaldb::pb::CMsketchColumn* _add = _internal_add_cmcolumns();
  // @@protoc_insertion_point(field_add:baikaldb.pb.CMsketch.cmcolumns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::CMsketchColumn >&
CMsketch::cmcolumns() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.CMsketch.cmcolumns)
  return cmcolumns_;
}

// -------------------------------------------------------------------

// HyperLogLogColumn

// optional int32 field_id = 1;
inline bool HyperLogLogColumn::_internal_has_field_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HyperLogLogColumn::has_field_id() const {
  return _internal_has_field_id();
}
inline void HyperLogLogColumn::clear_field_id() {
  field_id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HyperLogLogColumn::_internal_field_id() const {
  return field_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HyperLogLogColumn::field_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.HyperLogLogColumn.field_id)
  return _internal_field_id();
}
inline void HyperLogLogColumn::_internal_set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  field_id_ = value;
}
inline void HyperLogLogColumn::set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_field_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.HyperLogLogColumn.field_id)
}

// optional bytes hll = 2;
inline bool HyperLogLogColumn::_internal_has_hll() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HyperLogLogColumn::has_hll() const {
  return _internal_has_hll();
}
inline void HyperLogLogColumn::clear_hll() {
  hll_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HyperLogLogColumn::hll() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.HyperLogLogColumn.hll)
  return _internal_hll();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HyperLogLogColumn::set_hll(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 hll_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.HyperLogLogColumn.hll)
}
inline std::string* HyperLogLogColumn::mutable_hll() {
  std::string* _s = _internal_mutable_hll();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.HyperLogLogColumn.hll)
  return _s;
}
inline const std::string& HyperLogLogColumn::_internal_hll() const {
  return hll_.Get();
}
inline void HyperLogLogColumn::_internal_set_hll(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hll_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HyperLogLogColumn::_internal_mutable_hll() {
  _has_bits_[0] |= 0x00000001u;
  return hll_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HyperLogLogColumn::release_hll() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.HyperLogLogColumn.hll)
  if (!_internal_has_hll()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hll_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HyperLogLogColumn::set_allocated_hll(std::string* hll) {
  if (hll != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hll_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hll,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.HyperLogLogColumn.hll)
}

// optional uint64 estimate_count = 3;
inline bool HyperLogLogColumn::_internal_has_estimate_count() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HyperLogLogColumn::has_estimate_count() const {
  return _internal_has_estimate_count();
}
inline void HyperLogLogColumn::clear_estimate_count() {
  estimate_count_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HyperLogLogColumn::_internal_estimate_count() const {
  return estimate_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 HyperLogLogColumn::estimate_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.HyperLogLogColumn.estimate_count)
  return _internal_estimate_count();
}
inline void HyperLogLogColumn::_internal_set_estimate_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  estimate_count_ = value;
}
inline void HyperLogLogColumn::set_estimate_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_estimate_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.HyperLogLogColumn.estimate_count)
}

// -------------------------------------------------------------------

// HyperLogLog

// repeated .baikaldb.pb.HyperLogLogColumn hllcolumns = 1;
inline int HyperLogLog::_internal_hllcolumns_size() const {
  return hllcolumns_.size();
}
inline int HyperLogLog::hllcolumns_size() const {
  return _internal_hllcolumns_size();
}
inline void HyperLogLog::clear_hllcolumns() {
  hllcolumns_.Clear();
}
inline ::baikaldb::pb::HyperLogLogColumn* HyperLogLog::mutable_hllcolumns(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.HyperLogLog.hllcolumns)
  return hllcolumns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::HyperLogLogColumn >*
HyperLogLog::mutable_hllcolumns() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.HyperLogLog.hllcolumns)
  return &hllcolumns_;
}
inline const ::baikaldb::pb::HyperLogLogColumn& HyperLogLog::_internal_hllcolumns(int index) const {
  return hllcolumns_.Get(index);
}
inline const ::baikaldb::pb::HyperLogLogColumn& HyperLogLog::hllcolumns(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.HyperLogLog.hllcolumns)
  return _internal_hllcolumns(index);
}
inline ::baikaldb::pb::HyperLogLogColumn* HyperLogLog::_internal_add_hllcolumns() {
  return hllcolumns_.Add();
}
inline ::baikaldb::pb::HyperLogLogColumn* HyperLogLog::add_hllcolumns() {
  ::baikaldb::pb::HyperLogLogColumn* _add = _internal_add_hllcolumns();
  // @@protoc_insertion_point(field_add:baikaldb.pb.HyperLogLog.hllcolumns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::HyperLogLogColumn >&
HyperLogLog::hllcolumns() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.HyperLogLog.hllcolumns)
  return hllcolumns_;
}

// -------------------------------------------------------------------

// Statistics

// required int64 table_id = 1;
inline bool Statistics::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Statistics::has_table_id() const {
  return _internal_has_table_id();
}
inline void Statistics::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Statistics::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Statistics::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.Statistics.table_id)
  return _internal_table_id();
}
inline void Statistics::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  table_id_ = value;
}
inline void Statistics::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.Statistics.table_id)
}

// optional int64 version = 2;
inline bool Statistics::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Statistics::has_version() const {
  return _internal_has_version();
}
inline void Statistics::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Statistics::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Statistics::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.Statistics.version)
  return _internal_version();
}
inline void Statistics::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  version_ = value;
}
inline void Statistics::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.Statistics.version)
}

// optional .baikaldb.pb.Histogram histogram = 3;
inline bool Statistics::_internal_has_histogram() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || histogram_ != nullptr);
  return value;
}
inline bool Statistics::has_histogram() const {
  return _internal_has_histogram();
}
inline void Statistics::clear_histogram() {
  if (histogram_ != nullptr) histogram_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::Histogram& Statistics::_internal_histogram() const {
  const ::baikaldb::pb::Histogram* p = histogram_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::Histogram&>(
      ::baikaldb::pb::_Histogram_default_instance_);
}
inline const ::baikaldb::pb::Histogram& Statistics::histogram() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.Statistics.histogram)
  return _internal_histogram();
}
inline void Statistics::unsafe_arena_set_allocated_histogram(
    ::baikaldb::pb::Histogram* histogram) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(histogram_);
  }
  histogram_ = histogram;
  if (histogram) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.Statistics.histogram)
}
inline ::baikaldb::pb::Histogram* Statistics::release_histogram() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::Histogram* temp = histogram_;
  histogram_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::Histogram* Statistics::unsafe_arena_release_histogram() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.Statistics.histogram)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::Histogram* temp = histogram_;
  histogram_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::Histogram* Statistics::_internal_mutable_histogram() {
  _has_bits_[0] |= 0x00000001u;
  if (histogram_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::Histogram>(GetArenaForAllocation());
    histogram_ = p;
  }
  return histogram_;
}
inline ::baikaldb::pb::Histogram* Statistics::mutable_histogram() {
  ::baikaldb::pb::Histogram* _msg = _internal_mutable_histogram();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.Statistics.histogram)
  return _msg;
}
inline void Statistics::set_allocated_histogram(::baikaldb::pb::Histogram* histogram) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete histogram_;
  }
  if (histogram) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::Histogram>::GetOwningArena(histogram);
    if (message_arena != submessage_arena) {
      histogram = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, histogram, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  histogram_ = histogram;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.Statistics.histogram)
}

// optional .baikaldb.pb.CMsketch cmsketch = 4;
inline bool Statistics::_internal_has_cmsketch() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || cmsketch_ != nullptr);
  return value;
}
inline bool Statistics::has_cmsketch() const {
  return _internal_has_cmsketch();
}
inline void Statistics::clear_cmsketch() {
  if (cmsketch_ != nullptr) cmsketch_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::baikaldb::pb::CMsketch& Statistics::_internal_cmsketch() const {
  const ::baikaldb::pb::CMsketch* p = cmsketch_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::CMsketch&>(
      ::baikaldb::pb::_CMsketch_default_instance_);
}
inline const ::baikaldb::pb::CMsketch& Statistics::cmsketch() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.Statistics.cmsketch)
  return _internal_cmsketch();
}
inline void Statistics::unsafe_arena_set_allocated_cmsketch(
    ::baikaldb::pb::CMsketch* cmsketch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cmsketch_);
  }
  cmsketch_ = cmsketch;
  if (cmsketch) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.Statistics.cmsketch)
}
inline ::baikaldb::pb::CMsketch* Statistics::release_cmsketch() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::CMsketch* temp = cmsketch_;
  cmsketch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::CMsketch* Statistics::unsafe_arena_release_cmsketch() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.Statistics.cmsketch)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::CMsketch* temp = cmsketch_;
  cmsketch_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::CMsketch* Statistics::_internal_mutable_cmsketch() {
  _has_bits_[0] |= 0x00000002u;
  if (cmsketch_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::CMsketch>(GetArenaForAllocation());
    cmsketch_ = p;
  }
  return cmsketch_;
}
inline ::baikaldb::pb::CMsketch* Statistics::mutable_cmsketch() {
  ::baikaldb::pb::CMsketch* _msg = _internal_mutable_cmsketch();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.Statistics.cmsketch)
  return _msg;
}
inline void Statistics::set_allocated_cmsketch(::baikaldb::pb::CMsketch* cmsketch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cmsketch_;
  }
  if (cmsketch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::CMsketch>::GetOwningArena(cmsketch);
    if (message_arena != submessage_arena) {
      cmsketch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cmsketch, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cmsketch_ = cmsketch;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.Statistics.cmsketch)
}

// optional .baikaldb.pb.HyperLogLog hll = 5;
inline bool Statistics::_internal_has_hll() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || hll_ != nullptr);
  return value;
}
inline bool Statistics::has_hll() const {
  return _internal_has_hll();
}
inline void Statistics::clear_hll() {
  if (hll_ != nullptr) hll_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::baikaldb::pb::HyperLogLog& Statistics::_internal_hll() const {
  const ::baikaldb::pb::HyperLogLog* p = hll_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::HyperLogLog&>(
      ::baikaldb::pb::_HyperLogLog_default_instance_);
}
inline const ::baikaldb::pb::HyperLogLog& Statistics::hll() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.Statistics.hll)
  return _internal_hll();
}
inline void Statistics::unsafe_arena_set_allocated_hll(
    ::baikaldb::pb::HyperLogLog* hll) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hll_);
  }
  hll_ = hll;
  if (hll) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.Statistics.hll)
}
inline ::baikaldb::pb::HyperLogLog* Statistics::release_hll() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::HyperLogLog* temp = hll_;
  hll_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::HyperLogLog* Statistics::unsafe_arena_release_hll() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.Statistics.hll)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::HyperLogLog* temp = hll_;
  hll_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::HyperLogLog* Statistics::_internal_mutable_hll() {
  _has_bits_[0] |= 0x00000004u;
  if (hll_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::HyperLogLog>(GetArenaForAllocation());
    hll_ = p;
  }
  return hll_;
}
inline ::baikaldb::pb::HyperLogLog* Statistics::mutable_hll() {
  ::baikaldb::pb::HyperLogLog* _msg = _internal_mutable_hll();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.Statistics.hll)
  return _msg;
}
inline void Statistics::set_allocated_hll(::baikaldb::pb::HyperLogLog* hll) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hll_;
  }
  if (hll) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::HyperLogLog>::GetOwningArena(hll);
    if (message_arena != submessage_arena) {
      hll = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hll, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  hll_ = hll;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.Statistics.hll)
}

// optional int64 total_rows = 6;
inline bool Statistics::_internal_has_total_rows() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Statistics::has_total_rows() const {
  return _internal_has_total_rows();
}
inline void Statistics::clear_total_rows() {
  total_rows_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Statistics::_internal_total_rows() const {
  return total_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Statistics::total_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.Statistics.total_rows)
  return _internal_total_rows();
}
inline void Statistics::_internal_set_total_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  total_rows_ = value;
}
inline void Statistics::set_total_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_total_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.Statistics.total_rows)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace baikaldb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_statistics_2eproto
