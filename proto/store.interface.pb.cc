// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: store.interface.proto

#include "store.interface.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace baikaldb {
namespace pb {
constexpr KvOp::KvOp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , op_type_(0)

  , is_primary_key_(false)
  , ttl_timestamp_us_(int64_t{0}){}
struct KvOpDefaultTypeInternal {
  constexpr KvOpDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KvOpDefaultTypeInternal() {}
  union {
    KvOp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KvOpDefaultTypeInternal _KvOp_default_instance_;
constexpr RedisKv::RedisKv(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , expire_ms_(int64_t{0}){}
struct RedisKvDefaultTypeInternal {
  constexpr RedisKvDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RedisKvDefaultTypeInternal() {}
  union {
    RedisKv _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RedisKvDefaultTypeInternal _RedisKv_default_instance_;
constexpr RedisWriteRequest::RedisWriteRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : kvs_()
  , cmd_(0)

  , slot_(0u){}
struct RedisWriteRequestDefaultTypeInternal {
  constexpr RedisWriteRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RedisWriteRequestDefaultTypeInternal() {}
  union {
    RedisWriteRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RedisWriteRequestDefaultTypeInternal _RedisWriteRequest_default_instance_;
constexpr CachePlan::CachePlan(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : tuples_()
  , regions_()
  , kv_ops_()
  , plan_(nullptr)
  , op_type_(0)

  , seq_id_(0){}
struct CachePlanDefaultTypeInternal {
  constexpr CachePlanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CachePlanDefaultTypeInternal() {}
  union {
    CachePlan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CachePlanDefaultTypeInternal _CachePlan_default_instance_;
constexpr TransactionInfo::TransactionInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : need_rollback_seq_()
  , cache_plans_()
  , txn_id_(uint64_t{0u})
  , seq_id_(0)
  , start_seq_id_(0)
  , num_rows_(int64_t{0})
  , primary_region_id_(int64_t{0})
  , txn_state_(0)

  , optimize_1pc_(false)
  , autocommit_(false)
  , open_binlog_(false)
  , from_store_(false)
  , live_time_(int64_t{0})
  , start_ts_(int64_t{0})
  , commit_ts_(int64_t{0})
  , txn_timeout_(int64_t{0})
  , need_update_primary_timestamp_(false){}
struct TransactionInfoDefaultTypeInternal {
  constexpr TransactionInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TransactionInfoDefaultTypeInternal() {}
  union {
    TransactionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TransactionInfoDefaultTypeInternal _TransactionInfo_default_instance_;
constexpr AnalyzeInfo::AnalyzeInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : statistics_types_()
  , depth_(0)
  , width_(0)
  , table_rows_(int64_t{0})
  , sample_rows_(0){}
struct AnalyzeInfoDefaultTypeInternal {
  constexpr AnalyzeInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AnalyzeInfoDefaultTypeInternal() {}
  union {
    AnalyzeInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AnalyzeInfoDefaultTypeInternal _AnalyzeInfo_default_instance_;
constexpr BinlogDesc::BinlogDesc(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : db_tables_()
  , signs_()
  , txn_ids_()
  , user_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_ip_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , binlog_ts_(int64_t{0})
  , txn_id_(int64_t{0})
  , start_ts_(int64_t{0})
  , primary_region_id_(int64_t{0})
  , read_binlog_cnt_(int64_t{0})
  , binlog_row_cnt_(int64_t{0})
  , flash_back_read_(false)
  , read_offline_binlog_(false){}
struct BinlogDescDefaultTypeInternal {
  constexpr BinlogDescDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BinlogDescDefaultTypeInternal() {}
  union {
    BinlogDesc _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BinlogDescDefaultTypeInternal _BinlogDesc_default_instance_;
constexpr BatchStoreReq::BatchStoreReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : request_lens_()
  , region_id_(int64_t{0})
  , resend_start_pos_(int64_t{0}){}
struct BatchStoreReqDefaultTypeInternal {
  constexpr BatchStoreReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BatchStoreReqDefaultTypeInternal() {}
  union {
    BatchStoreReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BatchStoreReqDefaultTypeInternal _BatchStoreReq_default_instance_;
constexpr BatchStoreRes::BatchStoreRes(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : errmsg_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , leader_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , success_cnt_(int64_t{0})
  , applied_index_(int64_t{0})
  , braft_applied_index_(int64_t{0})
  , dml_latency_(int64_t{0})
  , errcode_(0)
{}
struct BatchStoreResDefaultTypeInternal {
  constexpr BatchStoreResDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BatchStoreResDefaultTypeInternal() {}
  union {
    BatchStoreRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BatchStoreResDefaultTypeInternal _BatchStoreRes_default_instance_;
constexpr RegionIndexs::RegionIndexs(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : external_full_path_()
  , olap_index_info_list_()
  , status_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , resource_tag_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , column_info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , region_id_(int64_t{0})
  , version_(int64_t{0})
  , apply_index_(int64_t{0})
  , table_id_(int64_t{0})
  , olap_state_(0)

  , path_diff_(false)
  , region_size_(int64_t{0}){}
struct RegionIndexsDefaultTypeInternal {
  constexpr RegionIndexsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RegionIndexsDefaultTypeInternal() {}
  union {
    RegionIndexs _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RegionIndexsDefaultTypeInternal _RegionIndexs_default_instance_;
constexpr ColumnRegionInfo::ColumnRegionInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : column_files_(nullptr){}
struct ColumnRegionInfoDefaultTypeInternal {
  constexpr ColumnRegionInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ColumnRegionInfoDefaultTypeInternal() {}
  union {
    ColumnRegionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ColumnRegionInfoDefaultTypeInternal _ColumnRegionInfo_default_instance_;
constexpr UseridCount::UseridCount(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : userid_(int64_t{0})
  , count_(int64_t{0}){}
struct UseridCountDefaultTypeInternal {
  constexpr UseridCountDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UseridCountDefaultTypeInternal() {}
  union {
    UseridCount _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UseridCountDefaultTypeInternal _UseridCount_default_instance_;
constexpr ExtraReq::ExtraReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : olap_info_(nullptr)
  , offline_binlog_info_(nullptr)
  , column_info_(nullptr)
  , sign_latency_(int64_t{0})
  , watt_stats_version_(uint64_t{0u})
  , use_read_idx_(false){}
struct ExtraReqDefaultTypeInternal {
  constexpr ExtraReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ExtraReqDefaultTypeInternal() {}
  union {
    ExtraReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ExtraReqDefaultTypeInternal _ExtraReq_default_instance_;
constexpr ExtraRes::ExtraRes(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : infos_()
  , afs_full_names_()
  , userid_count_()
  , vectorized_rows_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , vectorized_schema_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , offline_binlog_info_(nullptr)
  , wait_cost_(int64_t{0})
  , get_afs_path_succ_(false)
  , query_keypoint_succ_(false){}
struct ExtraResDefaultTypeInternal {
  constexpr ExtraResDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ExtraResDefaultTypeInternal() {}
  union {
    ExtraRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ExtraResDefaultTypeInternal _ExtraRes_default_instance_;
constexpr StoreReq::StoreReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : tuples_()
  , txn_infos_()
  , kv_ops_()
  , rollback_txn_ids_()
  , commit_txn_ids_()
  , multi_new_region_infos_()
  , start_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , end_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , plan_(nullptr)
  , new_region_info_(nullptr)
  , ddlwork_info_(nullptr)
  , analyze_info_(nullptr)
  , binlog_desc_(nullptr)
  , binlog_(nullptr)
  , extra_req_(nullptr)
  , redis_req_(nullptr)
  , region_id_(int64_t{0})
  , region_version_(int64_t{0})
  , log_id_(uint64_t{0u})
  , split_term_(int64_t{0})
  , split_end_index_(int64_t{0})
  , reduce_num_lines_(int64_t{0})
  , op_type_(0)

  , force_(false)
  , not_check_region_(false)
  , select_without_leader_(false)
  , is_trace_(false)
  , db_conn_id_(uint64_t{0u})
  , num_increase_rows_(int64_t{0})
  , sql_sign_(uint64_t{0u})
  , execute_type_(0)

  , is_rollup_base_(false)
  , sql_exec_timeout_(int64_t{0}){}
struct StoreReqDefaultTypeInternal {
  constexpr StoreReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreReqDefaultTypeInternal() {}
  union {
    StoreReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreReqDefaultTypeInternal _StoreReq_default_instance_;
constexpr RowValue::RowValue(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : tuple_values_(){}
struct RowValueDefaultTypeInternal {
  constexpr RowValueDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RowValueDefaultTypeInternal() {}
  union {
    RowValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RowValueDefaultTypeInternal _RowValue_default_instance_;
constexpr RegionLeader::RegionLeader(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : leader_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , region_id_(int64_t{0}){}
struct RegionLeaderDefaultTypeInternal {
  constexpr RegionLeaderDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RegionLeaderDefaultTypeInternal() {}
  union {
    RegionLeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RegionLeaderDefaultTypeInternal _RegionLeader_default_instance_;
constexpr IndexRecords::IndexRecords(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : records_()
  , old_records_()
  , index_id_(int64_t{0})
  , local_index_binlog_(false){}
struct IndexRecordsDefaultTypeInternal {
  constexpr IndexRecordsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IndexRecordsDefaultTypeInternal() {}
  union {
    IndexRecords _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IndexRecordsDefaultTypeInternal _IndexRecords_default_instance_;
constexpr RegionRaftStat::RegionRaftStat(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : applied_index_(int64_t{0})
  , snapshot_data_size_(uint64_t{0u})
  , snapshot_meta_size_(uint64_t{0u})
  , snapshot_index_(int64_t{0})
  , dml_latency_(int64_t{0}){}
struct RegionRaftStatDefaultTypeInternal {
  constexpr RegionRaftStatDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RegionRaftStatDefaultTypeInternal() {}
  union {
    RegionRaftStat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RegionRaftStatDefaultTypeInternal _RegionRaftStat_default_instance_;
constexpr RocksStatisticReq::RocksStatisticReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : keys_(){}
struct RocksStatisticReqDefaultTypeInternal {
  constexpr RocksStatisticReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RocksStatisticReqDefaultTypeInternal() {}
  union {
    RocksStatisticReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RocksStatisticReqDefaultTypeInternal _RocksStatisticReq_default_instance_;
constexpr RocksStatisticRes::RocksStatisticRes(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : key_()
  , value_()
  , level0_sst_num_(uint64_t{0u})
  , compaction_data_size_(uint64_t{0u})
  , errcode_(0)
{}
struct RocksStatisticResDefaultTypeInternal {
  constexpr RocksStatisticResDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RocksStatisticResDefaultTypeInternal() {}
  union {
    RocksStatisticRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RocksStatisticResDefaultTypeInternal _RocksStatisticRes_default_instance_;
constexpr BinlogQueryInfo::BinlogQueryInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : region_ip_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , region_id_(int64_t{0})
  , oldest_ts_(int64_t{0})
  , check_point_ts_(int64_t{0})
  , region_oldest_ts_(int64_t{0})
  , binlog_cf_oldest_ts_(int64_t{0})
  , data_cf_oldest_ts_(int64_t{0}){}
struct BinlogQueryInfoDefaultTypeInternal {
  constexpr BinlogQueryInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BinlogQueryInfoDefaultTypeInternal() {}
  union {
    BinlogQueryInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BinlogQueryInfoDefaultTypeInternal _BinlogQueryInfo_default_instance_;
constexpr StoreRes::StoreRes(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : tuple_ids_()
  , row_values_()
  , regions_()
  , txn_infos_()
  , region_leaders_()
  , records_()
  , binlogs_()
  , commit_ts_()
  , ttl_timestamp_()
  , errmsg_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , leader_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , cmsketch_(nullptr)
  , region_raft_stat_(nullptr)
  , extra_res_(nullptr)
  , binlog_info_(nullptr)
  , hll_(nullptr)
  , errcode_(0)

  , last_seq_id_(0)
  , affected_rows_(int64_t{0})
  , applied_index_(int64_t{0})
  , region_count_(int64_t{0})
  , mysql_errcode_(0)
  , is_merge_(false)
  , scan_rows_(int64_t{0})
  , filter_rows_(int64_t{0})
  , last_insert_id_(int64_t{0})
  , region_status_(0)

  , execute_type_(0)

  , read_disk_size_(int64_t{0})
  , orig_region_id_(int64_t{0}){}
struct StoreResDefaultTypeInternal {
  constexpr StoreResDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StoreResDefaultTypeInternal() {}
  union {
    StoreRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StoreResDefaultTypeInternal _StoreRes_default_instance_;
constexpr BatchRegionStoreReq::BatchRegionStoreReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : store_req_()
  , plan_()
  , limit_single_store_concurrency_(int64_t{0}){}
struct BatchRegionStoreReqDefaultTypeInternal {
  constexpr BatchRegionStoreReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BatchRegionStoreReqDefaultTypeInternal() {}
  union {
    BatchRegionStoreReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BatchRegionStoreReqDefaultTypeInternal _BatchRegionStoreReq_default_instance_;
constexpr BatchRegionStoreRes::BatchRegionStoreRes(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : store_res_(){}
struct BatchRegionStoreResDefaultTypeInternal {
  constexpr BatchRegionStoreResDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BatchRegionStoreResDefaultTypeInternal() {}
  union {
    BatchRegionStoreRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BatchRegionStoreResDefaultTypeInternal _BatchRegionStoreRes_default_instance_;
constexpr InitRegion::InitRegion(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : region_info_(nullptr)
  , schema_info_(nullptr)
  , snapshot_times_(0)
  , is_split_(false)
  , is_learner_(false){}
struct InitRegionDefaultTypeInternal {
  constexpr InitRegionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InitRegionDefaultTypeInternal() {}
  union {
    InitRegion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InitRegionDefaultTypeInternal _InitRegion_default_instance_;
constexpr GetAppliedIndex::GetAppliedIndex(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : region_id_(int64_t{0})
  , use_read_idx_(false)
  , use_raft_log_index_(false){}
struct GetAppliedIndexDefaultTypeInternal {
  constexpr GetAppliedIndexDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetAppliedIndexDefaultTypeInternal() {}
  union {
    GetAppliedIndex _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetAppliedIndexDefaultTypeInternal _GetAppliedIndex_default_instance_;
constexpr RemoveRegion::RemoveRegion(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : region_id_(int64_t{0})
  , force_(false)
  , need_delay_drop_(false){}
struct RemoveRegionDefaultTypeInternal {
  constexpr RemoveRegionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RemoveRegionDefaultTypeInternal() {}
  union {
    RemoveRegion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RemoveRegionDefaultTypeInternal _RemoveRegion_default_instance_;
constexpr RegionIds::RegionIds(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : region_ids_()
  , userids_()
  , table_id_(int64_t{0})
  , compact_type_(0)
  , compact_raft_log_(false)
  , clear_all_txns_(false)
  , query_apply_index_(false)
  , query_all_afs_file_(false)
  , txn_timeout_(int64_t{0})
  , query_olap_keypoint_(false){}
struct RegionIdsDefaultTypeInternal {
  constexpr RegionIdsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RegionIdsDefaultTypeInternal() {}
  union {
    RegionIds _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RegionIdsDefaultTypeInternal _RegionIds_default_instance_;
constexpr BackUpReq::BackUpReq(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct BackUpReqDefaultTypeInternal {
  constexpr BackUpReqDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BackUpReqDefaultTypeInternal() {}
  union {
    BackUpReq _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BackUpReqDefaultTypeInternal _BackUpReq_default_instance_;
constexpr BackUpRes::BackUpRes(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct BackUpResDefaultTypeInternal {
  constexpr BackUpResDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BackUpResDefaultTypeInternal() {}
  union {
    BackUpRes _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BackUpResDefaultTypeInternal _BackUpRes_default_instance_;
constexpr BackupRequest::BackupRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : region_id_(int64_t{0})
  , log_index_(int64_t{0})
  , backup_op_(0)

  , ingest_store_latest_sst_(false)
  , data_sst_to_process_size_(int64_t{0})
  , row_size_(int64_t{0})
  , streaming_id_(uint64_t{0u}){}
struct BackupRequestDefaultTypeInternal {
  constexpr BackupRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BackupRequestDefaultTypeInternal() {}
  union {
    BackupRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BackupRequestDefaultTypeInternal _BackupRequest_default_instance_;
constexpr BackupResponse::BackupResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : peers_()
  , unstable_followers_()
  , leader_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , log_index_(int64_t{0})
  , errcode_(0)

  , streaming_state_(0)

  , streaming_id_(uint64_t{0u}){}
struct BackupResponseDefaultTypeInternal {
  constexpr BackupResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BackupResponseDefaultTypeInternal() {}
  union {
    BackupResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BackupResponseDefaultTypeInternal _BackupResponse_default_instance_;
constexpr HealthCheck::HealthCheck(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct HealthCheckDefaultTypeInternal {
  constexpr HealthCheckDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~HealthCheckDefaultTypeInternal() {}
  union {
    HealthCheck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HealthCheckDefaultTypeInternal _HealthCheck_default_instance_;
constexpr OlapRegionIndexInfo::OlapRegionIndexInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : external_path_()
  , index_id_(int64_t{0})
  , state_(0)
{}
struct OlapRegionIndexInfoDefaultTypeInternal {
  constexpr OlapRegionIndexInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OlapRegionIndexInfoDefaultTypeInternal() {}
  union {
    OlapRegionIndexInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OlapRegionIndexInfoDefaultTypeInternal _OlapRegionIndexInfo_default_instance_;
constexpr OlapRegionInfo::OlapRegionInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : external_full_path_()
  , olap_index_info_list_()
  , new_olap_index_info_(nullptr)
  , state_time_(uint64_t{0u})
  , state_(0)
{}
struct OlapRegionInfoDefaultTypeInternal {
  constexpr OlapRegionInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~OlapRegionInfoDefaultTypeInternal() {}
  union {
    OlapRegionInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT OlapRegionInfoDefaultTypeInternal _OlapRegionInfo_default_instance_;
constexpr RegionOfflineBinlogInfo::RegionOfflineBinlogInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : external_full_path_()
  , oldest_ts_(int64_t{0})
  , newest_ts_(int64_t{0})
  , task_start_ts_(int64_t{0})
  , task_end_ts_(int64_t{0}){}
struct RegionOfflineBinlogInfoDefaultTypeInternal {
  constexpr RegionOfflineBinlogInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~RegionOfflineBinlogInfoDefaultTypeInternal() {}
  union {
    RegionOfflineBinlogInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT RegionOfflineBinlogInfoDefaultTypeInternal _RegionOfflineBinlogInfo_default_instance_;
constexpr CompactionFileRequest::CompactionFileRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : remote_compaction_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , file_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , offset_(uint64_t{0u})
  , count_(0u)
  , recursive_(false)
  , op_type_(1)
{}
struct CompactionFileRequestDefaultTypeInternal {
  constexpr CompactionFileRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CompactionFileRequestDefaultTypeInternal() {}
  union {
    CompactionFileRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CompactionFileRequestDefaultTypeInternal _CompactionFileRequest_default_instance_;
constexpr CompactionFileResponse::CompactionFileResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : file_info_()
  , data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , errcode_(0)
{}
struct CompactionFileResponseDefaultTypeInternal {
  constexpr CompactionFileResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CompactionFileResponseDefaultTypeInternal() {}
  union {
    CompactionFileResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CompactionFileResponseDefaultTypeInternal _CompactionFileResponse_default_instance_;
}  // namespace pb
}  // namespace baikaldb
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_store_2einterface_2eproto[39];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_store_2einterface_2eproto[7];
static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* file_level_service_descriptors_store_2einterface_2eproto[1];

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_store_2einterface_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::KvOp, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::KvOp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::KvOp, op_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::KvOp, key_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::KvOp, value_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::KvOp, ttl_timestamp_us_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::KvOp, is_primary_key_),
  2,
  0,
  1,
  4,
  3,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RedisKv, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RedisKv, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RedisKv, key_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RedisKv, value_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RedisKv, expire_ms_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RedisWriteRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RedisWriteRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RedisWriteRequest, cmd_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RedisWriteRequest, kvs_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RedisWriteRequest, slot_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CachePlan, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CachePlan, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CachePlan, op_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CachePlan, seq_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CachePlan, plan_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CachePlan, tuples_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CachePlan, regions_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CachePlan, kv_ops_),
  1,
  2,
  0,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, txn_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, seq_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, start_seq_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, optimize_1pc_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, need_rollback_seq_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, cache_plans_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, num_rows_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, autocommit_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, primary_region_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, txn_state_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, live_time_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, start_ts_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, commit_ts_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, open_binlog_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, from_store_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, txn_timeout_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionInfo, need_update_primary_timestamp_),
  0,
  1,
  2,
  6,
  ~0u,
  ~0u,
  3,
  7,
  4,
  5,
  10,
  11,
  12,
  8,
  9,
  13,
  14,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::AnalyzeInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::AnalyzeInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::AnalyzeInfo, depth_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::AnalyzeInfo, width_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::AnalyzeInfo, sample_rows_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::AnalyzeInfo, table_rows_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::AnalyzeInfo, statistics_types_),
  0,
  1,
  3,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogDesc, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogDesc, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogDesc, binlog_ts_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogDesc, txn_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogDesc, start_ts_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogDesc, primary_region_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogDesc, read_binlog_cnt_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogDesc, binlog_row_cnt_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogDesc, user_name_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogDesc, user_ip_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogDesc, db_tables_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogDesc, signs_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogDesc, txn_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogDesc, flash_back_read_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogDesc, read_offline_binlog_),
  2,
  3,
  4,
  5,
  6,
  7,
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchStoreReq, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchStoreReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchStoreReq, region_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchStoreReq, request_lens_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchStoreReq, resend_start_pos_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchStoreRes, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchStoreRes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchStoreRes, errcode_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchStoreRes, errmsg_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchStoreRes, leader_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchStoreRes, success_cnt_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchStoreRes, applied_index_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchStoreRes, braft_applied_index_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchStoreRes, dml_latency_),
  6,
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIndexs, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIndexs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIndexs, region_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIndexs, version_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIndexs, apply_index_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIndexs, status_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIndexs, resource_tag_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIndexs, table_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIndexs, olap_state_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIndexs, external_full_path_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIndexs, path_diff_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIndexs, region_size_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIndexs, column_info_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIndexs, olap_index_info_list_),
  3,
  4,
  5,
  0,
  1,
  6,
  7,
  ~0u,
  8,
  9,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ColumnRegionInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ColumnRegionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ColumnRegionInfo, column_files_),
  0,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UseridCount, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UseridCount, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UseridCount, userid_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UseridCount, count_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraReq, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraReq, use_read_idx_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraReq, sign_latency_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraReq, olap_info_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraReq, offline_binlog_info_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraReq, watt_stats_version_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraReq, column_info_),
  5,
  3,
  0,
  1,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraRes, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraRes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraRes, infos_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraRes, offline_binlog_info_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraRes, vectorized_rows_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraRes, vectorized_schema_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraRes, wait_cost_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraRes, afs_full_names_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraRes, get_afs_path_succ_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraRes, query_keypoint_succ_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExtraRes, userid_count_),
  ~0u,
  2,
  0,
  1,
  3,
  ~0u,
  4,
  5,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, op_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, tuples_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, region_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, region_version_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, plan_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, txn_infos_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, log_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, start_key_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, end_key_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, split_term_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, split_end_index_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, reduce_num_lines_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, force_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, not_check_region_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, new_region_info_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, select_without_leader_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, db_conn_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, ddlwork_info_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, num_increase_rows_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, kv_ops_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, is_trace_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, analyze_info_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, rollback_txn_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, commit_txn_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, binlog_desc_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, binlog_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, sql_sign_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, multi_new_region_infos_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, extra_req_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, execute_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, is_rollup_base_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, sql_exec_timeout_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreReq, redis_req_),
  16,
  ~0u,
  10,
  11,
  2,
  ~0u,
  12,
  0,
  1,
  13,
  14,
  15,
  17,
  18,
  3,
  19,
  21,
  4,
  22,
  ~0u,
  20,
  5,
  ~0u,
  ~0u,
  6,
  7,
  23,
  ~0u,
  8,
  24,
  25,
  26,
  9,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RowValue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RowValue, tuple_values_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionLeader, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionLeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionLeader, region_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionLeader, leader_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::IndexRecords, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::IndexRecords, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::IndexRecords, index_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::IndexRecords, records_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::IndexRecords, old_records_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::IndexRecords, local_index_binlog_),
  0,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionRaftStat, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionRaftStat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionRaftStat, applied_index_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionRaftStat, snapshot_data_size_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionRaftStat, snapshot_meta_size_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionRaftStat, snapshot_index_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionRaftStat, dml_latency_),
  0,
  1,
  2,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RocksStatisticReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RocksStatisticReq, keys_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RocksStatisticRes, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RocksStatisticRes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RocksStatisticRes, errcode_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RocksStatisticRes, level0_sst_num_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RocksStatisticRes, compaction_data_size_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RocksStatisticRes, key_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RocksStatisticRes, value_),
  2,
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogQueryInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogQueryInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogQueryInfo, region_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogQueryInfo, oldest_ts_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogQueryInfo, check_point_ts_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogQueryInfo, region_oldest_ts_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogQueryInfo, binlog_cf_oldest_ts_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogQueryInfo, data_cf_oldest_ts_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BinlogQueryInfo, region_ip_),
  1,
  2,
  3,
  4,
  5,
  6,
  0,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, errcode_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, errmsg_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, leader_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, tuple_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, row_values_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, affected_rows_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, regions_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, applied_index_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, last_seq_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, txn_infos_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, mysql_errcode_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, region_count_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, region_leaders_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, is_merge_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, records_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, scan_rows_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, cmsketch_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, filter_rows_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, binlogs_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, commit_ts_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, region_status_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, last_insert_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, region_raft_stat_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, ttl_timestamp_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, extra_res_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, binlog_info_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, execute_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, read_disk_size_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, orig_region_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::StoreRes, hll_),
  7,
  0,
  1,
  ~0u,
  ~0u,
  9,
  ~0u,
  10,
  8,
  ~0u,
  12,
  11,
  ~0u,
  13,
  ~0u,
  14,
  2,
  15,
  ~0u,
  ~0u,
  17,
  16,
  3,
  ~0u,
  4,
  5,
  18,
  19,
  20,
  6,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchRegionStoreReq, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchRegionStoreReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchRegionStoreReq, store_req_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchRegionStoreReq, limit_single_store_concurrency_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchRegionStoreReq, plan_),
  ~0u,
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchRegionStoreRes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BatchRegionStoreRes, store_res_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InitRegion, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InitRegion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InitRegion, region_info_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InitRegion, schema_info_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InitRegion, is_split_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InitRegion, snapshot_times_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InitRegion, is_learner_),
  0,
  1,
  3,
  2,
  4,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::GetAppliedIndex, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::GetAppliedIndex, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::GetAppliedIndex, region_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::GetAppliedIndex, use_read_idx_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::GetAppliedIndex, use_raft_log_index_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RemoveRegion, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RemoveRegion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RemoveRegion, region_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RemoveRegion, force_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RemoveRegion, need_delay_drop_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIds, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIds, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIds, region_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIds, compact_raft_log_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIds, table_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIds, compact_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIds, clear_all_txns_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIds, txn_timeout_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIds, query_apply_index_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIds, userids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIds, query_all_afs_file_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionIds, query_olap_keypoint_),
  ~0u,
  2,
  0,
  1,
  3,
  6,
  4,
  ~0u,
  5,
  7,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackUpReq, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackUpRes, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupRequest, region_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupRequest, log_index_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupRequest, backup_op_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupRequest, ingest_store_latest_sst_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupRequest, data_sst_to_process_size_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupRequest, row_size_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupRequest, streaming_id_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupResponse, log_index_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupResponse, errcode_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupResponse, leader_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupResponse, peers_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupResponse, unstable_followers_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupResponse, streaming_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BackupResponse, streaming_state_),
  1,
  2,
  0,
  ~0u,
  ~0u,
  4,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::HealthCheck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::OlapRegionIndexInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::OlapRegionIndexInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::OlapRegionIndexInfo, index_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::OlapRegionIndexInfo, external_path_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::OlapRegionIndexInfo, state_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::OlapRegionInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::OlapRegionInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::OlapRegionInfo, state_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::OlapRegionInfo, state_time_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::OlapRegionInfo, external_full_path_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::OlapRegionInfo, olap_index_info_list_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::OlapRegionInfo, new_olap_index_info_),
  2,
  1,
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionOfflineBinlogInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionOfflineBinlogInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionOfflineBinlogInfo, oldest_ts_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionOfflineBinlogInfo, newest_ts_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionOfflineBinlogInfo, task_start_ts_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionOfflineBinlogInfo, task_end_ts_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::RegionOfflineBinlogInfo, external_full_path_),
  0,
  1,
  2,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CompactionFileRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CompactionFileRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CompactionFileRequest, op_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CompactionFileRequest, remote_compaction_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CompactionFileRequest, file_name_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CompactionFileRequest, offset_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CompactionFileRequest, count_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CompactionFileRequest, data_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CompactionFileRequest, recursive_),
  6,
  0,
  1,
  3,
  4,
  2,
  5,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CompactionFileResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CompactionFileResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CompactionFileResponse, errcode_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CompactionFileResponse, data_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CompactionFileResponse, file_info_),
  1,
  0,
  ~0u,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, -1, sizeof(::baikaldb::pb::KvOp)},
  { 16, 25, -1, sizeof(::baikaldb::pb::RedisKv)},
  { 28, 37, -1, sizeof(::baikaldb::pb::RedisWriteRequest)},
  { 40, 52, -1, sizeof(::baikaldb::pb::CachePlan)},
  { 58, 81, -1, sizeof(::baikaldb::pb::TransactionInfo)},
  { 98, 109, -1, sizeof(::baikaldb::pb::AnalyzeInfo)},
  { 114, 133, -1, sizeof(::baikaldb::pb::BinlogDesc)},
  { 146, 155, -1, sizeof(::baikaldb::pb::BatchStoreReq)},
  { 158, 171, -1, sizeof(::baikaldb::pb::BatchStoreRes)},
  { 178, 196, -1, sizeof(::baikaldb::pb::RegionIndexs)},
  { 208, 215, -1, sizeof(::baikaldb::pb::ColumnRegionInfo)},
  { 216, 224, -1, sizeof(::baikaldb::pb::UseridCount)},
  { 226, 238, -1, sizeof(::baikaldb::pb::ExtraReq)},
  { 244, 259, -1, sizeof(::baikaldb::pb::ExtraRes)},
  { 268, 307, -1, sizeof(::baikaldb::pb::StoreReq)},
  { 340, -1, -1, sizeof(::baikaldb::pb::RowValue)},
  { 347, 355, -1, sizeof(::baikaldb::pb::RegionLeader)},
  { 357, 367, -1, sizeof(::baikaldb::pb::IndexRecords)},
  { 371, 382, -1, sizeof(::baikaldb::pb::RegionRaftStat)},
  { 387, -1, -1, sizeof(::baikaldb::pb::RocksStatisticReq)},
  { 394, 405, -1, sizeof(::baikaldb::pb::RocksStatisticRes)},
  { 410, 423, -1, sizeof(::baikaldb::pb::BinlogQueryInfo)},
  { 430, 466, -1, sizeof(::baikaldb::pb::StoreRes)},
  { 496, 505, -1, sizeof(::baikaldb::pb::BatchRegionStoreReq)},
  { 508, -1, -1, sizeof(::baikaldb::pb::BatchRegionStoreRes)},
  { 515, 526, -1, sizeof(::baikaldb::pb::InitRegion)},
  { 531, 540, -1, sizeof(::baikaldb::pb::GetAppliedIndex)},
  { 543, 552, -1, sizeof(::baikaldb::pb::RemoveRegion)},
  { 555, 571, -1, sizeof(::baikaldb::pb::RegionIds)},
  { 581, -1, -1, sizeof(::baikaldb::pb::BackUpReq)},
  { 587, -1, -1, sizeof(::baikaldb::pb::BackUpRes)},
  { 593, 606, -1, sizeof(::baikaldb::pb::BackupRequest)},
  { 613, 626, -1, sizeof(::baikaldb::pb::BackupResponse)},
  { 633, -1, -1, sizeof(::baikaldb::pb::HealthCheck)},
  { 639, 648, -1, sizeof(::baikaldb::pb::OlapRegionIndexInfo)},
  { 651, 662, -1, sizeof(::baikaldb::pb::OlapRegionInfo)},
  { 667, 678, -1, sizeof(::baikaldb::pb::RegionOfflineBinlogInfo)},
  { 683, 696, -1, sizeof(::baikaldb::pb::CompactionFileRequest)},
  { 703, 712, -1, sizeof(::baikaldb::pb::CompactionFileResponse)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_KvOp_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_RedisKv_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_RedisWriteRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_CachePlan_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_TransactionInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_AnalyzeInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_BinlogDesc_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_BatchStoreReq_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_BatchStoreRes_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_RegionIndexs_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_ColumnRegionInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_UseridCount_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_ExtraReq_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_ExtraRes_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_StoreReq_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_RowValue_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_RegionLeader_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_IndexRecords_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_RegionRaftStat_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_RocksStatisticReq_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_RocksStatisticRes_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_BinlogQueryInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_StoreRes_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_BatchRegionStoreReq_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_BatchRegionStoreRes_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_InitRegion_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_GetAppliedIndex_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_RemoveRegion_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_RegionIds_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_BackUpReq_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_BackUpRes_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_BackupRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_BackupResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_HealthCheck_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_OlapRegionIndexInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_OlapRegionInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_RegionOfflineBinlogInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_CompactionFileRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_CompactionFileResponse_default_instance_),
};

const char descriptor_table_protodef_store_2einterface_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\025store.interface.proto\022\013baikaldb.pb\032\014co"
  "mmon.proto\032\nraft.proto\032\nplan.proto\032\014opty"
  "pe.proto\032\020statistics.proto\032\024meta.interfa"
  "ce.proto\032\014binlog.proto\032\014column.proto\"z\n\004"
  "KvOp\022$\n\007op_type\030\001 \002(\0162\023.baikaldb.pb.OpTy"
  "pe\022\013\n\003key\030\002 \001(\014\022\r\n\005value\030\003 \001(\014\022\030\n\020ttl_ti"
  "mestamp_us\030\004 \001(\003\022\026\n\016is_primary_key\030\005 \001(\010"
  "\"8\n\007RedisKv\022\013\n\003key\030\001 \001(\014\022\r\n\005value\030\002 \001(\014\022"
  "\021\n\texpire_ms\030\003 \001(\003\"h\n\021RedisWriteRequest\022"
  "\"\n\003cmd\030\001 \001(\0162\025.baikaldb.pb.RedisCmd\022!\n\003k"
  "vs\030\002 \003(\0132\024.baikaldb.pb.RedisKv\022\014\n\004slot\030\003"
  " \001(\r\"\335\001\n\tCachePlan\022$\n\007op_type\030\001 \002(\0162\023.ba"
  "ikaldb.pb.OpType\022\016\n\006seq_id\030\002 \002(\005\022\037\n\004plan"
  "\030\003 \002(\0132\021.baikaldb.pb.Plan\022,\n\006tuples\030\004 \003("
  "\0132\034.baikaldb.pb.TupleDescriptor\022(\n\007regio"
  "ns\030\005 \003(\0132\027.baikaldb.pb.RegionInfo\022!\n\006kv_"
  "ops\030\006 \003(\0132\021.baikaldb.pb.KvOp\"\255\003\n\017Transac"
  "tionInfo\022\016\n\006txn_id\030\001 \002(\004\022\016\n\006seq_id\030\002 \002(\005"
  "\022\024\n\014start_seq_id\030\003 \001(\005\022\024\n\014optimize_1pc\030\004"
  " \001(\010\022\031\n\021need_rollback_seq\030\005 \003(\005\022+\n\013cache"
  "_plans\030\006 \003(\0132\026.baikaldb.pb.CachePlan\022\020\n\010"
  "num_rows\030\007 \001(\003\022\022\n\nautocommit\030\010 \001(\010\022\031\n\021pr"
  "imary_region_id\030\t \001(\003\022(\n\ttxn_state\030\n \001(\016"
  "2\025.baikaldb.pb.TxnState\022\021\n\tlive_time\030\013 \001"
  "(\003\022\020\n\010start_ts\030\014 \001(\003\022\021\n\tcommit_ts\030\r \001(\003\022"
  "\023\n\013open_binlog\030\016 \001(\010\022\022\n\nfrom_store\030\017 \001(\010"
  "\022\023\n\013txn_timeout\030\020 \001(\003\022%\n\035need_update_pri"
  "mary_timestamp\030\021 \001(\010\"\212\001\n\013AnalyzeInfo\022\r\n\005"
  "depth\030\001 \001(\005\022\r\n\005width\030\002 \001(\005\022\023\n\013sample_row"
  "s\030\003 \001(\005\022\022\n\ntable_rows\030\004 \001(\003\0224\n\020statistic"
  "s_types\030\005 \003(\0162\032.baikaldb.pb.StatisticTyp"
  "e\"\232\002\n\nBinlogDesc\022\021\n\tbinlog_ts\030\001 \002(\003\022\016\n\006t"
  "xn_id\030\002 \001(\003\022\020\n\010start_ts\030\003 \001(\003\022\031\n\021primary"
  "_region_id\030\004 \001(\003\022\027\n\017read_binlog_cnt\030\006 \001("
  "\003\022\026\n\016binlog_row_cnt\030\007 \001(\003\022\021\n\tuser_name\030\010"
  " \001(\014\022\017\n\007user_ip\030\t \001(\014\022\021\n\tdb_tables\030\n \003(\014"
  "\022\r\n\005signs\030\013 \003(\004\022\017\n\007txn_ids\030\014 \003(\003\022\027\n\017flas"
  "h_back_read\030\r \001(\010\022\033\n\023read_offline_binlog"
  "\030\016 \001(\010\"R\n\rBatchStoreReq\022\021\n\tregion_id\030\001 \002"
  "(\003\022\024\n\014request_lens\030\002 \003(\003\022\030\n\020resend_start"
  "_pos\030\003 \001(\003\"\264\001\n\rBatchStoreRes\022%\n\007errcode\030"
  "\001 \002(\0162\024.baikaldb.pb.ErrCode\022\016\n\006errmsg\030\002 "
  "\001(\014\022\016\n\006leader\030\003 \001(\t\022\023\n\013success_cnt\030\004 \001(\003"
  "\022\025\n\rapplied_index\030\005 \001(\003\022\033\n\023braft_applied"
  "_index\030\006 \001(\003\022\023\n\013dml_latency\030\007 \001(\003\"\311\002\n\014Re"
  "gionIndexs\022\021\n\tregion_id\030\001 \001(\003\022\017\n\007version"
  "\030\002 \001(\003\022\023\n\013apply_index\030\003 \001(\003\022\016\n\006status\030\004 "
  "\001(\t\022\024\n\014resource_tag\030\005 \001(\t\022\020\n\010table_id\030\006 "
  "\001(\003\022/\n\nolap_state\030\007 \001(\0162\033.baikaldb.pb.Ol"
  "apRegionStat\022\032\n\022external_full_path\030\010 \003(\t"
  "\022\021\n\tpath_diff\030\t \001(\010\022\023\n\013region_size\030\n \001(\003"
  "\022\023\n\013column_info\030\013 \001(\t\022>\n\024olap_index_info"
  "_list\030\014 \003(\0132 .baikaldb.pb.OlapRegionInde"
  "xInfo\"H\n\020ColumnRegionInfo\0224\n\014column_file"
  "s\030\001 \001(\0132\036.baikaldb.pb.RegionColumnFiles\""
  ",\n\013UseridCount\022\016\n\006userid\030\001 \001(\003\022\r\n\005count\030"
  "\002 \001(\003\"\371\001\n\010ExtraReq\022\024\n\014use_read_idx\030\001 \001(\010"
  "\022\024\n\014sign_latency\030\002 \001(\003\022.\n\tolap_info\030\003 \001("
  "\0132\033.baikaldb.pb.OlapRegionInfo\022A\n\023offlin"
  "e_binlog_info\030\004 \001(\0132$.baikaldb.pb.Region"
  "OfflineBinlogInfo\022\032\n\022watt_stats_version\030"
  "\005 \001(\004\0222\n\013column_info\030\006 \001(\0132\035.baikaldb.pb"
  ".ColumnRegionInfo\"\276\002\n\010ExtraRes\022(\n\005infos\030"
  "\001 \003(\0132\031.baikaldb.pb.RegionIndexs\022A\n\023offl"
  "ine_binlog_info\030\002 \001(\0132$.baikaldb.pb.Regi"
  "onOfflineBinlogInfo\022\027\n\017vectorized_rows\030\003"
  " \001(\014\022\031\n\021vectorized_schema\030\004 \001(\014\022\021\n\twait_"
  "cost\030\005 \001(\003\022\026\n\016afs_full_names\030\006 \003(\014\022\031\n\021ge"
  "t_afs_path_succ\030\007 \001(\010\022\033\n\023query_keypoint_"
  "succ\030\010 \001(\010\022.\n\014userid_count\030\t \003(\0132\030.baika"
  "ldb.pb.UseridCount\"\243\010\n\010StoreReq\022$\n\007op_ty"
  "pe\030\001 \002(\0162\023.baikaldb.pb.OpType\022,\n\006tuples\030"
  "\002 \003(\0132\034.baikaldb.pb.TupleDescriptor\022\021\n\tr"
  "egion_id\030\003 \002(\003\022\026\n\016region_version\030\004 \002(\003\022\037"
  "\n\004plan\030\005 \001(\0132\021.baikaldb.pb.Plan\022/\n\ttxn_i"
  "nfos\030\006 \003(\0132\034.baikaldb.pb.TransactionInfo"
  "\022\016\n\006log_id\030\007 \001(\006\022\021\n\tstart_key\030\t \001(\014\022\017\n\007e"
  "nd_key\030\n \001(\014\022\022\n\nsplit_term\030\013 \001(\003\022\027\n\017spli"
  "t_end_index\030\014 \001(\003\022\030\n\020reduce_num_lines\030\r "
  "\001(\003\022\r\n\005force\030\016 \001(\010\022\030\n\020not_check_region\030\017"
  " \001(\010\0220\n\017new_region_info\030\020 \001(\0132\027.baikaldb"
  ".pb.RegionInfo\022\035\n\025select_without_leader\030"
  "\021 \001(\010\022\022\n\ndb_conn_id\030\022 \001(\006\022.\n\014ddlwork_inf"
  "o\030\023 \001(\0132\030.baikaldb.pb.DdlWorkInfo\022\031\n\021num"
  "_increase_rows\030\024 \001(\003\022!\n\006kv_ops\030\025 \003(\0132\021.b"
  "aikaldb.pb.KvOp\022\020\n\010is_trace\030\026 \001(\010\022.\n\014ana"
  "lyze_info\030\027 \001(\0132\030.baikaldb.pb.AnalyzeInf"
  "o\022\030\n\020rollback_txn_ids\030\030 \003(\004\022\026\n\016commit_tx"
  "n_ids\030\031 \003(\004\022,\n\013binlog_desc\030\032 \001(\0132\027.baika"
  "ldb.pb.BinlogDesc\022#\n\006binlog\030\033 \001(\0132\023.baik"
  "aldb.pb.Binlog\022\020\n\010sql_sign\030\034 \001(\004\0227\n\026mult"
  "i_new_region_infos\030\035 \003(\0132\027.baikaldb.pb.R"
  "egionInfo\022(\n\textra_req\030\036 \001(\0132\025.baikaldb."
  "pb.ExtraReq\022.\n\014execute_type\030\037 \001(\0162\030.baik"
  "aldb.pb.ExecuteType\022\026\n\016is_rollup_base\030  "
  "\001(\010\022\030\n\020sql_exec_timeout\030! \001(\003\0221\n\tredis_r"
  "eq\030\" \001(\0132\036.baikaldb.pb.RedisWriteRequest"
  "\" \n\010RowValue\022\024\n\014tuple_values\030\001 \003(\014\"1\n\014Re"
  "gionLeader\022\021\n\tregion_id\030\001 \002(\003\022\016\n\006leader\030"
  "\002 \002(\t\"b\n\014IndexRecords\022\020\n\010index_id\030\001 \002(\003\022"
  "\017\n\007records\030\002 \003(\014\022\023\n\013old_records\030\003 \003(\014\022\032\n"
  "\022local_index_binlog\030\004 \001(\010\"\214\001\n\016RegionRaft"
  "Stat\022\025\n\rapplied_index\030\001 \001(\003\022\032\n\022snapshot_"
  "data_size\030\002 \001(\004\022\032\n\022snapshot_meta_size\030\003 "
  "\001(\004\022\026\n\016snapshot_index\030\004 \001(\003\022\023\n\013dml_laten"
  "cy\030\005 \001(\003\"!\n\021RocksStatisticReq\022\014\n\004keys\030\001 "
  "\003(\014\"\214\001\n\021RocksStatisticRes\022%\n\007errcode\030\001 \002"
  "(\0162\024.baikaldb.pb.ErrCode\022\026\n\016level0_sst_n"
  "um\030\002 \001(\004\022\034\n\024compaction_data_size\030\003 \001(\004\022\013"
  "\n\003key\030\004 \003(\014\022\r\n\005value\030\005 \003(\014\"\264\001\n\017BinlogQue"
  "ryInfo\022\021\n\tregion_id\030\001 \001(\003\022\021\n\toldest_ts\030\002"
  " \001(\003\022\026\n\016check_point_ts\030\003 \001(\003\022\030\n\020region_o"
  "ldest_ts\030\004 \001(\003\022\033\n\023binlog_cf_oldest_ts\030\005 "
  "\001(\003\022\031\n\021data_cf_oldest_ts\030\006 \001(\003\022\021\n\tregion"
  "_ip\030\007 \001(\t\"\272\007\n\010StoreRes\022%\n\007errcode\030\001 \002(\0162"
  "\024.baikaldb.pb.ErrCode\022\016\n\006errmsg\030\002 \001(\014\022\016\n"
  "\006leader\030\003 \001(\t\022\021\n\ttuple_ids\030\004 \003(\005\022)\n\nrow_"
  "values\030\005 \003(\0132\025.baikaldb.pb.RowValue\022\025\n\ra"
  "ffected_rows\030\006 \001(\003\022(\n\007regions\030\007 \003(\0132\027.ba"
  "ikaldb.pb.RegionInfo\022\025\n\rapplied_index\030\010 "
  "\001(\003\022\023\n\013last_seq_id\030\t \001(\005\022/\n\ttxn_infos\030\n "
  "\003(\0132\034.baikaldb.pb.TransactionInfo\022\025\n\rmys"
  "ql_errcode\030\013 \001(\005\022\024\n\014region_count\030\014 \001(\003\0221"
  "\n\016region_leaders\030\r \003(\0132\031.baikaldb.pb.Reg"
  "ionLeader\022\020\n\010is_merge\030\016 \001(\010\022*\n\007records\030\017"
  " \003(\0132\031.baikaldb.pb.IndexRecords\022\021\n\tscan_"
  "rows\030\020 \001(\003\022\'\n\010cmsketch\030\021 \001(\0132\025.baikaldb."
  "pb.CMsketch\022\023\n\013filter_rows\030\022 \001(\003\022\017\n\007binl"
  "ogs\030\023 \003(\014\022\021\n\tcommit_ts\030\024 \003(\003\022.\n\rregion_s"
  "tatus\030\025 \001(\0162\027.baikaldb.pb.PeerStatus\022\026\n\016"
  "last_insert_id\030\026 \001(\003\0225\n\020region_raft_stat"
  "\030\027 \001(\0132\033.baikaldb.pb.RegionRaftStat\022\025\n\rt"
  "tl_timestamp\030\030 \003(\003\022(\n\textra_res\030\031 \001(\0132\025."
  "baikaldb.pb.ExtraRes\0221\n\013binlog_info\030\032 \001("
  "\0132\034.baikaldb.pb.BinlogQueryInfo\022.\n\014execu"
  "te_type\030\033 \001(\0162\030.baikaldb.pb.ExecuteType\022"
  "\026\n\016read_disk_size\030\034 \001(\003\022\026\n\016orig_region_i"
  "d\030\035 \001(\003\022%\n\003hll\030\036 \001(\0132\030.baikaldb.pb.Hyper"
  "LogLog\"\210\001\n\023BatchRegionStoreReq\022(\n\tstore_"
  "req\030\001 \003(\0132\025.baikaldb.pb.StoreReq\022&\n\036limi"
  "t_single_store_concurrency\030\002 \002(\003\022\037\n\004plan"
  "\030\003 \003(\0132\021.baikaldb.pb.Plan\"\?\n\023BatchRegion"
  "StoreRes\022(\n\tstore_res\030\001 \003(\0132\025.baikaldb.p"
  "b.StoreRes\"\246\001\n\nInitRegion\022,\n\013region_info"
  "\030\001 \002(\0132\027.baikaldb.pb.RegionInfo\022,\n\013schem"
  "a_info\030\002 \001(\0132\027.baikaldb.pb.SchemaInfo\022\020\n"
  "\010is_split\030\003 \001(\010\022\026\n\016snapshot_times\030\004 \001(\005\022"
  "\022\n\nis_learner\030\005 \001(\010\"V\n\017GetAppliedIndex\022\021"
  "\n\tregion_id\030\001 \002(\003\022\024\n\014use_read_idx\030\002 \001(\010\022"
  "\032\n\022use_raft_log_index\030\003 \001(\010\"I\n\014RemoveReg"
  "ion\022\021\n\tregion_id\030\001 \002(\003\022\r\n\005force\030\002 \001(\010\022\027\n"
  "\017need_delay_drop\030\003 \001(\010\"\363\001\n\tRegionIds\022\022\n\n"
  "region_ids\030\001 \003(\003\022\030\n\020compact_raft_log\030\002 \001"
  "(\010\022\020\n\010table_id\030\003 \001(\003\022\024\n\014compact_type\030\004 \001"
  "(\005\022\026\n\016clear_all_txns\030\005 \001(\010\022\023\n\013txn_timeou"
  "t\030\006 \001(\003\022\031\n\021query_apply_index\030\007 \001(\010\022\017\n\007us"
  "erids\030\010 \003(\003\022\032\n\022query_all_afs_file\030\t \001(\010\022"
  "\033\n\023query_olap_keypoint\030\n \001(\010\"\013\n\tBackUpRe"
  "q\"\013\n\tBackUpRes\"\312\001\n\rBackupRequest\022\021\n\tregi"
  "on_id\030\001 \002(\003\022\021\n\tlog_index\030\002 \001(\003\022(\n\tbackup"
  "_op\030\003 \001(\0162\025.baikaldb.pb.BackupOp\022\037\n\027inge"
  "st_store_latest_sst\030\004 \001(\010\022 \n\030data_sst_to"
  "_process_size\030\005 \001(\003\022\020\n\010row_size\030\006 \001(\003\022\024\n"
  "\014streaming_id\030\007 \001(\004\"\316\001\n\016BackupResponse\022\021"
  "\n\tlog_index\030\001 \001(\003\022%\n\007errcode\030\002 \001(\0162\024.bai"
  "kaldb.pb.ErrCode\022\016\n\006leader\030\003 \001(\t\022\r\n\005peer"
  "s\030\004 \003(\t\022\032\n\022unstable_followers\030\005 \003(\t\022\024\n\014s"
  "treaming_id\030\006 \001(\004\0221\n\017streaming_state\030\007 \001"
  "(\0162\030.baikaldb.pb.StreamState\"\r\n\013HealthCh"
  "eck\"j\n\023OlapRegionIndexInfo\022\020\n\010index_id\030\001"
  " \002(\003\022\025\n\rexternal_path\030\002 \003(\t\022*\n\005state\030\003 \001"
  "(\0162\033.baikaldb.pb.OlapRegionStat\"\370\001\n\016Olap"
  "RegionInfo\0227\n\005state\030\001 \002(\0162\033.baikaldb.pb."
  "OlapRegionStat:\013OLAP_ACTIVE\022\022\n\nstate_tim"
  "e\030\002 \001(\004\022\032\n\022external_full_path\030\003 \003(\t\022>\n\024o"
  "lap_index_info_list\030\004 \003(\0132 .baikaldb.pb."
  "OlapRegionIndexInfo\022=\n\023new_olap_index_in"
  "fo\030\005 \001(\0132 .baikaldb.pb.OlapRegionIndexIn"
  "fo\"\207\001\n\027RegionOfflineBinlogInfo\022\021\n\toldest"
  "_ts\030\001 \002(\003\022\021\n\tnewest_ts\030\002 \002(\003\022\025\n\rtask_sta"
  "rt_ts\030\003 \001(\003\022\023\n\013task_end_ts\030\004 \001(\003\022\032\n\022exte"
  "rnal_full_path\030\005 \003(\t\"\270\001\n\025CompactionFileR"
  "equest\022.\n\007op_type\030\001 \002(\0162\035.baikaldb.pb.Co"
  "mpactionOpType\022\034\n\024remote_compaction_id\030\002"
  " \002(\t\022\021\n\tfile_name\030\003 \001(\t\022\016\n\006offset\030\004 \001(\004\022"
  "\r\n\005count\030\005 \001(\r\022\014\n\004data\030\006 \001(\014\022\021\n\trecursiv"
  "e\030\007 \001(\010\"\201\001\n\026CompactionFileResponse\022%\n\007er"
  "rcode\030\001 \002(\0162\024.baikaldb.pb.ErrCode\022\014\n\004dat"
  "a\030\002 \001(\014\0222\n\tfile_info\030\003 \003(\0132\037.baikaldb.pb"
  ".CompactionFileInfo*^\n\010RedisCmd\022\r\n\tREDIS"
  "_SET\020\000\022\r\n\tREDIS_DEL\020\001\022\020\n\014REDIS_EXPIRE\020\002\022"
  "\022\n\016REDIS_EXPIREAT\020\003\022\016\n\nREDIS_MSET\020\004*e\n\010T"
  "xnState\022\017\n\013TXN_UNKEOWN\020\000\022\017\n\013TXN_BEGINED\020"
  "\001\022\020\n\014TXN_PREPARED\020\002\022\021\n\rTXN_COMMITTED\020\003\022\022"
  "\n\016TXN_ROLLBACKED\020\004*T\n\rStatisticType\022\020\n\014S"
  "T_HISTOGRAM\020\000\022\017\n\013ST_CMSKETCH\020\001\022\022\n\016ST_HYP"
  "ERLOGLOG\020\002\022\014\n\010ST_CLEAR\020\003*`\n\013ExecuteType\022"
  "\014\n\010EXEC_ROW\020\000\022\024\n\020EXEC_ARROW_ACERO\020\001\022-\n)E"
  "XEC_ARROW_ACERO_PREFER_RETURN_ARROW_DATA"
  "\020\002*f\n\010BackupOp\022\023\n\017BACKUP_DOWNLOAD\020\000\022\021\n\rB"
  "ACKUP_UPLOAD\020\001\022\026\n\022BACKUP_QUERY_PEERS\020\002\022\032"
  "\n\026BACKUP_QUERY_STREAMING\020\003*[\n\016OlapRegion"
  "Stat\022\017\n\013OLAP_ACTIVE\020\000\022\022\n\016OLAP_IMMUTABLE\020"
  "\001\022\020\n\014OLAP_FLUSHED\020\002\022\022\n\016OLAP_TRUNCATED\020\003*"
  "\224\001\n\020CompactionOpType\022\013\n\007OP_READ\020\001\022\014\n\010OP_"
  "WRITE\020\002\022\022\n\016OP_DELETE_PATH\020\003\022\017\n\013OP_READ_D"
  "IR\020\004\022\022\n\016OP_PATH_EXISTS\020\005\022\021\n\rOP_CREATE_DI"
  "R\020\006\022\031\n\025OP_GET_FILE_INFO_LIST\020\0072\333\013\n\014Store"
  "Service\022=\n\013init_region\022\027.baikaldb.pb.Ini"
  "tRegion\032\025.baikaldb.pb.StoreRes\022X\n\023region"
  "_raft_control\022\037.baikaldb.pb.RaftControlR"
  "equest\032 .baikaldb.pb.RaftControlResponse"
  "\022\?\n\014health_check\022\030.baikaldb.pb.HealthChe"
  "ck\032\025.baikaldb.pb.StoreRes\022O\n\025async_apply"
  "_log_entry\022\032.baikaldb.pb.BatchStoreReq\032\032"
  ".baikaldb.pb.BatchStoreRes\0225\n\005query\022\025.ba"
  "ikaldb.pb.StoreReq\032\025.baikaldb.pb.StoreRe"
  "s\022Q\n\013query_batch\022 .baikaldb.pb.BatchRegi"
  "onStoreReq\032 .baikaldb.pb.BatchRegionStor"
  "eRes\022<\n\014query_binlog\022\025.baikaldb.pb.Store"
  "Req\032\025.baikaldb.pb.StoreRes\022A\n\rremove_reg"
  "ion\022\031.baikaldb.pb.RemoveRegion\032\025.baikald"
  "b.pb.StoreRes\0227\n\010add_peer\022\024.baikaldb.pb."
  "AddPeer\032\025.baikaldb.pb.StoreRes\022H\n\021get_ap"
  "plied_index\022\034.baikaldb.pb.GetAppliedInde"
  "x\032\025.baikaldb.pb.StoreRes\022\?\n\016compact_regi"
  "on\022\026.baikaldb.pb.RegionIds\032\025.baikaldb.pb"
  ".StoreRes\022@\n\017snapshot_region\022\026.baikaldb."
  "pb.RegionIds\032\025.baikaldb.pb.StoreRes\022\?\n\016r"
  "estore_region\022\026.baikaldb.pb.RegionIds\032\025."
  "baikaldb.pb.StoreRes\022D\n\023manual_split_reg"
  "ion\022\026.baikaldb.pb.RegionIds\032\025.baikaldb.p"
  "b.StoreRes\022=\n\014query_region\022\026.baikaldb.pb"
  ".RegionIds\032\025.baikaldb.pb.StoreRes\022E\n\024que"
  "ry_illegal_region\022\026.baikaldb.pb.RegionId"
  "s\032\025.baikaldb.pb.StoreRes\022\?\n\rbackup_regio"
  "n\022\026.baikaldb.pb.BackUpReq\032\026.baikaldb.pb."
  "BackUpRes\022A\n\006backup\022\032.baikaldb.pb.Backup"
  "Request\032\033.baikaldb.pb.BackupResponse\022U\n\023"
  "get_rocks_statistic\022\036.baikaldb.pb.RocksS"
  "tatisticReq\032\036.baikaldb.pb.RocksStatistic"
  "Res\022I\n\030manual_link_external_sst\022\026.baikal"
  "db.pb.RegionIds\032\025.baikaldb.pb.StoreRes\022\\"
  "\n\021query_file_system\022\".baikaldb.pb.Compac"
  "tionFileRequest\032#.baikaldb.pb.Compaction"
  "FileResponseB\003\200\001\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_store_2einterface_2eproto_deps[8] = {
  &::descriptor_table_binlog_2eproto,
  &::descriptor_table_column_2eproto,
  &::descriptor_table_common_2eproto,
  &::descriptor_table_meta_2einterface_2eproto,
  &::descriptor_table_optype_2eproto,
  &::descriptor_table_plan_2eproto,
  &::descriptor_table_raft_2eproto,
  &::descriptor_table_statistics_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_store_2einterface_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_store_2einterface_2eproto = {
  false, false, 9817, descriptor_table_protodef_store_2einterface_2eproto, "store.interface.proto", 
  &descriptor_table_store_2einterface_2eproto_once, descriptor_table_store_2einterface_2eproto_deps, 8, 39,
  schemas, file_default_instances, TableStruct_store_2einterface_2eproto::offsets,
  file_level_metadata_store_2einterface_2eproto, file_level_enum_descriptors_store_2einterface_2eproto, file_level_service_descriptors_store_2einterface_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_store_2einterface_2eproto_getter() {
  return &descriptor_table_store_2einterface_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_store_2einterface_2eproto(&descriptor_table_store_2einterface_2eproto);
namespace baikaldb {
namespace pb {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RedisCmd_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_store_2einterface_2eproto);
  return file_level_enum_descriptors_store_2einterface_2eproto[0];
}
bool RedisCmd_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TxnState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_store_2einterface_2eproto);
  return file_level_enum_descriptors_store_2einterface_2eproto[1];
}
bool TxnState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatisticType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_store_2einterface_2eproto);
  return file_level_enum_descriptors_store_2einterface_2eproto[2];
}
bool StatisticType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExecuteType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_store_2einterface_2eproto);
  return file_level_enum_descriptors_store_2einterface_2eproto[3];
}
bool ExecuteType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BackupOp_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_store_2einterface_2eproto);
  return file_level_enum_descriptors_store_2einterface_2eproto[4];
}
bool BackupOp_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OlapRegionStat_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_store_2einterface_2eproto);
  return file_level_enum_descriptors_store_2einterface_2eproto[5];
}
bool OlapRegionStat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompactionOpType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_store_2einterface_2eproto);
  return file_level_enum_descriptors_store_2einterface_2eproto[6];
}
bool CompactionOpType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class KvOp::_Internal {
 public:
  using HasBits = decltype(std::declval<KvOp>()._has_bits_);
  static void set_has_op_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ttl_timestamp_us(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_primary_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

KvOp::KvOp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.KvOp)
}
KvOp::KvOp(const KvOp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_value()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArenaForAllocation());
  }
  ::memcpy(&op_type_, &from.op_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&ttl_timestamp_us_) -
    reinterpret_cast<char*>(&op_type_)) + sizeof(ttl_timestamp_us_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.KvOp)
}

void KvOp::SharedCtor() {
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&op_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ttl_timestamp_us_) -
    reinterpret_cast<char*>(&op_type_)) + sizeof(ttl_timestamp_us_));
}

KvOp::~KvOp() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.KvOp)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void KvOp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void KvOp::ArenaDtor(void* object) {
  KvOp* _this = reinterpret_cast< KvOp* >(object);
  (void)_this;
}
void KvOp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KvOp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvOp::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.KvOp)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&op_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ttl_timestamp_us_) -
        reinterpret_cast<char*>(&op_type_)) + sizeof(ttl_timestamp_us_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvOp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.OpType op_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::OpType_IsValid(val))) {
            _internal_set_op_type(static_cast<::baikaldb::pb::OpType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 ttl_timestamp_us = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_ttl_timestamp_us(&has_bits);
          ttl_timestamp_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_primary_key = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_is_primary_key(&has_bits);
          is_primary_key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* KvOp::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.KvOp)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.OpType op_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_op_type(), target);
  }

  // optional bytes key = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_key(), target);
  }

  // optional bytes value = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_value(), target);
  }

  // optional int64 ttl_timestamp_us = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_ttl_timestamp_us(), target);
  }

  // optional bool is_primary_key = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_is_primary_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.KvOp)
  return target;
}

size_t KvOp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.KvOp)
  size_t total_size = 0;

  // required .baikaldb.pb.OpType op_type = 1;
  if (_internal_has_op_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_op_type());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes key = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_key());
    }

    // optional bytes value = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

  }
  if (cached_has_bits & 0x00000018u) {
    // optional bool is_primary_key = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional int64 ttl_timestamp_us = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_ttl_timestamp_us());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvOp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    KvOp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvOp::GetClassData() const { return &_class_data_; }

void KvOp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<KvOp *>(to)->MergeFrom(
      static_cast<const KvOp &>(from));
}


void KvOp::MergeFrom(const KvOp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.KvOp)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000004u) {
      op_type_ = from.op_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_primary_key_ = from.is_primary_key_;
    }
    if (cached_has_bits & 0x00000010u) {
      ttl_timestamp_us_ = from.ttl_timestamp_us_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvOp::CopyFrom(const KvOp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.KvOp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvOp::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void KvOp::InternalSwap(KvOp* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KvOp, ttl_timestamp_us_)
      + sizeof(KvOp::ttl_timestamp_us_)
      - PROTOBUF_FIELD_OFFSET(KvOp, op_type_)>(
          reinterpret_cast<char*>(&op_type_),
          reinterpret_cast<char*>(&other->op_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KvOp::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[0]);
}

// ===================================================================

class RedisKv::_Internal {
 public:
  using HasBits = decltype(std::declval<RedisKv>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_expire_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

RedisKv::RedisKv(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.RedisKv)
}
RedisKv::RedisKv(const RedisKv& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_value()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArenaForAllocation());
  }
  expire_ms_ = from.expire_ms_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.RedisKv)
}

void RedisKv::SharedCtor() {
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
expire_ms_ = int64_t{0};
}

RedisKv::~RedisKv() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.RedisKv)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RedisKv::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void RedisKv::ArenaDtor(void* object) {
  RedisKv* _this = reinterpret_cast< RedisKv* >(object);
  (void)_this;
}
void RedisKv::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RedisKv::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RedisKv::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.RedisKv)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmpty();
    }
  }
  expire_ms_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RedisKv::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 expire_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_expire_ms(&has_bits);
          expire_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RedisKv::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.RedisKv)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  // optional bytes value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_value(), target);
  }

  // optional int64 expire_ms = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_expire_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.RedisKv)
  return target;
}

size_t RedisKv::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.RedisKv)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes key = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_key());
    }

    // optional bytes value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_value());
    }

    // optional int64 expire_ms = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_expire_ms());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RedisKv::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RedisKv::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RedisKv::GetClassData() const { return &_class_data_; }

void RedisKv::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RedisKv *>(to)->MergeFrom(
      static_cast<const RedisKv &>(from));
}


void RedisKv::MergeFrom(const RedisKv& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.RedisKv)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000004u) {
      expire_ms_ = from.expire_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RedisKv::CopyFrom(const RedisKv& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.RedisKv)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RedisKv::IsInitialized() const {
  return true;
}

void RedisKv::InternalSwap(RedisKv* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
  swap(expire_ms_, other->expire_ms_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RedisKv::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[1]);
}

// ===================================================================

class RedisWriteRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<RedisWriteRequest>()._has_bits_);
  static void set_has_cmd(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

RedisWriteRequest::RedisWriteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  kvs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.RedisWriteRequest)
}
RedisWriteRequest::RedisWriteRequest(const RedisWriteRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      kvs_(from.kvs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&cmd_, &from.cmd_,
    static_cast<size_t>(reinterpret_cast<char*>(&slot_) -
    reinterpret_cast<char*>(&cmd_)) + sizeof(slot_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.RedisWriteRequest)
}

void RedisWriteRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&cmd_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&slot_) -
    reinterpret_cast<char*>(&cmd_)) + sizeof(slot_));
}

RedisWriteRequest::~RedisWriteRequest() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.RedisWriteRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RedisWriteRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RedisWriteRequest::ArenaDtor(void* object) {
  RedisWriteRequest* _this = reinterpret_cast< RedisWriteRequest* >(object);
  (void)_this;
}
void RedisWriteRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RedisWriteRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RedisWriteRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.RedisWriteRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  kvs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&cmd_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&slot_) -
        reinterpret_cast<char*>(&cmd_)) + sizeof(slot_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RedisWriteRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .baikaldb.pb.RedisCmd cmd = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::RedisCmd_IsValid(val))) {
            _internal_set_cmd(static_cast<::baikaldb::pb::RedisCmd>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.RedisKv kvs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_kvs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 slot = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_slot(&has_bits);
          slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RedisWriteRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.RedisWriteRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .baikaldb.pb.RedisCmd cmd = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_cmd(), target);
  }

  // repeated .baikaldb.pb.RedisKv kvs = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_kvs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_kvs(i), target, stream);
  }

  // optional uint32 slot = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_slot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.RedisWriteRequest)
  return target;
}

size_t RedisWriteRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.RedisWriteRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.RedisKv kvs = 2;
  total_size += 1UL * this->_internal_kvs_size();
  for (const auto& msg : this->kvs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .baikaldb.pb.RedisCmd cmd = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_cmd());
    }

    // optional uint32 slot = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_slot());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RedisWriteRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RedisWriteRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RedisWriteRequest::GetClassData() const { return &_class_data_; }

void RedisWriteRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RedisWriteRequest *>(to)->MergeFrom(
      static_cast<const RedisWriteRequest &>(from));
}


void RedisWriteRequest::MergeFrom(const RedisWriteRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.RedisWriteRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  kvs_.MergeFrom(from.kvs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      cmd_ = from.cmd_;
    }
    if (cached_has_bits & 0x00000002u) {
      slot_ = from.slot_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RedisWriteRequest::CopyFrom(const RedisWriteRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.RedisWriteRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RedisWriteRequest::IsInitialized() const {
  return true;
}

void RedisWriteRequest::InternalSwap(RedisWriteRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  kvs_.InternalSwap(&other->kvs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RedisWriteRequest, slot_)
      + sizeof(RedisWriteRequest::slot_)
      - PROTOBUF_FIELD_OFFSET(RedisWriteRequest, cmd_)>(
          reinterpret_cast<char*>(&cmd_),
          reinterpret_cast<char*>(&other->cmd_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RedisWriteRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[2]);
}

// ===================================================================

class CachePlan::_Internal {
 public:
  using HasBits = decltype(std::declval<CachePlan>()._has_bits_);
  static void set_has_op_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_seq_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::baikaldb::pb::Plan& plan(const CachePlan* msg);
  static void set_has_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::baikaldb::pb::Plan&
CachePlan::_Internal::plan(const CachePlan* msg) {
  return *msg->plan_;
}
void CachePlan::clear_plan() {
  if (plan_ != nullptr) plan_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void CachePlan::clear_tuples() {
  tuples_.Clear();
}
void CachePlan::clear_regions() {
  regions_.Clear();
}
CachePlan::CachePlan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  tuples_(arena),
  regions_(arena),
  kv_ops_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.CachePlan)
}
CachePlan::CachePlan(const CachePlan& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      tuples_(from.tuples_),
      regions_(from.regions_),
      kv_ops_(from.kv_ops_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_plan()) {
    plan_ = new ::baikaldb::pb::Plan(*from.plan_);
  } else {
    plan_ = nullptr;
  }
  ::memcpy(&op_type_, &from.op_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&seq_id_) -
    reinterpret_cast<char*>(&op_type_)) + sizeof(seq_id_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.CachePlan)
}

void CachePlan::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&plan_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&seq_id_) -
    reinterpret_cast<char*>(&plan_)) + sizeof(seq_id_));
}

CachePlan::~CachePlan() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.CachePlan)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CachePlan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete plan_;
}

void CachePlan::ArenaDtor(void* object) {
  CachePlan* _this = reinterpret_cast< CachePlan* >(object);
  (void)_this;
}
void CachePlan::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CachePlan::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CachePlan::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.CachePlan)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tuples_.Clear();
  regions_.Clear();
  kv_ops_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(plan_ != nullptr);
    plan_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&op_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&seq_id_) -
        reinterpret_cast<char*>(&op_type_)) + sizeof(seq_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CachePlan::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.OpType op_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::OpType_IsValid(val))) {
            _internal_set_op_type(static_cast<::baikaldb::pb::OpType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required int32 seq_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_seq_id(&has_bits);
          seq_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .baikaldb.pb.Plan plan = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.TupleDescriptor tuples = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tuples(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.RegionInfo regions = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_regions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.KvOp kv_ops = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_kv_ops(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CachePlan::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.CachePlan)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.OpType op_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_op_type(), target);
  }

  // required int32 seq_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_seq_id(), target);
  }

  // required .baikaldb.pb.Plan plan = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::plan(this), target, stream);
  }

  // repeated .baikaldb.pb.TupleDescriptor tuples = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_tuples_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_tuples(i), target, stream);
  }

  // repeated .baikaldb.pb.RegionInfo regions = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_regions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_regions(i), target, stream);
  }

  // repeated .baikaldb.pb.KvOp kv_ops = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_kv_ops_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_kv_ops(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.CachePlan)
  return target;
}

size_t CachePlan::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.CachePlan)
  size_t total_size = 0;

  if (_internal_has_plan()) {
    // required .baikaldb.pb.Plan plan = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *plan_);
  }

  if (_internal_has_op_type()) {
    // required .baikaldb.pb.OpType op_type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_op_type());
  }

  if (_internal_has_seq_id()) {
    // required int32 seq_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_seq_id());
  }

  return total_size;
}
size_t CachePlan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.CachePlan)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .baikaldb.pb.Plan plan = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *plan_);

    // required .baikaldb.pb.OpType op_type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_op_type());

    // required int32 seq_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_seq_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.TupleDescriptor tuples = 4;
  total_size += 1UL * this->_internal_tuples_size();
  for (const auto& msg : this->tuples_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.RegionInfo regions = 5;
  total_size += 1UL * this->_internal_regions_size();
  for (const auto& msg : this->regions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.KvOp kv_ops = 6;
  total_size += 1UL * this->_internal_kv_ops_size();
  for (const auto& msg : this->kv_ops_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CachePlan::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CachePlan::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CachePlan::GetClassData() const { return &_class_data_; }

void CachePlan::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CachePlan *>(to)->MergeFrom(
      static_cast<const CachePlan &>(from));
}


void CachePlan::MergeFrom(const CachePlan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.CachePlan)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  tuples_.MergeFrom(from.tuples_);
  regions_.MergeFrom(from.regions_);
  kv_ops_.MergeFrom(from.kv_ops_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_plan()->::baikaldb::pb::Plan::MergeFrom(from._internal_plan());
    }
    if (cached_has_bits & 0x00000002u) {
      op_type_ = from.op_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      seq_id_ = from.seq_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CachePlan::CopyFrom(const CachePlan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.CachePlan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CachePlan::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(tuples_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(regions_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(kv_ops_)) return false;
  if (_internal_has_plan()) {
    if (!plan_->IsInitialized()) return false;
  }
  return true;
}

void CachePlan::InternalSwap(CachePlan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  tuples_.InternalSwap(&other->tuples_);
  regions_.InternalSwap(&other->regions_);
  kv_ops_.InternalSwap(&other->kv_ops_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CachePlan, seq_id_)
      + sizeof(CachePlan::seq_id_)
      - PROTOBUF_FIELD_OFFSET(CachePlan, plan_)>(
          reinterpret_cast<char*>(&plan_),
          reinterpret_cast<char*>(&other->plan_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CachePlan::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[3]);
}

// ===================================================================

class TransactionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TransactionInfo>()._has_bits_);
  static void set_has_txn_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seq_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start_seq_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_optimize_1pc(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_num_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_autocommit(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_primary_region_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_txn_state(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_live_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_start_ts(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_commit_ts(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_open_binlog(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_from_store(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_txn_timeout(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_need_update_primary_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TransactionInfo::TransactionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  need_rollback_seq_(arena),
  cache_plans_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.TransactionInfo)
}
TransactionInfo::TransactionInfo(const TransactionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      need_rollback_seq_(from.need_rollback_seq_),
      cache_plans_(from.cache_plans_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&txn_id_, &from.txn_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&need_update_primary_timestamp_) -
    reinterpret_cast<char*>(&txn_id_)) + sizeof(need_update_primary_timestamp_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.TransactionInfo)
}

void TransactionInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&txn_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&need_update_primary_timestamp_) -
    reinterpret_cast<char*>(&txn_id_)) + sizeof(need_update_primary_timestamp_));
}

TransactionInfo::~TransactionInfo() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.TransactionInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TransactionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TransactionInfo::ArenaDtor(void* object) {
  TransactionInfo* _this = reinterpret_cast< TransactionInfo* >(object);
  (void)_this;
}
void TransactionInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TransactionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TransactionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.TransactionInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  need_rollback_seq_.Clear();
  cache_plans_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&txn_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&autocommit_) -
        reinterpret_cast<char*>(&txn_id_)) + sizeof(autocommit_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&open_binlog_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&need_update_primary_timestamp_) -
        reinterpret_cast<char*>(&open_binlog_)) + sizeof(need_update_primary_timestamp_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransactionInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 txn_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_txn_id(&has_bits);
          txn_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 seq_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_seq_id(&has_bits);
          seq_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 start_seq_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_start_seq_id(&has_bits);
          start_seq_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool optimize_1pc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_optimize_1pc(&has_bits);
          optimize_1pc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 need_rollback_seq = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_need_rollback_seq(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_need_rollback_seq(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.CachePlan cache_plans = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cache_plans(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 num_rows = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_num_rows(&has_bits);
          num_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool autocommit = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_autocommit(&has_bits);
          autocommit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 primary_region_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_primary_region_id(&has_bits);
          primary_region_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.TxnState txn_state = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::TxnState_IsValid(val))) {
            _internal_set_txn_state(static_cast<::baikaldb::pb::TxnState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 live_time = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_live_time(&has_bits);
          live_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 start_ts = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_start_ts(&has_bits);
          start_ts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 commit_ts = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_commit_ts(&has_bits);
          commit_ts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool open_binlog = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_open_binlog(&has_bits);
          open_binlog_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool from_store = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_from_store(&has_bits);
          from_store_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 txn_timeout = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_txn_timeout(&has_bits);
          txn_timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool need_update_primary_timestamp = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_need_update_primary_timestamp(&has_bits);
          need_update_primary_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TransactionInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.TransactionInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 txn_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_txn_id(), target);
  }

  // required int32 seq_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_seq_id(), target);
  }

  // optional int32 start_seq_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_start_seq_id(), target);
  }

  // optional bool optimize_1pc = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_optimize_1pc(), target);
  }

  // repeated int32 need_rollback_seq = 5;
  for (int i = 0, n = this->_internal_need_rollback_seq_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_need_rollback_seq(i), target);
  }

  // repeated .baikaldb.pb.CachePlan cache_plans = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cache_plans_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_cache_plans(i), target, stream);
  }

  // optional int64 num_rows = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(7, this->_internal_num_rows(), target);
  }

  // optional bool autocommit = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_autocommit(), target);
  }

  // optional int64 primary_region_id = 9;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(9, this->_internal_primary_region_id(), target);
  }

  // optional .baikaldb.pb.TxnState txn_state = 10;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      10, this->_internal_txn_state(), target);
  }

  // optional int64 live_time = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(11, this->_internal_live_time(), target);
  }

  // optional int64 start_ts = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(12, this->_internal_start_ts(), target);
  }

  // optional int64 commit_ts = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(13, this->_internal_commit_ts(), target);
  }

  // optional bool open_binlog = 14;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_open_binlog(), target);
  }

  // optional bool from_store = 15;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_from_store(), target);
  }

  // optional int64 txn_timeout = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(16, this->_internal_txn_timeout(), target);
  }

  // optional bool need_update_primary_timestamp = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_need_update_primary_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.TransactionInfo)
  return target;
}

size_t TransactionInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.TransactionInfo)
  size_t total_size = 0;

  if (_internal_has_txn_id()) {
    // required uint64 txn_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_txn_id());
  }

  if (_internal_has_seq_id()) {
    // required int32 seq_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_seq_id());
  }

  return total_size;
}
size_t TransactionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.TransactionInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 txn_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_txn_id());

    // required int32 seq_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_seq_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 need_rollback_seq = 5;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->need_rollback_seq_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_need_rollback_seq_size());
    total_size += data_size;
  }

  // repeated .baikaldb.pb.CachePlan cache_plans = 6;
  total_size += 1UL * this->_internal_cache_plans_size();
  for (const auto& msg : this->cache_plans_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000fcu) {
    // optional int32 start_seq_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_start_seq_id());
    }

    // optional int64 num_rows = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_num_rows());
    }

    // optional int64 primary_region_id = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_primary_region_id());
    }

    // optional .baikaldb.pb.TxnState txn_state = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_txn_state());
    }

    // optional bool optimize_1pc = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool autocommit = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional bool open_binlog = 14;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool from_store = 15;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional int64 live_time = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_live_time());
    }

    // optional int64 start_ts = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_start_ts());
    }

    // optional int64 commit_ts = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_commit_ts());
    }

    // optional int64 txn_timeout = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_txn_timeout());
    }

    // optional bool need_update_primary_timestamp = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransactionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TransactionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransactionInfo::GetClassData() const { return &_class_data_; }

void TransactionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TransactionInfo *>(to)->MergeFrom(
      static_cast<const TransactionInfo &>(from));
}


void TransactionInfo::MergeFrom(const TransactionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.TransactionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  need_rollback_seq_.MergeFrom(from.need_rollback_seq_);
  cache_plans_.MergeFrom(from.cache_plans_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      txn_id_ = from.txn_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      seq_id_ = from.seq_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      start_seq_id_ = from.start_seq_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      num_rows_ = from.num_rows_;
    }
    if (cached_has_bits & 0x00000010u) {
      primary_region_id_ = from.primary_region_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      txn_state_ = from.txn_state_;
    }
    if (cached_has_bits & 0x00000040u) {
      optimize_1pc_ = from.optimize_1pc_;
    }
    if (cached_has_bits & 0x00000080u) {
      autocommit_ = from.autocommit_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      open_binlog_ = from.open_binlog_;
    }
    if (cached_has_bits & 0x00000200u) {
      from_store_ = from.from_store_;
    }
    if (cached_has_bits & 0x00000400u) {
      live_time_ = from.live_time_;
    }
    if (cached_has_bits & 0x00000800u) {
      start_ts_ = from.start_ts_;
    }
    if (cached_has_bits & 0x00001000u) {
      commit_ts_ = from.commit_ts_;
    }
    if (cached_has_bits & 0x00002000u) {
      txn_timeout_ = from.txn_timeout_;
    }
    if (cached_has_bits & 0x00004000u) {
      need_update_primary_timestamp_ = from.need_update_primary_timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransactionInfo::CopyFrom(const TransactionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.TransactionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(cache_plans_)) return false;
  return true;
}

void TransactionInfo::InternalSwap(TransactionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  need_rollback_seq_.InternalSwap(&other->need_rollback_seq_);
  cache_plans_.InternalSwap(&other->cache_plans_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TransactionInfo, need_update_primary_timestamp_)
      + sizeof(TransactionInfo::need_update_primary_timestamp_)
      - PROTOBUF_FIELD_OFFSET(TransactionInfo, txn_id_)>(
          reinterpret_cast<char*>(&txn_id_),
          reinterpret_cast<char*>(&other->txn_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TransactionInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[4]);
}

// ===================================================================

class AnalyzeInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<AnalyzeInfo>()._has_bits_);
  static void set_has_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sample_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_table_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

AnalyzeInfo::AnalyzeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  statistics_types_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.AnalyzeInfo)
}
AnalyzeInfo::AnalyzeInfo(const AnalyzeInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      statistics_types_(from.statistics_types_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&depth_, &from.depth_,
    static_cast<size_t>(reinterpret_cast<char*>(&sample_rows_) -
    reinterpret_cast<char*>(&depth_)) + sizeof(sample_rows_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.AnalyzeInfo)
}

void AnalyzeInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&depth_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sample_rows_) -
    reinterpret_cast<char*>(&depth_)) + sizeof(sample_rows_));
}

AnalyzeInfo::~AnalyzeInfo() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.AnalyzeInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AnalyzeInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AnalyzeInfo::ArenaDtor(void* object) {
  AnalyzeInfo* _this = reinterpret_cast< AnalyzeInfo* >(object);
  (void)_this;
}
void AnalyzeInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AnalyzeInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AnalyzeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.AnalyzeInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  statistics_types_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&depth_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sample_rows_) -
        reinterpret_cast<char*>(&depth_)) + sizeof(sample_rows_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AnalyzeInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 depth = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_depth(&has_bits);
          depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sample_rows = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_sample_rows(&has_bits);
          sample_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 table_rows = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_table_rows(&has_bits);
          table_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.StatisticType statistics_types = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::StatisticType_IsValid(val))) {
              _internal_add_statistics_types(static_cast<::baikaldb::pb::StatisticType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_statistics_types(), ptr, ctx, ::baikaldb::pb::StatisticType_IsValid, &_internal_metadata_, 5);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AnalyzeInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.AnalyzeInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 depth = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_depth(), target);
  }

  // optional int32 width = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_width(), target);
  }

  // optional int32 sample_rows = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_sample_rows(), target);
  }

  // optional int64 table_rows = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_table_rows(), target);
  }

  // repeated .baikaldb.pb.StatisticType statistics_types = 5;
  for (int i = 0, n = this->_internal_statistics_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        5, this->_internal_statistics_types(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.AnalyzeInfo)
  return target;
}

size_t AnalyzeInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.AnalyzeInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.StatisticType statistics_types = 5;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_statistics_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_statistics_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 depth = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_depth());
    }

    // optional int32 width = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_width());
    }

    // optional int64 table_rows = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_table_rows());
    }

    // optional int32 sample_rows = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_sample_rows());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AnalyzeInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AnalyzeInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AnalyzeInfo::GetClassData() const { return &_class_data_; }

void AnalyzeInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AnalyzeInfo *>(to)->MergeFrom(
      static_cast<const AnalyzeInfo &>(from));
}


void AnalyzeInfo::MergeFrom(const AnalyzeInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.AnalyzeInfo)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  statistics_types_.MergeFrom(from.statistics_types_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      depth_ = from.depth_;
    }
    if (cached_has_bits & 0x00000002u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000004u) {
      table_rows_ = from.table_rows_;
    }
    if (cached_has_bits & 0x00000008u) {
      sample_rows_ = from.sample_rows_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AnalyzeInfo::CopyFrom(const AnalyzeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.AnalyzeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnalyzeInfo::IsInitialized() const {
  return true;
}

void AnalyzeInfo::InternalSwap(AnalyzeInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  statistics_types_.InternalSwap(&other->statistics_types_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AnalyzeInfo, sample_rows_)
      + sizeof(AnalyzeInfo::sample_rows_)
      - PROTOBUF_FIELD_OFFSET(AnalyzeInfo, depth_)>(
          reinterpret_cast<char*>(&depth_),
          reinterpret_cast<char*>(&other->depth_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AnalyzeInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[5]);
}

// ===================================================================

class BinlogDesc::_Internal {
 public:
  using HasBits = decltype(std::declval<BinlogDesc>()._has_bits_);
  static void set_has_binlog_ts(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txn_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_start_ts(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_primary_region_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_read_binlog_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_binlog_row_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_flash_back_read(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_read_offline_binlog(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

BinlogDesc::BinlogDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  db_tables_(arena),
  signs_(arena),
  txn_ids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.BinlogDesc)
}
BinlogDesc::BinlogDesc(const BinlogDesc& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      db_tables_(from.db_tables_),
      signs_(from.signs_),
      txn_ids_(from.txn_ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_user_name()) {
    user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_name(), 
      GetArenaForAllocation());
  }
  user_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_user_ip()) {
    user_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_ip(), 
      GetArenaForAllocation());
  }
  ::memcpy(&binlog_ts_, &from.binlog_ts_,
    static_cast<size_t>(reinterpret_cast<char*>(&read_offline_binlog_) -
    reinterpret_cast<char*>(&binlog_ts_)) + sizeof(read_offline_binlog_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.BinlogDesc)
}

void BinlogDesc::SharedCtor() {
user_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
user_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&binlog_ts_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&read_offline_binlog_) -
    reinterpret_cast<char*>(&binlog_ts_)) + sizeof(read_offline_binlog_));
}

BinlogDesc::~BinlogDesc() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.BinlogDesc)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BinlogDesc::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BinlogDesc::ArenaDtor(void* object) {
  BinlogDesc* _this = reinterpret_cast< BinlogDesc* >(object);
  (void)_this;
}
void BinlogDesc::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BinlogDesc::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BinlogDesc::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.BinlogDesc)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  db_tables_.Clear();
  signs_.Clear();
  txn_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      user_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      user_ip_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&binlog_ts_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&binlog_row_cnt_) -
        reinterpret_cast<char*>(&binlog_ts_)) + sizeof(binlog_row_cnt_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&flash_back_read_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&read_offline_binlog_) -
        reinterpret_cast<char*>(&flash_back_read_)) + sizeof(read_offline_binlog_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BinlogDesc::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 binlog_ts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_binlog_ts(&has_bits);
          binlog_ts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 txn_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_txn_id(&has_bits);
          txn_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 start_ts = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_start_ts(&has_bits);
          start_ts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 primary_region_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_primary_region_id(&has_bits);
          primary_region_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 read_binlog_cnt = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_read_binlog_cnt(&has_bits);
          read_binlog_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 binlog_row_cnt = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_binlog_row_cnt(&has_bits);
          binlog_row_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes user_name = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          auto str = _internal_mutable_user_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes user_ip = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          auto str = _internal_mutable_user_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes db_tables = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_db_tables();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 signs = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_signs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<88>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_signs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 txn_ids = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_txn_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<96>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_txn_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool flash_back_read = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_flash_back_read(&has_bits);
          flash_back_read_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool read_offline_binlog = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_read_offline_binlog(&has_bits);
          read_offline_binlog_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BinlogDesc::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.BinlogDesc)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 binlog_ts = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_binlog_ts(), target);
  }

  // optional int64 txn_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_txn_id(), target);
  }

  // optional int64 start_ts = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_start_ts(), target);
  }

  // optional int64 primary_region_id = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_primary_region_id(), target);
  }

  // optional int64 read_binlog_cnt = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_read_binlog_cnt(), target);
  }

  // optional int64 binlog_row_cnt = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(7, this->_internal_binlog_row_cnt(), target);
  }

  // optional bytes user_name = 8;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_user_name(), target);
  }

  // optional bytes user_ip = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_user_ip(), target);
  }

  // repeated bytes db_tables = 10;
  for (int i = 0, n = this->_internal_db_tables_size(); i < n; i++) {
    const auto& s = this->_internal_db_tables(i);
    target = stream->WriteBytes(10, s, target);
  }

  // repeated uint64 signs = 11;
  for (int i = 0, n = this->_internal_signs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(11, this->_internal_signs(i), target);
  }

  // repeated int64 txn_ids = 12;
  for (int i = 0, n = this->_internal_txn_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(12, this->_internal_txn_ids(i), target);
  }

  // optional bool flash_back_read = 13;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_flash_back_read(), target);
  }

  // optional bool read_offline_binlog = 14;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_read_offline_binlog(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.BinlogDesc)
  return target;
}

size_t BinlogDesc::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.BinlogDesc)
  size_t total_size = 0;

  // required int64 binlog_ts = 1;
  if (_internal_has_binlog_ts()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_binlog_ts());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes db_tables = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(db_tables_.size());
  for (int i = 0, n = db_tables_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      db_tables_.Get(i));
  }

  // repeated uint64 signs = 11;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->signs_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_signs_size());
    total_size += data_size;
  }

  // repeated int64 txn_ids = 12;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->txn_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_txn_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes user_name = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_user_name());
    }

    // optional bytes user_ip = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_user_ip());
    }

  }
  if (cached_has_bits & 0x000000f8u) {
    // optional int64 txn_id = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_txn_id());
    }

    // optional int64 start_ts = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_start_ts());
    }

    // optional int64 primary_region_id = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_primary_region_id());
    }

    // optional int64 read_binlog_cnt = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_read_binlog_cnt());
    }

    // optional int64 binlog_row_cnt = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_binlog_row_cnt());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool flash_back_read = 13;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool read_offline_binlog = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BinlogDesc::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BinlogDesc::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BinlogDesc::GetClassData() const { return &_class_data_; }

void BinlogDesc::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BinlogDesc *>(to)->MergeFrom(
      static_cast<const BinlogDesc &>(from));
}


void BinlogDesc::MergeFrom(const BinlogDesc& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.BinlogDesc)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  db_tables_.MergeFrom(from.db_tables_);
  signs_.MergeFrom(from.signs_);
  txn_ids_.MergeFrom(from.txn_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_user_name(from._internal_user_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_user_ip(from._internal_user_ip());
    }
    if (cached_has_bits & 0x00000004u) {
      binlog_ts_ = from.binlog_ts_;
    }
    if (cached_has_bits & 0x00000008u) {
      txn_id_ = from.txn_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      start_ts_ = from.start_ts_;
    }
    if (cached_has_bits & 0x00000020u) {
      primary_region_id_ = from.primary_region_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      read_binlog_cnt_ = from.read_binlog_cnt_;
    }
    if (cached_has_bits & 0x00000080u) {
      binlog_row_cnt_ = from.binlog_row_cnt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      flash_back_read_ = from.flash_back_read_;
    }
    if (cached_has_bits & 0x00000200u) {
      read_offline_binlog_ = from.read_offline_binlog_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BinlogDesc::CopyFrom(const BinlogDesc& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.BinlogDesc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BinlogDesc::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void BinlogDesc::InternalSwap(BinlogDesc* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  db_tables_.InternalSwap(&other->db_tables_);
  signs_.InternalSwap(&other->signs_);
  txn_ids_.InternalSwap(&other->txn_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_name_, lhs_arena,
      &other->user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_ip_, lhs_arena,
      &other->user_ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BinlogDesc, read_offline_binlog_)
      + sizeof(BinlogDesc::read_offline_binlog_)
      - PROTOBUF_FIELD_OFFSET(BinlogDesc, binlog_ts_)>(
          reinterpret_cast<char*>(&binlog_ts_),
          reinterpret_cast<char*>(&other->binlog_ts_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BinlogDesc::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[6]);
}

// ===================================================================

class BatchStoreReq::_Internal {
 public:
  using HasBits = decltype(std::declval<BatchStoreReq>()._has_bits_);
  static void set_has_region_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_resend_start_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

BatchStoreReq::BatchStoreReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  request_lens_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.BatchStoreReq)
}
BatchStoreReq::BatchStoreReq(const BatchStoreReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      request_lens_(from.request_lens_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&region_id_, &from.region_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&resend_start_pos_) -
    reinterpret_cast<char*>(&region_id_)) + sizeof(resend_start_pos_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.BatchStoreReq)
}

void BatchStoreReq::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&region_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&resend_start_pos_) -
    reinterpret_cast<char*>(&region_id_)) + sizeof(resend_start_pos_));
}

BatchStoreReq::~BatchStoreReq() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.BatchStoreReq)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BatchStoreReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BatchStoreReq::ArenaDtor(void* object) {
  BatchStoreReq* _this = reinterpret_cast< BatchStoreReq* >(object);
  (void)_this;
}
void BatchStoreReq::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BatchStoreReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BatchStoreReq::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.BatchStoreReq)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  request_lens_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&region_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&resend_start_pos_) -
        reinterpret_cast<char*>(&region_id_)) + sizeof(resend_start_pos_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchStoreReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 region_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_region_id(&has_bits);
          region_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 request_lens = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_request_lens(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_request_lens(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 resend_start_pos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_resend_start_pos(&has_bits);
          resend_start_pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BatchStoreReq::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.BatchStoreReq)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 region_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_region_id(), target);
  }

  // repeated int64 request_lens = 2;
  for (int i = 0, n = this->_internal_request_lens_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_request_lens(i), target);
  }

  // optional int64 resend_start_pos = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_resend_start_pos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.BatchStoreReq)
  return target;
}

size_t BatchStoreReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.BatchStoreReq)
  size_t total_size = 0;

  // required int64 region_id = 1;
  if (_internal_has_region_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_region_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 request_lens = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->request_lens_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_request_lens_size());
    total_size += data_size;
  }

  // optional int64 resend_start_pos = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_resend_start_pos());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchStoreReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BatchStoreReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchStoreReq::GetClassData() const { return &_class_data_; }

void BatchStoreReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BatchStoreReq *>(to)->MergeFrom(
      static_cast<const BatchStoreReq &>(from));
}


void BatchStoreReq::MergeFrom(const BatchStoreReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.BatchStoreReq)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  request_lens_.MergeFrom(from.request_lens_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      region_id_ = from.region_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      resend_start_pos_ = from.resend_start_pos_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchStoreReq::CopyFrom(const BatchStoreReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.BatchStoreReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchStoreReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void BatchStoreReq::InternalSwap(BatchStoreReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  request_lens_.InternalSwap(&other->request_lens_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BatchStoreReq, resend_start_pos_)
      + sizeof(BatchStoreReq::resend_start_pos_)
      - PROTOBUF_FIELD_OFFSET(BatchStoreReq, region_id_)>(
          reinterpret_cast<char*>(&region_id_),
          reinterpret_cast<char*>(&other->region_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchStoreReq::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[7]);
}

// ===================================================================

class BatchStoreRes::_Internal {
 public:
  using HasBits = decltype(std::declval<BatchStoreRes>()._has_bits_);
  static void set_has_errcode(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_errmsg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_leader(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_success_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_applied_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_braft_applied_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dml_latency(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000040) ^ 0x00000040) != 0;
  }
};

BatchStoreRes::BatchStoreRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.BatchStoreRes)
}
BatchStoreRes::BatchStoreRes(const BatchStoreRes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  errmsg_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_errmsg()) {
    errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_errmsg(), 
      GetArenaForAllocation());
  }
  leader_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_leader()) {
    leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_leader(), 
      GetArenaForAllocation());
  }
  ::memcpy(&success_cnt_, &from.success_cnt_,
    static_cast<size_t>(reinterpret_cast<char*>(&errcode_) -
    reinterpret_cast<char*>(&success_cnt_)) + sizeof(errcode_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.BatchStoreRes)
}

void BatchStoreRes::SharedCtor() {
errmsg_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
leader_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&success_cnt_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&errcode_) -
    reinterpret_cast<char*>(&success_cnt_)) + sizeof(errcode_));
}

BatchStoreRes::~BatchStoreRes() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.BatchStoreRes)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BatchStoreRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  errmsg_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  leader_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BatchStoreRes::ArenaDtor(void* object) {
  BatchStoreRes* _this = reinterpret_cast< BatchStoreRes* >(object);
  (void)_this;
}
void BatchStoreRes::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BatchStoreRes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BatchStoreRes::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.BatchStoreRes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      errmsg_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      leader_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&success_cnt_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&errcode_) -
        reinterpret_cast<char*>(&success_cnt_)) + sizeof(errcode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchStoreRes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.ErrCode errcode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::ErrCode_IsValid(val))) {
            _internal_set_errcode(static_cast<::baikaldb::pb::ErrCode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes errmsg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_errmsg();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string leader = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_leader();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.BatchStoreRes.leader");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 success_cnt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_success_cnt(&has_bits);
          success_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 applied_index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_applied_index(&has_bits);
          applied_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 braft_applied_index = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_braft_applied_index(&has_bits);
          braft_applied_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 dml_latency = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_dml_latency(&has_bits);
          dml_latency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BatchStoreRes::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.BatchStoreRes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.ErrCode errcode = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_errcode(), target);
  }

  // optional bytes errmsg = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_errmsg(), target);
  }

  // optional string leader = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_leader().data(), static_cast<int>(this->_internal_leader().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.BatchStoreRes.leader");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_leader(), target);
  }

  // optional int64 success_cnt = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_success_cnt(), target);
  }

  // optional int64 applied_index = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_applied_index(), target);
  }

  // optional int64 braft_applied_index = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_braft_applied_index(), target);
  }

  // optional int64 dml_latency = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(7, this->_internal_dml_latency(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.BatchStoreRes)
  return target;
}

size_t BatchStoreRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.BatchStoreRes)
  size_t total_size = 0;

  // required .baikaldb.pb.ErrCode errcode = 1;
  if (_internal_has_errcode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_errcode());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes errmsg = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_errmsg());
    }

    // optional string leader = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_leader());
    }

    // optional int64 success_cnt = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_success_cnt());
    }

    // optional int64 applied_index = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_applied_index());
    }

    // optional int64 braft_applied_index = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_braft_applied_index());
    }

    // optional int64 dml_latency = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_dml_latency());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchStoreRes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BatchStoreRes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchStoreRes::GetClassData() const { return &_class_data_; }

void BatchStoreRes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BatchStoreRes *>(to)->MergeFrom(
      static_cast<const BatchStoreRes &>(from));
}


void BatchStoreRes::MergeFrom(const BatchStoreRes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.BatchStoreRes)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_errmsg(from._internal_errmsg());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_leader(from._internal_leader());
    }
    if (cached_has_bits & 0x00000004u) {
      success_cnt_ = from.success_cnt_;
    }
    if (cached_has_bits & 0x00000008u) {
      applied_index_ = from.applied_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      braft_applied_index_ = from.braft_applied_index_;
    }
    if (cached_has_bits & 0x00000020u) {
      dml_latency_ = from.dml_latency_;
    }
    if (cached_has_bits & 0x00000040u) {
      errcode_ = from.errcode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchStoreRes::CopyFrom(const BatchStoreRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.BatchStoreRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchStoreRes::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void BatchStoreRes::InternalSwap(BatchStoreRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &errmsg_, lhs_arena,
      &other->errmsg_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &leader_, lhs_arena,
      &other->leader_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BatchStoreRes, errcode_)
      + sizeof(BatchStoreRes::errcode_)
      - PROTOBUF_FIELD_OFFSET(BatchStoreRes, success_cnt_)>(
          reinterpret_cast<char*>(&success_cnt_),
          reinterpret_cast<char*>(&other->success_cnt_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchStoreRes::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[8]);
}

// ===================================================================

class RegionIndexs::_Internal {
 public:
  using HasBits = decltype(std::declval<RegionIndexs>()._has_bits_);
  static void set_has_region_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_apply_index(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_resource_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_olap_state(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_path_diff(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_region_size(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_column_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

RegionIndexs::RegionIndexs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  external_full_path_(arena),
  olap_index_info_list_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.RegionIndexs)
}
RegionIndexs::RegionIndexs(const RegionIndexs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      external_full_path_(from.external_full_path_),
      olap_index_info_list_(from.olap_index_info_list_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  status_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_status()) {
    status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_status(), 
      GetArenaForAllocation());
  }
  resource_tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_resource_tag()) {
    resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_resource_tag(), 
      GetArenaForAllocation());
  }
  column_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_column_info()) {
    column_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_column_info(), 
      GetArenaForAllocation());
  }
  ::memcpy(&region_id_, &from.region_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&region_size_) -
    reinterpret_cast<char*>(&region_id_)) + sizeof(region_size_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.RegionIndexs)
}

void RegionIndexs::SharedCtor() {
status_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
resource_tag_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
column_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&region_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&region_size_) -
    reinterpret_cast<char*>(&region_id_)) + sizeof(region_size_));
}

RegionIndexs::~RegionIndexs() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.RegionIndexs)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RegionIndexs::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  status_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  resource_tag_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  column_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void RegionIndexs::ArenaDtor(void* object) {
  RegionIndexs* _this = reinterpret_cast< RegionIndexs* >(object);
  (void)_this;
}
void RegionIndexs::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RegionIndexs::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RegionIndexs::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.RegionIndexs)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  external_full_path_.Clear();
  olap_index_info_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      status_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      resource_tag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      column_info_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&region_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&olap_state_) -
        reinterpret_cast<char*>(&region_id_)) + sizeof(olap_state_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&path_diff_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&region_size_) -
        reinterpret_cast<char*>(&path_diff_)) + sizeof(region_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RegionIndexs::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 region_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_region_id(&has_bits);
          region_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 apply_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_apply_index(&has_bits);
          apply_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string status = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_status();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.RegionIndexs.status");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string resource_tag = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_resource_tag();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.RegionIndexs.resource_tag");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 table_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_table_id(&has_bits);
          table_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.OlapRegionStat olap_state = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::OlapRegionStat_IsValid(val))) {
            _internal_set_olap_state(static_cast<::baikaldb::pb::OlapRegionStat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated string external_full_path = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_external_full_path();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.RegionIndexs.external_full_path");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool path_diff = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_path_diff(&has_bits);
          path_diff_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 region_size = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_region_size(&has_bits);
          region_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string column_info = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          auto str = _internal_mutable_column_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.RegionIndexs.column_info");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.OlapRegionIndexInfo olap_index_info_list = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_olap_index_info_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RegionIndexs::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.RegionIndexs)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 region_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_region_id(), target);
  }

  // optional int64 version = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_version(), target);
  }

  // optional int64 apply_index = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_apply_index(), target);
  }

  // optional string status = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_status().data(), static_cast<int>(this->_internal_status().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.RegionIndexs.status");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_status(), target);
  }

  // optional string resource_tag = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_resource_tag().data(), static_cast<int>(this->_internal_resource_tag().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.RegionIndexs.resource_tag");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_resource_tag(), target);
  }

  // optional int64 table_id = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_table_id(), target);
  }

  // optional .baikaldb.pb.OlapRegionStat olap_state = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_olap_state(), target);
  }

  // repeated string external_full_path = 8;
  for (int i = 0, n = this->_internal_external_full_path_size(); i < n; i++) {
    const auto& s = this->_internal_external_full_path(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.RegionIndexs.external_full_path");
    target = stream->WriteString(8, s, target);
  }

  // optional bool path_diff = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_path_diff(), target);
  }

  // optional int64 region_size = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(10, this->_internal_region_size(), target);
  }

  // optional string column_info = 11;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_column_info().data(), static_cast<int>(this->_internal_column_info().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.RegionIndexs.column_info");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_column_info(), target);
  }

  // repeated .baikaldb.pb.OlapRegionIndexInfo olap_index_info_list = 12;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_olap_index_info_list_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, this->_internal_olap_index_info_list(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.RegionIndexs)
  return target;
}

size_t RegionIndexs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.RegionIndexs)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string external_full_path = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(external_full_path_.size());
  for (int i = 0, n = external_full_path_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      external_full_path_.Get(i));
  }

  // repeated .baikaldb.pb.OlapRegionIndexInfo olap_index_info_list = 12;
  total_size += 1UL * this->_internal_olap_index_info_list_size();
  for (const auto& msg : this->olap_index_info_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string status = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_status());
    }

    // optional string resource_tag = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_resource_tag());
    }

    // optional string column_info = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_column_info());
    }

    // optional int64 region_id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_region_id());
    }

    // optional int64 version = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_version());
    }

    // optional int64 apply_index = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_apply_index());
    }

    // optional int64 table_id = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_table_id());
    }

    // optional .baikaldb.pb.OlapRegionStat olap_state = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_olap_state());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool path_diff = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional int64 region_size = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_region_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RegionIndexs::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RegionIndexs::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RegionIndexs::GetClassData() const { return &_class_data_; }

void RegionIndexs::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RegionIndexs *>(to)->MergeFrom(
      static_cast<const RegionIndexs &>(from));
}


void RegionIndexs::MergeFrom(const RegionIndexs& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.RegionIndexs)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  external_full_path_.MergeFrom(from.external_full_path_);
  olap_index_info_list_.MergeFrom(from.olap_index_info_list_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_status(from._internal_status());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_resource_tag(from._internal_resource_tag());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_column_info(from._internal_column_info());
    }
    if (cached_has_bits & 0x00000008u) {
      region_id_ = from.region_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000020u) {
      apply_index_ = from.apply_index_;
    }
    if (cached_has_bits & 0x00000040u) {
      table_id_ = from.table_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      olap_state_ = from.olap_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      path_diff_ = from.path_diff_;
    }
    if (cached_has_bits & 0x00000200u) {
      region_size_ = from.region_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RegionIndexs::CopyFrom(const RegionIndexs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.RegionIndexs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegionIndexs::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(olap_index_info_list_)) return false;
  return true;
}

void RegionIndexs::InternalSwap(RegionIndexs* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  external_full_path_.InternalSwap(&other->external_full_path_);
  olap_index_info_list_.InternalSwap(&other->olap_index_info_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &status_, lhs_arena,
      &other->status_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &resource_tag_, lhs_arena,
      &other->resource_tag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &column_info_, lhs_arena,
      &other->column_info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RegionIndexs, region_size_)
      + sizeof(RegionIndexs::region_size_)
      - PROTOBUF_FIELD_OFFSET(RegionIndexs, region_id_)>(
          reinterpret_cast<char*>(&region_id_),
          reinterpret_cast<char*>(&other->region_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RegionIndexs::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[9]);
}

// ===================================================================

class ColumnRegionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ColumnRegionInfo>()._has_bits_);
  static const ::baikaldb::pb::RegionColumnFiles& column_files(const ColumnRegionInfo* msg);
  static void set_has_column_files(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::baikaldb::pb::RegionColumnFiles&
ColumnRegionInfo::_Internal::column_files(const ColumnRegionInfo* msg) {
  return *msg->column_files_;
}
void ColumnRegionInfo::clear_column_files() {
  if (column_files_ != nullptr) column_files_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
ColumnRegionInfo::ColumnRegionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.ColumnRegionInfo)
}
ColumnRegionInfo::ColumnRegionInfo(const ColumnRegionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_column_files()) {
    column_files_ = new ::baikaldb::pb::RegionColumnFiles(*from.column_files_);
  } else {
    column_files_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.ColumnRegionInfo)
}

void ColumnRegionInfo::SharedCtor() {
column_files_ = nullptr;
}

ColumnRegionInfo::~ColumnRegionInfo() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.ColumnRegionInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ColumnRegionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete column_files_;
}

void ColumnRegionInfo::ArenaDtor(void* object) {
  ColumnRegionInfo* _this = reinterpret_cast< ColumnRegionInfo* >(object);
  (void)_this;
}
void ColumnRegionInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ColumnRegionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ColumnRegionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.ColumnRegionInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(column_files_ != nullptr);
    column_files_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ColumnRegionInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .baikaldb.pb.RegionColumnFiles column_files = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_column_files(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ColumnRegionInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.ColumnRegionInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .baikaldb.pb.RegionColumnFiles column_files = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::column_files(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.ColumnRegionInfo)
  return target;
}

size_t ColumnRegionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.ColumnRegionInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .baikaldb.pb.RegionColumnFiles column_files = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *column_files_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ColumnRegionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ColumnRegionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ColumnRegionInfo::GetClassData() const { return &_class_data_; }

void ColumnRegionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ColumnRegionInfo *>(to)->MergeFrom(
      static_cast<const ColumnRegionInfo &>(from));
}


void ColumnRegionInfo::MergeFrom(const ColumnRegionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.ColumnRegionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_column_files()) {
    _internal_mutable_column_files()->::baikaldb::pb::RegionColumnFiles::MergeFrom(from._internal_column_files());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ColumnRegionInfo::CopyFrom(const ColumnRegionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.ColumnRegionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColumnRegionInfo::IsInitialized() const {
  return true;
}

void ColumnRegionInfo::InternalSwap(ColumnRegionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(column_files_, other->column_files_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ColumnRegionInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[10]);
}

// ===================================================================

class UseridCount::_Internal {
 public:
  using HasBits = decltype(std::declval<UseridCount>()._has_bits_);
  static void set_has_userid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UseridCount::UseridCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.UseridCount)
}
UseridCount::UseridCount(const UseridCount& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&userid_, &from.userid_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&userid_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.UseridCount)
}

void UseridCount::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&userid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&userid_)) + sizeof(count_));
}

UseridCount::~UseridCount() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.UseridCount)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UseridCount::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UseridCount::ArenaDtor(void* object) {
  UseridCount* _this = reinterpret_cast< UseridCount* >(object);
  (void)_this;
}
void UseridCount::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UseridCount::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UseridCount::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.UseridCount)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&userid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&userid_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UseridCount::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 userid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_userid(&has_bits);
          userid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UseridCount::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.UseridCount)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 userid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_userid(), target);
  }

  // optional int64 count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.UseridCount)
  return target;
}

size_t UseridCount::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.UseridCount)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 userid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_userid());
    }

    // optional int64 count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UseridCount::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UseridCount::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UseridCount::GetClassData() const { return &_class_data_; }

void UseridCount::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UseridCount *>(to)->MergeFrom(
      static_cast<const UseridCount &>(from));
}


void UseridCount::MergeFrom(const UseridCount& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.UseridCount)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      userid_ = from.userid_;
    }
    if (cached_has_bits & 0x00000002u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UseridCount::CopyFrom(const UseridCount& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.UseridCount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UseridCount::IsInitialized() const {
  return true;
}

void UseridCount::InternalSwap(UseridCount* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UseridCount, count_)
      + sizeof(UseridCount::count_)
      - PROTOBUF_FIELD_OFFSET(UseridCount, userid_)>(
          reinterpret_cast<char*>(&userid_),
          reinterpret_cast<char*>(&other->userid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UseridCount::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[11]);
}

// ===================================================================

class ExtraReq::_Internal {
 public:
  using HasBits = decltype(std::declval<ExtraReq>()._has_bits_);
  static void set_has_use_read_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_sign_latency(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::baikaldb::pb::OlapRegionInfo& olap_info(const ExtraReq* msg);
  static void set_has_olap_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::baikaldb::pb::RegionOfflineBinlogInfo& offline_binlog_info(const ExtraReq* msg);
  static void set_has_offline_binlog_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_watt_stats_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::baikaldb::pb::ColumnRegionInfo& column_info(const ExtraReq* msg);
  static void set_has_column_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::baikaldb::pb::OlapRegionInfo&
ExtraReq::_Internal::olap_info(const ExtraReq* msg) {
  return *msg->olap_info_;
}
const ::baikaldb::pb::RegionOfflineBinlogInfo&
ExtraReq::_Internal::offline_binlog_info(const ExtraReq* msg) {
  return *msg->offline_binlog_info_;
}
const ::baikaldb::pb::ColumnRegionInfo&
ExtraReq::_Internal::column_info(const ExtraReq* msg) {
  return *msg->column_info_;
}
ExtraReq::ExtraReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.ExtraReq)
}
ExtraReq::ExtraReq(const ExtraReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_olap_info()) {
    olap_info_ = new ::baikaldb::pb::OlapRegionInfo(*from.olap_info_);
  } else {
    olap_info_ = nullptr;
  }
  if (from._internal_has_offline_binlog_info()) {
    offline_binlog_info_ = new ::baikaldb::pb::RegionOfflineBinlogInfo(*from.offline_binlog_info_);
  } else {
    offline_binlog_info_ = nullptr;
  }
  if (from._internal_has_column_info()) {
    column_info_ = new ::baikaldb::pb::ColumnRegionInfo(*from.column_info_);
  } else {
    column_info_ = nullptr;
  }
  ::memcpy(&sign_latency_, &from.sign_latency_,
    static_cast<size_t>(reinterpret_cast<char*>(&use_read_idx_) -
    reinterpret_cast<char*>(&sign_latency_)) + sizeof(use_read_idx_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.ExtraReq)
}

void ExtraReq::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&olap_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&use_read_idx_) -
    reinterpret_cast<char*>(&olap_info_)) + sizeof(use_read_idx_));
}

ExtraReq::~ExtraReq() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.ExtraReq)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ExtraReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete olap_info_;
  if (this != internal_default_instance()) delete offline_binlog_info_;
  if (this != internal_default_instance()) delete column_info_;
}

void ExtraReq::ArenaDtor(void* object) {
  ExtraReq* _this = reinterpret_cast< ExtraReq* >(object);
  (void)_this;
}
void ExtraReq::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ExtraReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ExtraReq::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.ExtraReq)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(olap_info_ != nullptr);
      olap_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(offline_binlog_info_ != nullptr);
      offline_binlog_info_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(column_info_ != nullptr);
      column_info_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&sign_latency_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&use_read_idx_) -
        reinterpret_cast<char*>(&sign_latency_)) + sizeof(use_read_idx_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExtraReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool use_read_idx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_use_read_idx(&has_bits);
          use_read_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 sign_latency = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_sign_latency(&has_bits);
          sign_latency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.OlapRegionInfo olap_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_olap_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.RegionOfflineBinlogInfo offline_binlog_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_offline_binlog_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 watt_stats_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_watt_stats_version(&has_bits);
          watt_stats_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.ColumnRegionInfo column_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_column_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ExtraReq::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.ExtraReq)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool use_read_idx = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_use_read_idx(), target);
  }

  // optional int64 sign_latency = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_sign_latency(), target);
  }

  // optional .baikaldb.pb.OlapRegionInfo olap_info = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::olap_info(this), target, stream);
  }

  // optional .baikaldb.pb.RegionOfflineBinlogInfo offline_binlog_info = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::offline_binlog_info(this), target, stream);
  }

  // optional uint64 watt_stats_version = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_watt_stats_version(), target);
  }

  // optional .baikaldb.pb.ColumnRegionInfo column_info = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::column_info(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.ExtraReq)
  return target;
}

size_t ExtraReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.ExtraReq)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .baikaldb.pb.OlapRegionInfo olap_info = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *olap_info_);
    }

    // optional .baikaldb.pb.RegionOfflineBinlogInfo offline_binlog_info = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *offline_binlog_info_);
    }

    // optional .baikaldb.pb.ColumnRegionInfo column_info = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *column_info_);
    }

    // optional int64 sign_latency = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_sign_latency());
    }

    // optional uint64 watt_stats_version = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_watt_stats_version());
    }

    // optional bool use_read_idx = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExtraReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ExtraReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExtraReq::GetClassData() const { return &_class_data_; }

void ExtraReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ExtraReq *>(to)->MergeFrom(
      static_cast<const ExtraReq &>(from));
}


void ExtraReq::MergeFrom(const ExtraReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.ExtraReq)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_olap_info()->::baikaldb::pb::OlapRegionInfo::MergeFrom(from._internal_olap_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_offline_binlog_info()->::baikaldb::pb::RegionOfflineBinlogInfo::MergeFrom(from._internal_offline_binlog_info());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_column_info()->::baikaldb::pb::ColumnRegionInfo::MergeFrom(from._internal_column_info());
    }
    if (cached_has_bits & 0x00000008u) {
      sign_latency_ = from.sign_latency_;
    }
    if (cached_has_bits & 0x00000010u) {
      watt_stats_version_ = from.watt_stats_version_;
    }
    if (cached_has_bits & 0x00000020u) {
      use_read_idx_ = from.use_read_idx_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExtraReq::CopyFrom(const ExtraReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.ExtraReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExtraReq::IsInitialized() const {
  if (_internal_has_olap_info()) {
    if (!olap_info_->IsInitialized()) return false;
  }
  if (_internal_has_offline_binlog_info()) {
    if (!offline_binlog_info_->IsInitialized()) return false;
  }
  return true;
}

void ExtraReq::InternalSwap(ExtraReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExtraReq, use_read_idx_)
      + sizeof(ExtraReq::use_read_idx_)
      - PROTOBUF_FIELD_OFFSET(ExtraReq, olap_info_)>(
          reinterpret_cast<char*>(&olap_info_),
          reinterpret_cast<char*>(&other->olap_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExtraReq::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[12]);
}

// ===================================================================

class ExtraRes::_Internal {
 public:
  using HasBits = decltype(std::declval<ExtraRes>()._has_bits_);
  static const ::baikaldb::pb::RegionOfflineBinlogInfo& offline_binlog_info(const ExtraRes* msg);
  static void set_has_offline_binlog_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_vectorized_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_vectorized_schema(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_wait_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_get_afs_path_succ(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_query_keypoint_succ(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::baikaldb::pb::RegionOfflineBinlogInfo&
ExtraRes::_Internal::offline_binlog_info(const ExtraRes* msg) {
  return *msg->offline_binlog_info_;
}
ExtraRes::ExtraRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  infos_(arena),
  afs_full_names_(arena),
  userid_count_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.ExtraRes)
}
ExtraRes::ExtraRes(const ExtraRes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      infos_(from.infos_),
      afs_full_names_(from.afs_full_names_),
      userid_count_(from.userid_count_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  vectorized_rows_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_vectorized_rows()) {
    vectorized_rows_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_vectorized_rows(), 
      GetArenaForAllocation());
  }
  vectorized_schema_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_vectorized_schema()) {
    vectorized_schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_vectorized_schema(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_offline_binlog_info()) {
    offline_binlog_info_ = new ::baikaldb::pb::RegionOfflineBinlogInfo(*from.offline_binlog_info_);
  } else {
    offline_binlog_info_ = nullptr;
  }
  ::memcpy(&wait_cost_, &from.wait_cost_,
    static_cast<size_t>(reinterpret_cast<char*>(&query_keypoint_succ_) -
    reinterpret_cast<char*>(&wait_cost_)) + sizeof(query_keypoint_succ_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.ExtraRes)
}

void ExtraRes::SharedCtor() {
vectorized_rows_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
vectorized_schema_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&offline_binlog_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&query_keypoint_succ_) -
    reinterpret_cast<char*>(&offline_binlog_info_)) + sizeof(query_keypoint_succ_));
}

ExtraRes::~ExtraRes() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.ExtraRes)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ExtraRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  vectorized_rows_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  vectorized_schema_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete offline_binlog_info_;
}

void ExtraRes::ArenaDtor(void* object) {
  ExtraRes* _this = reinterpret_cast< ExtraRes* >(object);
  (void)_this;
}
void ExtraRes::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ExtraRes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ExtraRes::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.ExtraRes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  infos_.Clear();
  afs_full_names_.Clear();
  userid_count_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      vectorized_rows_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      vectorized_schema_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(offline_binlog_info_ != nullptr);
      offline_binlog_info_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&wait_cost_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&query_keypoint_succ_) -
        reinterpret_cast<char*>(&wait_cost_)) + sizeof(query_keypoint_succ_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExtraRes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .baikaldb.pb.RegionIndexs infos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.RegionOfflineBinlogInfo offline_binlog_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_offline_binlog_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes vectorized_rows = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_vectorized_rows();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes vectorized_schema = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_vectorized_schema();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 wait_cost = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_wait_cost(&has_bits);
          wait_cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes afs_full_names = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_afs_full_names();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool get_afs_path_succ = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_get_afs_path_succ(&has_bits);
          get_afs_path_succ_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool query_keypoint_succ = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_query_keypoint_succ(&has_bits);
          query_keypoint_succ_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.UseridCount userid_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_userid_count(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ExtraRes::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.ExtraRes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .baikaldb.pb.RegionIndexs infos = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_infos_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_infos(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .baikaldb.pb.RegionOfflineBinlogInfo offline_binlog_info = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::offline_binlog_info(this), target, stream);
  }

  // optional bytes vectorized_rows = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_vectorized_rows(), target);
  }

  // optional bytes vectorized_schema = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_vectorized_schema(), target);
  }

  // optional int64 wait_cost = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_wait_cost(), target);
  }

  // repeated bytes afs_full_names = 6;
  for (int i = 0, n = this->_internal_afs_full_names_size(); i < n; i++) {
    const auto& s = this->_internal_afs_full_names(i);
    target = stream->WriteBytes(6, s, target);
  }

  // optional bool get_afs_path_succ = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_get_afs_path_succ(), target);
  }

  // optional bool query_keypoint_succ = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_query_keypoint_succ(), target);
  }

  // repeated .baikaldb.pb.UseridCount userid_count = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_userid_count_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, this->_internal_userid_count(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.ExtraRes)
  return target;
}

size_t ExtraRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.ExtraRes)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.RegionIndexs infos = 1;
  total_size += 1UL * this->_internal_infos_size();
  for (const auto& msg : this->infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated bytes afs_full_names = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(afs_full_names_.size());
  for (int i = 0, n = afs_full_names_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      afs_full_names_.Get(i));
  }

  // repeated .baikaldb.pb.UseridCount userid_count = 9;
  total_size += 1UL * this->_internal_userid_count_size();
  for (const auto& msg : this->userid_count_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes vectorized_rows = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_vectorized_rows());
    }

    // optional bytes vectorized_schema = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_vectorized_schema());
    }

    // optional .baikaldb.pb.RegionOfflineBinlogInfo offline_binlog_info = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *offline_binlog_info_);
    }

    // optional int64 wait_cost = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_wait_cost());
    }

    // optional bool get_afs_path_succ = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool query_keypoint_succ = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExtraRes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ExtraRes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExtraRes::GetClassData() const { return &_class_data_; }

void ExtraRes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ExtraRes *>(to)->MergeFrom(
      static_cast<const ExtraRes &>(from));
}


void ExtraRes::MergeFrom(const ExtraRes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.ExtraRes)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  infos_.MergeFrom(from.infos_);
  afs_full_names_.MergeFrom(from.afs_full_names_);
  userid_count_.MergeFrom(from.userid_count_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_vectorized_rows(from._internal_vectorized_rows());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_vectorized_schema(from._internal_vectorized_schema());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_offline_binlog_info()->::baikaldb::pb::RegionOfflineBinlogInfo::MergeFrom(from._internal_offline_binlog_info());
    }
    if (cached_has_bits & 0x00000008u) {
      wait_cost_ = from.wait_cost_;
    }
    if (cached_has_bits & 0x00000010u) {
      get_afs_path_succ_ = from.get_afs_path_succ_;
    }
    if (cached_has_bits & 0x00000020u) {
      query_keypoint_succ_ = from.query_keypoint_succ_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExtraRes::CopyFrom(const ExtraRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.ExtraRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExtraRes::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(infos_)) return false;
  if (_internal_has_offline_binlog_info()) {
    if (!offline_binlog_info_->IsInitialized()) return false;
  }
  return true;
}

void ExtraRes::InternalSwap(ExtraRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  infos_.InternalSwap(&other->infos_);
  afs_full_names_.InternalSwap(&other->afs_full_names_);
  userid_count_.InternalSwap(&other->userid_count_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &vectorized_rows_, lhs_arena,
      &other->vectorized_rows_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &vectorized_schema_, lhs_arena,
      &other->vectorized_schema_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExtraRes, query_keypoint_succ_)
      + sizeof(ExtraRes::query_keypoint_succ_)
      - PROTOBUF_FIELD_OFFSET(ExtraRes, offline_binlog_info_)>(
          reinterpret_cast<char*>(&offline_binlog_info_),
          reinterpret_cast<char*>(&other->offline_binlog_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExtraRes::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[13]);
}

// ===================================================================

class StoreReq::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreReq>()._has_bits_);
  static void set_has_op_type(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_region_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_region_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::baikaldb::pb::Plan& plan(const StoreReq* msg);
  static void set_has_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_log_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_start_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_split_term(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_split_end_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_reduce_num_lines(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_force(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_not_check_region(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::baikaldb::pb::RegionInfo& new_region_info(const StoreReq* msg);
  static void set_has_new_region_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_select_without_leader(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_db_conn_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::baikaldb::pb::DdlWorkInfo& ddlwork_info(const StoreReq* msg);
  static void set_has_ddlwork_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_num_increase_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_is_trace(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::baikaldb::pb::AnalyzeInfo& analyze_info(const StoreReq* msg);
  static void set_has_analyze_info(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::baikaldb::pb::BinlogDesc& binlog_desc(const StoreReq* msg);
  static void set_has_binlog_desc(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::baikaldb::pb::Binlog& binlog(const StoreReq* msg);
  static void set_has_binlog(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_sql_sign(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static const ::baikaldb::pb::ExtraReq& extra_req(const StoreReq* msg);
  static void set_has_extra_req(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_execute_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_is_rollup_base(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_sql_exec_timeout(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static const ::baikaldb::pb::RedisWriteRequest& redis_req(const StoreReq* msg);
  static void set_has_redis_req(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00010c00) ^ 0x00010c00) != 0;
  }
};

const ::baikaldb::pb::Plan&
StoreReq::_Internal::plan(const StoreReq* msg) {
  return *msg->plan_;
}
const ::baikaldb::pb::RegionInfo&
StoreReq::_Internal::new_region_info(const StoreReq* msg) {
  return *msg->new_region_info_;
}
const ::baikaldb::pb::DdlWorkInfo&
StoreReq::_Internal::ddlwork_info(const StoreReq* msg) {
  return *msg->ddlwork_info_;
}
const ::baikaldb::pb::AnalyzeInfo&
StoreReq::_Internal::analyze_info(const StoreReq* msg) {
  return *msg->analyze_info_;
}
const ::baikaldb::pb::BinlogDesc&
StoreReq::_Internal::binlog_desc(const StoreReq* msg) {
  return *msg->binlog_desc_;
}
const ::baikaldb::pb::Binlog&
StoreReq::_Internal::binlog(const StoreReq* msg) {
  return *msg->binlog_;
}
const ::baikaldb::pb::ExtraReq&
StoreReq::_Internal::extra_req(const StoreReq* msg) {
  return *msg->extra_req_;
}
const ::baikaldb::pb::RedisWriteRequest&
StoreReq::_Internal::redis_req(const StoreReq* msg) {
  return *msg->redis_req_;
}
void StoreReq::clear_tuples() {
  tuples_.Clear();
}
void StoreReq::clear_plan() {
  if (plan_ != nullptr) plan_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void StoreReq::clear_new_region_info() {
  if (new_region_info_ != nullptr) new_region_info_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
void StoreReq::clear_ddlwork_info() {
  if (ddlwork_info_ != nullptr) ddlwork_info_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
void StoreReq::clear_binlog() {
  if (binlog_ != nullptr) binlog_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
void StoreReq::clear_multi_new_region_infos() {
  multi_new_region_infos_.Clear();
}
StoreReq::StoreReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  tuples_(arena),
  txn_infos_(arena),
  kv_ops_(arena),
  rollback_txn_ids_(arena),
  commit_txn_ids_(arena),
  multi_new_region_infos_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.StoreReq)
}
StoreReq::StoreReq(const StoreReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      tuples_(from.tuples_),
      txn_infos_(from.txn_infos_),
      kv_ops_(from.kv_ops_),
      rollback_txn_ids_(from.rollback_txn_ids_),
      commit_txn_ids_(from.commit_txn_ids_),
      multi_new_region_infos_(from.multi_new_region_infos_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  start_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_start_key()) {
    start_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_start_key(), 
      GetArenaForAllocation());
  }
  end_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_end_key()) {
    end_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_end_key(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_plan()) {
    plan_ = new ::baikaldb::pb::Plan(*from.plan_);
  } else {
    plan_ = nullptr;
  }
  if (from._internal_has_new_region_info()) {
    new_region_info_ = new ::baikaldb::pb::RegionInfo(*from.new_region_info_);
  } else {
    new_region_info_ = nullptr;
  }
  if (from._internal_has_ddlwork_info()) {
    ddlwork_info_ = new ::baikaldb::pb::DdlWorkInfo(*from.ddlwork_info_);
  } else {
    ddlwork_info_ = nullptr;
  }
  if (from._internal_has_analyze_info()) {
    analyze_info_ = new ::baikaldb::pb::AnalyzeInfo(*from.analyze_info_);
  } else {
    analyze_info_ = nullptr;
  }
  if (from._internal_has_binlog_desc()) {
    binlog_desc_ = new ::baikaldb::pb::BinlogDesc(*from.binlog_desc_);
  } else {
    binlog_desc_ = nullptr;
  }
  if (from._internal_has_binlog()) {
    binlog_ = new ::baikaldb::pb::Binlog(*from.binlog_);
  } else {
    binlog_ = nullptr;
  }
  if (from._internal_has_extra_req()) {
    extra_req_ = new ::baikaldb::pb::ExtraReq(*from.extra_req_);
  } else {
    extra_req_ = nullptr;
  }
  if (from._internal_has_redis_req()) {
    redis_req_ = new ::baikaldb::pb::RedisWriteRequest(*from.redis_req_);
  } else {
    redis_req_ = nullptr;
  }
  ::memcpy(&region_id_, &from.region_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&sql_exec_timeout_) -
    reinterpret_cast<char*>(&region_id_)) + sizeof(sql_exec_timeout_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.StoreReq)
}

void StoreReq::SharedCtor() {
start_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
end_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&plan_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sql_exec_timeout_) -
    reinterpret_cast<char*>(&plan_)) + sizeof(sql_exec_timeout_));
}

StoreReq::~StoreReq() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.StoreReq)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  start_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  end_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete plan_;
  if (this != internal_default_instance()) delete new_region_info_;
  if (this != internal_default_instance()) delete ddlwork_info_;
  if (this != internal_default_instance()) delete analyze_info_;
  if (this != internal_default_instance()) delete binlog_desc_;
  if (this != internal_default_instance()) delete binlog_;
  if (this != internal_default_instance()) delete extra_req_;
  if (this != internal_default_instance()) delete redis_req_;
}

void StoreReq::ArenaDtor(void* object) {
  StoreReq* _this = reinterpret_cast< StoreReq* >(object);
  (void)_this;
}
void StoreReq::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreReq::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.StoreReq)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tuples_.Clear();
  txn_infos_.Clear();
  kv_ops_.Clear();
  rollback_txn_ids_.Clear();
  commit_txn_ids_.Clear();
  multi_new_region_infos_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      start_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      end_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(plan_ != nullptr);
      plan_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(new_region_info_ != nullptr);
      new_region_info_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(ddlwork_info_ != nullptr);
      ddlwork_info_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(analyze_info_ != nullptr);
      analyze_info_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(binlog_desc_ != nullptr);
      binlog_desc_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(binlog_ != nullptr);
      binlog_->Clear();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(extra_req_ != nullptr);
      extra_req_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(redis_req_ != nullptr);
      redis_req_->Clear();
    }
  }
  if (cached_has_bits & 0x0000fc00u) {
    ::memset(&region_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&reduce_num_lines_) -
        reinterpret_cast<char*>(&region_id_)) + sizeof(reduce_num_lines_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&op_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sql_sign_) -
        reinterpret_cast<char*>(&op_type_)) + sizeof(sql_sign_));
  }
  if (cached_has_bits & 0x07000000u) {
    ::memset(&execute_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sql_exec_timeout_) -
        reinterpret_cast<char*>(&execute_type_)) + sizeof(sql_exec_timeout_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.OpType op_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::OpType_IsValid(val))) {
            _internal_set_op_type(static_cast<::baikaldb::pb::OpType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.TupleDescriptor tuples = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tuples(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required int64 region_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_region_id(&has_bits);
          region_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 region_version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_region_version(&has_bits);
          region_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.Plan plan = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.TransactionInfo txn_infos = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_txn_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 log_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 57)) {
          _Internal::set_has_log_id(&has_bits);
          log_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else
          goto handle_unusual;
        continue;
      // optional bytes start_key = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          auto str = _internal_mutable_start_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes end_key = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          auto str = _internal_mutable_end_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 split_term = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_split_term(&has_bits);
          split_term_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 split_end_index = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_split_end_index(&has_bits);
          split_end_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 reduce_num_lines = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_reduce_num_lines(&has_bits);
          reduce_num_lines_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool force = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_force(&has_bits);
          force_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool not_check_region = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_not_check_region(&has_bits);
          not_check_region_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.RegionInfo new_region_info = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_region_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool select_without_leader = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_select_without_leader(&has_bits);
          select_without_leader_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 db_conn_id = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 145)) {
          _Internal::set_has_db_conn_id(&has_bits);
          db_conn_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint64>(ptr);
          ptr += sizeof(::PROTOBUF_NAMESPACE_ID::uint64);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.DdlWorkInfo ddlwork_info = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_ddlwork_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 num_increase_rows = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_num_increase_rows(&has_bits);
          num_increase_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.KvOp kv_ops = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_kv_ops(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool is_trace = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 176)) {
          _Internal::set_has_is_trace(&has_bits);
          is_trace_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.AnalyzeInfo analyze_info = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_analyze_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 rollback_txn_ids = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 192)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_rollback_txn_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<192>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 194) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_rollback_txn_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 commit_txn_ids = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 200)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_commit_txn_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<200>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 202) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_commit_txn_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.BinlogDesc binlog_desc = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_binlog_desc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.Binlog binlog = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_binlog(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 sql_sign = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 224)) {
          _Internal::set_has_sql_sign(&has_bits);
          sql_sign_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.RegionInfo multi_new_region_infos = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 234)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_multi_new_region_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<234>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.ExtraReq extra_req = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_extra_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.ExecuteType execute_type = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 248)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::ExecuteType_IsValid(val))) {
            _internal_set_execute_type(static_cast<::baikaldb::pb::ExecuteType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(31, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_rollup_base = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 0)) {
          _Internal::set_has_is_rollup_base(&has_bits);
          is_rollup_base_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 sql_exec_timeout = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_sql_exec_timeout(&has_bits);
          sql_exec_timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.RedisWriteRequest redis_req = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_redis_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StoreReq::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.StoreReq)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.OpType op_type = 1;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_op_type(), target);
  }

  // repeated .baikaldb.pb.TupleDescriptor tuples = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_tuples_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_tuples(i), target, stream);
  }

  // required int64 region_id = 3;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_region_id(), target);
  }

  // required int64 region_version = 4;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_region_version(), target);
  }

  // optional .baikaldb.pb.Plan plan = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::plan(this), target, stream);
  }

  // repeated .baikaldb.pb.TransactionInfo txn_infos = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_txn_infos_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_txn_infos(i), target, stream);
  }

  // optional fixed64 log_id = 7;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(7, this->_internal_log_id(), target);
  }

  // optional bytes start_key = 9;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_start_key(), target);
  }

  // optional bytes end_key = 10;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        10, this->_internal_end_key(), target);
  }

  // optional int64 split_term = 11;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(11, this->_internal_split_term(), target);
  }

  // optional int64 split_end_index = 12;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(12, this->_internal_split_end_index(), target);
  }

  // optional int64 reduce_num_lines = 13;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(13, this->_internal_reduce_num_lines(), target);
  }

  // optional bool force = 14;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_force(), target);
  }

  // optional bool not_check_region = 15;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_not_check_region(), target);
  }

  // optional .baikaldb.pb.RegionInfo new_region_info = 16;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        16, _Internal::new_region_info(this), target, stream);
  }

  // optional bool select_without_leader = 17;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_select_without_leader(), target);
  }

  // optional fixed64 db_conn_id = 18;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(18, this->_internal_db_conn_id(), target);
  }

  // optional .baikaldb.pb.DdlWorkInfo ddlwork_info = 19;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        19, _Internal::ddlwork_info(this), target, stream);
  }

  // optional int64 num_increase_rows = 20;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(20, this->_internal_num_increase_rows(), target);
  }

  // repeated .baikaldb.pb.KvOp kv_ops = 21;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_kv_ops_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, this->_internal_kv_ops(i), target, stream);
  }

  // optional bool is_trace = 22;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(22, this->_internal_is_trace(), target);
  }

  // optional .baikaldb.pb.AnalyzeInfo analyze_info = 23;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        23, _Internal::analyze_info(this), target, stream);
  }

  // repeated uint64 rollback_txn_ids = 24;
  for (int i = 0, n = this->_internal_rollback_txn_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(24, this->_internal_rollback_txn_ids(i), target);
  }

  // repeated uint64 commit_txn_ids = 25;
  for (int i = 0, n = this->_internal_commit_txn_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(25, this->_internal_commit_txn_ids(i), target);
  }

  // optional .baikaldb.pb.BinlogDesc binlog_desc = 26;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        26, _Internal::binlog_desc(this), target, stream);
  }

  // optional .baikaldb.pb.Binlog binlog = 27;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        27, _Internal::binlog(this), target, stream);
  }

  // optional uint64 sql_sign = 28;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(28, this->_internal_sql_sign(), target);
  }

  // repeated .baikaldb.pb.RegionInfo multi_new_region_infos = 29;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_multi_new_region_infos_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, this->_internal_multi_new_region_infos(i), target, stream);
  }

  // optional .baikaldb.pb.ExtraReq extra_req = 30;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        30, _Internal::extra_req(this), target, stream);
  }

  // optional .baikaldb.pb.ExecuteType execute_type = 31;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      31, this->_internal_execute_type(), target);
  }

  // optional bool is_rollup_base = 32;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(32, this->_internal_is_rollup_base(), target);
  }

  // optional int64 sql_exec_timeout = 33;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(33, this->_internal_sql_exec_timeout(), target);
  }

  // optional .baikaldb.pb.RedisWriteRequest redis_req = 34;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        34, _Internal::redis_req(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.StoreReq)
  return target;
}

size_t StoreReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.StoreReq)
  size_t total_size = 0;

  if (_internal_has_region_id()) {
    // required int64 region_id = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_region_id());
  }

  if (_internal_has_region_version()) {
    // required int64 region_version = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_region_version());
  }

  if (_internal_has_op_type()) {
    // required .baikaldb.pb.OpType op_type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_op_type());
  }

  return total_size;
}
size_t StoreReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.StoreReq)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00010c00) ^ 0x00010c00) == 0) {  // All required fields are present.
    // required int64 region_id = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_region_id());

    // required int64 region_version = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_region_version());

    // required .baikaldb.pb.OpType op_type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_op_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.TupleDescriptor tuples = 2;
  total_size += 1UL * this->_internal_tuples_size();
  for (const auto& msg : this->tuples_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.TransactionInfo txn_infos = 6;
  total_size += 1UL * this->_internal_txn_infos_size();
  for (const auto& msg : this->txn_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.KvOp kv_ops = 21;
  total_size += 2UL * this->_internal_kv_ops_size();
  for (const auto& msg : this->kv_ops_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint64 rollback_txn_ids = 24;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->rollback_txn_ids_);
    total_size += 2 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_rollback_txn_ids_size());
    total_size += data_size;
  }

  // repeated uint64 commit_txn_ids = 25;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->commit_txn_ids_);
    total_size += 2 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_commit_txn_ids_size());
    total_size += data_size;
  }

  // repeated .baikaldb.pb.RegionInfo multi_new_region_infos = 29;
  total_size += 2UL * this->_internal_multi_new_region_infos_size();
  for (const auto& msg : this->multi_new_region_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes start_key = 9;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_start_key());
    }

    // optional bytes end_key = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_end_key());
    }

    // optional .baikaldb.pb.Plan plan = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *plan_);
    }

    // optional .baikaldb.pb.RegionInfo new_region_info = 16;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *new_region_info_);
    }

    // optional .baikaldb.pb.DdlWorkInfo ddlwork_info = 19;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ddlwork_info_);
    }

    // optional .baikaldb.pb.AnalyzeInfo analyze_info = 23;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *analyze_info_);
    }

    // optional .baikaldb.pb.BinlogDesc binlog_desc = 26;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *binlog_desc_);
    }

    // optional .baikaldb.pb.Binlog binlog = 27;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *binlog_);
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional .baikaldb.pb.ExtraReq extra_req = 30;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *extra_req_);
    }

    // optional .baikaldb.pb.RedisWriteRequest redis_req = 34;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *redis_req_);
    }

  }
  if (cached_has_bits & 0x0000f000u) {
    // optional fixed64 log_id = 7;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 8;
    }

    // optional int64 split_term = 11;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_split_term());
    }

    // optional int64 split_end_index = 12;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_split_end_index());
    }

    // optional int64 reduce_num_lines = 13;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_reduce_num_lines());
    }

  }
  if (cached_has_bits & 0x00fe0000u) {
    // optional bool force = 14;
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 1;
    }

    // optional bool not_check_region = 15;
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 1;
    }

    // optional bool select_without_leader = 17;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional bool is_trace = 22;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional fixed64 db_conn_id = 18;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 8;
    }

    // optional int64 num_increase_rows = 20;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_num_increase_rows());
    }

    // optional uint64 sql_sign = 28;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_sql_sign());
    }

  }
  if (cached_has_bits & 0x07000000u) {
    // optional .baikaldb.pb.ExecuteType execute_type = 31;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_execute_type());
    }

    // optional bool is_rollup_base = 32;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional int64 sql_exec_timeout = 33;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_sql_exec_timeout());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreReq::GetClassData() const { return &_class_data_; }

void StoreReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreReq *>(to)->MergeFrom(
      static_cast<const StoreReq &>(from));
}


void StoreReq::MergeFrom(const StoreReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.StoreReq)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  tuples_.MergeFrom(from.tuples_);
  txn_infos_.MergeFrom(from.txn_infos_);
  kv_ops_.MergeFrom(from.kv_ops_);
  rollback_txn_ids_.MergeFrom(from.rollback_txn_ids_);
  commit_txn_ids_.MergeFrom(from.commit_txn_ids_);
  multi_new_region_infos_.MergeFrom(from.multi_new_region_infos_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_start_key(from._internal_start_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_end_key(from._internal_end_key());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_plan()->::baikaldb::pb::Plan::MergeFrom(from._internal_plan());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_new_region_info()->::baikaldb::pb::RegionInfo::MergeFrom(from._internal_new_region_info());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_ddlwork_info()->::baikaldb::pb::DdlWorkInfo::MergeFrom(from._internal_ddlwork_info());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_analyze_info()->::baikaldb::pb::AnalyzeInfo::MergeFrom(from._internal_analyze_info());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_binlog_desc()->::baikaldb::pb::BinlogDesc::MergeFrom(from._internal_binlog_desc());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_binlog()->::baikaldb::pb::Binlog::MergeFrom(from._internal_binlog());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_extra_req()->::baikaldb::pb::ExtraReq::MergeFrom(from._internal_extra_req());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_redis_req()->::baikaldb::pb::RedisWriteRequest::MergeFrom(from._internal_redis_req());
    }
    if (cached_has_bits & 0x00000400u) {
      region_id_ = from.region_id_;
    }
    if (cached_has_bits & 0x00000800u) {
      region_version_ = from.region_version_;
    }
    if (cached_has_bits & 0x00001000u) {
      log_id_ = from.log_id_;
    }
    if (cached_has_bits & 0x00002000u) {
      split_term_ = from.split_term_;
    }
    if (cached_has_bits & 0x00004000u) {
      split_end_index_ = from.split_end_index_;
    }
    if (cached_has_bits & 0x00008000u) {
      reduce_num_lines_ = from.reduce_num_lines_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      op_type_ = from.op_type_;
    }
    if (cached_has_bits & 0x00020000u) {
      force_ = from.force_;
    }
    if (cached_has_bits & 0x00040000u) {
      not_check_region_ = from.not_check_region_;
    }
    if (cached_has_bits & 0x00080000u) {
      select_without_leader_ = from.select_without_leader_;
    }
    if (cached_has_bits & 0x00100000u) {
      is_trace_ = from.is_trace_;
    }
    if (cached_has_bits & 0x00200000u) {
      db_conn_id_ = from.db_conn_id_;
    }
    if (cached_has_bits & 0x00400000u) {
      num_increase_rows_ = from.num_increase_rows_;
    }
    if (cached_has_bits & 0x00800000u) {
      sql_sign_ = from.sql_sign_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x07000000u) {
    if (cached_has_bits & 0x01000000u) {
      execute_type_ = from.execute_type_;
    }
    if (cached_has_bits & 0x02000000u) {
      is_rollup_base_ = from.is_rollup_base_;
    }
    if (cached_has_bits & 0x04000000u) {
      sql_exec_timeout_ = from.sql_exec_timeout_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreReq::CopyFrom(const StoreReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.StoreReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(tuples_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(txn_infos_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(kv_ops_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(multi_new_region_infos_)) return false;
  if (_internal_has_plan()) {
    if (!plan_->IsInitialized()) return false;
  }
  if (_internal_has_new_region_info()) {
    if (!new_region_info_->IsInitialized()) return false;
  }
  if (_internal_has_ddlwork_info()) {
    if (!ddlwork_info_->IsInitialized()) return false;
  }
  if (_internal_has_binlog_desc()) {
    if (!binlog_desc_->IsInitialized()) return false;
  }
  if (_internal_has_extra_req()) {
    if (!extra_req_->IsInitialized()) return false;
  }
  return true;
}

void StoreReq::InternalSwap(StoreReq* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  tuples_.InternalSwap(&other->tuples_);
  txn_infos_.InternalSwap(&other->txn_infos_);
  kv_ops_.InternalSwap(&other->kv_ops_);
  rollback_txn_ids_.InternalSwap(&other->rollback_txn_ids_);
  commit_txn_ids_.InternalSwap(&other->commit_txn_ids_);
  multi_new_region_infos_.InternalSwap(&other->multi_new_region_infos_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &start_key_, lhs_arena,
      &other->start_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &end_key_, lhs_arena,
      &other->end_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreReq, sql_exec_timeout_)
      + sizeof(StoreReq::sql_exec_timeout_)
      - PROTOBUF_FIELD_OFFSET(StoreReq, plan_)>(
          reinterpret_cast<char*>(&plan_),
          reinterpret_cast<char*>(&other->plan_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreReq::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[14]);
}

// ===================================================================

class RowValue::_Internal {
 public:
};

RowValue::RowValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  tuple_values_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.RowValue)
}
RowValue::RowValue(const RowValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      tuple_values_(from.tuple_values_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.RowValue)
}

void RowValue::SharedCtor() {
}

RowValue::~RowValue() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.RowValue)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RowValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RowValue::ArenaDtor(void* object) {
  RowValue* _this = reinterpret_cast< RowValue* >(object);
  (void)_this;
}
void RowValue::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RowValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RowValue::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.RowValue)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tuple_values_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RowValue::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes tuple_values = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_tuple_values();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RowValue::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.RowValue)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes tuple_values = 1;
  for (int i = 0, n = this->_internal_tuple_values_size(); i < n; i++) {
    const auto& s = this->_internal_tuple_values(i);
    target = stream->WriteBytes(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.RowValue)
  return target;
}

size_t RowValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.RowValue)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes tuple_values = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(tuple_values_.size());
  for (int i = 0, n = tuple_values_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      tuple_values_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RowValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RowValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RowValue::GetClassData() const { return &_class_data_; }

void RowValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RowValue *>(to)->MergeFrom(
      static_cast<const RowValue &>(from));
}


void RowValue::MergeFrom(const RowValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.RowValue)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  tuple_values_.MergeFrom(from.tuple_values_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RowValue::CopyFrom(const RowValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.RowValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RowValue::IsInitialized() const {
  return true;
}

void RowValue::InternalSwap(RowValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  tuple_values_.InternalSwap(&other->tuple_values_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RowValue::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[15]);
}

// ===================================================================

class RegionLeader::_Internal {
 public:
  using HasBits = decltype(std::declval<RegionLeader>()._has_bits_);
  static void set_has_region_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_leader(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

RegionLeader::RegionLeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.RegionLeader)
}
RegionLeader::RegionLeader(const RegionLeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  leader_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_leader()) {
    leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_leader(), 
      GetArenaForAllocation());
  }
  region_id_ = from.region_id_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.RegionLeader)
}

void RegionLeader::SharedCtor() {
leader_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
region_id_ = int64_t{0};
}

RegionLeader::~RegionLeader() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.RegionLeader)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RegionLeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  leader_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void RegionLeader::ArenaDtor(void* object) {
  RegionLeader* _this = reinterpret_cast< RegionLeader* >(object);
  (void)_this;
}
void RegionLeader::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RegionLeader::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RegionLeader::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.RegionLeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    leader_.ClearNonDefaultToEmpty();
  }
  region_id_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RegionLeader::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 region_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_region_id(&has_bits);
          region_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string leader = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_leader();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.RegionLeader.leader");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RegionLeader::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.RegionLeader)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 region_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_region_id(), target);
  }

  // required string leader = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_leader().data(), static_cast<int>(this->_internal_leader().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.RegionLeader.leader");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_leader(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.RegionLeader)
  return target;
}

size_t RegionLeader::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.RegionLeader)
  size_t total_size = 0;

  if (_internal_has_leader()) {
    // required string leader = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_leader());
  }

  if (_internal_has_region_id()) {
    // required int64 region_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_region_id());
  }

  return total_size;
}
size_t RegionLeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.RegionLeader)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string leader = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_leader());

    // required int64 region_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_region_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RegionLeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RegionLeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RegionLeader::GetClassData() const { return &_class_data_; }

void RegionLeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RegionLeader *>(to)->MergeFrom(
      static_cast<const RegionLeader &>(from));
}


void RegionLeader::MergeFrom(const RegionLeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.RegionLeader)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_leader(from._internal_leader());
    }
    if (cached_has_bits & 0x00000002u) {
      region_id_ = from.region_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RegionLeader::CopyFrom(const RegionLeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.RegionLeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegionLeader::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RegionLeader::InternalSwap(RegionLeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &leader_, lhs_arena,
      &other->leader_, rhs_arena
  );
  swap(region_id_, other->region_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RegionLeader::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[16]);
}

// ===================================================================

class IndexRecords::_Internal {
 public:
  using HasBits = decltype(std::declval<IndexRecords>()._has_bits_);
  static void set_has_index_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_local_index_binlog(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

IndexRecords::IndexRecords(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  records_(arena),
  old_records_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.IndexRecords)
}
IndexRecords::IndexRecords(const IndexRecords& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      records_(from.records_),
      old_records_(from.old_records_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&index_id_, &from.index_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&local_index_binlog_) -
    reinterpret_cast<char*>(&index_id_)) + sizeof(local_index_binlog_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.IndexRecords)
}

void IndexRecords::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&index_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&local_index_binlog_) -
    reinterpret_cast<char*>(&index_id_)) + sizeof(local_index_binlog_));
}

IndexRecords::~IndexRecords() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.IndexRecords)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IndexRecords::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IndexRecords::ArenaDtor(void* object) {
  IndexRecords* _this = reinterpret_cast< IndexRecords* >(object);
  (void)_this;
}
void IndexRecords::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IndexRecords::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IndexRecords::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.IndexRecords)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  records_.Clear();
  old_records_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&index_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&local_index_binlog_) -
        reinterpret_cast<char*>(&index_id_)) + sizeof(local_index_binlog_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IndexRecords::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 index_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_index_id(&has_bits);
          index_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes records = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_records();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes old_records = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_old_records();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool local_index_binlog = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_local_index_binlog(&has_bits);
          local_index_binlog_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* IndexRecords::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.IndexRecords)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 index_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_index_id(), target);
  }

  // repeated bytes records = 2;
  for (int i = 0, n = this->_internal_records_size(); i < n; i++) {
    const auto& s = this->_internal_records(i);
    target = stream->WriteBytes(2, s, target);
  }

  // repeated bytes old_records = 3;
  for (int i = 0, n = this->_internal_old_records_size(); i < n; i++) {
    const auto& s = this->_internal_old_records(i);
    target = stream->WriteBytes(3, s, target);
  }

  // optional bool local_index_binlog = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_local_index_binlog(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.IndexRecords)
  return target;
}

size_t IndexRecords::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.IndexRecords)
  size_t total_size = 0;

  // required int64 index_id = 1;
  if (_internal_has_index_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_index_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes records = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(records_.size());
  for (int i = 0, n = records_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      records_.Get(i));
  }

  // repeated bytes old_records = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(old_records_.size());
  for (int i = 0, n = old_records_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      old_records_.Get(i));
  }

  // optional bool local_index_binlog = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IndexRecords::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IndexRecords::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IndexRecords::GetClassData() const { return &_class_data_; }

void IndexRecords::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IndexRecords *>(to)->MergeFrom(
      static_cast<const IndexRecords &>(from));
}


void IndexRecords::MergeFrom(const IndexRecords& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.IndexRecords)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  records_.MergeFrom(from.records_);
  old_records_.MergeFrom(from.old_records_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      index_id_ = from.index_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      local_index_binlog_ = from.local_index_binlog_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IndexRecords::CopyFrom(const IndexRecords& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.IndexRecords)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IndexRecords::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void IndexRecords::InternalSwap(IndexRecords* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  records_.InternalSwap(&other->records_);
  old_records_.InternalSwap(&other->old_records_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IndexRecords, local_index_binlog_)
      + sizeof(IndexRecords::local_index_binlog_)
      - PROTOBUF_FIELD_OFFSET(IndexRecords, index_id_)>(
          reinterpret_cast<char*>(&index_id_),
          reinterpret_cast<char*>(&other->index_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IndexRecords::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[17]);
}

// ===================================================================

class RegionRaftStat::_Internal {
 public:
  using HasBits = decltype(std::declval<RegionRaftStat>()._has_bits_);
  static void set_has_applied_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_snapshot_data_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_snapshot_meta_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_snapshot_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dml_latency(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

RegionRaftStat::RegionRaftStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.RegionRaftStat)
}
RegionRaftStat::RegionRaftStat(const RegionRaftStat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&applied_index_, &from.applied_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&dml_latency_) -
    reinterpret_cast<char*>(&applied_index_)) + sizeof(dml_latency_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.RegionRaftStat)
}

void RegionRaftStat::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&applied_index_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&dml_latency_) -
    reinterpret_cast<char*>(&applied_index_)) + sizeof(dml_latency_));
}

RegionRaftStat::~RegionRaftStat() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.RegionRaftStat)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RegionRaftStat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RegionRaftStat::ArenaDtor(void* object) {
  RegionRaftStat* _this = reinterpret_cast< RegionRaftStat* >(object);
  (void)_this;
}
void RegionRaftStat::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RegionRaftStat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RegionRaftStat::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.RegionRaftStat)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&applied_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&dml_latency_) -
        reinterpret_cast<char*>(&applied_index_)) + sizeof(dml_latency_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RegionRaftStat::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 applied_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_applied_index(&has_bits);
          applied_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 snapshot_data_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_snapshot_data_size(&has_bits);
          snapshot_data_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 snapshot_meta_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_snapshot_meta_size(&has_bits);
          snapshot_meta_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 snapshot_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_snapshot_index(&has_bits);
          snapshot_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 dml_latency = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_dml_latency(&has_bits);
          dml_latency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RegionRaftStat::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.RegionRaftStat)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 applied_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_applied_index(), target);
  }

  // optional uint64 snapshot_data_size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_snapshot_data_size(), target);
  }

  // optional uint64 snapshot_meta_size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_snapshot_meta_size(), target);
  }

  // optional int64 snapshot_index = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_snapshot_index(), target);
  }

  // optional int64 dml_latency = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_dml_latency(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.RegionRaftStat)
  return target;
}

size_t RegionRaftStat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.RegionRaftStat)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int64 applied_index = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_applied_index());
    }

    // optional uint64 snapshot_data_size = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_snapshot_data_size());
    }

    // optional uint64 snapshot_meta_size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_snapshot_meta_size());
    }

    // optional int64 snapshot_index = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_snapshot_index());
    }

    // optional int64 dml_latency = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_dml_latency());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RegionRaftStat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RegionRaftStat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RegionRaftStat::GetClassData() const { return &_class_data_; }

void RegionRaftStat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RegionRaftStat *>(to)->MergeFrom(
      static_cast<const RegionRaftStat &>(from));
}


void RegionRaftStat::MergeFrom(const RegionRaftStat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.RegionRaftStat)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      applied_index_ = from.applied_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      snapshot_data_size_ = from.snapshot_data_size_;
    }
    if (cached_has_bits & 0x00000004u) {
      snapshot_meta_size_ = from.snapshot_meta_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      snapshot_index_ = from.snapshot_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      dml_latency_ = from.dml_latency_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RegionRaftStat::CopyFrom(const RegionRaftStat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.RegionRaftStat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegionRaftStat::IsInitialized() const {
  return true;
}

void RegionRaftStat::InternalSwap(RegionRaftStat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RegionRaftStat, dml_latency_)
      + sizeof(RegionRaftStat::dml_latency_)
      - PROTOBUF_FIELD_OFFSET(RegionRaftStat, applied_index_)>(
          reinterpret_cast<char*>(&applied_index_),
          reinterpret_cast<char*>(&other->applied_index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RegionRaftStat::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[18]);
}

// ===================================================================

class RocksStatisticReq::_Internal {
 public:
};

RocksStatisticReq::RocksStatisticReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  keys_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.RocksStatisticReq)
}
RocksStatisticReq::RocksStatisticReq(const RocksStatisticReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      keys_(from.keys_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.RocksStatisticReq)
}

void RocksStatisticReq::SharedCtor() {
}

RocksStatisticReq::~RocksStatisticReq() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.RocksStatisticReq)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RocksStatisticReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RocksStatisticReq::ArenaDtor(void* object) {
  RocksStatisticReq* _this = reinterpret_cast< RocksStatisticReq* >(object);
  (void)_this;
}
void RocksStatisticReq::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RocksStatisticReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RocksStatisticReq::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.RocksStatisticReq)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  keys_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RocksStatisticReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated bytes keys = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_keys();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RocksStatisticReq::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.RocksStatisticReq)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes keys = 1;
  for (int i = 0, n = this->_internal_keys_size(); i < n; i++) {
    const auto& s = this->_internal_keys(i);
    target = stream->WriteBytes(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.RocksStatisticReq)
  return target;
}

size_t RocksStatisticReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.RocksStatisticReq)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes keys = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(keys_.size());
  for (int i = 0, n = keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      keys_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RocksStatisticReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RocksStatisticReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RocksStatisticReq::GetClassData() const { return &_class_data_; }

void RocksStatisticReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RocksStatisticReq *>(to)->MergeFrom(
      static_cast<const RocksStatisticReq &>(from));
}


void RocksStatisticReq::MergeFrom(const RocksStatisticReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.RocksStatisticReq)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  keys_.MergeFrom(from.keys_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RocksStatisticReq::CopyFrom(const RocksStatisticReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.RocksStatisticReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RocksStatisticReq::IsInitialized() const {
  return true;
}

void RocksStatisticReq::InternalSwap(RocksStatisticReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  keys_.InternalSwap(&other->keys_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RocksStatisticReq::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[19]);
}

// ===================================================================

class RocksStatisticRes::_Internal {
 public:
  using HasBits = decltype(std::declval<RocksStatisticRes>()._has_bits_);
  static void set_has_errcode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_level0_sst_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_compaction_data_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

RocksStatisticRes::RocksStatisticRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  key_(arena),
  value_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.RocksStatisticRes)
}
RocksStatisticRes::RocksStatisticRes(const RocksStatisticRes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      key_(from.key_),
      value_(from.value_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&level0_sst_num_, &from.level0_sst_num_,
    static_cast<size_t>(reinterpret_cast<char*>(&errcode_) -
    reinterpret_cast<char*>(&level0_sst_num_)) + sizeof(errcode_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.RocksStatisticRes)
}

void RocksStatisticRes::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&level0_sst_num_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&errcode_) -
    reinterpret_cast<char*>(&level0_sst_num_)) + sizeof(errcode_));
}

RocksStatisticRes::~RocksStatisticRes() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.RocksStatisticRes)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RocksStatisticRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RocksStatisticRes::ArenaDtor(void* object) {
  RocksStatisticRes* _this = reinterpret_cast< RocksStatisticRes* >(object);
  (void)_this;
}
void RocksStatisticRes::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RocksStatisticRes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RocksStatisticRes::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.RocksStatisticRes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  key_.Clear();
  value_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&level0_sst_num_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&errcode_) -
        reinterpret_cast<char*>(&level0_sst_num_)) + sizeof(errcode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RocksStatisticRes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.ErrCode errcode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::ErrCode_IsValid(val))) {
            _internal_set_errcode(static_cast<::baikaldb::pb::ErrCode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 level0_sst_num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_level0_sst_num(&has_bits);
          level0_sst_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 compaction_data_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_compaction_data_size(&has_bits);
          compaction_data_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_key();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_value();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RocksStatisticRes::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.RocksStatisticRes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.ErrCode errcode = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_errcode(), target);
  }

  // optional uint64 level0_sst_num = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_level0_sst_num(), target);
  }

  // optional uint64 compaction_data_size = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_compaction_data_size(), target);
  }

  // repeated bytes key = 4;
  for (int i = 0, n = this->_internal_key_size(); i < n; i++) {
    const auto& s = this->_internal_key(i);
    target = stream->WriteBytes(4, s, target);
  }

  // repeated bytes value = 5;
  for (int i = 0, n = this->_internal_value_size(); i < n; i++) {
    const auto& s = this->_internal_value(i);
    target = stream->WriteBytes(5, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.RocksStatisticRes)
  return target;
}

size_t RocksStatisticRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.RocksStatisticRes)
  size_t total_size = 0;

  // required .baikaldb.pb.ErrCode errcode = 1;
  if (_internal_has_errcode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_errcode());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes key = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(key_.size());
  for (int i = 0, n = key_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      key_.Get(i));
  }

  // repeated bytes value = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(value_.size());
  for (int i = 0, n = value_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      value_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 level0_sst_num = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_level0_sst_num());
    }

    // optional uint64 compaction_data_size = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_compaction_data_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RocksStatisticRes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RocksStatisticRes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RocksStatisticRes::GetClassData() const { return &_class_data_; }

void RocksStatisticRes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RocksStatisticRes *>(to)->MergeFrom(
      static_cast<const RocksStatisticRes &>(from));
}


void RocksStatisticRes::MergeFrom(const RocksStatisticRes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.RocksStatisticRes)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  key_.MergeFrom(from.key_);
  value_.MergeFrom(from.value_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      level0_sst_num_ = from.level0_sst_num_;
    }
    if (cached_has_bits & 0x00000002u) {
      compaction_data_size_ = from.compaction_data_size_;
    }
    if (cached_has_bits & 0x00000004u) {
      errcode_ = from.errcode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RocksStatisticRes::CopyFrom(const RocksStatisticRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.RocksStatisticRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RocksStatisticRes::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RocksStatisticRes::InternalSwap(RocksStatisticRes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  key_.InternalSwap(&other->key_);
  value_.InternalSwap(&other->value_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RocksStatisticRes, errcode_)
      + sizeof(RocksStatisticRes::errcode_)
      - PROTOBUF_FIELD_OFFSET(RocksStatisticRes, level0_sst_num_)>(
          reinterpret_cast<char*>(&level0_sst_num_),
          reinterpret_cast<char*>(&other->level0_sst_num_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RocksStatisticRes::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[20]);
}

// ===================================================================

class BinlogQueryInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<BinlogQueryInfo>()._has_bits_);
  static void set_has_region_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_oldest_ts(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_check_point_ts(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_region_oldest_ts(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_binlog_cf_oldest_ts(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_data_cf_oldest_ts(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_region_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BinlogQueryInfo::BinlogQueryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.BinlogQueryInfo)
}
BinlogQueryInfo::BinlogQueryInfo(const BinlogQueryInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  region_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_region_ip()) {
    region_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_region_ip(), 
      GetArenaForAllocation());
  }
  ::memcpy(&region_id_, &from.region_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&data_cf_oldest_ts_) -
    reinterpret_cast<char*>(&region_id_)) + sizeof(data_cf_oldest_ts_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.BinlogQueryInfo)
}

void BinlogQueryInfo::SharedCtor() {
region_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&region_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&data_cf_oldest_ts_) -
    reinterpret_cast<char*>(&region_id_)) + sizeof(data_cf_oldest_ts_));
}

BinlogQueryInfo::~BinlogQueryInfo() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.BinlogQueryInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BinlogQueryInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  region_ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BinlogQueryInfo::ArenaDtor(void* object) {
  BinlogQueryInfo* _this = reinterpret_cast< BinlogQueryInfo* >(object);
  (void)_this;
}
void BinlogQueryInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BinlogQueryInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BinlogQueryInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.BinlogQueryInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    region_ip_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&region_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&data_cf_oldest_ts_) -
        reinterpret_cast<char*>(&region_id_)) + sizeof(data_cf_oldest_ts_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BinlogQueryInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 region_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_region_id(&has_bits);
          region_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 oldest_ts = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_oldest_ts(&has_bits);
          oldest_ts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 check_point_ts = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_check_point_ts(&has_bits);
          check_point_ts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 region_oldest_ts = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_region_oldest_ts(&has_bits);
          region_oldest_ts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 binlog_cf_oldest_ts = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_binlog_cf_oldest_ts(&has_bits);
          binlog_cf_oldest_ts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 data_cf_oldest_ts = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_data_cf_oldest_ts(&has_bits);
          data_cf_oldest_ts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string region_ip = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_region_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.BinlogQueryInfo.region_ip");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BinlogQueryInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.BinlogQueryInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 region_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_region_id(), target);
  }

  // optional int64 oldest_ts = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_oldest_ts(), target);
  }

  // optional int64 check_point_ts = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_check_point_ts(), target);
  }

  // optional int64 region_oldest_ts = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_region_oldest_ts(), target);
  }

  // optional int64 binlog_cf_oldest_ts = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_binlog_cf_oldest_ts(), target);
  }

  // optional int64 data_cf_oldest_ts = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_data_cf_oldest_ts(), target);
  }

  // optional string region_ip = 7;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_region_ip().data(), static_cast<int>(this->_internal_region_ip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.BinlogQueryInfo.region_ip");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_region_ip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.BinlogQueryInfo)
  return target;
}

size_t BinlogQueryInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.BinlogQueryInfo)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string region_ip = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_region_ip());
    }

    // optional int64 region_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_region_id());
    }

    // optional int64 oldest_ts = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_oldest_ts());
    }

    // optional int64 check_point_ts = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_check_point_ts());
    }

    // optional int64 region_oldest_ts = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_region_oldest_ts());
    }

    // optional int64 binlog_cf_oldest_ts = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_binlog_cf_oldest_ts());
    }

    // optional int64 data_cf_oldest_ts = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_data_cf_oldest_ts());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BinlogQueryInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BinlogQueryInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BinlogQueryInfo::GetClassData() const { return &_class_data_; }

void BinlogQueryInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BinlogQueryInfo *>(to)->MergeFrom(
      static_cast<const BinlogQueryInfo &>(from));
}


void BinlogQueryInfo::MergeFrom(const BinlogQueryInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.BinlogQueryInfo)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_region_ip(from._internal_region_ip());
    }
    if (cached_has_bits & 0x00000002u) {
      region_id_ = from.region_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      oldest_ts_ = from.oldest_ts_;
    }
    if (cached_has_bits & 0x00000008u) {
      check_point_ts_ = from.check_point_ts_;
    }
    if (cached_has_bits & 0x00000010u) {
      region_oldest_ts_ = from.region_oldest_ts_;
    }
    if (cached_has_bits & 0x00000020u) {
      binlog_cf_oldest_ts_ = from.binlog_cf_oldest_ts_;
    }
    if (cached_has_bits & 0x00000040u) {
      data_cf_oldest_ts_ = from.data_cf_oldest_ts_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BinlogQueryInfo::CopyFrom(const BinlogQueryInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.BinlogQueryInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BinlogQueryInfo::IsInitialized() const {
  return true;
}

void BinlogQueryInfo::InternalSwap(BinlogQueryInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &region_ip_, lhs_arena,
      &other->region_ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BinlogQueryInfo, data_cf_oldest_ts_)
      + sizeof(BinlogQueryInfo::data_cf_oldest_ts_)
      - PROTOBUF_FIELD_OFFSET(BinlogQueryInfo, region_id_)>(
          reinterpret_cast<char*>(&region_id_),
          reinterpret_cast<char*>(&other->region_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BinlogQueryInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[21]);
}

// ===================================================================

class StoreRes::_Internal {
 public:
  using HasBits = decltype(std::declval<StoreRes>()._has_bits_);
  static void set_has_errcode(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_errmsg(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_leader(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_affected_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_applied_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_last_seq_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_mysql_errcode(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_region_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_is_merge(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_scan_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::baikaldb::pb::CMsketch& cmsketch(const StoreRes* msg);
  static void set_has_cmsketch(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_filter_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_region_status(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_last_insert_id(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::baikaldb::pb::RegionRaftStat& region_raft_stat(const StoreRes* msg);
  static void set_has_region_raft_stat(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::baikaldb::pb::ExtraRes& extra_res(const StoreRes* msg);
  static void set_has_extra_res(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::baikaldb::pb::BinlogQueryInfo& binlog_info(const StoreRes* msg);
  static void set_has_binlog_info(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_execute_type(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_read_disk_size(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_orig_region_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::baikaldb::pb::HyperLogLog& hll(const StoreRes* msg);
  static void set_has_hll(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000080) ^ 0x00000080) != 0;
  }
};

const ::baikaldb::pb::CMsketch&
StoreRes::_Internal::cmsketch(const StoreRes* msg) {
  return *msg->cmsketch_;
}
const ::baikaldb::pb::RegionRaftStat&
StoreRes::_Internal::region_raft_stat(const StoreRes* msg) {
  return *msg->region_raft_stat_;
}
const ::baikaldb::pb::ExtraRes&
StoreRes::_Internal::extra_res(const StoreRes* msg) {
  return *msg->extra_res_;
}
const ::baikaldb::pb::BinlogQueryInfo&
StoreRes::_Internal::binlog_info(const StoreRes* msg) {
  return *msg->binlog_info_;
}
const ::baikaldb::pb::HyperLogLog&
StoreRes::_Internal::hll(const StoreRes* msg) {
  return *msg->hll_;
}
void StoreRes::clear_regions() {
  regions_.Clear();
}
void StoreRes::clear_cmsketch() {
  if (cmsketch_ != nullptr) cmsketch_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void StoreRes::clear_hll() {
  if (hll_ != nullptr) hll_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
StoreRes::StoreRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  tuple_ids_(arena),
  row_values_(arena),
  regions_(arena),
  txn_infos_(arena),
  region_leaders_(arena),
  records_(arena),
  binlogs_(arena),
  commit_ts_(arena),
  ttl_timestamp_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.StoreRes)
}
StoreRes::StoreRes(const StoreRes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      tuple_ids_(from.tuple_ids_),
      row_values_(from.row_values_),
      regions_(from.regions_),
      txn_infos_(from.txn_infos_),
      region_leaders_(from.region_leaders_),
      records_(from.records_),
      binlogs_(from.binlogs_),
      commit_ts_(from.commit_ts_),
      ttl_timestamp_(from.ttl_timestamp_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  errmsg_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_errmsg()) {
    errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_errmsg(), 
      GetArenaForAllocation());
  }
  leader_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_leader()) {
    leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_leader(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_cmsketch()) {
    cmsketch_ = new ::baikaldb::pb::CMsketch(*from.cmsketch_);
  } else {
    cmsketch_ = nullptr;
  }
  if (from._internal_has_region_raft_stat()) {
    region_raft_stat_ = new ::baikaldb::pb::RegionRaftStat(*from.region_raft_stat_);
  } else {
    region_raft_stat_ = nullptr;
  }
  if (from._internal_has_extra_res()) {
    extra_res_ = new ::baikaldb::pb::ExtraRes(*from.extra_res_);
  } else {
    extra_res_ = nullptr;
  }
  if (from._internal_has_binlog_info()) {
    binlog_info_ = new ::baikaldb::pb::BinlogQueryInfo(*from.binlog_info_);
  } else {
    binlog_info_ = nullptr;
  }
  if (from._internal_has_hll()) {
    hll_ = new ::baikaldb::pb::HyperLogLog(*from.hll_);
  } else {
    hll_ = nullptr;
  }
  ::memcpy(&errcode_, &from.errcode_,
    static_cast<size_t>(reinterpret_cast<char*>(&orig_region_id_) -
    reinterpret_cast<char*>(&errcode_)) + sizeof(orig_region_id_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.StoreRes)
}

void StoreRes::SharedCtor() {
errmsg_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
leader_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&cmsketch_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&orig_region_id_) -
    reinterpret_cast<char*>(&cmsketch_)) + sizeof(orig_region_id_));
}

StoreRes::~StoreRes() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.StoreRes)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void StoreRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  errmsg_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  leader_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete cmsketch_;
  if (this != internal_default_instance()) delete region_raft_stat_;
  if (this != internal_default_instance()) delete extra_res_;
  if (this != internal_default_instance()) delete binlog_info_;
  if (this != internal_default_instance()) delete hll_;
}

void StoreRes::ArenaDtor(void* object) {
  StoreRes* _this = reinterpret_cast< StoreRes* >(object);
  (void)_this;
}
void StoreRes::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StoreRes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StoreRes::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.StoreRes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tuple_ids_.Clear();
  row_values_.Clear();
  regions_.Clear();
  txn_infos_.Clear();
  region_leaders_.Clear();
  records_.Clear();
  binlogs_.Clear();
  commit_ts_.Clear();
  ttl_timestamp_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      errmsg_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      leader_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(cmsketch_ != nullptr);
      cmsketch_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(region_raft_stat_ != nullptr);
      region_raft_stat_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(extra_res_ != nullptr);
      extra_res_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(binlog_info_ != nullptr);
      binlog_info_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(hll_ != nullptr);
      hll_->Clear();
    }
  }
  errcode_ = 0;
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&last_seq_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&filter_rows_) -
        reinterpret_cast<char*>(&last_seq_id_)) + sizeof(filter_rows_));
  }
  if (cached_has_bits & 0x001f0000u) {
    ::memset(&last_insert_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&orig_region_id_) -
        reinterpret_cast<char*>(&last_insert_id_)) + sizeof(orig_region_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StoreRes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.ErrCode errcode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::ErrCode_IsValid(val))) {
            _internal_set_errcode(static_cast<::baikaldb::pb::ErrCode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes errmsg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_errmsg();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string leader = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_leader();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.StoreRes.leader");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 tuple_ids = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_tuple_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_tuple_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.RowValue row_values = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_row_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 affected_rows = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_affected_rows(&has_bits);
          affected_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.RegionInfo regions = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_regions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 applied_index = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_applied_index(&has_bits);
          applied_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 last_seq_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_last_seq_id(&has_bits);
          last_seq_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.TransactionInfo txn_infos = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_txn_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 mysql_errcode = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_mysql_errcode(&has_bits);
          mysql_errcode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 region_count = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_region_count(&has_bits);
          region_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.RegionLeader region_leaders = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_region_leaders(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool is_merge = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_is_merge(&has_bits);
          is_merge_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.IndexRecords records = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_records(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 scan_rows = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_scan_rows(&has_bits);
          scan_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.CMsketch cmsketch = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_cmsketch(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 filter_rows = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          _Internal::set_has_filter_rows(&has_bits);
          filter_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes binlogs = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_binlogs();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<154>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 commit_ts = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_commit_ts(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<160>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_commit_ts(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.PeerStatus region_status = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 168)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::PeerStatus_IsValid(val))) {
            _internal_set_region_status(static_cast<::baikaldb::pb::PeerStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(21, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 last_insert_id = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 176)) {
          _Internal::set_has_last_insert_id(&has_bits);
          last_insert_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.RegionRaftStat region_raft_stat = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_region_raft_stat(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 ttl_timestamp = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 192)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_ttl_timestamp(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<192>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 194) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_ttl_timestamp(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.ExtraRes extra_res = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_extra_res(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.BinlogQueryInfo binlog_info = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_binlog_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.ExecuteType execute_type = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 216)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::ExecuteType_IsValid(val))) {
            _internal_set_execute_type(static_cast<::baikaldb::pb::ExecuteType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(27, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 read_disk_size = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 224)) {
          _Internal::set_has_read_disk_size(&has_bits);
          read_disk_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 orig_region_id = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 232)) {
          _Internal::set_has_orig_region_id(&has_bits);
          orig_region_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.HyperLogLog hll = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_hll(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StoreRes::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.StoreRes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.ErrCode errcode = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_errcode(), target);
  }

  // optional bytes errmsg = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_errmsg(), target);
  }

  // optional string leader = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_leader().data(), static_cast<int>(this->_internal_leader().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.StoreRes.leader");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_leader(), target);
  }

  // repeated int32 tuple_ids = 4;
  for (int i = 0, n = this->_internal_tuple_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_tuple_ids(i), target);
  }

  // repeated .baikaldb.pb.RowValue row_values = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_row_values_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_row_values(i), target, stream);
  }

  // optional int64 affected_rows = 6;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_affected_rows(), target);
  }

  // repeated .baikaldb.pb.RegionInfo regions = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_regions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_regions(i), target, stream);
  }

  // optional int64 applied_index = 8;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(8, this->_internal_applied_index(), target);
  }

  // optional int32 last_seq_id = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_last_seq_id(), target);
  }

  // repeated .baikaldb.pb.TransactionInfo txn_infos = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_txn_infos_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_txn_infos(i), target, stream);
  }

  // optional int32 mysql_errcode = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_mysql_errcode(), target);
  }

  // optional int64 region_count = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(12, this->_internal_region_count(), target);
  }

  // repeated .baikaldb.pb.RegionLeader region_leaders = 13;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_region_leaders_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, this->_internal_region_leaders(i), target, stream);
  }

  // optional bool is_merge = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_is_merge(), target);
  }

  // repeated .baikaldb.pb.IndexRecords records = 15;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_records_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, this->_internal_records(i), target, stream);
  }

  // optional int64 scan_rows = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(16, this->_internal_scan_rows(), target);
  }

  // optional .baikaldb.pb.CMsketch cmsketch = 17;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        17, _Internal::cmsketch(this), target, stream);
  }

  // optional int64 filter_rows = 18;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(18, this->_internal_filter_rows(), target);
  }

  // repeated bytes binlogs = 19;
  for (int i = 0, n = this->_internal_binlogs_size(); i < n; i++) {
    const auto& s = this->_internal_binlogs(i);
    target = stream->WriteBytes(19, s, target);
  }

  // repeated int64 commit_ts = 20;
  for (int i = 0, n = this->_internal_commit_ts_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(20, this->_internal_commit_ts(i), target);
  }

  // optional .baikaldb.pb.PeerStatus region_status = 21;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      21, this->_internal_region_status(), target);
  }

  // optional int64 last_insert_id = 22;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(22, this->_internal_last_insert_id(), target);
  }

  // optional .baikaldb.pb.RegionRaftStat region_raft_stat = 23;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        23, _Internal::region_raft_stat(this), target, stream);
  }

  // repeated int64 ttl_timestamp = 24;
  for (int i = 0, n = this->_internal_ttl_timestamp_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(24, this->_internal_ttl_timestamp(i), target);
  }

  // optional .baikaldb.pb.ExtraRes extra_res = 25;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        25, _Internal::extra_res(this), target, stream);
  }

  // optional .baikaldb.pb.BinlogQueryInfo binlog_info = 26;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        26, _Internal::binlog_info(this), target, stream);
  }

  // optional .baikaldb.pb.ExecuteType execute_type = 27;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      27, this->_internal_execute_type(), target);
  }

  // optional int64 read_disk_size = 28;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(28, this->_internal_read_disk_size(), target);
  }

  // optional int64 orig_region_id = 29;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(29, this->_internal_orig_region_id(), target);
  }

  // optional .baikaldb.pb.HyperLogLog hll = 30;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        30, _Internal::hll(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.StoreRes)
  return target;
}

size_t StoreRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.StoreRes)
  size_t total_size = 0;

  // required .baikaldb.pb.ErrCode errcode = 1;
  if (_internal_has_errcode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_errcode());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 tuple_ids = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->tuple_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_tuple_ids_size());
    total_size += data_size;
  }

  // repeated .baikaldb.pb.RowValue row_values = 5;
  total_size += 1UL * this->_internal_row_values_size();
  for (const auto& msg : this->row_values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.RegionInfo regions = 7;
  total_size += 1UL * this->_internal_regions_size();
  for (const auto& msg : this->regions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.TransactionInfo txn_infos = 10;
  total_size += 1UL * this->_internal_txn_infos_size();
  for (const auto& msg : this->txn_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.RegionLeader region_leaders = 13;
  total_size += 1UL * this->_internal_region_leaders_size();
  for (const auto& msg : this->region_leaders_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.IndexRecords records = 15;
  total_size += 1UL * this->_internal_records_size();
  for (const auto& msg : this->records_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated bytes binlogs = 19;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(binlogs_.size());
  for (int i = 0, n = binlogs_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      binlogs_.Get(i));
  }

  // repeated int64 commit_ts = 20;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->commit_ts_);
    total_size += 2 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_commit_ts_size());
    total_size += data_size;
  }

  // repeated int64 ttl_timestamp = 24;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->ttl_timestamp_);
    total_size += 2 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_ttl_timestamp_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes errmsg = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_errmsg());
    }

    // optional string leader = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_leader());
    }

    // optional .baikaldb.pb.CMsketch cmsketch = 17;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cmsketch_);
    }

    // optional .baikaldb.pb.RegionRaftStat region_raft_stat = 23;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *region_raft_stat_);
    }

    // optional .baikaldb.pb.ExtraRes extra_res = 25;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *extra_res_);
    }

    // optional .baikaldb.pb.BinlogQueryInfo binlog_info = 26;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *binlog_info_);
    }

    // optional .baikaldb.pb.HyperLogLog hll = 30;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *hll_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 last_seq_id = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_last_seq_id());
    }

    // optional int64 affected_rows = 6;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_affected_rows());
    }

    // optional int64 applied_index = 8;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_applied_index());
    }

    // optional int64 region_count = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_region_count());
    }

    // optional int32 mysql_errcode = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_mysql_errcode());
    }

    // optional bool is_merge = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional int64 scan_rows = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_scan_rows());
    }

    // optional int64 filter_rows = 18;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_filter_rows());
    }

  }
  if (cached_has_bits & 0x001f0000u) {
    // optional int64 last_insert_id = 22;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_last_insert_id());
    }

    // optional .baikaldb.pb.PeerStatus region_status = 21;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_region_status());
    }

    // optional .baikaldb.pb.ExecuteType execute_type = 27;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_execute_type());
    }

    // optional int64 read_disk_size = 28;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_read_disk_size());
    }

    // optional int64 orig_region_id = 29;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_orig_region_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StoreRes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    StoreRes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StoreRes::GetClassData() const { return &_class_data_; }

void StoreRes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<StoreRes *>(to)->MergeFrom(
      static_cast<const StoreRes &>(from));
}


void StoreRes::MergeFrom(const StoreRes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.StoreRes)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  tuple_ids_.MergeFrom(from.tuple_ids_);
  row_values_.MergeFrom(from.row_values_);
  regions_.MergeFrom(from.regions_);
  txn_infos_.MergeFrom(from.txn_infos_);
  region_leaders_.MergeFrom(from.region_leaders_);
  records_.MergeFrom(from.records_);
  binlogs_.MergeFrom(from.binlogs_);
  commit_ts_.MergeFrom(from.commit_ts_);
  ttl_timestamp_.MergeFrom(from.ttl_timestamp_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_errmsg(from._internal_errmsg());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_leader(from._internal_leader());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_cmsketch()->::baikaldb::pb::CMsketch::MergeFrom(from._internal_cmsketch());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_region_raft_stat()->::baikaldb::pb::RegionRaftStat::MergeFrom(from._internal_region_raft_stat());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_extra_res()->::baikaldb::pb::ExtraRes::MergeFrom(from._internal_extra_res());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_binlog_info()->::baikaldb::pb::BinlogQueryInfo::MergeFrom(from._internal_binlog_info());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_hll()->::baikaldb::pb::HyperLogLog::MergeFrom(from._internal_hll());
    }
    if (cached_has_bits & 0x00000080u) {
      errcode_ = from.errcode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      last_seq_id_ = from.last_seq_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      affected_rows_ = from.affected_rows_;
    }
    if (cached_has_bits & 0x00000400u) {
      applied_index_ = from.applied_index_;
    }
    if (cached_has_bits & 0x00000800u) {
      region_count_ = from.region_count_;
    }
    if (cached_has_bits & 0x00001000u) {
      mysql_errcode_ = from.mysql_errcode_;
    }
    if (cached_has_bits & 0x00002000u) {
      is_merge_ = from.is_merge_;
    }
    if (cached_has_bits & 0x00004000u) {
      scan_rows_ = from.scan_rows_;
    }
    if (cached_has_bits & 0x00008000u) {
      filter_rows_ = from.filter_rows_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x001f0000u) {
    if (cached_has_bits & 0x00010000u) {
      last_insert_id_ = from.last_insert_id_;
    }
    if (cached_has_bits & 0x00020000u) {
      region_status_ = from.region_status_;
    }
    if (cached_has_bits & 0x00040000u) {
      execute_type_ = from.execute_type_;
    }
    if (cached_has_bits & 0x00080000u) {
      read_disk_size_ = from.read_disk_size_;
    }
    if (cached_has_bits & 0x00100000u) {
      orig_region_id_ = from.orig_region_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StoreRes::CopyFrom(const StoreRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.StoreRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreRes::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(regions_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(txn_infos_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(region_leaders_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(records_)) return false;
  if (_internal_has_cmsketch()) {
    if (!cmsketch_->IsInitialized()) return false;
  }
  if (_internal_has_extra_res()) {
    if (!extra_res_->IsInitialized()) return false;
  }
  return true;
}

void StoreRes::InternalSwap(StoreRes* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  tuple_ids_.InternalSwap(&other->tuple_ids_);
  row_values_.InternalSwap(&other->row_values_);
  regions_.InternalSwap(&other->regions_);
  txn_infos_.InternalSwap(&other->txn_infos_);
  region_leaders_.InternalSwap(&other->region_leaders_);
  records_.InternalSwap(&other->records_);
  binlogs_.InternalSwap(&other->binlogs_);
  commit_ts_.InternalSwap(&other->commit_ts_);
  ttl_timestamp_.InternalSwap(&other->ttl_timestamp_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &errmsg_, lhs_arena,
      &other->errmsg_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &leader_, lhs_arena,
      &other->leader_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StoreRes, orig_region_id_)
      + sizeof(StoreRes::orig_region_id_)
      - PROTOBUF_FIELD_OFFSET(StoreRes, cmsketch_)>(
          reinterpret_cast<char*>(&cmsketch_),
          reinterpret_cast<char*>(&other->cmsketch_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StoreRes::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[22]);
}

// ===================================================================

class BatchRegionStoreReq::_Internal {
 public:
  using HasBits = decltype(std::declval<BatchRegionStoreReq>()._has_bits_);
  static void set_has_limit_single_store_concurrency(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

void BatchRegionStoreReq::clear_plan() {
  plan_.Clear();
}
BatchRegionStoreReq::BatchRegionStoreReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  store_req_(arena),
  plan_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.BatchRegionStoreReq)
}
BatchRegionStoreReq::BatchRegionStoreReq(const BatchRegionStoreReq& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      store_req_(from.store_req_),
      plan_(from.plan_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  limit_single_store_concurrency_ = from.limit_single_store_concurrency_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.BatchRegionStoreReq)
}

void BatchRegionStoreReq::SharedCtor() {
limit_single_store_concurrency_ = int64_t{0};
}

BatchRegionStoreReq::~BatchRegionStoreReq() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.BatchRegionStoreReq)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BatchRegionStoreReq::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BatchRegionStoreReq::ArenaDtor(void* object) {
  BatchRegionStoreReq* _this = reinterpret_cast< BatchRegionStoreReq* >(object);
  (void)_this;
}
void BatchRegionStoreReq::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BatchRegionStoreReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BatchRegionStoreReq::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.BatchRegionStoreReq)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  store_req_.Clear();
  plan_.Clear();
  limit_single_store_concurrency_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchRegionStoreReq::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .baikaldb.pb.StoreReq store_req = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_store_req(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required int64 limit_single_store_concurrency = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_limit_single_store_concurrency(&has_bits);
          limit_single_store_concurrency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Plan plan = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_plan(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BatchRegionStoreReq::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.BatchRegionStoreReq)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .baikaldb.pb.StoreReq store_req = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_store_req_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_store_req(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // required int64 limit_single_store_concurrency = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_limit_single_store_concurrency(), target);
  }

  // repeated .baikaldb.pb.Plan plan = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_plan_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_plan(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.BatchRegionStoreReq)
  return target;
}

size_t BatchRegionStoreReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.BatchRegionStoreReq)
  size_t total_size = 0;

  // required int64 limit_single_store_concurrency = 2;
  if (_internal_has_limit_single_store_concurrency()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_limit_single_store_concurrency());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.StoreReq store_req = 1;
  total_size += 1UL * this->_internal_store_req_size();
  for (const auto& msg : this->store_req_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.Plan plan = 3;
  total_size += 1UL * this->_internal_plan_size();
  for (const auto& msg : this->plan_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchRegionStoreReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BatchRegionStoreReq::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchRegionStoreReq::GetClassData() const { return &_class_data_; }

void BatchRegionStoreReq::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BatchRegionStoreReq *>(to)->MergeFrom(
      static_cast<const BatchRegionStoreReq &>(from));
}


void BatchRegionStoreReq::MergeFrom(const BatchRegionStoreReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.BatchRegionStoreReq)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  store_req_.MergeFrom(from.store_req_);
  plan_.MergeFrom(from.plan_);
  if (from._internal_has_limit_single_store_concurrency()) {
    _internal_set_limit_single_store_concurrency(from._internal_limit_single_store_concurrency());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchRegionStoreReq::CopyFrom(const BatchRegionStoreReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.BatchRegionStoreReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchRegionStoreReq::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(store_req_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(plan_)) return false;
  return true;
}

void BatchRegionStoreReq::InternalSwap(BatchRegionStoreReq* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  store_req_.InternalSwap(&other->store_req_);
  plan_.InternalSwap(&other->plan_);
  swap(limit_single_store_concurrency_, other->limit_single_store_concurrency_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchRegionStoreReq::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[23]);
}

// ===================================================================

class BatchRegionStoreRes::_Internal {
 public:
};

BatchRegionStoreRes::BatchRegionStoreRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  store_res_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.BatchRegionStoreRes)
}
BatchRegionStoreRes::BatchRegionStoreRes(const BatchRegionStoreRes& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      store_res_(from.store_res_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.BatchRegionStoreRes)
}

void BatchRegionStoreRes::SharedCtor() {
}

BatchRegionStoreRes::~BatchRegionStoreRes() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.BatchRegionStoreRes)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BatchRegionStoreRes::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BatchRegionStoreRes::ArenaDtor(void* object) {
  BatchRegionStoreRes* _this = reinterpret_cast< BatchRegionStoreRes* >(object);
  (void)_this;
}
void BatchRegionStoreRes::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BatchRegionStoreRes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BatchRegionStoreRes::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.BatchRegionStoreRes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  store_res_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BatchRegionStoreRes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .baikaldb.pb.StoreRes store_res = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_store_res(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BatchRegionStoreRes::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.BatchRegionStoreRes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .baikaldb.pb.StoreRes store_res = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_store_res_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_store_res(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.BatchRegionStoreRes)
  return target;
}

size_t BatchRegionStoreRes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.BatchRegionStoreRes)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.StoreRes store_res = 1;
  total_size += 1UL * this->_internal_store_res_size();
  for (const auto& msg : this->store_res_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BatchRegionStoreRes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BatchRegionStoreRes::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BatchRegionStoreRes::GetClassData() const { return &_class_data_; }

void BatchRegionStoreRes::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BatchRegionStoreRes *>(to)->MergeFrom(
      static_cast<const BatchRegionStoreRes &>(from));
}


void BatchRegionStoreRes::MergeFrom(const BatchRegionStoreRes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.BatchRegionStoreRes)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  store_res_.MergeFrom(from.store_res_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BatchRegionStoreRes::CopyFrom(const BatchRegionStoreRes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.BatchRegionStoreRes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BatchRegionStoreRes::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(store_res_)) return false;
  return true;
}

void BatchRegionStoreRes::InternalSwap(BatchRegionStoreRes* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  store_res_.InternalSwap(&other->store_res_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BatchRegionStoreRes::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[24]);
}

// ===================================================================

class InitRegion::_Internal {
 public:
  using HasBits = decltype(std::declval<InitRegion>()._has_bits_);
  static const ::baikaldb::pb::RegionInfo& region_info(const InitRegion* msg);
  static void set_has_region_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::baikaldb::pb::SchemaInfo& schema_info(const InitRegion* msg);
  static void set_has_schema_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_split(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_snapshot_times(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_learner(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::baikaldb::pb::RegionInfo&
InitRegion::_Internal::region_info(const InitRegion* msg) {
  return *msg->region_info_;
}
const ::baikaldb::pb::SchemaInfo&
InitRegion::_Internal::schema_info(const InitRegion* msg) {
  return *msg->schema_info_;
}
void InitRegion::clear_region_info() {
  if (region_info_ != nullptr) region_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void InitRegion::clear_schema_info() {
  if (schema_info_ != nullptr) schema_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
InitRegion::InitRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.InitRegion)
}
InitRegion::InitRegion(const InitRegion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_region_info()) {
    region_info_ = new ::baikaldb::pb::RegionInfo(*from.region_info_);
  } else {
    region_info_ = nullptr;
  }
  if (from._internal_has_schema_info()) {
    schema_info_ = new ::baikaldb::pb::SchemaInfo(*from.schema_info_);
  } else {
    schema_info_ = nullptr;
  }
  ::memcpy(&snapshot_times_, &from.snapshot_times_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_learner_) -
    reinterpret_cast<char*>(&snapshot_times_)) + sizeof(is_learner_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.InitRegion)
}

void InitRegion::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&region_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_learner_) -
    reinterpret_cast<char*>(&region_info_)) + sizeof(is_learner_));
}

InitRegion::~InitRegion() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.InitRegion)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void InitRegion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete region_info_;
  if (this != internal_default_instance()) delete schema_info_;
}

void InitRegion::ArenaDtor(void* object) {
  InitRegion* _this = reinterpret_cast< InitRegion* >(object);
  (void)_this;
}
void InitRegion::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InitRegion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InitRegion::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.InitRegion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(region_info_ != nullptr);
      region_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(schema_info_ != nullptr);
      schema_info_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&snapshot_times_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_learner_) -
        reinterpret_cast<char*>(&snapshot_times_)) + sizeof(is_learner_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InitRegion::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.RegionInfo region_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_region_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.SchemaInfo schema_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_schema_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_split = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_is_split(&has_bits);
          is_split_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 snapshot_times = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_snapshot_times(&has_bits);
          snapshot_times_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_learner = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_is_learner(&has_bits);
          is_learner_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* InitRegion::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.InitRegion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.RegionInfo region_info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::region_info(this), target, stream);
  }

  // optional .baikaldb.pb.SchemaInfo schema_info = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::schema_info(this), target, stream);
  }

  // optional bool is_split = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_is_split(), target);
  }

  // optional int32 snapshot_times = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_snapshot_times(), target);
  }

  // optional bool is_learner = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_is_learner(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.InitRegion)
  return target;
}

size_t InitRegion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.InitRegion)
  size_t total_size = 0;

  // required .baikaldb.pb.RegionInfo region_info = 1;
  if (_internal_has_region_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *region_info_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional .baikaldb.pb.SchemaInfo schema_info = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *schema_info_);
    }

    // optional int32 snapshot_times = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_snapshot_times());
    }

    // optional bool is_split = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool is_learner = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InitRegion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    InitRegion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InitRegion::GetClassData() const { return &_class_data_; }

void InitRegion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<InitRegion *>(to)->MergeFrom(
      static_cast<const InitRegion &>(from));
}


void InitRegion::MergeFrom(const InitRegion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.InitRegion)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_region_info()->::baikaldb::pb::RegionInfo::MergeFrom(from._internal_region_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_schema_info()->::baikaldb::pb::SchemaInfo::MergeFrom(from._internal_schema_info());
    }
    if (cached_has_bits & 0x00000004u) {
      snapshot_times_ = from.snapshot_times_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_split_ = from.is_split_;
    }
    if (cached_has_bits & 0x00000010u) {
      is_learner_ = from.is_learner_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InitRegion::CopyFrom(const InitRegion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.InitRegion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitRegion::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_region_info()) {
    if (!region_info_->IsInitialized()) return false;
  }
  if (_internal_has_schema_info()) {
    if (!schema_info_->IsInitialized()) return false;
  }
  return true;
}

void InitRegion::InternalSwap(InitRegion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InitRegion, is_learner_)
      + sizeof(InitRegion::is_learner_)
      - PROTOBUF_FIELD_OFFSET(InitRegion, region_info_)>(
          reinterpret_cast<char*>(&region_info_),
          reinterpret_cast<char*>(&other->region_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InitRegion::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[25]);
}

// ===================================================================

class GetAppliedIndex::_Internal {
 public:
  using HasBits = decltype(std::declval<GetAppliedIndex>()._has_bits_);
  static void set_has_region_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_use_read_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_use_raft_log_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

GetAppliedIndex::GetAppliedIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.GetAppliedIndex)
}
GetAppliedIndex::GetAppliedIndex(const GetAppliedIndex& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&region_id_, &from.region_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&use_raft_log_index_) -
    reinterpret_cast<char*>(&region_id_)) + sizeof(use_raft_log_index_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.GetAppliedIndex)
}

void GetAppliedIndex::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&region_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&use_raft_log_index_) -
    reinterpret_cast<char*>(&region_id_)) + sizeof(use_raft_log_index_));
}

GetAppliedIndex::~GetAppliedIndex() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.GetAppliedIndex)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetAppliedIndex::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetAppliedIndex::ArenaDtor(void* object) {
  GetAppliedIndex* _this = reinterpret_cast< GetAppliedIndex* >(object);
  (void)_this;
}
void GetAppliedIndex::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetAppliedIndex::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetAppliedIndex::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.GetAppliedIndex)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&region_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&use_raft_log_index_) -
        reinterpret_cast<char*>(&region_id_)) + sizeof(use_raft_log_index_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetAppliedIndex::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 region_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_region_id(&has_bits);
          region_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_read_idx = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_use_read_idx(&has_bits);
          use_read_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_raft_log_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_use_raft_log_index(&has_bits);
          use_raft_log_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetAppliedIndex::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.GetAppliedIndex)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 region_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_region_id(), target);
  }

  // optional bool use_read_idx = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_use_read_idx(), target);
  }

  // optional bool use_raft_log_index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_use_raft_log_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.GetAppliedIndex)
  return target;
}

size_t GetAppliedIndex::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.GetAppliedIndex)
  size_t total_size = 0;

  // required int64 region_id = 1;
  if (_internal_has_region_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_region_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional bool use_read_idx = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool use_raft_log_index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetAppliedIndex::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetAppliedIndex::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetAppliedIndex::GetClassData() const { return &_class_data_; }

void GetAppliedIndex::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetAppliedIndex *>(to)->MergeFrom(
      static_cast<const GetAppliedIndex &>(from));
}


void GetAppliedIndex::MergeFrom(const GetAppliedIndex& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.GetAppliedIndex)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      region_id_ = from.region_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      use_read_idx_ = from.use_read_idx_;
    }
    if (cached_has_bits & 0x00000004u) {
      use_raft_log_index_ = from.use_raft_log_index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetAppliedIndex::CopyFrom(const GetAppliedIndex& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.GetAppliedIndex)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAppliedIndex::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GetAppliedIndex::InternalSwap(GetAppliedIndex* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetAppliedIndex, use_raft_log_index_)
      + sizeof(GetAppliedIndex::use_raft_log_index_)
      - PROTOBUF_FIELD_OFFSET(GetAppliedIndex, region_id_)>(
          reinterpret_cast<char*>(&region_id_),
          reinterpret_cast<char*>(&other->region_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetAppliedIndex::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[26]);
}

// ===================================================================

class RemoveRegion::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoveRegion>()._has_bits_);
  static void set_has_region_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_force(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_need_delay_drop(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

RemoveRegion::RemoveRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.RemoveRegion)
}
RemoveRegion::RemoveRegion(const RemoveRegion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&region_id_, &from.region_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&need_delay_drop_) -
    reinterpret_cast<char*>(&region_id_)) + sizeof(need_delay_drop_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.RemoveRegion)
}

void RemoveRegion::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&region_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&need_delay_drop_) -
    reinterpret_cast<char*>(&region_id_)) + sizeof(need_delay_drop_));
}

RemoveRegion::~RemoveRegion() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.RemoveRegion)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RemoveRegion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RemoveRegion::ArenaDtor(void* object) {
  RemoveRegion* _this = reinterpret_cast< RemoveRegion* >(object);
  (void)_this;
}
void RemoveRegion::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RemoveRegion::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RemoveRegion::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.RemoveRegion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&region_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&need_delay_drop_) -
        reinterpret_cast<char*>(&region_id_)) + sizeof(need_delay_drop_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoveRegion::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 region_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_region_id(&has_bits);
          region_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool force = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_force(&has_bits);
          force_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool need_delay_drop = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_need_delay_drop(&has_bits);
          need_delay_drop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RemoveRegion::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.RemoveRegion)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 region_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_region_id(), target);
  }

  // optional bool force = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_force(), target);
  }

  // optional bool need_delay_drop = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_need_delay_drop(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.RemoveRegion)
  return target;
}

size_t RemoveRegion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.RemoveRegion)
  size_t total_size = 0;

  // required int64 region_id = 1;
  if (_internal_has_region_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_region_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional bool force = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool need_delay_drop = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoveRegion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RemoveRegion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoveRegion::GetClassData() const { return &_class_data_; }

void RemoveRegion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RemoveRegion *>(to)->MergeFrom(
      static_cast<const RemoveRegion &>(from));
}


void RemoveRegion::MergeFrom(const RemoveRegion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.RemoveRegion)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      region_id_ = from.region_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      force_ = from.force_;
    }
    if (cached_has_bits & 0x00000004u) {
      need_delay_drop_ = from.need_delay_drop_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoveRegion::CopyFrom(const RemoveRegion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.RemoveRegion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoveRegion::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RemoveRegion::InternalSwap(RemoveRegion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RemoveRegion, need_delay_drop_)
      + sizeof(RemoveRegion::need_delay_drop_)
      - PROTOBUF_FIELD_OFFSET(RemoveRegion, region_id_)>(
          reinterpret_cast<char*>(&region_id_),
          reinterpret_cast<char*>(&other->region_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoveRegion::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[27]);
}

// ===================================================================

class RegionIds::_Internal {
 public:
  using HasBits = decltype(std::declval<RegionIds>()._has_bits_);
  static void set_has_compact_raft_log(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_compact_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_clear_all_txns(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_txn_timeout(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_query_apply_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_query_all_afs_file(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_query_olap_keypoint(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

RegionIds::RegionIds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  region_ids_(arena),
  userids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.RegionIds)
}
RegionIds::RegionIds(const RegionIds& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      region_ids_(from.region_ids_),
      userids_(from.userids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&table_id_, &from.table_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&query_olap_keypoint_) -
    reinterpret_cast<char*>(&table_id_)) + sizeof(query_olap_keypoint_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.RegionIds)
}

void RegionIds::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&table_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&query_olap_keypoint_) -
    reinterpret_cast<char*>(&table_id_)) + sizeof(query_olap_keypoint_));
}

RegionIds::~RegionIds() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.RegionIds)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RegionIds::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RegionIds::ArenaDtor(void* object) {
  RegionIds* _this = reinterpret_cast< RegionIds* >(object);
  (void)_this;
}
void RegionIds::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RegionIds::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RegionIds::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.RegionIds)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  region_ids_.Clear();
  userids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&table_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&query_olap_keypoint_) -
        reinterpret_cast<char*>(&table_id_)) + sizeof(query_olap_keypoint_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RegionIds::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 region_ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_region_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_region_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool compact_raft_log = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_compact_raft_log(&has_bits);
          compact_raft_log_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 table_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_table_id(&has_bits);
          table_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 compact_type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_compact_type(&has_bits);
          compact_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool clear_all_txns = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_clear_all_txns(&has_bits);
          clear_all_txns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 txn_timeout = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_txn_timeout(&has_bits);
          txn_timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool query_apply_index = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_query_apply_index(&has_bits);
          query_apply_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 userids = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_userids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_userids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool query_all_afs_file = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_query_all_afs_file(&has_bits);
          query_all_afs_file_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool query_olap_keypoint = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_query_olap_keypoint(&has_bits);
          query_olap_keypoint_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RegionIds::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.RegionIds)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 region_ids = 1;
  for (int i = 0, n = this->_internal_region_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_region_ids(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool compact_raft_log = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_compact_raft_log(), target);
  }

  // optional int64 table_id = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_table_id(), target);
  }

  // optional int32 compact_type = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_compact_type(), target);
  }

  // optional bool clear_all_txns = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_clear_all_txns(), target);
  }

  // optional int64 txn_timeout = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_txn_timeout(), target);
  }

  // optional bool query_apply_index = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_query_apply_index(), target);
  }

  // repeated int64 userids = 8;
  for (int i = 0, n = this->_internal_userids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(8, this->_internal_userids(i), target);
  }

  // optional bool query_all_afs_file = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_query_all_afs_file(), target);
  }

  // optional bool query_olap_keypoint = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_query_olap_keypoint(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.RegionIds)
  return target;
}

size_t RegionIds::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.RegionIds)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 region_ids = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->region_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_region_ids_size());
    total_size += data_size;
  }

  // repeated int64 userids = 8;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->userids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_userids_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int64 table_id = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_table_id());
    }

    // optional int32 compact_type = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_compact_type());
    }

    // optional bool compact_raft_log = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool clear_all_txns = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool query_apply_index = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool query_all_afs_file = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional int64 txn_timeout = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_txn_timeout());
    }

    // optional bool query_olap_keypoint = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RegionIds::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RegionIds::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RegionIds::GetClassData() const { return &_class_data_; }

void RegionIds::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RegionIds *>(to)->MergeFrom(
      static_cast<const RegionIds &>(from));
}


void RegionIds::MergeFrom(const RegionIds& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.RegionIds)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  region_ids_.MergeFrom(from.region_ids_);
  userids_.MergeFrom(from.userids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      table_id_ = from.table_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      compact_type_ = from.compact_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      compact_raft_log_ = from.compact_raft_log_;
    }
    if (cached_has_bits & 0x00000008u) {
      clear_all_txns_ = from.clear_all_txns_;
    }
    if (cached_has_bits & 0x00000010u) {
      query_apply_index_ = from.query_apply_index_;
    }
    if (cached_has_bits & 0x00000020u) {
      query_all_afs_file_ = from.query_all_afs_file_;
    }
    if (cached_has_bits & 0x00000040u) {
      txn_timeout_ = from.txn_timeout_;
    }
    if (cached_has_bits & 0x00000080u) {
      query_olap_keypoint_ = from.query_olap_keypoint_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RegionIds::CopyFrom(const RegionIds& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.RegionIds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegionIds::IsInitialized() const {
  return true;
}

void RegionIds::InternalSwap(RegionIds* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  region_ids_.InternalSwap(&other->region_ids_);
  userids_.InternalSwap(&other->userids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RegionIds, query_olap_keypoint_)
      + sizeof(RegionIds::query_olap_keypoint_)
      - PROTOBUF_FIELD_OFFSET(RegionIds, table_id_)>(
          reinterpret_cast<char*>(&table_id_),
          reinterpret_cast<char*>(&other->table_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RegionIds::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[28]);
}

// ===================================================================

class BackUpReq::_Internal {
 public:
};

BackUpReq::BackUpReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.BackUpReq)
}
BackUpReq::BackUpReq(const BackUpReq& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.BackUpReq)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BackUpReq::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BackUpReq::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata BackUpReq::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[29]);
}

// ===================================================================

class BackUpRes::_Internal {
 public:
};

BackUpRes::BackUpRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.BackUpRes)
}
BackUpRes::BackUpRes(const BackUpRes& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.BackUpRes)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BackUpRes::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BackUpRes::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata BackUpRes::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[30]);
}

// ===================================================================

class BackupRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<BackupRequest>()._has_bits_);
  static void set_has_region_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_log_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_backup_op(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ingest_store_latest_sst(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_data_sst_to_process_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_row_size(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_streaming_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

BackupRequest::BackupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.BackupRequest)
}
BackupRequest::BackupRequest(const BackupRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&region_id_, &from.region_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&streaming_id_) -
    reinterpret_cast<char*>(&region_id_)) + sizeof(streaming_id_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.BackupRequest)
}

void BackupRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&region_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&streaming_id_) -
    reinterpret_cast<char*>(&region_id_)) + sizeof(streaming_id_));
}

BackupRequest::~BackupRequest() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.BackupRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BackupRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BackupRequest::ArenaDtor(void* object) {
  BackupRequest* _this = reinterpret_cast< BackupRequest* >(object);
  (void)_this;
}
void BackupRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BackupRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BackupRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.BackupRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&region_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&streaming_id_) -
        reinterpret_cast<char*>(&region_id_)) + sizeof(streaming_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BackupRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 region_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_region_id(&has_bits);
          region_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 log_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_log_index(&has_bits);
          log_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.BackupOp backup_op = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::BackupOp_IsValid(val))) {
            _internal_set_backup_op(static_cast<::baikaldb::pb::BackupOp>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool ingest_store_latest_sst = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_ingest_store_latest_sst(&has_bits);
          ingest_store_latest_sst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 data_sst_to_process_size = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_data_sst_to_process_size(&has_bits);
          data_sst_to_process_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 row_size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_row_size(&has_bits);
          row_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 streaming_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_streaming_id(&has_bits);
          streaming_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BackupRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.BackupRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 region_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_region_id(), target);
  }

  // optional int64 log_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_log_index(), target);
  }

  // optional .baikaldb.pb.BackupOp backup_op = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_backup_op(), target);
  }

  // optional bool ingest_store_latest_sst = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_ingest_store_latest_sst(), target);
  }

  // optional int64 data_sst_to_process_size = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_data_sst_to_process_size(), target);
  }

  // optional int64 row_size = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_row_size(), target);
  }

  // optional uint64 streaming_id = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(7, this->_internal_streaming_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.BackupRequest)
  return target;
}

size_t BackupRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.BackupRequest)
  size_t total_size = 0;

  // required int64 region_id = 1;
  if (_internal_has_region_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_region_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007eu) {
    // optional int64 log_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_log_index());
    }

    // optional .baikaldb.pb.BackupOp backup_op = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_backup_op());
    }

    // optional bool ingest_store_latest_sst = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional int64 data_sst_to_process_size = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_data_sst_to_process_size());
    }

    // optional int64 row_size = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_row_size());
    }

    // optional uint64 streaming_id = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_streaming_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BackupRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BackupRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BackupRequest::GetClassData() const { return &_class_data_; }

void BackupRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BackupRequest *>(to)->MergeFrom(
      static_cast<const BackupRequest &>(from));
}


void BackupRequest::MergeFrom(const BackupRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.BackupRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      region_id_ = from.region_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      log_index_ = from.log_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      backup_op_ = from.backup_op_;
    }
    if (cached_has_bits & 0x00000008u) {
      ingest_store_latest_sst_ = from.ingest_store_latest_sst_;
    }
    if (cached_has_bits & 0x00000010u) {
      data_sst_to_process_size_ = from.data_sst_to_process_size_;
    }
    if (cached_has_bits & 0x00000020u) {
      row_size_ = from.row_size_;
    }
    if (cached_has_bits & 0x00000040u) {
      streaming_id_ = from.streaming_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BackupRequest::CopyFrom(const BackupRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.BackupRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BackupRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void BackupRequest::InternalSwap(BackupRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BackupRequest, streaming_id_)
      + sizeof(BackupRequest::streaming_id_)
      - PROTOBUF_FIELD_OFFSET(BackupRequest, region_id_)>(
          reinterpret_cast<char*>(&region_id_),
          reinterpret_cast<char*>(&other->region_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BackupRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[31]);
}

// ===================================================================

class BackupResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<BackupResponse>()._has_bits_);
  static void set_has_log_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_errcode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_leader(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_streaming_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_streaming_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

BackupResponse::BackupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  peers_(arena),
  unstable_followers_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.BackupResponse)
}
BackupResponse::BackupResponse(const BackupResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      peers_(from.peers_),
      unstable_followers_(from.unstable_followers_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  leader_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_leader()) {
    leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_leader(), 
      GetArenaForAllocation());
  }
  ::memcpy(&log_index_, &from.log_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&streaming_id_) -
    reinterpret_cast<char*>(&log_index_)) + sizeof(streaming_id_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.BackupResponse)
}

void BackupResponse::SharedCtor() {
leader_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&log_index_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&streaming_id_) -
    reinterpret_cast<char*>(&log_index_)) + sizeof(streaming_id_));
}

BackupResponse::~BackupResponse() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.BackupResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BackupResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  leader_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BackupResponse::ArenaDtor(void* object) {
  BackupResponse* _this = reinterpret_cast< BackupResponse* >(object);
  (void)_this;
}
void BackupResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BackupResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BackupResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.BackupResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  peers_.Clear();
  unstable_followers_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    leader_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&log_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&streaming_id_) -
        reinterpret_cast<char*>(&log_index_)) + sizeof(streaming_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BackupResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 log_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_log_index(&has_bits);
          log_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.ErrCode errcode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::ErrCode_IsValid(val))) {
            _internal_set_errcode(static_cast<::baikaldb::pb::ErrCode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string leader = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_leader();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.BackupResponse.leader");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string peers = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_peers();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.BackupResponse.peers");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string unstable_followers = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_unstable_followers();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.BackupResponse.unstable_followers");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 streaming_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_streaming_id(&has_bits);
          streaming_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.StreamState streaming_state = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::StreamState_IsValid(val))) {
            _internal_set_streaming_state(static_cast<::baikaldb::pb::StreamState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BackupResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.BackupResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 log_index = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_log_index(), target);
  }

  // optional .baikaldb.pb.ErrCode errcode = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_errcode(), target);
  }

  // optional string leader = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_leader().data(), static_cast<int>(this->_internal_leader().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.BackupResponse.leader");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_leader(), target);
  }

  // repeated string peers = 4;
  for (int i = 0, n = this->_internal_peers_size(); i < n; i++) {
    const auto& s = this->_internal_peers(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.BackupResponse.peers");
    target = stream->WriteString(4, s, target);
  }

  // repeated string unstable_followers = 5;
  for (int i = 0, n = this->_internal_unstable_followers_size(); i < n; i++) {
    const auto& s = this->_internal_unstable_followers(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.BackupResponse.unstable_followers");
    target = stream->WriteString(5, s, target);
  }

  // optional uint64 streaming_id = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_streaming_id(), target);
  }

  // optional .baikaldb.pb.StreamState streaming_state = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_streaming_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.BackupResponse)
  return target;
}

size_t BackupResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.BackupResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string peers = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(peers_.size());
  for (int i = 0, n = peers_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      peers_.Get(i));
  }

  // repeated string unstable_followers = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(unstable_followers_.size());
  for (int i = 0, n = unstable_followers_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      unstable_followers_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string leader = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_leader());
    }

    // optional int64 log_index = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_log_index());
    }

    // optional .baikaldb.pb.ErrCode errcode = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_errcode());
    }

    // optional .baikaldb.pb.StreamState streaming_state = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_streaming_state());
    }

    // optional uint64 streaming_id = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_streaming_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BackupResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BackupResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BackupResponse::GetClassData() const { return &_class_data_; }

void BackupResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BackupResponse *>(to)->MergeFrom(
      static_cast<const BackupResponse &>(from));
}


void BackupResponse::MergeFrom(const BackupResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.BackupResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  peers_.MergeFrom(from.peers_);
  unstable_followers_.MergeFrom(from.unstable_followers_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_leader(from._internal_leader());
    }
    if (cached_has_bits & 0x00000002u) {
      log_index_ = from.log_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      errcode_ = from.errcode_;
    }
    if (cached_has_bits & 0x00000008u) {
      streaming_state_ = from.streaming_state_;
    }
    if (cached_has_bits & 0x00000010u) {
      streaming_id_ = from.streaming_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BackupResponse::CopyFrom(const BackupResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.BackupResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BackupResponse::IsInitialized() const {
  return true;
}

void BackupResponse::InternalSwap(BackupResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  peers_.InternalSwap(&other->peers_);
  unstable_followers_.InternalSwap(&other->unstable_followers_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &leader_, lhs_arena,
      &other->leader_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BackupResponse, streaming_id_)
      + sizeof(BackupResponse::streaming_id_)
      - PROTOBUF_FIELD_OFFSET(BackupResponse, log_index_)>(
          reinterpret_cast<char*>(&log_index_),
          reinterpret_cast<char*>(&other->log_index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BackupResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[32]);
}

// ===================================================================

class HealthCheck::_Internal {
 public:
};

HealthCheck::HealthCheck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.HealthCheck)
}
HealthCheck::HealthCheck(const HealthCheck& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.HealthCheck)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HealthCheck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HealthCheck::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata HealthCheck::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[33]);
}

// ===================================================================

class OlapRegionIndexInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<OlapRegionIndexInfo>()._has_bits_);
  static void set_has_index_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

OlapRegionIndexInfo::OlapRegionIndexInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  external_path_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.OlapRegionIndexInfo)
}
OlapRegionIndexInfo::OlapRegionIndexInfo(const OlapRegionIndexInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      external_path_(from.external_path_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&index_id_, &from.index_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&state_) -
    reinterpret_cast<char*>(&index_id_)) + sizeof(state_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.OlapRegionIndexInfo)
}

void OlapRegionIndexInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&index_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&state_) -
    reinterpret_cast<char*>(&index_id_)) + sizeof(state_));
}

OlapRegionIndexInfo::~OlapRegionIndexInfo() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.OlapRegionIndexInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void OlapRegionIndexInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void OlapRegionIndexInfo::ArenaDtor(void* object) {
  OlapRegionIndexInfo* _this = reinterpret_cast< OlapRegionIndexInfo* >(object);
  (void)_this;
}
void OlapRegionIndexInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void OlapRegionIndexInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OlapRegionIndexInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.OlapRegionIndexInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  external_path_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&index_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&state_) -
        reinterpret_cast<char*>(&index_id_)) + sizeof(state_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OlapRegionIndexInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 index_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_index_id(&has_bits);
          index_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string external_path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_external_path();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.OlapRegionIndexInfo.external_path");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.OlapRegionStat state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::OlapRegionStat_IsValid(val))) {
            _internal_set_state(static_cast<::baikaldb::pb::OlapRegionStat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* OlapRegionIndexInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.OlapRegionIndexInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 index_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_index_id(), target);
  }

  // repeated string external_path = 2;
  for (int i = 0, n = this->_internal_external_path_size(); i < n; i++) {
    const auto& s = this->_internal_external_path(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.OlapRegionIndexInfo.external_path");
    target = stream->WriteString(2, s, target);
  }

  // optional .baikaldb.pb.OlapRegionStat state = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.OlapRegionIndexInfo)
  return target;
}

size_t OlapRegionIndexInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.OlapRegionIndexInfo)
  size_t total_size = 0;

  // required int64 index_id = 1;
  if (_internal_has_index_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_index_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string external_path = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(external_path_.size());
  for (int i = 0, n = external_path_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      external_path_.Get(i));
  }

  // optional .baikaldb.pb.OlapRegionStat state = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_state());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OlapRegionIndexInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    OlapRegionIndexInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OlapRegionIndexInfo::GetClassData() const { return &_class_data_; }

void OlapRegionIndexInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<OlapRegionIndexInfo *>(to)->MergeFrom(
      static_cast<const OlapRegionIndexInfo &>(from));
}


void OlapRegionIndexInfo::MergeFrom(const OlapRegionIndexInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.OlapRegionIndexInfo)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  external_path_.MergeFrom(from.external_path_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      index_id_ = from.index_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      state_ = from.state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OlapRegionIndexInfo::CopyFrom(const OlapRegionIndexInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.OlapRegionIndexInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OlapRegionIndexInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void OlapRegionIndexInfo::InternalSwap(OlapRegionIndexInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  external_path_.InternalSwap(&other->external_path_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OlapRegionIndexInfo, state_)
      + sizeof(OlapRegionIndexInfo::state_)
      - PROTOBUF_FIELD_OFFSET(OlapRegionIndexInfo, index_id_)>(
          reinterpret_cast<char*>(&index_id_),
          reinterpret_cast<char*>(&other->index_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OlapRegionIndexInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[34]);
}

// ===================================================================

class OlapRegionInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<OlapRegionInfo>()._has_bits_);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_state_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::baikaldb::pb::OlapRegionIndexInfo& new_olap_index_info(const OlapRegionInfo* msg);
  static void set_has_new_olap_index_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

const ::baikaldb::pb::OlapRegionIndexInfo&
OlapRegionInfo::_Internal::new_olap_index_info(const OlapRegionInfo* msg) {
  return *msg->new_olap_index_info_;
}
OlapRegionInfo::OlapRegionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  external_full_path_(arena),
  olap_index_info_list_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.OlapRegionInfo)
}
OlapRegionInfo::OlapRegionInfo(const OlapRegionInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      external_full_path_(from.external_full_path_),
      olap_index_info_list_(from.olap_index_info_list_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_new_olap_index_info()) {
    new_olap_index_info_ = new ::baikaldb::pb::OlapRegionIndexInfo(*from.new_olap_index_info_);
  } else {
    new_olap_index_info_ = nullptr;
  }
  ::memcpy(&state_time_, &from.state_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&state_) -
    reinterpret_cast<char*>(&state_time_)) + sizeof(state_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.OlapRegionInfo)
}

void OlapRegionInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&new_olap_index_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&state_) -
    reinterpret_cast<char*>(&new_olap_index_info_)) + sizeof(state_));
}

OlapRegionInfo::~OlapRegionInfo() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.OlapRegionInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void OlapRegionInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete new_olap_index_info_;
}

void OlapRegionInfo::ArenaDtor(void* object) {
  OlapRegionInfo* _this = reinterpret_cast< OlapRegionInfo* >(object);
  (void)_this;
}
void OlapRegionInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void OlapRegionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void OlapRegionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.OlapRegionInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  external_full_path_.Clear();
  olap_index_info_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(new_olap_index_info_ != nullptr);
    new_olap_index_info_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&state_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&state_) -
        reinterpret_cast<char*>(&state_time_)) + sizeof(state_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OlapRegionInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.OlapRegionStat state = 1 [default = OLAP_ACTIVE];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::OlapRegionStat_IsValid(val))) {
            _internal_set_state(static_cast<::baikaldb::pb::OlapRegionStat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 state_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_state_time(&has_bits);
          state_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string external_full_path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_external_full_path();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.OlapRegionInfo.external_full_path");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.OlapRegionIndexInfo olap_index_info_list = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_olap_index_info_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.OlapRegionIndexInfo new_olap_index_info = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_olap_index_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* OlapRegionInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.OlapRegionInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.OlapRegionStat state = 1 [default = OLAP_ACTIVE];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  // optional uint64 state_time = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_state_time(), target);
  }

  // repeated string external_full_path = 3;
  for (int i = 0, n = this->_internal_external_full_path_size(); i < n; i++) {
    const auto& s = this->_internal_external_full_path(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.OlapRegionInfo.external_full_path");
    target = stream->WriteString(3, s, target);
  }

  // repeated .baikaldb.pb.OlapRegionIndexInfo olap_index_info_list = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_olap_index_info_list_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_olap_index_info_list(i), target, stream);
  }

  // optional .baikaldb.pb.OlapRegionIndexInfo new_olap_index_info = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::new_olap_index_info(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.OlapRegionInfo)
  return target;
}

size_t OlapRegionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.OlapRegionInfo)
  size_t total_size = 0;

  // required .baikaldb.pb.OlapRegionStat state = 1 [default = OLAP_ACTIVE];
  if (_internal_has_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_state());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string external_full_path = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(external_full_path_.size());
  for (int i = 0, n = external_full_path_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      external_full_path_.Get(i));
  }

  // repeated .baikaldb.pb.OlapRegionIndexInfo olap_index_info_list = 4;
  total_size += 1UL * this->_internal_olap_index_info_list_size();
  for (const auto& msg : this->olap_index_info_list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .baikaldb.pb.OlapRegionIndexInfo new_olap_index_info = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *new_olap_index_info_);
    }

    // optional uint64 state_time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_state_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData OlapRegionInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    OlapRegionInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*OlapRegionInfo::GetClassData() const { return &_class_data_; }

void OlapRegionInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<OlapRegionInfo *>(to)->MergeFrom(
      static_cast<const OlapRegionInfo &>(from));
}


void OlapRegionInfo::MergeFrom(const OlapRegionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.OlapRegionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  external_full_path_.MergeFrom(from.external_full_path_);
  olap_index_info_list_.MergeFrom(from.olap_index_info_list_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_new_olap_index_info()->::baikaldb::pb::OlapRegionIndexInfo::MergeFrom(from._internal_new_olap_index_info());
    }
    if (cached_has_bits & 0x00000002u) {
      state_time_ = from.state_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      state_ = from.state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void OlapRegionInfo::CopyFrom(const OlapRegionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.OlapRegionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OlapRegionInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(olap_index_info_list_)) return false;
  if (_internal_has_new_olap_index_info()) {
    if (!new_olap_index_info_->IsInitialized()) return false;
  }
  return true;
}

void OlapRegionInfo::InternalSwap(OlapRegionInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  external_full_path_.InternalSwap(&other->external_full_path_);
  olap_index_info_list_.InternalSwap(&other->olap_index_info_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OlapRegionInfo, state_)
      + sizeof(OlapRegionInfo::state_)
      - PROTOBUF_FIELD_OFFSET(OlapRegionInfo, new_olap_index_info_)>(
          reinterpret_cast<char*>(&new_olap_index_info_),
          reinterpret_cast<char*>(&other->new_olap_index_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OlapRegionInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[35]);
}

// ===================================================================

class RegionOfflineBinlogInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<RegionOfflineBinlogInfo>()._has_bits_);
  static void set_has_oldest_ts(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_newest_ts(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_task_start_ts(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_task_end_ts(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

RegionOfflineBinlogInfo::RegionOfflineBinlogInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  external_full_path_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.RegionOfflineBinlogInfo)
}
RegionOfflineBinlogInfo::RegionOfflineBinlogInfo(const RegionOfflineBinlogInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      external_full_path_(from.external_full_path_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&oldest_ts_, &from.oldest_ts_,
    static_cast<size_t>(reinterpret_cast<char*>(&task_end_ts_) -
    reinterpret_cast<char*>(&oldest_ts_)) + sizeof(task_end_ts_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.RegionOfflineBinlogInfo)
}

void RegionOfflineBinlogInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&oldest_ts_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&task_end_ts_) -
    reinterpret_cast<char*>(&oldest_ts_)) + sizeof(task_end_ts_));
}

RegionOfflineBinlogInfo::~RegionOfflineBinlogInfo() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.RegionOfflineBinlogInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void RegionOfflineBinlogInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RegionOfflineBinlogInfo::ArenaDtor(void* object) {
  RegionOfflineBinlogInfo* _this = reinterpret_cast< RegionOfflineBinlogInfo* >(object);
  (void)_this;
}
void RegionOfflineBinlogInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RegionOfflineBinlogInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RegionOfflineBinlogInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.RegionOfflineBinlogInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  external_full_path_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&oldest_ts_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&task_end_ts_) -
        reinterpret_cast<char*>(&oldest_ts_)) + sizeof(task_end_ts_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RegionOfflineBinlogInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 oldest_ts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_oldest_ts(&has_bits);
          oldest_ts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 newest_ts = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_newest_ts(&has_bits);
          newest_ts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 task_start_ts = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_task_start_ts(&has_bits);
          task_start_ts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 task_end_ts = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_task_end_ts(&has_bits);
          task_end_ts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string external_full_path = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_external_full_path();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.RegionOfflineBinlogInfo.external_full_path");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RegionOfflineBinlogInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.RegionOfflineBinlogInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 oldest_ts = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_oldest_ts(), target);
  }

  // required int64 newest_ts = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_newest_ts(), target);
  }

  // optional int64 task_start_ts = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_task_start_ts(), target);
  }

  // optional int64 task_end_ts = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_task_end_ts(), target);
  }

  // repeated string external_full_path = 5;
  for (int i = 0, n = this->_internal_external_full_path_size(); i < n; i++) {
    const auto& s = this->_internal_external_full_path(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.RegionOfflineBinlogInfo.external_full_path");
    target = stream->WriteString(5, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.RegionOfflineBinlogInfo)
  return target;
}

size_t RegionOfflineBinlogInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.RegionOfflineBinlogInfo)
  size_t total_size = 0;

  if (_internal_has_oldest_ts()) {
    // required int64 oldest_ts = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_oldest_ts());
  }

  if (_internal_has_newest_ts()) {
    // required int64 newest_ts = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_newest_ts());
  }

  return total_size;
}
size_t RegionOfflineBinlogInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.RegionOfflineBinlogInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int64 oldest_ts = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_oldest_ts());

    // required int64 newest_ts = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_newest_ts());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string external_full_path = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(external_full_path_.size());
  for (int i = 0, n = external_full_path_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      external_full_path_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000cu) {
    // optional int64 task_start_ts = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_task_start_ts());
    }

    // optional int64 task_end_ts = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_task_end_ts());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RegionOfflineBinlogInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    RegionOfflineBinlogInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RegionOfflineBinlogInfo::GetClassData() const { return &_class_data_; }

void RegionOfflineBinlogInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<RegionOfflineBinlogInfo *>(to)->MergeFrom(
      static_cast<const RegionOfflineBinlogInfo &>(from));
}


void RegionOfflineBinlogInfo::MergeFrom(const RegionOfflineBinlogInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.RegionOfflineBinlogInfo)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  external_full_path_.MergeFrom(from.external_full_path_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      oldest_ts_ = from.oldest_ts_;
    }
    if (cached_has_bits & 0x00000002u) {
      newest_ts_ = from.newest_ts_;
    }
    if (cached_has_bits & 0x00000004u) {
      task_start_ts_ = from.task_start_ts_;
    }
    if (cached_has_bits & 0x00000008u) {
      task_end_ts_ = from.task_end_ts_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RegionOfflineBinlogInfo::CopyFrom(const RegionOfflineBinlogInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.RegionOfflineBinlogInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegionOfflineBinlogInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void RegionOfflineBinlogInfo::InternalSwap(RegionOfflineBinlogInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  external_full_path_.InternalSwap(&other->external_full_path_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RegionOfflineBinlogInfo, task_end_ts_)
      + sizeof(RegionOfflineBinlogInfo::task_end_ts_)
      - PROTOBUF_FIELD_OFFSET(RegionOfflineBinlogInfo, oldest_ts_)>(
          reinterpret_cast<char*>(&oldest_ts_),
          reinterpret_cast<char*>(&other->oldest_ts_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RegionOfflineBinlogInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[36]);
}

// ===================================================================

class CompactionFileRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CompactionFileRequest>()._has_bits_);
  static void set_has_op_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_remote_compaction_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_file_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_recursive(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000041) ^ 0x00000041) != 0;
  }
};

CompactionFileRequest::CompactionFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.CompactionFileRequest)
}
CompactionFileRequest::CompactionFileRequest(const CompactionFileRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  remote_compaction_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_remote_compaction_id()) {
    remote_compaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_remote_compaction_id(), 
      GetArenaForAllocation());
  }
  file_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_file_name()) {
    file_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_file_name(), 
      GetArenaForAllocation());
  }
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_data()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&offset_, &from.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&op_type_) -
    reinterpret_cast<char*>(&offset_)) + sizeof(op_type_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.CompactionFileRequest)
}

void CompactionFileRequest::SharedCtor() {
remote_compaction_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
file_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&offset_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&recursive_) -
    reinterpret_cast<char*>(&offset_)) + sizeof(recursive_));
op_type_ = 1;
}

CompactionFileRequest::~CompactionFileRequest() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.CompactionFileRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CompactionFileRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  remote_compaction_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  file_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CompactionFileRequest::ArenaDtor(void* object) {
  CompactionFileRequest* _this = reinterpret_cast< CompactionFileRequest* >(object);
  (void)_this;
}
void CompactionFileRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CompactionFileRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CompactionFileRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.CompactionFileRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      remote_compaction_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      file_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      data_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&recursive_) -
        reinterpret_cast<char*>(&offset_)) + sizeof(recursive_));
    op_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CompactionFileRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.CompactionOpType op_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::CompactionOpType_IsValid(val))) {
            _internal_set_op_type(static_cast<::baikaldb::pb::CompactionOpType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required string remote_compaction_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_remote_compaction_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.CompactionFileRequest.remote_compaction_id");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string file_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_file_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.CompactionFileRequest.file_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 offset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool recursive = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_recursive(&has_bits);
          recursive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CompactionFileRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.CompactionFileRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.CompactionOpType op_type = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_op_type(), target);
  }

  // required string remote_compaction_id = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_remote_compaction_id().data(), static_cast<int>(this->_internal_remote_compaction_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.CompactionFileRequest.remote_compaction_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_remote_compaction_id(), target);
  }

  // optional string file_name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_file_name().data(), static_cast<int>(this->_internal_file_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.CompactionFileRequest.file_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_file_name(), target);
  }

  // optional uint64 offset = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_offset(), target);
  }

  // optional uint32 count = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_count(), target);
  }

  // optional bytes data = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_data(), target);
  }

  // optional bool recursive = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_recursive(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.CompactionFileRequest)
  return target;
}

size_t CompactionFileRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.CompactionFileRequest)
  size_t total_size = 0;

  if (_internal_has_remote_compaction_id()) {
    // required string remote_compaction_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_remote_compaction_id());
  }

  if (_internal_has_op_type()) {
    // required .baikaldb.pb.CompactionOpType op_type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_op_type());
  }

  return total_size;
}
size_t CompactionFileRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.CompactionFileRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000041) ^ 0x00000041) == 0) {  // All required fields are present.
    // required string remote_compaction_id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_remote_compaction_id());

    // required .baikaldb.pb.CompactionOpType op_type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_op_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003eu) {
    // optional string file_name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_file_name());
    }

    // optional bytes data = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional uint64 offset = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_offset());
    }

    // optional uint32 count = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

    // optional bool recursive = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompactionFileRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CompactionFileRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompactionFileRequest::GetClassData() const { return &_class_data_; }

void CompactionFileRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CompactionFileRequest *>(to)->MergeFrom(
      static_cast<const CompactionFileRequest &>(from));
}


void CompactionFileRequest::MergeFrom(const CompactionFileRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.CompactionFileRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_remote_compaction_id(from._internal_remote_compaction_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_file_name(from._internal_file_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000008u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000010u) {
      count_ = from.count_;
    }
    if (cached_has_bits & 0x00000020u) {
      recursive_ = from.recursive_;
    }
    if (cached_has_bits & 0x00000040u) {
      op_type_ = from.op_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CompactionFileRequest::CopyFrom(const CompactionFileRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.CompactionFileRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompactionFileRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CompactionFileRequest::InternalSwap(CompactionFileRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &remote_compaction_id_, lhs_arena,
      &other->remote_compaction_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &file_name_, lhs_arena,
      &other->file_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CompactionFileRequest, recursive_)
      + sizeof(CompactionFileRequest::recursive_)
      - PROTOBUF_FIELD_OFFSET(CompactionFileRequest, offset_)>(
          reinterpret_cast<char*>(&offset_),
          reinterpret_cast<char*>(&other->offset_));
  swap(op_type_, other->op_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CompactionFileRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[37]);
}

// ===================================================================

class CompactionFileResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CompactionFileResponse>()._has_bits_);
  static void set_has_errcode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

void CompactionFileResponse::clear_file_info() {
  file_info_.Clear();
}
CompactionFileResponse::CompactionFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  file_info_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.CompactionFileResponse)
}
CompactionFileResponse::CompactionFileResponse(const CompactionFileResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      file_info_(from.file_info_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_data()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  errcode_ = from.errcode_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.CompactionFileResponse)
}

void CompactionFileResponse::SharedCtor() {
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
errcode_ = 0;
}

CompactionFileResponse::~CompactionFileResponse() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.CompactionFileResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CompactionFileResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CompactionFileResponse::ArenaDtor(void* object) {
  CompactionFileResponse* _this = reinterpret_cast< CompactionFileResponse* >(object);
  (void)_this;
}
void CompactionFileResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CompactionFileResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CompactionFileResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.CompactionFileResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  file_info_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    data_.ClearNonDefaultToEmpty();
  }
  errcode_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CompactionFileResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.ErrCode errcode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::ErrCode_IsValid(val))) {
            _internal_set_errcode(static_cast<::baikaldb::pb::ErrCode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.CompactionFileInfo file_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_file_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CompactionFileResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.CompactionFileResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.ErrCode errcode = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_errcode(), target);
  }

  // optional bytes data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  // repeated .baikaldb.pb.CompactionFileInfo file_info = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_file_info_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_file_info(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.CompactionFileResponse)
  return target;
}

size_t CompactionFileResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.CompactionFileResponse)
  size_t total_size = 0;

  // required .baikaldb.pb.ErrCode errcode = 1;
  if (_internal_has_errcode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_errcode());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.CompactionFileInfo file_info = 3;
  total_size += 1UL * this->_internal_file_info_size();
  for (const auto& msg : this->file_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes data = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CompactionFileResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CompactionFileResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CompactionFileResponse::GetClassData() const { return &_class_data_; }

void CompactionFileResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CompactionFileResponse *>(to)->MergeFrom(
      static_cast<const CompactionFileResponse &>(from));
}


void CompactionFileResponse::MergeFrom(const CompactionFileResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.CompactionFileResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  file_info_.MergeFrom(from.file_info_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      errcode_ = from.errcode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CompactionFileResponse::CopyFrom(const CompactionFileResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.CompactionFileResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CompactionFileResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(file_info_)) return false;
  return true;
}

void CompactionFileResponse::InternalSwap(CompactionFileResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  file_info_.InternalSwap(&other->file_info_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  swap(errcode_, other->errcode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CompactionFileResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_store_2einterface_2eproto_getter, &descriptor_table_store_2einterface_2eproto_once,
      file_level_metadata_store_2einterface_2eproto[38]);
}

// ===================================================================

StoreService::~StoreService() {}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* StoreService::descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_store_2einterface_2eproto);
  return file_level_service_descriptors_store_2einterface_2eproto[0];
}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* StoreService::GetDescriptor() {
  return descriptor();
}

void StoreService::init_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::InitRegion*,
                         ::baikaldb::pb::StoreRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method init_region() not implemented.");
  done->Run();
}

void StoreService::region_raft_control(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::RaftControlRequest*,
                         ::baikaldb::pb::RaftControlResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method region_raft_control() not implemented.");
  done->Run();
}

void StoreService::health_check(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::HealthCheck*,
                         ::baikaldb::pb::StoreRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method health_check() not implemented.");
  done->Run();
}

void StoreService::async_apply_log_entry(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::BatchStoreReq*,
                         ::baikaldb::pb::BatchStoreRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method async_apply_log_entry() not implemented.");
  done->Run();
}

void StoreService::query(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::StoreReq*,
                         ::baikaldb::pb::StoreRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method query() not implemented.");
  done->Run();
}

void StoreService::query_batch(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::BatchRegionStoreReq*,
                         ::baikaldb::pb::BatchRegionStoreRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method query_batch() not implemented.");
  done->Run();
}

void StoreService::query_binlog(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::StoreReq*,
                         ::baikaldb::pb::StoreRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method query_binlog() not implemented.");
  done->Run();
}

void StoreService::remove_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::RemoveRegion*,
                         ::baikaldb::pb::StoreRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method remove_region() not implemented.");
  done->Run();
}

void StoreService::add_peer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::AddPeer*,
                         ::baikaldb::pb::StoreRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method add_peer() not implemented.");
  done->Run();
}

void StoreService::get_applied_index(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::GetAppliedIndex*,
                         ::baikaldb::pb::StoreRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method get_applied_index() not implemented.");
  done->Run();
}

void StoreService::compact_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::RegionIds*,
                         ::baikaldb::pb::StoreRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method compact_region() not implemented.");
  done->Run();
}

void StoreService::snapshot_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::RegionIds*,
                         ::baikaldb::pb::StoreRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method snapshot_region() not implemented.");
  done->Run();
}

void StoreService::restore_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::RegionIds*,
                         ::baikaldb::pb::StoreRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method restore_region() not implemented.");
  done->Run();
}

void StoreService::manual_split_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::RegionIds*,
                         ::baikaldb::pb::StoreRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method manual_split_region() not implemented.");
  done->Run();
}

void StoreService::query_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::RegionIds*,
                         ::baikaldb::pb::StoreRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method query_region() not implemented.");
  done->Run();
}

void StoreService::query_illegal_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::RegionIds*,
                         ::baikaldb::pb::StoreRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method query_illegal_region() not implemented.");
  done->Run();
}

void StoreService::backup_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::BackUpReq*,
                         ::baikaldb::pb::BackUpRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method backup_region() not implemented.");
  done->Run();
}

void StoreService::backup(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::BackupRequest*,
                         ::baikaldb::pb::BackupResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method backup() not implemented.");
  done->Run();
}

void StoreService::get_rocks_statistic(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::RocksStatisticReq*,
                         ::baikaldb::pb::RocksStatisticRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method get_rocks_statistic() not implemented.");
  done->Run();
}

void StoreService::manual_link_external_sst(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::RegionIds*,
                         ::baikaldb::pb::StoreRes*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method manual_link_external_sst() not implemented.");
  done->Run();
}

void StoreService::query_file_system(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::baikaldb::pb::CompactionFileRequest*,
                         ::baikaldb::pb::CompactionFileResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method query_file_system() not implemented.");
  done->Run();
}

void StoreService::CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                             ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                             const ::PROTOBUF_NAMESPACE_ID::Message* request,
                             ::PROTOBUF_NAMESPACE_ID::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_store_2einterface_2eproto[0]);
  switch(method->index()) {
    case 0:
      init_region(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::InitRegion*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::StoreRes*>(
                 response),
             done);
      break;
    case 1:
      region_raft_control(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::RaftControlRequest*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::RaftControlResponse*>(
                 response),
             done);
      break;
    case 2:
      health_check(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::HealthCheck*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::StoreRes*>(
                 response),
             done);
      break;
    case 3:
      async_apply_log_entry(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::BatchStoreReq*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::BatchStoreRes*>(
                 response),
             done);
      break;
    case 4:
      query(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::StoreReq*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::StoreRes*>(
                 response),
             done);
      break;
    case 5:
      query_batch(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::BatchRegionStoreReq*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::BatchRegionStoreRes*>(
                 response),
             done);
      break;
    case 6:
      query_binlog(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::StoreReq*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::StoreRes*>(
                 response),
             done);
      break;
    case 7:
      remove_region(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::RemoveRegion*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::StoreRes*>(
                 response),
             done);
      break;
    case 8:
      add_peer(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::AddPeer*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::StoreRes*>(
                 response),
             done);
      break;
    case 9:
      get_applied_index(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::GetAppliedIndex*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::StoreRes*>(
                 response),
             done);
      break;
    case 10:
      compact_region(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::RegionIds*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::StoreRes*>(
                 response),
             done);
      break;
    case 11:
      snapshot_region(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::RegionIds*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::StoreRes*>(
                 response),
             done);
      break;
    case 12:
      restore_region(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::RegionIds*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::StoreRes*>(
                 response),
             done);
      break;
    case 13:
      manual_split_region(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::RegionIds*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::StoreRes*>(
                 response),
             done);
      break;
    case 14:
      query_region(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::RegionIds*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::StoreRes*>(
                 response),
             done);
      break;
    case 15:
      query_illegal_region(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::RegionIds*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::StoreRes*>(
                 response),
             done);
      break;
    case 16:
      backup_region(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::BackUpReq*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::BackUpRes*>(
                 response),
             done);
      break;
    case 17:
      backup(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::BackupRequest*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::BackupResponse*>(
                 response),
             done);
      break;
    case 18:
      get_rocks_statistic(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::RocksStatisticReq*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::RocksStatisticRes*>(
                 response),
             done);
      break;
    case 19:
      manual_link_external_sst(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::RegionIds*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::StoreRes*>(
                 response),
             done);
      break;
    case 20:
      query_file_system(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::baikaldb::pb::CompactionFileRequest*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::baikaldb::pb::CompactionFileResponse*>(
                 response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& StoreService::GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::baikaldb::pb::InitRegion::default_instance();
    case 1:
      return ::baikaldb::pb::RaftControlRequest::default_instance();
    case 2:
      return ::baikaldb::pb::HealthCheck::default_instance();
    case 3:
      return ::baikaldb::pb::BatchStoreReq::default_instance();
    case 4:
      return ::baikaldb::pb::StoreReq::default_instance();
    case 5:
      return ::baikaldb::pb::BatchRegionStoreReq::default_instance();
    case 6:
      return ::baikaldb::pb::StoreReq::default_instance();
    case 7:
      return ::baikaldb::pb::RemoveRegion::default_instance();
    case 8:
      return ::baikaldb::pb::AddPeer::default_instance();
    case 9:
      return ::baikaldb::pb::GetAppliedIndex::default_instance();
    case 10:
      return ::baikaldb::pb::RegionIds::default_instance();
    case 11:
      return ::baikaldb::pb::RegionIds::default_instance();
    case 12:
      return ::baikaldb::pb::RegionIds::default_instance();
    case 13:
      return ::baikaldb::pb::RegionIds::default_instance();
    case 14:
      return ::baikaldb::pb::RegionIds::default_instance();
    case 15:
      return ::baikaldb::pb::RegionIds::default_instance();
    case 16:
      return ::baikaldb::pb::BackUpReq::default_instance();
    case 17:
      return ::baikaldb::pb::BackupRequest::default_instance();
    case 18:
      return ::baikaldb::pb::RocksStatisticReq::default_instance();
    case 19:
      return ::baikaldb::pb::RegionIds::default_instance();
    case 20:
      return ::baikaldb::pb::CompactionFileRequest::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& StoreService::GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::baikaldb::pb::StoreRes::default_instance();
    case 1:
      return ::baikaldb::pb::RaftControlResponse::default_instance();
    case 2:
      return ::baikaldb::pb::StoreRes::default_instance();
    case 3:
      return ::baikaldb::pb::BatchStoreRes::default_instance();
    case 4:
      return ::baikaldb::pb::StoreRes::default_instance();
    case 5:
      return ::baikaldb::pb::BatchRegionStoreRes::default_instance();
    case 6:
      return ::baikaldb::pb::StoreRes::default_instance();
    case 7:
      return ::baikaldb::pb::StoreRes::default_instance();
    case 8:
      return ::baikaldb::pb::StoreRes::default_instance();
    case 9:
      return ::baikaldb::pb::StoreRes::default_instance();
    case 10:
      return ::baikaldb::pb::StoreRes::default_instance();
    case 11:
      return ::baikaldb::pb::StoreRes::default_instance();
    case 12:
      return ::baikaldb::pb::StoreRes::default_instance();
    case 13:
      return ::baikaldb::pb::StoreRes::default_instance();
    case 14:
      return ::baikaldb::pb::StoreRes::default_instance();
    case 15:
      return ::baikaldb::pb::StoreRes::default_instance();
    case 16:
      return ::baikaldb::pb::BackUpRes::default_instance();
    case 17:
      return ::baikaldb::pb::BackupResponse::default_instance();
    case 18:
      return ::baikaldb::pb::RocksStatisticRes::default_instance();
    case 19:
      return ::baikaldb::pb::StoreRes::default_instance();
    case 20:
      return ::baikaldb::pb::CompactionFileResponse::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

StoreService_Stub::StoreService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
StoreService_Stub::StoreService_Stub(
    ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
    ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::PROTOBUF_NAMESPACE_ID::Service::STUB_OWNS_CHANNEL) {}
StoreService_Stub::~StoreService_Stub() {
  if (owns_channel_) delete channel_;
}

void StoreService_Stub::init_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::InitRegion* request,
                              ::baikaldb::pb::StoreRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void StoreService_Stub::region_raft_control(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::RaftControlRequest* request,
                              ::baikaldb::pb::RaftControlResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void StoreService_Stub::health_check(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::HealthCheck* request,
                              ::baikaldb::pb::StoreRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void StoreService_Stub::async_apply_log_entry(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::BatchStoreReq* request,
                              ::baikaldb::pb::BatchStoreRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}
void StoreService_Stub::query(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::StoreReq* request,
                              ::baikaldb::pb::StoreRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(4),
                       controller, request, response, done);
}
void StoreService_Stub::query_batch(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::BatchRegionStoreReq* request,
                              ::baikaldb::pb::BatchRegionStoreRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(5),
                       controller, request, response, done);
}
void StoreService_Stub::query_binlog(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::StoreReq* request,
                              ::baikaldb::pb::StoreRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(6),
                       controller, request, response, done);
}
void StoreService_Stub::remove_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::RemoveRegion* request,
                              ::baikaldb::pb::StoreRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(7),
                       controller, request, response, done);
}
void StoreService_Stub::add_peer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::AddPeer* request,
                              ::baikaldb::pb::StoreRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(8),
                       controller, request, response, done);
}
void StoreService_Stub::get_applied_index(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::GetAppliedIndex* request,
                              ::baikaldb::pb::StoreRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(9),
                       controller, request, response, done);
}
void StoreService_Stub::compact_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::RegionIds* request,
                              ::baikaldb::pb::StoreRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(10),
                       controller, request, response, done);
}
void StoreService_Stub::snapshot_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::RegionIds* request,
                              ::baikaldb::pb::StoreRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(11),
                       controller, request, response, done);
}
void StoreService_Stub::restore_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::RegionIds* request,
                              ::baikaldb::pb::StoreRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(12),
                       controller, request, response, done);
}
void StoreService_Stub::manual_split_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::RegionIds* request,
                              ::baikaldb::pb::StoreRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(13),
                       controller, request, response, done);
}
void StoreService_Stub::query_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::RegionIds* request,
                              ::baikaldb::pb::StoreRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(14),
                       controller, request, response, done);
}
void StoreService_Stub::query_illegal_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::RegionIds* request,
                              ::baikaldb::pb::StoreRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(15),
                       controller, request, response, done);
}
void StoreService_Stub::backup_region(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::BackUpReq* request,
                              ::baikaldb::pb::BackUpRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(16),
                       controller, request, response, done);
}
void StoreService_Stub::backup(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::BackupRequest* request,
                              ::baikaldb::pb::BackupResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(17),
                       controller, request, response, done);
}
void StoreService_Stub::get_rocks_statistic(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::RocksStatisticReq* request,
                              ::baikaldb::pb::RocksStatisticRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(18),
                       controller, request, response, done);
}
void StoreService_Stub::manual_link_external_sst(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::RegionIds* request,
                              ::baikaldb::pb::StoreRes* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(19),
                       controller, request, response, done);
}
void StoreService_Stub::query_file_system(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::baikaldb::pb::CompactionFileRequest* request,
                              ::baikaldb::pb::CompactionFileResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(20),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace pb
}  // namespace baikaldb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::baikaldb::pb::KvOp* Arena::CreateMaybeMessage< ::baikaldb::pb::KvOp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::KvOp >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::RedisKv* Arena::CreateMaybeMessage< ::baikaldb::pb::RedisKv >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::RedisKv >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::RedisWriteRequest* Arena::CreateMaybeMessage< ::baikaldb::pb::RedisWriteRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::RedisWriteRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::CachePlan* Arena::CreateMaybeMessage< ::baikaldb::pb::CachePlan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::CachePlan >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::TransactionInfo* Arena::CreateMaybeMessage< ::baikaldb::pb::TransactionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::TransactionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::AnalyzeInfo* Arena::CreateMaybeMessage< ::baikaldb::pb::AnalyzeInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::AnalyzeInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::BinlogDesc* Arena::CreateMaybeMessage< ::baikaldb::pb::BinlogDesc >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::BinlogDesc >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::BatchStoreReq* Arena::CreateMaybeMessage< ::baikaldb::pb::BatchStoreReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::BatchStoreReq >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::BatchStoreRes* Arena::CreateMaybeMessage< ::baikaldb::pb::BatchStoreRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::BatchStoreRes >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::RegionIndexs* Arena::CreateMaybeMessage< ::baikaldb::pb::RegionIndexs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::RegionIndexs >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::ColumnRegionInfo* Arena::CreateMaybeMessage< ::baikaldb::pb::ColumnRegionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::ColumnRegionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::UseridCount* Arena::CreateMaybeMessage< ::baikaldb::pb::UseridCount >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::UseridCount >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::ExtraReq* Arena::CreateMaybeMessage< ::baikaldb::pb::ExtraReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::ExtraReq >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::ExtraRes* Arena::CreateMaybeMessage< ::baikaldb::pb::ExtraRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::ExtraRes >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::StoreReq* Arena::CreateMaybeMessage< ::baikaldb::pb::StoreReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::StoreReq >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::RowValue* Arena::CreateMaybeMessage< ::baikaldb::pb::RowValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::RowValue >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::RegionLeader* Arena::CreateMaybeMessage< ::baikaldb::pb::RegionLeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::RegionLeader >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::IndexRecords* Arena::CreateMaybeMessage< ::baikaldb::pb::IndexRecords >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::IndexRecords >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::RegionRaftStat* Arena::CreateMaybeMessage< ::baikaldb::pb::RegionRaftStat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::RegionRaftStat >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::RocksStatisticReq* Arena::CreateMaybeMessage< ::baikaldb::pb::RocksStatisticReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::RocksStatisticReq >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::RocksStatisticRes* Arena::CreateMaybeMessage< ::baikaldb::pb::RocksStatisticRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::RocksStatisticRes >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::BinlogQueryInfo* Arena::CreateMaybeMessage< ::baikaldb::pb::BinlogQueryInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::BinlogQueryInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::StoreRes* Arena::CreateMaybeMessage< ::baikaldb::pb::StoreRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::StoreRes >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::BatchRegionStoreReq* Arena::CreateMaybeMessage< ::baikaldb::pb::BatchRegionStoreReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::BatchRegionStoreReq >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::BatchRegionStoreRes* Arena::CreateMaybeMessage< ::baikaldb::pb::BatchRegionStoreRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::BatchRegionStoreRes >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::InitRegion* Arena::CreateMaybeMessage< ::baikaldb::pb::InitRegion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::InitRegion >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::GetAppliedIndex* Arena::CreateMaybeMessage< ::baikaldb::pb::GetAppliedIndex >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::GetAppliedIndex >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::RemoveRegion* Arena::CreateMaybeMessage< ::baikaldb::pb::RemoveRegion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::RemoveRegion >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::RegionIds* Arena::CreateMaybeMessage< ::baikaldb::pb::RegionIds >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::RegionIds >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::BackUpReq* Arena::CreateMaybeMessage< ::baikaldb::pb::BackUpReq >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::BackUpReq >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::BackUpRes* Arena::CreateMaybeMessage< ::baikaldb::pb::BackUpRes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::BackUpRes >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::BackupRequest* Arena::CreateMaybeMessage< ::baikaldb::pb::BackupRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::BackupRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::BackupResponse* Arena::CreateMaybeMessage< ::baikaldb::pb::BackupResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::BackupResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::HealthCheck* Arena::CreateMaybeMessage< ::baikaldb::pb::HealthCheck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::HealthCheck >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::OlapRegionIndexInfo* Arena::CreateMaybeMessage< ::baikaldb::pb::OlapRegionIndexInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::OlapRegionIndexInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::OlapRegionInfo* Arena::CreateMaybeMessage< ::baikaldb::pb::OlapRegionInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::OlapRegionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::RegionOfflineBinlogInfo* Arena::CreateMaybeMessage< ::baikaldb::pb::RegionOfflineBinlogInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::RegionOfflineBinlogInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::CompactionFileRequest* Arena::CreateMaybeMessage< ::baikaldb::pb::CompactionFileRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::CompactionFileRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::CompactionFileResponse* Arena::CreateMaybeMessage< ::baikaldb::pb::CompactionFileResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::CompactionFileResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
