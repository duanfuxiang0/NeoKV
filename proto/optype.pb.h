// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: optype.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_optype_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_optype_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_optype_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_optype_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_optype_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace baikaldb {
namespace pb {

enum OpType : int {
  OP_NONE = 0,
  OP_INSERT = 1,
  OP_DELETE = 2,
  OP_UPDATE = 3,
  OP_SELECT = 4,
  OP_BEGIN = 5,
  OP_COMMIT = 6,
  OP_ROLLBACK = 7,
  OP_KILL = 8,
  OP_START_SPLIT = 9,
  OP_START_SPLIT_FOR_TAIL = 10,
  OP_VALIDATE_AND_ADD_VERSION = 11,
  OP_ADD_VERSION_FOR_SPLIT_REGION = 12,
  OP_TRUNCATE_TABLE = 13,
  OP_PREPARE = 14,
  OP_EXPLAIN = 15,
  OP_ADJUSTKEY_AND_ADD_VERSION = 16,
  OP_START_DDL = 17,
  OP_START_DDL_FOR_DROP_INDEX = 18,
  OP_UPDATE_STORE_DDLWORK = 19,
  OP_KV_BATCH = 20,
  OP_PUT_KV = 21,
  OP_DELETE_KV = 22,
  OP_KV_BATCH_SPLIT = 23,
  OP_TXN_QUERY_PRIMARY_REGION = 24,
  OP_TXN_QUERY_STATE = 25,
  OP_TXN_COMPLETE = 26,
  OP_CLEAR_APPLYING_TXN = 27,
  OP_SELECT_FOR_UPDATE = 28,
  OP_MERGE_KV = 29,
  OP_UNION = 51,
  OP_LOAD = 52,
  OP_UPDATE_PRIMARY_TIMESTAMP = 53,
  OP_PARTIAL_ROLLBACK = 54,
  OP_READ_BINLOG = 60,
  OP_PREWRITE_BINLOG = 61,
  OP_COMMIT_BINLOG = 62,
  OP_ROLLBACK_BINLOG = 63,
  OP_FAKE_BINLOG = 64,
  OP_RECOVER_BINLOG = 65,
  OP_QUERY_BINLOG = 66,
  OP_UPDATE_OFFLINE_BINLOG = 67,
  OP_QUERY_OFFLINE_BINLOG = 68,
  OP_RECOVER_OFFLINE_BINLOG = 69,
  OP_OLAP_INFO = 80,
  OP_OLAP_INDEX_INFO = 81,
  OP_ROLLUP_REGION_INIT = 82,
  OP_ROLLUP_REGION_FINISH = 83,
  OP_ROLLUP_REGION_FAILED = 84,
  OP_ROLLUP_CLEAR_VERSION = 85,
  OP_COLUMN_INFO = 86,
  OP_REDIS_WRITE = 90,
  OP_ADD_LOGICAL = 114,
  OP_ADD_PHYSICAL = 115,
  OP_ADD_INSTANCE = 116,
  OP_DROP_LOGICAL = 117,
  OP_DROP_PHYSICAL = 118,
  OP_DROP_INSTANCE = 119,
  OP_UPDATE_INSTANCE = 120,
  OP_MOVE_PHYSICAL = 121,
  OP_CREATE_USER = 122,
  OP_ADD_PRIVILEGE = 123,
  OP_DROP_USER = 124,
  OP_DROP_PRIVILEGE = 125,
  OP_CREATE_NAMESPACE = 126,
  OP_CREATE_DATABASE = 127,
  OP_CREATE_TABLE = 128,
  OP_DROP_NAMESPACE = 129,
  OP_DROP_DATABASE = 130,
  OP_DROP_TABLE = 131,
  OP_RENAME_TABLE = 132,
  OP_ADD_FIELD = 133,
  OP_ADD_INDEX = 134,
  OP_DROP_INDEX = 135,
  OP_DROP_FIELD = 136,
  OP_RENAME_FIELD = 137,
  OP_RENAME_INDEX = 138,
  OP_MODIFY_FIELD = 139,
  OP_MODIFY_NAMESPACE = 140,
  OP_MODIFY_DATABASE = 141,
  OP_UPDATE_REGION = 142,
  OP_DROP_REGION = 143,
  OP_SPLIT_REGION = 144,
  OP_UPDATE_BYTE_SIZE = 145,
  OP_GEN_ID_FOR_AUTO_INCREMENT = 146,
  OP_UPDATE_FOR_AUTO_INCREMENT = 147,
  OP_RESTORE_REGION = 148,
  OP_OPEN_UNSAFE_DECISION = 149,
  OP_SET_INSTANCE_MIGRATE = 150,
  OP_ADD_ID_FOR_AUTO_INCREMENT = 152,
  OP_DROP_ID_FOR_AUTO_INCREMENT = 153,
  OP_CLOSE_LOAD_BALANCE = 154,
  OP_OPEN_LOAD_BALANCE = 155,
  OP_CLOSE_UNSAFE_DECISION = 156,
  OP_UPDATE_DISTS = 157,
  OP_CLOSE_MIGRATE = 158,
  OP_OPEN_MIGRATE = 159,
  OP_UPDATE_SPLIT_LINES = 160,
  OP_SET_INSTANCE_STATUS = 161,
  OP_MODIFY_RESOURCE_TAG = 163,
  OP_MERGE_REGION = 164,
  OP_UPDATE_MERGE_SWITCH = 165,
  OP_UPDATE_INDEX_STATUS = 166,
  OP_DELETE_DDLWORK = 167,
  OP_UPDATE_SCHEMA_CONF = 168,
  OP_RESTORE_TABLE = 169,
  OP_DROP_TABLE_TOMBSTONE = 170,
  OP_RECOVERY_ALL_REGION = 171,
  OP_UPDATE_STATISTICS = 172,
  OP_GEN_TSO = 173,
  OP_RESET_TSO = 174,
  OP_UPDATE_TSO = 175,
  OP_QUERY_TSO_INFO = 176,
  OP_LINK_BINLOG = 177,
  OP_UNLINK_BINLOG = 178,
  OP_SET_INDEX_HINT_STATUS = 179,
  OP_UPDATE_TTL_DURATION = 180,
  OP_UPDATE_INSTANCE_PARAM = 181,
  OP_UPDATE_INDEX_REGION_DDL_WORK = 182,
  OP_SUSPEND_DDL_WORK = 183,
  OP_RESTART_DDL_WORK = 184,
  OP_REMOVE_GLOBAL_INDEX_DATA = 185,
  OP_UPDATE_MAIN_LOGICAL_ROOM = 186,
  OP_ADD_LEARNER = 187,
  OP_DROP_LEARNER = 188,
  OP_OPEN_NETWORK_SEGMENT_BALANCE = 189,
  OP_CLOSE_NETWORK_SEGMENT_BALANCE = 190,
  OP_UPDATE_TABLE_COMMENT = 191,
  OP_SWAP_TABLE = 192,
  OP_MODIFY_PARTITION = 193,
  OP_UPDATE_CHARSET = 194,
  OP_ADD_PARTITION = 195,
  OP_DROP_PARTITION = 196,
  OP_UPDATE_DYNAMIC_PARTITION_ATTR = 197,
  OP_DROP_PARTITION_TS = 198,
  OP_SPECIFY_SPLIT_KEYS = 199,
  OP_CONVERT_PARTITION = 200,
  OP_MODIFY_USER = 201,
  OP_CREATE_VIEW = 202,
  OP_DROP_VIEW = 203,
  OP_DROP_INVALID_PRIVILEGE = 204
};
bool OpType_IsValid(int value);
constexpr OpType OpType_MIN = OP_NONE;
constexpr OpType OpType_MAX = OP_DROP_INVALID_PRIVILEGE;
constexpr int OpType_ARRAYSIZE = OpType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OpType_descriptor();
template<typename T>
inline const std::string& OpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OpType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OpType_descriptor(), enum_t_value);
}
inline bool OpType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OpType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OpType>(
    OpType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace baikaldb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::baikaldb::pb::OpType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::OpType>() {
  return ::baikaldb::pb::OpType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_optype_2eproto
