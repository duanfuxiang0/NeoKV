// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: console.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_console_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_console_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "meta.interface.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_console_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_console_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[26]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_console_2eproto;
namespace baikaldb {
namespace pb {
class ConsoleRequest;
struct ConsoleRequestDefaultTypeInternal;
extern ConsoleRequestDefaultTypeInternal _ConsoleRequest_default_instance_;
class ConsoleResponse;
struct ConsoleResponseDefaultTypeInternal;
extern ConsoleResponseDefaultTypeInternal _ConsoleResponse_default_instance_;
class OverViewInfo;
struct OverViewInfoDefaultTypeInternal;
extern OverViewInfoDefaultTypeInternal _OverViewInfo_default_instance_;
class QueryParam;
struct QueryParamDefaultTypeInternal;
extern QueryParamDefaultTypeInternal _QueryParam_default_instance_;
class QueryStatusRequest;
struct QueryStatusRequestDefaultTypeInternal;
extern QueryStatusRequestDefaultTypeInternal _QueryStatusRequest_default_instance_;
class QueryStatusResponse;
struct QueryStatusResponseDefaultTypeInternal;
extern QueryStatusResponseDefaultTypeInternal _QueryStatusResponse_default_instance_;
class ReplicationStatus;
struct ReplicationStatusDefaultTypeInternal;
extern ReplicationStatusDefaultTypeInternal _ReplicationStatus_default_instance_;
class ShowxColumn;
struct ShowxColumnDefaultTypeInternal;
extern ShowxColumnDefaultTypeInternal _ShowxColumn_default_instance_;
class ShowxCondition;
struct ShowxConditionDefaultTypeInternal;
extern ShowxConditionDefaultTypeInternal _ShowxCondition_default_instance_;
class ShowxData;
struct ShowxDataDefaultTypeInternal;
extern ShowxDataDefaultTypeInternal _ShowxData_default_instance_;
class ShowxRequest;
struct ShowxRequestDefaultTypeInternal;
extern ShowxRequestDefaultTypeInternal _ShowxRequest_default_instance_;
class ShowxResponse;
struct ShowxResponseDefaultTypeInternal;
extern ShowxResponseDefaultTypeInternal _ShowxResponse_default_instance_;
class ShowxRow;
struct ShowxRowDefaultTypeInternal;
extern ShowxRowDefaultTypeInternal _ShowxRow_default_instance_;
class TableName;
struct TableNameDefaultTypeInternal;
extern TableNameDefaultTypeInternal _TableName_default_instance_;
class WatchClusterInfo;
struct WatchClusterInfoDefaultTypeInternal;
extern WatchClusterInfoDefaultTypeInternal _WatchClusterInfo_default_instance_;
class WatchDatabaseInfo;
struct WatchDatabaseInfoDefaultTypeInternal;
extern WatchDatabaseInfoDefaultTypeInternal _WatchDatabaseInfo_default_instance_;
class WatchImportTask;
struct WatchImportTaskDefaultTypeInternal;
extern WatchImportTaskDefaultTypeInternal _WatchImportTask_default_instance_;
class WatchInstanceInfo;
struct WatchInstanceInfoDefaultTypeInternal;
extern WatchInstanceInfoDefaultTypeInternal _WatchInstanceInfo_default_instance_;
class WatchNameSpace;
struct WatchNameSpaceDefaultTypeInternal;
extern WatchNameSpaceDefaultTypeInternal _WatchNameSpace_default_instance_;
class WatchPlatForm;
struct WatchPlatFormDefaultTypeInternal;
extern WatchPlatFormDefaultTypeInternal _WatchPlatForm_default_instance_;
class WatchRegionInfo;
struct WatchRegionInfoDefaultTypeInternal;
extern WatchRegionInfoDefaultTypeInternal _WatchRegionInfo_default_instance_;
class WatchSSTTask;
struct WatchSSTTaskDefaultTypeInternal;
extern WatchSSTTaskDefaultTypeInternal _WatchSSTTask_default_instance_;
class WatchSchemaInfo;
struct WatchSchemaInfoDefaultTypeInternal;
extern WatchSchemaInfoDefaultTypeInternal _WatchSchemaInfo_default_instance_;
class WatchTableInfo;
struct WatchTableInfoDefaultTypeInternal;
extern WatchTableInfoDefaultTypeInternal _WatchTableInfo_default_instance_;
class WatchTaskList;
struct WatchTaskListDefaultTypeInternal;
extern WatchTaskListDefaultTypeInternal _WatchTaskList_default_instance_;
class WatchUserInfo;
struct WatchUserInfoDefaultTypeInternal;
extern WatchUserInfoDefaultTypeInternal _WatchUserInfo_default_instance_;
}  // namespace pb
}  // namespace baikaldb
PROTOBUF_NAMESPACE_OPEN
template<> ::baikaldb::pb::ConsoleRequest* Arena::CreateMaybeMessage<::baikaldb::pb::ConsoleRequest>(Arena*);
template<> ::baikaldb::pb::ConsoleResponse* Arena::CreateMaybeMessage<::baikaldb::pb::ConsoleResponse>(Arena*);
template<> ::baikaldb::pb::OverViewInfo* Arena::CreateMaybeMessage<::baikaldb::pb::OverViewInfo>(Arena*);
template<> ::baikaldb::pb::QueryParam* Arena::CreateMaybeMessage<::baikaldb::pb::QueryParam>(Arena*);
template<> ::baikaldb::pb::QueryStatusRequest* Arena::CreateMaybeMessage<::baikaldb::pb::QueryStatusRequest>(Arena*);
template<> ::baikaldb::pb::QueryStatusResponse* Arena::CreateMaybeMessage<::baikaldb::pb::QueryStatusResponse>(Arena*);
template<> ::baikaldb::pb::ReplicationStatus* Arena::CreateMaybeMessage<::baikaldb::pb::ReplicationStatus>(Arena*);
template<> ::baikaldb::pb::ShowxColumn* Arena::CreateMaybeMessage<::baikaldb::pb::ShowxColumn>(Arena*);
template<> ::baikaldb::pb::ShowxCondition* Arena::CreateMaybeMessage<::baikaldb::pb::ShowxCondition>(Arena*);
template<> ::baikaldb::pb::ShowxData* Arena::CreateMaybeMessage<::baikaldb::pb::ShowxData>(Arena*);
template<> ::baikaldb::pb::ShowxRequest* Arena::CreateMaybeMessage<::baikaldb::pb::ShowxRequest>(Arena*);
template<> ::baikaldb::pb::ShowxResponse* Arena::CreateMaybeMessage<::baikaldb::pb::ShowxResponse>(Arena*);
template<> ::baikaldb::pb::ShowxRow* Arena::CreateMaybeMessage<::baikaldb::pb::ShowxRow>(Arena*);
template<> ::baikaldb::pb::TableName* Arena::CreateMaybeMessage<::baikaldb::pb::TableName>(Arena*);
template<> ::baikaldb::pb::WatchClusterInfo* Arena::CreateMaybeMessage<::baikaldb::pb::WatchClusterInfo>(Arena*);
template<> ::baikaldb::pb::WatchDatabaseInfo* Arena::CreateMaybeMessage<::baikaldb::pb::WatchDatabaseInfo>(Arena*);
template<> ::baikaldb::pb::WatchImportTask* Arena::CreateMaybeMessage<::baikaldb::pb::WatchImportTask>(Arena*);
template<> ::baikaldb::pb::WatchInstanceInfo* Arena::CreateMaybeMessage<::baikaldb::pb::WatchInstanceInfo>(Arena*);
template<> ::baikaldb::pb::WatchNameSpace* Arena::CreateMaybeMessage<::baikaldb::pb::WatchNameSpace>(Arena*);
template<> ::baikaldb::pb::WatchPlatForm* Arena::CreateMaybeMessage<::baikaldb::pb::WatchPlatForm>(Arena*);
template<> ::baikaldb::pb::WatchRegionInfo* Arena::CreateMaybeMessage<::baikaldb::pb::WatchRegionInfo>(Arena*);
template<> ::baikaldb::pb::WatchSSTTask* Arena::CreateMaybeMessage<::baikaldb::pb::WatchSSTTask>(Arena*);
template<> ::baikaldb::pb::WatchSchemaInfo* Arena::CreateMaybeMessage<::baikaldb::pb::WatchSchemaInfo>(Arena*);
template<> ::baikaldb::pb::WatchTableInfo* Arena::CreateMaybeMessage<::baikaldb::pb::WatchTableInfo>(Arena*);
template<> ::baikaldb::pb::WatchTaskList* Arena::CreateMaybeMessage<::baikaldb::pb::WatchTaskList>(Arena*);
template<> ::baikaldb::pb::WatchUserInfo* Arena::CreateMaybeMessage<::baikaldb::pb::WatchUserInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace baikaldb {
namespace pb {

enum WatchOpType : int {
  WATCH_UNKNOWN = 1,
  WATCH_PLATFORM = 2,
  WATCH_OVERVIEW = 3,
  WATCH_TABLE = 4,
  WATCH_INSTANCE = 5,
  WATCH_REGION = 6,
  WATCH_USER = 7,
  WATCH_NAMESPACE = 8,
  WATCH_DATABASE = 9,
  WATCH_CLUSTER = 10,
  WATCH_SCHEMA = 11,
  WATCH_REGION_WATT = 12
};
bool WatchOpType_IsValid(int value);
constexpr WatchOpType WatchOpType_MIN = WATCH_UNKNOWN;
constexpr WatchOpType WatchOpType_MAX = WATCH_REGION_WATT;
constexpr int WatchOpType_ARRAYSIZE = WatchOpType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WatchOpType_descriptor();
template<typename T>
inline const std::string& WatchOpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WatchOpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WatchOpType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WatchOpType_descriptor(), enum_t_value);
}
inline bool WatchOpType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WatchOpType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WatchOpType>(
    WatchOpType_descriptor(), name, value);
}
// ===================================================================

class ConsoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ConsoleRequest) */ {
 public:
  inline ConsoleRequest() : ConsoleRequest(nullptr) {}
  ~ConsoleRequest() override;
  explicit constexpr ConsoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConsoleRequest(const ConsoleRequest& from);
  ConsoleRequest(ConsoleRequest&& from) noexcept
    : ConsoleRequest() {
    *this = ::std::move(from);
  }

  inline ConsoleRequest& operator=(const ConsoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsoleRequest& operator=(ConsoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConsoleRequest* internal_default_instance() {
    return reinterpret_cast<const ConsoleRequest*>(
               &_ConsoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ConsoleRequest& a, ConsoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConsoleRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConsoleRequest* New() const final {
    return new ConsoleRequest();
  }

  ConsoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConsoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConsoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConsoleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsoleRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ConsoleRequest";
  }
  protected:
  explicit ConsoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalRoomFieldNumber = 2,
    kPhysicalRoomFieldNumber = 3,
    kInstanceAddressFieldNumber = 4,
    kUserNameFieldNumber = 5,
    kNamespaceNameFieldNumber = 6,
    kDatabaseFieldNumber = 7,
    kTableNameFieldNumber = 8,
    kResourceTagFieldNumber = 10,
    kRegionIdFieldNumber = 9,
    kOpTypeFieldNumber = 1,
  };
  // optional string logical_room = 2;
  bool has_logical_room() const;
  private:
  bool _internal_has_logical_room() const;
  public:
  void clear_logical_room();
  const std::string& logical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_logical_room();
  void set_allocated_logical_room(std::string* logical_room);
  private:
  const std::string& _internal_logical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logical_room(const std::string& value);
  std::string* _internal_mutable_logical_room();
  public:

  // optional string physical_room = 3;
  bool has_physical_room() const;
  private:
  bool _internal_has_physical_room() const;
  public:
  void clear_physical_room();
  const std::string& physical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_physical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_physical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_physical_room();
  void set_allocated_physical_room(std::string* physical_room);
  private:
  const std::string& _internal_physical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_physical_room(const std::string& value);
  std::string* _internal_mutable_physical_room();
  public:

  // optional string instance_address = 4;
  bool has_instance_address() const;
  private:
  bool _internal_has_instance_address() const;
  public:
  void clear_instance_address();
  const std::string& instance_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_instance_address();
  void set_allocated_instance_address(std::string* instance_address);
  private:
  const std::string& _internal_instance_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_address(const std::string& value);
  std::string* _internal_mutable_instance_address();
  public:

  // optional string user_name = 5;
  bool has_user_name() const;
  private:
  bool _internal_has_user_name() const;
  public:
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // optional string namespace_name = 6;
  bool has_namespace_name() const;
  private:
  bool _internal_has_namespace_name() const;
  public:
  void clear_namespace_name();
  const std::string& namespace_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_namespace_name();
  void set_allocated_namespace_name(std::string* namespace_name);
  private:
  const std::string& _internal_namespace_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_name(const std::string& value);
  std::string* _internal_mutable_namespace_name();
  public:

  // optional string database = 7;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_MUST_USE_RESULT std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // optional string table_name = 8;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional string resource_tag = 10;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional int64 region_id = 9;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.WatchOpType op_type = 1;
  bool has_op_type() const;
  private:
  bool _internal_has_op_type() const;
  public:
  void clear_op_type();
  ::baikaldb::pb::WatchOpType op_type() const;
  void set_op_type(::baikaldb::pb::WatchOpType value);
  private:
  ::baikaldb::pb::WatchOpType _internal_op_type() const;
  void _internal_set_op_type(::baikaldb::pb::WatchOpType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ConsoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr physical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  int op_type_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class ReplicationStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ReplicationStatus) */ {
 public:
  inline ReplicationStatus() : ReplicationStatus(nullptr) {}
  ~ReplicationStatus() override;
  explicit constexpr ReplicationStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplicationStatus(const ReplicationStatus& from);
  ReplicationStatus(ReplicationStatus&& from) noexcept
    : ReplicationStatus() {
    *this = ::std::move(from);
  }

  inline ReplicationStatus& operator=(const ReplicationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicationStatus& operator=(ReplicationStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplicationStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplicationStatus* internal_default_instance() {
    return reinterpret_cast<const ReplicationStatus*>(
               &_ReplicationStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ReplicationStatus& a, ReplicationStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplicationStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplicationStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReplicationStatus* New() const final {
    return new ReplicationStatus();
  }

  ReplicationStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReplicationStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplicationStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReplicationStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplicationStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ReplicationStatus";
  }
  protected:
  explicit ReplicationStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionCountFieldNumber = 1,
    kRowCountFieldNumber = 2,
  };
  // optional int64 region_count = 1;
  bool has_region_count() const;
  private:
  bool _internal_has_region_count() const;
  public:
  void clear_region_count();
  ::PROTOBUF_NAMESPACE_ID::int64 region_count() const;
  void set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_count() const;
  void _internal_set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 row_count = 2;
  bool has_row_count() const;
  private:
  bool _internal_has_row_count() const;
  public:
  void clear_row_count();
  ::PROTOBUF_NAMESPACE_ID::int64 row_count() const;
  void set_row_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_row_count() const;
  void _internal_set_row_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ReplicationStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 row_count_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class QueryParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.QueryParam) */ {
 public:
  inline QueryParam() : QueryParam(nullptr) {}
  ~QueryParam() override;
  explicit constexpr QueryParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryParam(const QueryParam& from);
  QueryParam(QueryParam&& from) noexcept
    : QueryParam() {
    *this = ::std::move(from);
  }

  inline QueryParam& operator=(const QueryParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryParam& operator=(QueryParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryParam* internal_default_instance() {
    return reinterpret_cast<const QueryParam*>(
               &_QueryParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(QueryParam& a, QueryParam& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryParam* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryParam* New() const final {
    return new QueryParam();
  }

  QueryParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryParam& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.QueryParam";
  }
  protected:
  explicit QueryParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhysicalRoomFieldNumber = 2,
    kInstanceFieldNumber = 3,
    kResourceTagFieldNumber = 4,
    kTableNameFieldNumber = 5,
    kRegionIdFieldNumber = 6,
    kStartFieldNumber = 7,
    kLimitFieldNumber = 8,
    kLogicalRoomFieldNumber = 9,
    kStepFieldNumber = 10,
    kNamespaceNameFieldNumber = 11,
    kDatabaseFieldNumber = 12,
    kTableIdFieldNumber = 13,
    kRawStartKeyFieldNumber = 14,
    kDoneFileFieldNumber = 15,
    kClusterNameFieldNumber = 16,
    kAgoDaysFieldNumber = 17,
    kUserSqlFieldNumber = 18,
    kModleFieldNumber = 19,
    kCharsetFieldNumber = 20,
    kIntervalDaysFieldNumber = 21,
    kCrudDatabaseFieldNumber = 22,
    kPlatformFieldNumber = 23,
    kMetaServerBnsFieldNumber = 24,
    kBaikaldbBnsFieldNumber = 25,
    kExportTimeFieldNumber = 26,
    kPartitionIdFieldNumber = 27,
    kOptypeFieldNumber = 1,
  };
  // optional string physical_room = 2;
  bool has_physical_room() const;
  private:
  bool _internal_has_physical_room() const;
  public:
  void clear_physical_room();
  const std::string& physical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_physical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_physical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_physical_room();
  void set_allocated_physical_room(std::string* physical_room);
  private:
  const std::string& _internal_physical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_physical_room(const std::string& value);
  std::string* _internal_mutable_physical_room();
  public:

  // optional string instance = 3;
  bool has_instance() const;
  private:
  bool _internal_has_instance() const;
  public:
  void clear_instance();
  const std::string& instance() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance();
  PROTOBUF_MUST_USE_RESULT std::string* release_instance();
  void set_allocated_instance(std::string* instance);
  private:
  const std::string& _internal_instance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance(const std::string& value);
  std::string* _internal_mutable_instance();
  public:

  // optional string resource_tag = 4;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional string table_name = 5;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional string region_id = 6;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  const std::string& region_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_region_id();
  void set_allocated_region_id(std::string* region_id);
  private:
  const std::string& _internal_region_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region_id(const std::string& value);
  std::string* _internal_mutable_region_id();
  public:

  // optional string start = 7;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const std::string& start() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start();
  PROTOBUF_MUST_USE_RESULT std::string* release_start();
  void set_allocated_start(std::string* start);
  private:
  const std::string& _internal_start() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start(const std::string& value);
  std::string* _internal_mutable_start();
  public:

  // optional string limit = 8;
  bool has_limit() const;
  private:
  bool _internal_has_limit() const;
  public:
  void clear_limit();
  const std::string& limit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_limit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_limit();
  PROTOBUF_MUST_USE_RESULT std::string* release_limit();
  void set_allocated_limit(std::string* limit);
  private:
  const std::string& _internal_limit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_limit(const std::string& value);
  std::string* _internal_mutable_limit();
  public:

  // optional string logical_room = 9;
  bool has_logical_room() const;
  private:
  bool _internal_has_logical_room() const;
  public:
  void clear_logical_room();
  const std::string& logical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_logical_room();
  void set_allocated_logical_room(std::string* logical_room);
  private:
  const std::string& _internal_logical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logical_room(const std::string& value);
  std::string* _internal_mutable_logical_room();
  public:

  // optional string step = 10;
  bool has_step() const;
  private:
  bool _internal_has_step() const;
  public:
  void clear_step();
  const std::string& step() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_step(ArgT0&& arg0, ArgT... args);
  std::string* mutable_step();
  PROTOBUF_MUST_USE_RESULT std::string* release_step();
  void set_allocated_step(std::string* step);
  private:
  const std::string& _internal_step() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_step(const std::string& value);
  std::string* _internal_mutable_step();
  public:

  // optional string namespace_name = 11;
  bool has_namespace_name() const;
  private:
  bool _internal_has_namespace_name() const;
  public:
  void clear_namespace_name();
  const std::string& namespace_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_namespace_name();
  void set_allocated_namespace_name(std::string* namespace_name);
  private:
  const std::string& _internal_namespace_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_name(const std::string& value);
  std::string* _internal_mutable_namespace_name();
  public:

  // optional string database = 12;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_MUST_USE_RESULT std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // optional string table_id = 13;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const std::string& table_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_id();
  void set_allocated_table_id(std::string* table_id);
  private:
  const std::string& _internal_table_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_id(const std::string& value);
  std::string* _internal_mutable_table_id();
  public:

  // optional string raw_start_key = 14;
  bool has_raw_start_key() const;
  private:
  bool _internal_has_raw_start_key() const;
  public:
  void clear_raw_start_key();
  const std::string& raw_start_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw_start_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw_start_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_raw_start_key();
  void set_allocated_raw_start_key(std::string* raw_start_key);
  private:
  const std::string& _internal_raw_start_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_start_key(const std::string& value);
  std::string* _internal_mutable_raw_start_key();
  public:

  // optional string done_file = 15;
  bool has_done_file() const;
  private:
  bool _internal_has_done_file() const;
  public:
  void clear_done_file();
  const std::string& done_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_done_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_done_file();
  PROTOBUF_MUST_USE_RESULT std::string* release_done_file();
  void set_allocated_done_file(std::string* done_file);
  private:
  const std::string& _internal_done_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_done_file(const std::string& value);
  std::string* _internal_mutable_done_file();
  public:

  // optional string cluster_name = 16;
  bool has_cluster_name() const;
  private:
  bool _internal_has_cluster_name() const;
  public:
  void clear_cluster_name();
  const std::string& cluster_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cluster_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cluster_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_cluster_name();
  void set_allocated_cluster_name(std::string* cluster_name);
  private:
  const std::string& _internal_cluster_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cluster_name(const std::string& value);
  std::string* _internal_mutable_cluster_name();
  public:

  // optional string ago_days = 17;
  bool has_ago_days() const;
  private:
  bool _internal_has_ago_days() const;
  public:
  void clear_ago_days();
  const std::string& ago_days() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ago_days(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ago_days();
  PROTOBUF_MUST_USE_RESULT std::string* release_ago_days();
  void set_allocated_ago_days(std::string* ago_days);
  private:
  const std::string& _internal_ago_days() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ago_days(const std::string& value);
  std::string* _internal_mutable_ago_days();
  public:

  // optional string user_sql = 18;
  bool has_user_sql() const;
  private:
  bool _internal_has_user_sql() const;
  public:
  void clear_user_sql();
  const std::string& user_sql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_sql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_sql();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_sql();
  void set_allocated_user_sql(std::string* user_sql);
  private:
  const std::string& _internal_user_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_sql(const std::string& value);
  std::string* _internal_mutable_user_sql();
  public:

  // optional string modle = 19;
  bool has_modle() const;
  private:
  bool _internal_has_modle() const;
  public:
  void clear_modle();
  const std::string& modle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modle();
  PROTOBUF_MUST_USE_RESULT std::string* release_modle();
  void set_allocated_modle(std::string* modle);
  private:
  const std::string& _internal_modle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modle(const std::string& value);
  std::string* _internal_mutable_modle();
  public:

  // optional string charset = 20;
  bool has_charset() const;
  private:
  bool _internal_has_charset() const;
  public:
  void clear_charset();
  const std::string& charset() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_charset(ArgT0&& arg0, ArgT... args);
  std::string* mutable_charset();
  PROTOBUF_MUST_USE_RESULT std::string* release_charset();
  void set_allocated_charset(std::string* charset);
  private:
  const std::string& _internal_charset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_charset(const std::string& value);
  std::string* _internal_mutable_charset();
  public:

  // optional string interval_days = 21;
  bool has_interval_days() const;
  private:
  bool _internal_has_interval_days() const;
  public:
  void clear_interval_days();
  const std::string& interval_days() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interval_days(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interval_days();
  PROTOBUF_MUST_USE_RESULT std::string* release_interval_days();
  void set_allocated_interval_days(std::string* interval_days);
  private:
  const std::string& _internal_interval_days() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interval_days(const std::string& value);
  std::string* _internal_mutable_interval_days();
  public:

  // optional string crud_database = 22;
  bool has_crud_database() const;
  private:
  bool _internal_has_crud_database() const;
  public:
  void clear_crud_database();
  const std::string& crud_database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_crud_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_crud_database();
  PROTOBUF_MUST_USE_RESULT std::string* release_crud_database();
  void set_allocated_crud_database(std::string* crud_database);
  private:
  const std::string& _internal_crud_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_crud_database(const std::string& value);
  std::string* _internal_mutable_crud_database();
  public:

  // optional string platform = 23;
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_MUST_USE_RESULT std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // optional string meta_server_bns = 24;
  bool has_meta_server_bns() const;
  private:
  bool _internal_has_meta_server_bns() const;
  public:
  void clear_meta_server_bns();
  const std::string& meta_server_bns() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_meta_server_bns(ArgT0&& arg0, ArgT... args);
  std::string* mutable_meta_server_bns();
  PROTOBUF_MUST_USE_RESULT std::string* release_meta_server_bns();
  void set_allocated_meta_server_bns(std::string* meta_server_bns);
  private:
  const std::string& _internal_meta_server_bns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_meta_server_bns(const std::string& value);
  std::string* _internal_mutable_meta_server_bns();
  public:

  // optional string baikaldb_bns = 25;
  bool has_baikaldb_bns() const;
  private:
  bool _internal_has_baikaldb_bns() const;
  public:
  void clear_baikaldb_bns();
  const std::string& baikaldb_bns() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_baikaldb_bns(ArgT0&& arg0, ArgT... args);
  std::string* mutable_baikaldb_bns();
  PROTOBUF_MUST_USE_RESULT std::string* release_baikaldb_bns();
  void set_allocated_baikaldb_bns(std::string* baikaldb_bns);
  private:
  const std::string& _internal_baikaldb_bns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_baikaldb_bns(const std::string& value);
  std::string* _internal_mutable_baikaldb_bns();
  public:

  // optional string export_time = 26;
  bool has_export_time() const;
  private:
  bool _internal_has_export_time() const;
  public:
  void clear_export_time();
  const std::string& export_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_export_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_export_time();
  PROTOBUF_MUST_USE_RESULT std::string* release_export_time();
  void set_allocated_export_time(std::string* export_time);
  private:
  const std::string& _internal_export_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_export_time(const std::string& value);
  std::string* _internal_mutable_export_time();
  public:

  // optional string partition_id = 27;
  bool has_partition_id() const;
  private:
  bool _internal_has_partition_id() const;
  public:
  void clear_partition_id();
  const std::string& partition_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partition_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partition_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_partition_id();
  void set_allocated_partition_id(std::string* partition_id);
  private:
  const std::string& _internal_partition_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_id(const std::string& value);
  std::string* _internal_mutable_partition_id();
  public:

  // required .baikaldb.pb.WatchOpType optype = 1;
  bool has_optype() const;
  private:
  bool _internal_has_optype() const;
  public:
  void clear_optype();
  ::baikaldb::pb::WatchOpType optype() const;
  void set_optype(::baikaldb::pb::WatchOpType value);
  private:
  ::baikaldb::pb::WatchOpType _internal_optype() const;
  void _internal_set_optype(::baikaldb::pb::WatchOpType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.QueryParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr physical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr limit_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr step_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_start_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr done_file_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cluster_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ago_days_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_sql_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modle_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr charset_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interval_days_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr crud_database_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr meta_server_bns_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr baikaldb_bns_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr export_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_id_;
  int optype_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class OverViewInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.OverViewInfo) */ {
 public:
  inline OverViewInfo() : OverViewInfo(nullptr) {}
  ~OverViewInfo() override;
  explicit constexpr OverViewInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OverViewInfo(const OverViewInfo& from);
  OverViewInfo(OverViewInfo&& from) noexcept
    : OverViewInfo() {
    *this = ::std::move(from);
  }

  inline OverViewInfo& operator=(const OverViewInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OverViewInfo& operator=(OverViewInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OverViewInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OverViewInfo* internal_default_instance() {
    return reinterpret_cast<const OverViewInfo*>(
               &_OverViewInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(OverViewInfo& a, OverViewInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OverViewInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OverViewInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OverViewInfo* New() const final {
    return new OverViewInfo();
  }

  OverViewInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OverViewInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OverViewInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OverViewInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OverViewInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.OverViewInfo";
  }
  protected:
  explicit OverViewInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsageFieldNumber = 1,
    kInstancesStatusFieldNumber = 2,
    kReplicationsStatusFieldNumber = 3,
  };
  // optional string usage = 1;
  bool has_usage() const;
  private:
  bool _internal_has_usage() const;
  public:
  void clear_usage();
  const std::string& usage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_usage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_usage();
  PROTOBUF_MUST_USE_RESULT std::string* release_usage();
  void set_allocated_usage(std::string* usage);
  private:
  const std::string& _internal_usage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_usage(const std::string& value);
  std::string* _internal_mutable_usage();
  public:

  // optional string instances_status = 2;
  bool has_instances_status() const;
  private:
  bool _internal_has_instances_status() const;
  public:
  void clear_instances_status();
  const std::string& instances_status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instances_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instances_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_instances_status();
  void set_allocated_instances_status(std::string* instances_status);
  private:
  const std::string& _internal_instances_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instances_status(const std::string& value);
  std::string* _internal_mutable_instances_status();
  public:

  // optional .baikaldb.pb.ReplicationStatus replications_status = 3;
  bool has_replications_status() const;
  private:
  bool _internal_has_replications_status() const;
  public:
  void clear_replications_status();
  const ::baikaldb::pb::ReplicationStatus& replications_status() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::ReplicationStatus* release_replications_status();
  ::baikaldb::pb::ReplicationStatus* mutable_replications_status();
  void set_allocated_replications_status(::baikaldb::pb::ReplicationStatus* replications_status);
  private:
  const ::baikaldb::pb::ReplicationStatus& _internal_replications_status() const;
  ::baikaldb::pb::ReplicationStatus* _internal_mutable_replications_status();
  public:
  void unsafe_arena_set_allocated_replications_status(
      ::baikaldb::pb::ReplicationStatus* replications_status);
  ::baikaldb::pb::ReplicationStatus* unsafe_arena_release_replications_status();

  // @@protoc_insertion_point(class_scope:baikaldb.pb.OverViewInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr usage_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instances_status_;
  ::baikaldb::pb::ReplicationStatus* replications_status_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class WatchTableInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.WatchTableInfo) */ {
 public:
  inline WatchTableInfo() : WatchTableInfo(nullptr) {}
  ~WatchTableInfo() override;
  explicit constexpr WatchTableInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchTableInfo(const WatchTableInfo& from);
  WatchTableInfo(WatchTableInfo&& from) noexcept
    : WatchTableInfo() {
    *this = ::std::move(from);
  }

  inline WatchTableInfo& operator=(const WatchTableInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchTableInfo& operator=(WatchTableInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchTableInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchTableInfo* internal_default_instance() {
    return reinterpret_cast<const WatchTableInfo*>(
               &_WatchTableInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(WatchTableInfo& a, WatchTableInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchTableInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchTableInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchTableInfo* New() const final {
    return new WatchTableInfo();
  }

  WatchTableInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchTableInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchTableInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchTableInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchTableInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.WatchTableInfo";
  }
  protected:
  explicit WatchTableInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNameFieldNumber = 3,
    kResourceTagFieldNumber = 4,
    kCreateTimeFieldNumber = 9,
    kBinlogFieldNumber = 16,
    kIdFieldNumber = 1,
    kTableIdFieldNumber = 2,
    kMaxFieldIdFieldNumber = 5,
    kVersionFieldNumber = 6,
    kByteSizePerRecordFieldNumber = 8,
    kRegionCountFieldNumber = 10,
    kRowCountFieldNumber = 11,
    kRegionSizeFieldNumber = 12,
    kMainTableIdFieldNumber = 13,
    kRegionSplitLinesFieldNumber = 14,
    kTableSizeFieldNumber = 15,
    kStatusFieldNumber = 7,
  };
  // optional string table_name = 3;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional string resource_tag = 4;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional string create_time = 9;
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  const std::string& create_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_time();
  PROTOBUF_MUST_USE_RESULT std::string* release_create_time();
  void set_allocated_create_time(std::string* create_time);
  private:
  const std::string& _internal_create_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_time(const std::string& value);
  std::string* _internal_mutable_create_time();
  public:

  // optional string binlog = 16;
  bool has_binlog() const;
  private:
  bool _internal_has_binlog() const;
  public:
  void clear_binlog();
  const std::string& binlog() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binlog(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binlog();
  PROTOBUF_MUST_USE_RESULT std::string* release_binlog();
  void set_allocated_binlog(std::string* binlog);
  private:
  const std::string& _internal_binlog() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binlog(const std::string& value);
  std::string* _internal_mutable_binlog();
  public:

  // optional int64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 table_id = 2;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 max_field_id = 5;
  bool has_max_field_id() const;
  private:
  bool _internal_has_max_field_id() const;
  public:
  void clear_max_field_id();
  ::PROTOBUF_NAMESPACE_ID::int64 max_field_id() const;
  void set_max_field_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_max_field_id() const;
  void _internal_set_max_field_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 version = 6;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 byte_size_per_record = 8;
  bool has_byte_size_per_record() const;
  private:
  bool _internal_has_byte_size_per_record() const;
  public:
  void clear_byte_size_per_record();
  ::PROTOBUF_NAMESPACE_ID::int64 byte_size_per_record() const;
  void set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_byte_size_per_record() const;
  void _internal_set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_count = 10;
  bool has_region_count() const;
  private:
  bool _internal_has_region_count() const;
  public:
  void clear_region_count();
  ::PROTOBUF_NAMESPACE_ID::int64 region_count() const;
  void set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_count() const;
  void _internal_set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 row_count = 11;
  bool has_row_count() const;
  private:
  bool _internal_has_row_count() const;
  public:
  void clear_row_count();
  ::PROTOBUF_NAMESPACE_ID::int64 row_count() const;
  void set_row_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_row_count() const;
  void _internal_set_row_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_size = 12;
  bool has_region_size() const;
  private:
  bool _internal_has_region_size() const;
  public:
  void clear_region_size();
  ::PROTOBUF_NAMESPACE_ID::int64 region_size() const;
  void set_region_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_size() const;
  void _internal_set_region_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 main_table_id = 13;
  bool has_main_table_id() const;
  private:
  bool _internal_has_main_table_id() const;
  public:
  void clear_main_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 main_table_id() const;
  void set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_main_table_id() const;
  void _internal_set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_split_lines = 14;
  bool has_region_split_lines() const;
  private:
  bool _internal_has_region_split_lines() const;
  public:
  void clear_region_split_lines();
  ::PROTOBUF_NAMESPACE_ID::int64 region_split_lines() const;
  void set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_split_lines() const;
  void _internal_set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 table_size = 15;
  bool has_table_size() const;
  private:
  bool _internal_has_table_size() const;
  public:
  void clear_table_size();
  ::PROTOBUF_NAMESPACE_ID::int64 table_size() const;
  void set_table_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_size() const;
  void _internal_set_table_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.Status status = 7;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::baikaldb::pb::Status status() const;
  void set_status(::baikaldb::pb::Status value);
  private:
  ::baikaldb::pb::Status _internal_status() const;
  void _internal_set_status(::baikaldb::pb::Status value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.WatchTableInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binlog_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_field_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  ::PROTOBUF_NAMESPACE_ID::int64 byte_size_per_record_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 row_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 main_table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_split_lines_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_size_;
  int status_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class WatchUserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.WatchUserInfo) */ {
 public:
  inline WatchUserInfo() : WatchUserInfo(nullptr) {}
  ~WatchUserInfo() override;
  explicit constexpr WatchUserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchUserInfo(const WatchUserInfo& from);
  WatchUserInfo(WatchUserInfo&& from) noexcept
    : WatchUserInfo() {
    *this = ::std::move(from);
  }

  inline WatchUserInfo& operator=(const WatchUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchUserInfo& operator=(WatchUserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchUserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchUserInfo* internal_default_instance() {
    return reinterpret_cast<const WatchUserInfo*>(
               &_WatchUserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(WatchUserInfo& a, WatchUserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchUserInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchUserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchUserInfo* New() const final {
    return new WatchUserInfo();
  }

  WatchUserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchUserInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchUserInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchUserInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchUserInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.WatchUserInfo";
  }
  protected:
  explicit WatchUserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kTablenameFieldNumber = 4,
    kNamespaceNameFieldNumber = 6,
    kIdFieldNumber = 3,
    kPermissionFieldNumber = 5,
  };
  // optional string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string password = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional string tablename = 4;
  bool has_tablename() const;
  private:
  bool _internal_has_tablename() const;
  public:
  void clear_tablename();
  const std::string& tablename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tablename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tablename();
  PROTOBUF_MUST_USE_RESULT std::string* release_tablename();
  void set_allocated_tablename(std::string* tablename);
  private:
  const std::string& _internal_tablename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tablename(const std::string& value);
  std::string* _internal_mutable_tablename();
  public:

  // optional string namespace_name = 6;
  bool has_namespace_name() const;
  private:
  bool _internal_has_namespace_name() const;
  public:
  void clear_namespace_name();
  const std::string& namespace_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_namespace_name();
  void set_allocated_namespace_name(std::string* namespace_name);
  private:
  const std::string& _internal_namespace_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_name(const std::string& value);
  std::string* _internal_mutable_namespace_name();
  public:

  // optional int64 id = 3;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.RW permission = 5;
  bool has_permission() const;
  private:
  bool _internal_has_permission() const;
  public:
  void clear_permission();
  ::baikaldb::pb::RW permission() const;
  void set_permission(::baikaldb::pb::RW value);
  private:
  ::baikaldb::pb::RW _internal_permission() const;
  void _internal_set_permission(::baikaldb::pb::RW value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.WatchUserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tablename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_name_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  int permission_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class WatchInstanceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.WatchInstanceInfo) */ {
 public:
  inline WatchInstanceInfo() : WatchInstanceInfo(nullptr) {}
  ~WatchInstanceInfo() override;
  explicit constexpr WatchInstanceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchInstanceInfo(const WatchInstanceInfo& from);
  WatchInstanceInfo(WatchInstanceInfo&& from) noexcept
    : WatchInstanceInfo() {
    *this = ::std::move(from);
  }

  inline WatchInstanceInfo& operator=(const WatchInstanceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchInstanceInfo& operator=(WatchInstanceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchInstanceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchInstanceInfo* internal_default_instance() {
    return reinterpret_cast<const WatchInstanceInfo*>(
               &_WatchInstanceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WatchInstanceInfo& a, WatchInstanceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchInstanceInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchInstanceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchInstanceInfo* New() const final {
    return new WatchInstanceInfo();
  }

  WatchInstanceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchInstanceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchInstanceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchInstanceInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchInstanceInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.WatchInstanceInfo";
  }
  protected:
  explicit WatchInstanceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kResourceTagFieldNumber = 4,
    kPhysicalRoomFieldNumber = 6,
    kLogicalRoomFieldNumber = 7,
    kVersionFieldNumber = 12,
    kCapacityFieldNumber = 2,
    kUsedSizeFieldNumber = 3,
    kPeerCountFieldNumber = 8,
    kLeaderCountFieldNumber = 9,
    kRegionCountFieldNumber = 10,
    kIdFieldNumber = 11,
    kStatusFieldNumber = 5,
  };
  // required string address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional string resource_tag = 4;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional string physical_room = 6;
  bool has_physical_room() const;
  private:
  bool _internal_has_physical_room() const;
  public:
  void clear_physical_room();
  const std::string& physical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_physical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_physical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_physical_room();
  void set_allocated_physical_room(std::string* physical_room);
  private:
  const std::string& _internal_physical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_physical_room(const std::string& value);
  std::string* _internal_mutable_physical_room();
  public:

  // optional string logical_room = 7;
  bool has_logical_room() const;
  private:
  bool _internal_has_logical_room() const;
  public:
  void clear_logical_room();
  const std::string& logical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_logical_room();
  void set_allocated_logical_room(std::string* logical_room);
  private:
  const std::string& _internal_logical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logical_room(const std::string& value);
  std::string* _internal_mutable_logical_room();
  public:

  // optional string version = 12;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional int64 capacity = 2;
  bool has_capacity() const;
  private:
  bool _internal_has_capacity() const;
  public:
  void clear_capacity();
  ::PROTOBUF_NAMESPACE_ID::int64 capacity() const;
  void set_capacity(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_capacity() const;
  void _internal_set_capacity(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 used_size = 3;
  bool has_used_size() const;
  private:
  bool _internal_has_used_size() const;
  public:
  void clear_used_size();
  ::PROTOBUF_NAMESPACE_ID::int64 used_size() const;
  void set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_used_size() const;
  void _internal_set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 peer_count = 8;
  bool has_peer_count() const;
  private:
  bool _internal_has_peer_count() const;
  public:
  void clear_peer_count();
  ::PROTOBUF_NAMESPACE_ID::int64 peer_count() const;
  void set_peer_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_peer_count() const;
  void _internal_set_peer_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 leader_count = 9;
  bool has_leader_count() const;
  private:
  bool _internal_has_leader_count() const;
  public:
  void clear_leader_count();
  ::PROTOBUF_NAMESPACE_ID::int64 leader_count() const;
  void set_leader_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_leader_count() const;
  void _internal_set_leader_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_count = 10;
  bool has_region_count() const;
  private:
  bool _internal_has_region_count() const;
  public:
  void clear_region_count();
  ::PROTOBUF_NAMESPACE_ID::int64 region_count() const;
  void set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_count() const;
  void _internal_set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 id = 11;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.Status status = 5;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::baikaldb::pb::Status status() const;
  void set_status(::baikaldb::pb::Status value);
  private:
  ::baikaldb::pb::Status _internal_status() const;
  void _internal_set_status(::baikaldb::pb::Status value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.WatchInstanceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr physical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::int64 capacity_;
  ::PROTOBUF_NAMESPACE_ID::int64 used_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 peer_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 leader_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  int status_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class WatchRegionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.WatchRegionInfo) */ {
 public:
  inline WatchRegionInfo() : WatchRegionInfo(nullptr) {}
  ~WatchRegionInfo() override;
  explicit constexpr WatchRegionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchRegionInfo(const WatchRegionInfo& from);
  WatchRegionInfo(WatchRegionInfo&& from) noexcept
    : WatchRegionInfo() {
    *this = ::std::move(from);
  }

  inline WatchRegionInfo& operator=(const WatchRegionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchRegionInfo& operator=(WatchRegionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchRegionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchRegionInfo* internal_default_instance() {
    return reinterpret_cast<const WatchRegionInfo*>(
               &_WatchRegionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(WatchRegionInfo& a, WatchRegionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchRegionInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchRegionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchRegionInfo* New() const final {
    return new WatchRegionInfo();
  }

  WatchRegionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchRegionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchRegionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchRegionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchRegionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.WatchRegionInfo";
  }
  protected:
  explicit WatchRegionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNameFieldNumber = 2,
    kStartKeyFieldNumber = 7,
    kEndKeyFieldNumber = 8,
    kPeersFieldNumber = 9,
    kLeaderFieldNumber = 10,
    kResourceTagFieldNumber = 17,
    kCreateTimeFieldNumber = 19,
    kRawStartKeyFieldNumber = 22,
    kRegionIdFieldNumber = 1,
    kPartitionIdFieldNumber = 3,
    kReplicaNumFieldNumber = 4,
    kVersionFieldNumber = 5,
    kConfVersionFieldNumber = 6,
    kUsedSizeFieldNumber = 12,
    kLogIndexFieldNumber = 13,
    kParentFieldNumber = 18,
    kTableIdFieldNumber = 20,
    kIdFieldNumber = 21,
    kNumTableLinesFieldNumber = 23,
    kMainTableIdFieldNumber = 24,
    kStatusFieldNumber = 11,
  };
  // optional string table_name = 2;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional string start_key = 7;
  bool has_start_key() const;
  private:
  bool _internal_has_start_key() const;
  public:
  void clear_start_key();
  const std::string& start_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_start_key();
  void set_allocated_start_key(std::string* start_key);
  private:
  const std::string& _internal_start_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_key(const std::string& value);
  std::string* _internal_mutable_start_key();
  public:

  // optional string end_key = 8;
  bool has_end_key() const;
  private:
  bool _internal_has_end_key() const;
  public:
  void clear_end_key();
  const std::string& end_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_end_key();
  void set_allocated_end_key(std::string* end_key);
  private:
  const std::string& _internal_end_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_key(const std::string& value);
  std::string* _internal_mutable_end_key();
  public:

  // optional string peers = 9;
  bool has_peers() const;
  private:
  bool _internal_has_peers() const;
  public:
  void clear_peers();
  const std::string& peers() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peers(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peers();
  PROTOBUF_MUST_USE_RESULT std::string* release_peers();
  void set_allocated_peers(std::string* peers);
  private:
  const std::string& _internal_peers() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peers(const std::string& value);
  std::string* _internal_mutable_peers();
  public:

  // optional string leader = 10;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // optional string resource_tag = 17;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional string create_time = 19;
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  const std::string& create_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_time();
  PROTOBUF_MUST_USE_RESULT std::string* release_create_time();
  void set_allocated_create_time(std::string* create_time);
  private:
  const std::string& _internal_create_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_time(const std::string& value);
  std::string* _internal_mutable_create_time();
  public:

  // optional string raw_start_key = 22;
  bool has_raw_start_key() const;
  private:
  bool _internal_has_raw_start_key() const;
  public:
  void clear_raw_start_key();
  const std::string& raw_start_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw_start_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw_start_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_raw_start_key();
  void set_allocated_raw_start_key(std::string* raw_start_key);
  private:
  const std::string& _internal_raw_start_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_start_key(const std::string& value);
  std::string* _internal_mutable_raw_start_key();
  public:

  // required int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 partition_id = 3;
  bool has_partition_id() const;
  private:
  bool _internal_has_partition_id() const;
  public:
  void clear_partition_id();
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id() const;
  void set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_partition_id() const;
  void _internal_set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 replica_num = 4;
  bool has_replica_num() const;
  private:
  bool _internal_has_replica_num() const;
  public:
  void clear_replica_num();
  ::PROTOBUF_NAMESPACE_ID::int64 replica_num() const;
  void set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_replica_num() const;
  void _internal_set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 version = 5;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 conf_version = 6;
  bool has_conf_version() const;
  private:
  bool _internal_has_conf_version() const;
  public:
  void clear_conf_version();
  ::PROTOBUF_NAMESPACE_ID::int64 conf_version() const;
  void set_conf_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_conf_version() const;
  void _internal_set_conf_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 used_size = 12;
  bool has_used_size() const;
  private:
  bool _internal_has_used_size() const;
  public:
  void clear_used_size();
  ::PROTOBUF_NAMESPACE_ID::int64 used_size() const;
  void set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_used_size() const;
  void _internal_set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 log_index = 13;
  bool has_log_index() const;
  private:
  bool _internal_has_log_index() const;
  public:
  void clear_log_index();
  ::PROTOBUF_NAMESPACE_ID::int64 log_index() const;
  void set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_log_index() const;
  void _internal_set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 parent = 18;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  ::PROTOBUF_NAMESPACE_ID::int64 parent() const;
  void set_parent(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_parent() const;
  void _internal_set_parent(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 table_id = 20;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 id = 21;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 num_table_lines = 23;
  bool has_num_table_lines() const;
  private:
  bool _internal_has_num_table_lines() const;
  public:
  void clear_num_table_lines();
  ::PROTOBUF_NAMESPACE_ID::int64 num_table_lines() const;
  void set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_num_table_lines() const;
  void _internal_set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 main_table_id = 24;
  bool has_main_table_id() const;
  private:
  bool _internal_has_main_table_id() const;
  public:
  void clear_main_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 main_table_id() const;
  void set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_main_table_id() const;
  void _internal_set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.RegionStatus status = 11;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::baikaldb::pb::RegionStatus status() const;
  void set_status(::baikaldb::pb::RegionStatus value);
  private:
  ::baikaldb::pb::RegionStatus _internal_status() const;
  void _internal_set_status(::baikaldb::pb::RegionStatus value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.WatchRegionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_start_key_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 replica_num_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  ::PROTOBUF_NAMESPACE_ID::int64 conf_version_;
  ::PROTOBUF_NAMESPACE_ID::int64 used_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 log_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 parent_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_table_lines_;
  ::PROTOBUF_NAMESPACE_ID::int64 main_table_id_;
  int status_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class WatchNameSpace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.WatchNameSpace) */ {
 public:
  inline WatchNameSpace() : WatchNameSpace(nullptr) {}
  ~WatchNameSpace() override;
  explicit constexpr WatchNameSpace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchNameSpace(const WatchNameSpace& from);
  WatchNameSpace(WatchNameSpace&& from) noexcept
    : WatchNameSpace() {
    *this = ::std::move(from);
  }

  inline WatchNameSpace& operator=(const WatchNameSpace& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchNameSpace& operator=(WatchNameSpace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchNameSpace& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchNameSpace* internal_default_instance() {
    return reinterpret_cast<const WatchNameSpace*>(
               &_WatchNameSpace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(WatchNameSpace& a, WatchNameSpace& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchNameSpace* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchNameSpace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchNameSpace* New() const final {
    return new WatchNameSpace();
  }

  WatchNameSpace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchNameSpace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchNameSpace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchNameSpace& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchNameSpace* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.WatchNameSpace";
  }
  protected:
  explicit WatchNameSpace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceNameFieldNumber = 1,
  };
  // repeated string namespace_name = 1;
  int namespace_name_size() const;
  private:
  int _internal_namespace_name_size() const;
  public:
  void clear_namespace_name();
  const std::string& namespace_name(int index) const;
  std::string* mutable_namespace_name(int index);
  void set_namespace_name(int index, const std::string& value);
  void set_namespace_name(int index, std::string&& value);
  void set_namespace_name(int index, const char* value);
  void set_namespace_name(int index, const char* value, size_t size);
  std::string* add_namespace_name();
  void add_namespace_name(const std::string& value);
  void add_namespace_name(std::string&& value);
  void add_namespace_name(const char* value);
  void add_namespace_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& namespace_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_namespace_name();
  private:
  const std::string& _internal_namespace_name(int index) const;
  std::string* _internal_add_namespace_name();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.WatchNameSpace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> namespace_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class TableName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TableName) */ {
 public:
  inline TableName() : TableName(nullptr) {}
  ~TableName() override;
  explicit constexpr TableName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableName(const TableName& from);
  TableName(TableName&& from) noexcept
    : TableName() {
    *this = ::std::move(from);
  }

  inline TableName& operator=(const TableName& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableName& operator=(TableName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableName& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableName* internal_default_instance() {
    return reinterpret_cast<const TableName*>(
               &_TableName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TableName& a, TableName& b) {
    a.Swap(&b);
  }
  inline void Swap(TableName* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TableName* New() const final {
    return new TableName();
  }

  TableName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TableName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TableName& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableName* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TableName";
  }
  protected:
  explicit TableName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int64 id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TableName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class WatchDatabaseInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.WatchDatabaseInfo) */ {
 public:
  inline WatchDatabaseInfo() : WatchDatabaseInfo(nullptr) {}
  ~WatchDatabaseInfo() override;
  explicit constexpr WatchDatabaseInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchDatabaseInfo(const WatchDatabaseInfo& from);
  WatchDatabaseInfo(WatchDatabaseInfo&& from) noexcept
    : WatchDatabaseInfo() {
    *this = ::std::move(from);
  }

  inline WatchDatabaseInfo& operator=(const WatchDatabaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchDatabaseInfo& operator=(WatchDatabaseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchDatabaseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchDatabaseInfo* internal_default_instance() {
    return reinterpret_cast<const WatchDatabaseInfo*>(
               &_WatchDatabaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(WatchDatabaseInfo& a, WatchDatabaseInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchDatabaseInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchDatabaseInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchDatabaseInfo* New() const final {
    return new WatchDatabaseInfo();
  }

  WatchDatabaseInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchDatabaseInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchDatabaseInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchDatabaseInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchDatabaseInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.WatchDatabaseInfo";
  }
  protected:
  explicit WatchDatabaseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 3,
    kNameFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // repeated .baikaldb.pb.TableName children = 3;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::baikaldb::pb::TableName* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TableName >*
      mutable_children();
  private:
  const ::baikaldb::pb::TableName& _internal_children(int index) const;
  ::baikaldb::pb::TableName* _internal_add_children();
  public:
  const ::baikaldb::pb::TableName& children(int index) const;
  ::baikaldb::pb::TableName* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TableName >&
      children() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int64 id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.WatchDatabaseInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TableName > children_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class WatchClusterInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.WatchClusterInfo) */ {
 public:
  inline WatchClusterInfo() : WatchClusterInfo(nullptr) {}
  ~WatchClusterInfo() override;
  explicit constexpr WatchClusterInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchClusterInfo(const WatchClusterInfo& from);
  WatchClusterInfo(WatchClusterInfo&& from) noexcept
    : WatchClusterInfo() {
    *this = ::std::move(from);
  }

  inline WatchClusterInfo& operator=(const WatchClusterInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchClusterInfo& operator=(WatchClusterInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchClusterInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchClusterInfo* internal_default_instance() {
    return reinterpret_cast<const WatchClusterInfo*>(
               &_WatchClusterInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(WatchClusterInfo& a, WatchClusterInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchClusterInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchClusterInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchClusterInfo* New() const final {
    return new WatchClusterInfo();
  }

  WatchClusterInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchClusterInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchClusterInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchClusterInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchClusterInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.WatchClusterInfo";
  }
  protected:
  explicit WatchClusterInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int64 id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.WatchClusterInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class WatchImportTask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.WatchImportTask) */ {
 public:
  inline WatchImportTask() : WatchImportTask(nullptr) {}
  ~WatchImportTask() override;
  explicit constexpr WatchImportTask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchImportTask(const WatchImportTask& from);
  WatchImportTask(WatchImportTask&& from) noexcept
    : WatchImportTask() {
    *this = ::std::move(from);
  }

  inline WatchImportTask& operator=(const WatchImportTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchImportTask& operator=(WatchImportTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchImportTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchImportTask* internal_default_instance() {
    return reinterpret_cast<const WatchImportTask*>(
               &_WatchImportTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(WatchImportTask& a, WatchImportTask& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchImportTask* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchImportTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchImportTask* New() const final {
    return new WatchImportTask();
  }

  WatchImportTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchImportTask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchImportTask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchImportTask& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchImportTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.WatchImportTask";
  }
  protected:
  explicit WatchImportTask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 2,
    kEndTimeFieldNumber = 3,
    kExecTimeFieldNumber = 4,
    kModleFieldNumber = 6,
    kStatusFieldNumber = 7,
    kVersionFieldNumber = 1,
    kImportLineFieldNumber = 5,
  };
  // optional string start_time = 2;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const std::string& start_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_time();
  PROTOBUF_MUST_USE_RESULT std::string* release_start_time();
  void set_allocated_start_time(std::string* start_time);
  private:
  const std::string& _internal_start_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_time(const std::string& value);
  std::string* _internal_mutable_start_time();
  public:

  // optional string end_time = 3;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const std::string& end_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end_time();
  PROTOBUF_MUST_USE_RESULT std::string* release_end_time();
  void set_allocated_end_time(std::string* end_time);
  private:
  const std::string& _internal_end_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_time(const std::string& value);
  std::string* _internal_mutable_end_time();
  public:

  // optional string exec_time = 4;
  bool has_exec_time() const;
  private:
  bool _internal_has_exec_time() const;
  public:
  void clear_exec_time();
  const std::string& exec_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exec_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exec_time();
  PROTOBUF_MUST_USE_RESULT std::string* release_exec_time();
  void set_allocated_exec_time(std::string* exec_time);
  private:
  const std::string& _internal_exec_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exec_time(const std::string& value);
  std::string* _internal_mutable_exec_time();
  public:

  // optional string modle = 6;
  bool has_modle() const;
  private:
  bool _internal_has_modle() const;
  public:
  void clear_modle();
  const std::string& modle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modle();
  PROTOBUF_MUST_USE_RESULT std::string* release_modle();
  void set_allocated_modle(std::string* modle);
  private:
  const std::string& _internal_modle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modle(const std::string& value);
  std::string* _internal_mutable_modle();
  public:

  // optional string status = 7;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional int64 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 import_line = 5;
  bool has_import_line() const;
  private:
  bool _internal_has_import_line() const;
  public:
  void clear_import_line();
  ::PROTOBUF_NAMESPACE_ID::int64 import_line() const;
  void set_import_line(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_import_line() const;
  void _internal_set_import_line(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.WatchImportTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exec_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modle_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  ::PROTOBUF_NAMESPACE_ID::int64 import_line_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class WatchSSTTask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.WatchSSTTask) */ {
 public:
  inline WatchSSTTask() : WatchSSTTask(nullptr) {}
  ~WatchSSTTask() override;
  explicit constexpr WatchSSTTask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchSSTTask(const WatchSSTTask& from);
  WatchSSTTask(WatchSSTTask&& from) noexcept
    : WatchSSTTask() {
    *this = ::std::move(from);
  }

  inline WatchSSTTask& operator=(const WatchSSTTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchSSTTask& operator=(WatchSSTTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchSSTTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchSSTTask* internal_default_instance() {
    return reinterpret_cast<const WatchSSTTask*>(
               &_WatchSSTTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(WatchSSTTask& a, WatchSSTTask& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchSSTTask* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchSSTTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchSSTTask* New() const final {
    return new WatchSSTTask();
  }

  WatchSSTTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchSSTTask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchSSTTask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchSSTTask& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchSSTTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.WatchSSTTask";
  }
  protected:
  explicit WatchSSTTask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseFieldNumber = 1,
    kTableNameFieldNumber = 2,
    kTableIdFieldNumber = 3,
    kStartTimeFieldNumber = 4,
    kEndTimeFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  // optional string database = 1;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_MUST_USE_RESULT std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // optional string table_name = 2;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional string table_id = 3;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const std::string& table_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_id();
  void set_allocated_table_id(std::string* table_id);
  private:
  const std::string& _internal_table_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_id(const std::string& value);
  std::string* _internal_mutable_table_id();
  public:

  // optional string start_time = 4;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  const std::string& start_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_time();
  PROTOBUF_MUST_USE_RESULT std::string* release_start_time();
  void set_allocated_start_time(std::string* start_time);
  private:
  const std::string& _internal_start_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_time(const std::string& value);
  std::string* _internal_mutable_start_time();
  public:

  // optional string end_time = 5;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const std::string& end_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end_time();
  PROTOBUF_MUST_USE_RESULT std::string* release_end_time();
  void set_allocated_end_time(std::string* end_time);
  private:
  const std::string& _internal_end_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_time(const std::string& value);
  std::string* _internal_mutable_end_time();
  public:

  // optional string status = 6;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.WatchSSTTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class WatchTaskList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.WatchTaskList) */ {
 public:
  inline WatchTaskList() : WatchTaskList(nullptr) {}
  ~WatchTaskList() override;
  explicit constexpr WatchTaskList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchTaskList(const WatchTaskList& from);
  WatchTaskList(WatchTaskList&& from) noexcept
    : WatchTaskList() {
    *this = ::std::move(from);
  }

  inline WatchTaskList& operator=(const WatchTaskList& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchTaskList& operator=(WatchTaskList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchTaskList& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchTaskList* internal_default_instance() {
    return reinterpret_cast<const WatchTaskList*>(
               &_WatchTaskList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(WatchTaskList& a, WatchTaskList& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchTaskList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchTaskList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchTaskList* New() const final {
    return new WatchTaskList();
  }

  WatchTaskList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchTaskList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchTaskList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchTaskList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchTaskList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.WatchTaskList";
  }
  protected:
  explicit WatchTaskList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableInfoFieldNumber = 1,
    kClusterNameFieldNumber = 2,
    kDoneFileFieldNumber = 3,
    kUserSqlFieldNumber = 4,
    kAgoDaysFieldNumber = 5,
    kCharsetFieldNumber = 6,
    kModleFieldNumber = 7,
    kStatusFieldNumber = 8,
  };
  // optional string table_info = 1;
  bool has_table_info() const;
  private:
  bool _internal_has_table_info() const;
  public:
  void clear_table_info();
  const std::string& table_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_info();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_info();
  void set_allocated_table_info(std::string* table_info);
  private:
  const std::string& _internal_table_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_info(const std::string& value);
  std::string* _internal_mutable_table_info();
  public:

  // optional string cluster_name = 2;
  bool has_cluster_name() const;
  private:
  bool _internal_has_cluster_name() const;
  public:
  void clear_cluster_name();
  const std::string& cluster_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cluster_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cluster_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_cluster_name();
  void set_allocated_cluster_name(std::string* cluster_name);
  private:
  const std::string& _internal_cluster_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cluster_name(const std::string& value);
  std::string* _internal_mutable_cluster_name();
  public:

  // optional string done_file = 3;
  bool has_done_file() const;
  private:
  bool _internal_has_done_file() const;
  public:
  void clear_done_file();
  const std::string& done_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_done_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_done_file();
  PROTOBUF_MUST_USE_RESULT std::string* release_done_file();
  void set_allocated_done_file(std::string* done_file);
  private:
  const std::string& _internal_done_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_done_file(const std::string& value);
  std::string* _internal_mutable_done_file();
  public:

  // optional string user_sql = 4;
  bool has_user_sql() const;
  private:
  bool _internal_has_user_sql() const;
  public:
  void clear_user_sql();
  const std::string& user_sql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_sql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_sql();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_sql();
  void set_allocated_user_sql(std::string* user_sql);
  private:
  const std::string& _internal_user_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_sql(const std::string& value);
  std::string* _internal_mutable_user_sql();
  public:

  // optional string ago_days = 5;
  bool has_ago_days() const;
  private:
  bool _internal_has_ago_days() const;
  public:
  void clear_ago_days();
  const std::string& ago_days() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ago_days(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ago_days();
  PROTOBUF_MUST_USE_RESULT std::string* release_ago_days();
  void set_allocated_ago_days(std::string* ago_days);
  private:
  const std::string& _internal_ago_days() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ago_days(const std::string& value);
  std::string* _internal_mutable_ago_days();
  public:

  // optional string charset = 6;
  bool has_charset() const;
  private:
  bool _internal_has_charset() const;
  public:
  void clear_charset();
  const std::string& charset() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_charset(ArgT0&& arg0, ArgT... args);
  std::string* mutable_charset();
  PROTOBUF_MUST_USE_RESULT std::string* release_charset();
  void set_allocated_charset(std::string* charset);
  private:
  const std::string& _internal_charset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_charset(const std::string& value);
  std::string* _internal_mutable_charset();
  public:

  // optional string modle = 7;
  bool has_modle() const;
  private:
  bool _internal_has_modle() const;
  public:
  void clear_modle();
  const std::string& modle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modle();
  PROTOBUF_MUST_USE_RESULT std::string* release_modle();
  void set_allocated_modle(std::string* modle);
  private:
  const std::string& _internal_modle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modle(const std::string& value);
  std::string* _internal_mutable_modle();
  public:

  // optional string status = 8;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.WatchTaskList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cluster_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr done_file_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_sql_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ago_days_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr charset_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modle_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class WatchSchemaInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.WatchSchemaInfo) */ {
 public:
  inline WatchSchemaInfo() : WatchSchemaInfo(nullptr) {}
  ~WatchSchemaInfo() override;
  explicit constexpr WatchSchemaInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchSchemaInfo(const WatchSchemaInfo& from);
  WatchSchemaInfo(WatchSchemaInfo&& from) noexcept
    : WatchSchemaInfo() {
    *this = ::std::move(from);
  }

  inline WatchSchemaInfo& operator=(const WatchSchemaInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchSchemaInfo& operator=(WatchSchemaInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchSchemaInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchSchemaInfo* internal_default_instance() {
    return reinterpret_cast<const WatchSchemaInfo*>(
               &_WatchSchemaInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(WatchSchemaInfo& a, WatchSchemaInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchSchemaInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchSchemaInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchSchemaInfo* New() const final {
    return new WatchSchemaInfo();
  }

  WatchSchemaInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchSchemaInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchSchemaInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchSchemaInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchSchemaInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.WatchSchemaInfo";
  }
  protected:
  explicit WatchSchemaInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemasFieldNumber = 2,
    kFullTableNameFieldNumber = 1,
  };
  // repeated .baikaldb.pb.QuerySchema schemas = 2;
  int schemas_size() const;
  private:
  int _internal_schemas_size() const;
  public:
  void clear_schemas();
  ::baikaldb::pb::QuerySchema* mutable_schemas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QuerySchema >*
      mutable_schemas();
  private:
  const ::baikaldb::pb::QuerySchema& _internal_schemas(int index) const;
  ::baikaldb::pb::QuerySchema* _internal_add_schemas();
  public:
  const ::baikaldb::pb::QuerySchema& schemas(int index) const;
  ::baikaldb::pb::QuerySchema* add_schemas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QuerySchema >&
      schemas() const;

  // optional string full_table_name = 1;
  bool has_full_table_name() const;
  private:
  bool _internal_has_full_table_name() const;
  public:
  void clear_full_table_name();
  const std::string& full_table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_full_table_name();
  void set_allocated_full_table_name(std::string* full_table_name);
  private:
  const std::string& _internal_full_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_table_name(const std::string& value);
  std::string* _internal_mutable_full_table_name();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.WatchSchemaInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QuerySchema > schemas_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_table_name_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class WatchPlatForm final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.WatchPlatForm) */ {
 public:
  inline WatchPlatForm() : WatchPlatForm(nullptr) {}
  ~WatchPlatForm() override;
  explicit constexpr WatchPlatForm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchPlatForm(const WatchPlatForm& from);
  WatchPlatForm(WatchPlatForm&& from) noexcept
    : WatchPlatForm() {
    *this = ::std::move(from);
  }

  inline WatchPlatForm& operator=(const WatchPlatForm& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchPlatForm& operator=(WatchPlatForm&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchPlatForm& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchPlatForm* internal_default_instance() {
    return reinterpret_cast<const WatchPlatForm*>(
               &_WatchPlatForm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(WatchPlatForm& a, WatchPlatForm& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchPlatForm* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchPlatForm* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WatchPlatForm* New() const final {
    return new WatchPlatForm();
  }

  WatchPlatForm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WatchPlatForm>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchPlatForm& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchPlatForm& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchPlatForm* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.WatchPlatForm";
  }
  protected:
  explicit WatchPlatForm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlatFormFieldNumber = 1,
  };
  // repeated string plat_form = 1;
  int plat_form_size() const;
  private:
  int _internal_plat_form_size() const;
  public:
  void clear_plat_form();
  const std::string& plat_form(int index) const;
  std::string* mutable_plat_form(int index);
  void set_plat_form(int index, const std::string& value);
  void set_plat_form(int index, std::string&& value);
  void set_plat_form(int index, const char* value);
  void set_plat_form(int index, const char* value, size_t size);
  std::string* add_plat_form();
  void add_plat_form(const std::string& value);
  void add_plat_form(std::string&& value);
  void add_plat_form(const char* value);
  void add_plat_form(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& plat_form() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_plat_form();
  private:
  const std::string& _internal_plat_form(int index) const;
  std::string* _internal_add_plat_form();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.WatchPlatForm)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> plat_form_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class ConsoleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ConsoleResponse) */ {
 public:
  inline ConsoleResponse() : ConsoleResponse(nullptr) {}
  ~ConsoleResponse() override;
  explicit constexpr ConsoleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConsoleResponse(const ConsoleResponse& from);
  ConsoleResponse(ConsoleResponse&& from) noexcept
    : ConsoleResponse() {
    *this = ::std::move(from);
  }

  inline ConsoleResponse& operator=(const ConsoleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsoleResponse& operator=(ConsoleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsoleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConsoleResponse* internal_default_instance() {
    return reinterpret_cast<const ConsoleResponse*>(
               &_ConsoleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ConsoleResponse& a, ConsoleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConsoleResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsoleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConsoleResponse* New() const final {
    return new ConsoleResponse();
  }

  ConsoleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConsoleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConsoleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConsoleResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsoleResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ConsoleResponse";
  }
  protected:
  explicit ConsoleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableInfosFieldNumber = 5,
    kInstanceInfosFieldNumber = 6,
    kUserPrivilegesFieldNumber = 7,
    kRegionInfosFieldNumber = 8,
    kDatabasesFieldNumber = 10,
    kClusterInfosFieldNumber = 12,
    kImportTaskFieldNumber = 13,
    kTaskListFieldNumber = 14,
    kSstBackupTaskFieldNumber = 16,
    kErrmsgFieldNumber = 2,
    kOverviewFieldNumber = 4,
    kNamespacesFieldNumber = 9,
    kTableSchemasFieldNumber = 11,
    kPlatFormsFieldNumber = 15,
    kItemnumFieldNumber = 3,
    kPartitionNumFieldNumber = 17,
    kErrcodeFieldNumber = 1,
  };
  // repeated .baikaldb.pb.WatchTableInfo table_infos = 5;
  int table_infos_size() const;
  private:
  int _internal_table_infos_size() const;
  public:
  void clear_table_infos();
  ::baikaldb::pb::WatchTableInfo* mutable_table_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchTableInfo >*
      mutable_table_infos();
  private:
  const ::baikaldb::pb::WatchTableInfo& _internal_table_infos(int index) const;
  ::baikaldb::pb::WatchTableInfo* _internal_add_table_infos();
  public:
  const ::baikaldb::pb::WatchTableInfo& table_infos(int index) const;
  ::baikaldb::pb::WatchTableInfo* add_table_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchTableInfo >&
      table_infos() const;

  // repeated .baikaldb.pb.WatchInstanceInfo instance_infos = 6;
  int instance_infos_size() const;
  private:
  int _internal_instance_infos_size() const;
  public:
  void clear_instance_infos();
  ::baikaldb::pb::WatchInstanceInfo* mutable_instance_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchInstanceInfo >*
      mutable_instance_infos();
  private:
  const ::baikaldb::pb::WatchInstanceInfo& _internal_instance_infos(int index) const;
  ::baikaldb::pb::WatchInstanceInfo* _internal_add_instance_infos();
  public:
  const ::baikaldb::pb::WatchInstanceInfo& instance_infos(int index) const;
  ::baikaldb::pb::WatchInstanceInfo* add_instance_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchInstanceInfo >&
      instance_infos() const;

  // repeated .baikaldb.pb.WatchUserInfo user_privileges = 7;
  int user_privileges_size() const;
  private:
  int _internal_user_privileges_size() const;
  public:
  void clear_user_privileges();
  ::baikaldb::pb::WatchUserInfo* mutable_user_privileges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchUserInfo >*
      mutable_user_privileges();
  private:
  const ::baikaldb::pb::WatchUserInfo& _internal_user_privileges(int index) const;
  ::baikaldb::pb::WatchUserInfo* _internal_add_user_privileges();
  public:
  const ::baikaldb::pb::WatchUserInfo& user_privileges(int index) const;
  ::baikaldb::pb::WatchUserInfo* add_user_privileges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchUserInfo >&
      user_privileges() const;

  // repeated .baikaldb.pb.WatchRegionInfo region_infos = 8;
  int region_infos_size() const;
  private:
  int _internal_region_infos_size() const;
  public:
  void clear_region_infos();
  ::baikaldb::pb::WatchRegionInfo* mutable_region_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchRegionInfo >*
      mutable_region_infos();
  private:
  const ::baikaldb::pb::WatchRegionInfo& _internal_region_infos(int index) const;
  ::baikaldb::pb::WatchRegionInfo* _internal_add_region_infos();
  public:
  const ::baikaldb::pb::WatchRegionInfo& region_infos(int index) const;
  ::baikaldb::pb::WatchRegionInfo* add_region_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchRegionInfo >&
      region_infos() const;

  // repeated .baikaldb.pb.WatchDatabaseInfo databases = 10;
  int databases_size() const;
  private:
  int _internal_databases_size() const;
  public:
  void clear_databases();
  ::baikaldb::pb::WatchDatabaseInfo* mutable_databases(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchDatabaseInfo >*
      mutable_databases();
  private:
  const ::baikaldb::pb::WatchDatabaseInfo& _internal_databases(int index) const;
  ::baikaldb::pb::WatchDatabaseInfo* _internal_add_databases();
  public:
  const ::baikaldb::pb::WatchDatabaseInfo& databases(int index) const;
  ::baikaldb::pb::WatchDatabaseInfo* add_databases();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchDatabaseInfo >&
      databases() const;

  // repeated .baikaldb.pb.WatchClusterInfo cluster_infos = 12;
  int cluster_infos_size() const;
  private:
  int _internal_cluster_infos_size() const;
  public:
  void clear_cluster_infos();
  ::baikaldb::pb::WatchClusterInfo* mutable_cluster_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchClusterInfo >*
      mutable_cluster_infos();
  private:
  const ::baikaldb::pb::WatchClusterInfo& _internal_cluster_infos(int index) const;
  ::baikaldb::pb::WatchClusterInfo* _internal_add_cluster_infos();
  public:
  const ::baikaldb::pb::WatchClusterInfo& cluster_infos(int index) const;
  ::baikaldb::pb::WatchClusterInfo* add_cluster_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchClusterInfo >&
      cluster_infos() const;

  // repeated .baikaldb.pb.WatchImportTask import_task = 13;
  int import_task_size() const;
  private:
  int _internal_import_task_size() const;
  public:
  void clear_import_task();
  ::baikaldb::pb::WatchImportTask* mutable_import_task(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchImportTask >*
      mutable_import_task();
  private:
  const ::baikaldb::pb::WatchImportTask& _internal_import_task(int index) const;
  ::baikaldb::pb::WatchImportTask* _internal_add_import_task();
  public:
  const ::baikaldb::pb::WatchImportTask& import_task(int index) const;
  ::baikaldb::pb::WatchImportTask* add_import_task();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchImportTask >&
      import_task() const;

  // repeated .baikaldb.pb.WatchTaskList task_list = 14;
  int task_list_size() const;
  private:
  int _internal_task_list_size() const;
  public:
  void clear_task_list();
  ::baikaldb::pb::WatchTaskList* mutable_task_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchTaskList >*
      mutable_task_list();
  private:
  const ::baikaldb::pb::WatchTaskList& _internal_task_list(int index) const;
  ::baikaldb::pb::WatchTaskList* _internal_add_task_list();
  public:
  const ::baikaldb::pb::WatchTaskList& task_list(int index) const;
  ::baikaldb::pb::WatchTaskList* add_task_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchTaskList >&
      task_list() const;

  // repeated .baikaldb.pb.WatchSSTTask sst_backup_task = 16;
  int sst_backup_task_size() const;
  private:
  int _internal_sst_backup_task_size() const;
  public:
  void clear_sst_backup_task();
  ::baikaldb::pb::WatchSSTTask* mutable_sst_backup_task(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchSSTTask >*
      mutable_sst_backup_task();
  private:
  const ::baikaldb::pb::WatchSSTTask& _internal_sst_backup_task(int index) const;
  ::baikaldb::pb::WatchSSTTask* _internal_add_sst_backup_task();
  public:
  const ::baikaldb::pb::WatchSSTTask& sst_backup_task(int index) const;
  ::baikaldb::pb::WatchSSTTask* add_sst_backup_task();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchSSTTask >&
      sst_backup_task() const;

  // optional string errmsg = 2;
  bool has_errmsg() const;
  private:
  bool _internal_has_errmsg() const;
  public:
  void clear_errmsg();
  const std::string& errmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errmsg();
  PROTOBUF_MUST_USE_RESULT std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // optional .baikaldb.pb.OverViewInfo overview = 4;
  bool has_overview() const;
  private:
  bool _internal_has_overview() const;
  public:
  void clear_overview();
  const ::baikaldb::pb::OverViewInfo& overview() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::OverViewInfo* release_overview();
  ::baikaldb::pb::OverViewInfo* mutable_overview();
  void set_allocated_overview(::baikaldb::pb::OverViewInfo* overview);
  private:
  const ::baikaldb::pb::OverViewInfo& _internal_overview() const;
  ::baikaldb::pb::OverViewInfo* _internal_mutable_overview();
  public:
  void unsafe_arena_set_allocated_overview(
      ::baikaldb::pb::OverViewInfo* overview);
  ::baikaldb::pb::OverViewInfo* unsafe_arena_release_overview();

  // optional .baikaldb.pb.WatchNameSpace namespaces = 9;
  bool has_namespaces() const;
  private:
  bool _internal_has_namespaces() const;
  public:
  void clear_namespaces();
  const ::baikaldb::pb::WatchNameSpace& namespaces() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::WatchNameSpace* release_namespaces();
  ::baikaldb::pb::WatchNameSpace* mutable_namespaces();
  void set_allocated_namespaces(::baikaldb::pb::WatchNameSpace* namespaces);
  private:
  const ::baikaldb::pb::WatchNameSpace& _internal_namespaces() const;
  ::baikaldb::pb::WatchNameSpace* _internal_mutable_namespaces();
  public:
  void unsafe_arena_set_allocated_namespaces(
      ::baikaldb::pb::WatchNameSpace* namespaces);
  ::baikaldb::pb::WatchNameSpace* unsafe_arena_release_namespaces();

  // optional .baikaldb.pb.WatchSchemaInfo table_schemas = 11;
  bool has_table_schemas() const;
  private:
  bool _internal_has_table_schemas() const;
  public:
  void clear_table_schemas();
  const ::baikaldb::pb::WatchSchemaInfo& table_schemas() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::WatchSchemaInfo* release_table_schemas();
  ::baikaldb::pb::WatchSchemaInfo* mutable_table_schemas();
  void set_allocated_table_schemas(::baikaldb::pb::WatchSchemaInfo* table_schemas);
  private:
  const ::baikaldb::pb::WatchSchemaInfo& _internal_table_schemas() const;
  ::baikaldb::pb::WatchSchemaInfo* _internal_mutable_table_schemas();
  public:
  void unsafe_arena_set_allocated_table_schemas(
      ::baikaldb::pb::WatchSchemaInfo* table_schemas);
  ::baikaldb::pb::WatchSchemaInfo* unsafe_arena_release_table_schemas();

  // optional .baikaldb.pb.WatchPlatForm plat_forms = 15;
  bool has_plat_forms() const;
  private:
  bool _internal_has_plat_forms() const;
  public:
  void clear_plat_forms();
  const ::baikaldb::pb::WatchPlatForm& plat_forms() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::WatchPlatForm* release_plat_forms();
  ::baikaldb::pb::WatchPlatForm* mutable_plat_forms();
  void set_allocated_plat_forms(::baikaldb::pb::WatchPlatForm* plat_forms);
  private:
  const ::baikaldb::pb::WatchPlatForm& _internal_plat_forms() const;
  ::baikaldb::pb::WatchPlatForm* _internal_mutable_plat_forms();
  public:
  void unsafe_arena_set_allocated_plat_forms(
      ::baikaldb::pb::WatchPlatForm* plat_forms);
  ::baikaldb::pb::WatchPlatForm* unsafe_arena_release_plat_forms();

  // optional int64 itemnum = 3;
  bool has_itemnum() const;
  private:
  bool _internal_has_itemnum() const;
  public:
  void clear_itemnum();
  ::PROTOBUF_NAMESPACE_ID::int64 itemnum() const;
  void set_itemnum(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_itemnum() const;
  void _internal_set_itemnum(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 partition_num = 17;
  bool has_partition_num() const;
  private:
  bool _internal_has_partition_num() const;
  public:
  void clear_partition_num();
  ::PROTOBUF_NAMESPACE_ID::int64 partition_num() const;
  void set_partition_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_partition_num() const;
  void _internal_set_partition_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required .baikaldb.pb.ErrCode errcode = 1;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::ErrCode errcode() const;
  void set_errcode(::baikaldb::pb::ErrCode value);
  private:
  ::baikaldb::pb::ErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::ErrCode value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ConsoleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchTableInfo > table_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchInstanceInfo > instance_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchUserInfo > user_privileges_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchRegionInfo > region_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchDatabaseInfo > databases_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchClusterInfo > cluster_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchImportTask > import_task_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchTaskList > task_list_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchSSTTask > sst_backup_task_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  ::baikaldb::pb::OverViewInfo* overview_;
  ::baikaldb::pb::WatchNameSpace* namespaces_;
  ::baikaldb::pb::WatchSchemaInfo* table_schemas_;
  ::baikaldb::pb::WatchPlatForm* plat_forms_;
  ::PROTOBUF_NAMESPACE_ID::int64 itemnum_;
  ::PROTOBUF_NAMESPACE_ID::int64 partition_num_;
  int errcode_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class ShowxCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ShowxCondition) */ {
 public:
  inline ShowxCondition() : ShowxCondition(nullptr) {}
  ~ShowxCondition() override;
  explicit constexpr ShowxCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowxCondition(const ShowxCondition& from);
  ShowxCondition(ShowxCondition&& from) noexcept
    : ShowxCondition() {
    *this = ::std::move(from);
  }

  inline ShowxCondition& operator=(const ShowxCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowxCondition& operator=(ShowxCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShowxCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowxCondition* internal_default_instance() {
    return reinterpret_cast<const ShowxCondition*>(
               &_ShowxCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ShowxCondition& a, ShowxCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(ShowxCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowxCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShowxCondition* New() const final {
    return new ShowxCondition();
  }

  ShowxCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShowxCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShowxCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShowxCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShowxCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ShowxCondition";
  }
  protected:
  explicit ShowxCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTFieldNumber = 1,
    kKFieldNumber = 2,
    kVFieldNumber = 3,
  };
  // optional string t = 1;
  bool has_t() const;
  private:
  bool _internal_has_t() const;
  public:
  void clear_t();
  const std::string& t() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_t(ArgT0&& arg0, ArgT... args);
  std::string* mutable_t();
  PROTOBUF_MUST_USE_RESULT std::string* release_t();
  void set_allocated_t(std::string* t);
  private:
  const std::string& _internal_t() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_t(const std::string& value);
  std::string* _internal_mutable_t();
  public:

  // optional string k = 2;
  bool has_k() const;
  private:
  bool _internal_has_k() const;
  public:
  void clear_k();
  const std::string& k() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_k(ArgT0&& arg0, ArgT... args);
  std::string* mutable_k();
  PROTOBUF_MUST_USE_RESULT std::string* release_k();
  void set_allocated_k(std::string* k);
  private:
  const std::string& _internal_k() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_k(const std::string& value);
  std::string* _internal_mutable_k();
  public:

  // optional string v = 3;
  bool has_v() const;
  private:
  bool _internal_has_v() const;
  public:
  void clear_v();
  const std::string& v() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v();
  PROTOBUF_MUST_USE_RESULT std::string* release_v();
  void set_allocated_v(std::string* v);
  private:
  const std::string& _internal_v() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v(const std::string& value);
  std::string* _internal_mutable_v();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ShowxCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr t_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr k_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class ShowxRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ShowxRequest) */ {
 public:
  inline ShowxRequest() : ShowxRequest(nullptr) {}
  ~ShowxRequest() override;
  explicit constexpr ShowxRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowxRequest(const ShowxRequest& from);
  ShowxRequest(ShowxRequest&& from) noexcept
    : ShowxRequest() {
    *this = ::std::move(from);
  }

  inline ShowxRequest& operator=(const ShowxRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowxRequest& operator=(ShowxRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShowxRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowxRequest* internal_default_instance() {
    return reinterpret_cast<const ShowxRequest*>(
               &_ShowxRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ShowxRequest& a, ShowxRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShowxRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowxRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShowxRequest* New() const final {
    return new ShowxRequest();
  }

  ShowxRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShowxRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShowxRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShowxRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShowxRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ShowxRequest";
  }
  protected:
  explicit ShowxRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionsFieldNumber = 1,
  };
  // repeated .baikaldb.pb.ShowxCondition conditions = 1;
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;
  public:
  void clear_conditions();
  ::baikaldb::pb::ShowxCondition* mutable_conditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ShowxCondition >*
      mutable_conditions();
  private:
  const ::baikaldb::pb::ShowxCondition& _internal_conditions(int index) const;
  ::baikaldb::pb::ShowxCondition* _internal_add_conditions();
  public:
  const ::baikaldb::pb::ShowxCondition& conditions(int index) const;
  ::baikaldb::pb::ShowxCondition* add_conditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ShowxCondition >&
      conditions() const;

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ShowxRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ShowxCondition > conditions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class QueryStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.QueryStatusRequest) */ {
 public:
  inline QueryStatusRequest() : QueryStatusRequest(nullptr) {}
  ~QueryStatusRequest() override;
  explicit constexpr QueryStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryStatusRequest(const QueryStatusRequest& from);
  QueryStatusRequest(QueryStatusRequest&& from) noexcept
    : QueryStatusRequest() {
    *this = ::std::move(from);
  }

  inline QueryStatusRequest& operator=(const QueryStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryStatusRequest& operator=(QueryStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryStatusRequest* internal_default_instance() {
    return reinterpret_cast<const QueryStatusRequest*>(
               &_QueryStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(QueryStatusRequest& a, QueryStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryStatusRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryStatusRequest* New() const final {
    return new QueryStatusRequest();
  }

  QueryStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryStatusRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryStatusRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.QueryStatusRequest";
  }
  protected:
  explicit QueryStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskNameFieldNumber = 1,
    kPlatformFieldNumber = 2,
    kVersionFieldNumber = 3,
  };
  // required string task_name = 1;
  bool has_task_name() const;
  private:
  bool _internal_has_task_name() const;
  public:
  void clear_task_name();
  const std::string& task_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_task_name();
  void set_allocated_task_name(std::string* task_name);
  private:
  const std::string& _internal_task_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_name(const std::string& value);
  std::string* _internal_mutable_task_name();
  public:

  // required string platform = 2;
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_MUST_USE_RESULT std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // required int64 version = 3;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.QueryStatusRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class QueryStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.QueryStatusResponse) */ {
 public:
  inline QueryStatusResponse() : QueryStatusResponse(nullptr) {}
  ~QueryStatusResponse() override;
  explicit constexpr QueryStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryStatusResponse(const QueryStatusResponse& from);
  QueryStatusResponse(QueryStatusResponse&& from) noexcept
    : QueryStatusResponse() {
    *this = ::std::move(from);
  }

  inline QueryStatusResponse& operator=(const QueryStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryStatusResponse& operator=(QueryStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryStatusResponse* internal_default_instance() {
    return reinterpret_cast<const QueryStatusResponse*>(
               &_QueryStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(QueryStatusResponse& a, QueryStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryStatusResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryStatusResponse* New() const final {
    return new QueryStatusResponse();
  }

  QueryStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryStatusResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryStatusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.QueryStatusResponse";
  }
  protected:
  explicit QueryStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kResultFieldNumber = 3,
    kErrcodeFieldNumber = 1,
  };
  // optional string status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional string result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_MUST_USE_RESULT std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // required .baikaldb.pb.ErrCode errcode = 1;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::ErrCode errcode() const;
  void set_errcode(::baikaldb::pb::ErrCode value);
  private:
  ::baikaldb::pb::ErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::ErrCode value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.QueryStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
  int errcode_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class ShowxColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ShowxColumn) */ {
 public:
  inline ShowxColumn() : ShowxColumn(nullptr) {}
  ~ShowxColumn() override;
  explicit constexpr ShowxColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowxColumn(const ShowxColumn& from);
  ShowxColumn(ShowxColumn&& from) noexcept
    : ShowxColumn() {
    *this = ::std::move(from);
  }

  inline ShowxColumn& operator=(const ShowxColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowxColumn& operator=(ShowxColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShowxColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowxColumn* internal_default_instance() {
    return reinterpret_cast<const ShowxColumn*>(
               &_ShowxColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ShowxColumn& a, ShowxColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(ShowxColumn* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowxColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShowxColumn* New() const final {
    return new ShowxColumn();
  }

  ShowxColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShowxColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShowxColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShowxColumn& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShowxColumn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ShowxColumn";
  }
  protected:
  explicit ShowxColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kIdFieldNumber = 2,
    kUnitFieldNumber = 3,
    kTextAlignFieldNumber = 4,
    kWidthFieldNumber = 6,
    kAccuracyFieldNumber = 7,
    kRemarkFieldNumber = 8,
    kAutoWrapFieldNumber = 5,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string unit = 3;
  bool has_unit() const;
  private:
  bool _internal_has_unit() const;
  public:
  void clear_unit();
  const std::string& unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unit();
  PROTOBUF_MUST_USE_RESULT std::string* release_unit();
  void set_allocated_unit(std::string* unit);
  private:
  const std::string& _internal_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unit(const std::string& value);
  std::string* _internal_mutable_unit();
  public:

  // optional string textAlign = 4;
  bool has_textalign() const;
  private:
  bool _internal_has_textalign() const;
  public:
  void clear_textalign();
  const std::string& textalign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_textalign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_textalign();
  PROTOBUF_MUST_USE_RESULT std::string* release_textalign();
  void set_allocated_textalign(std::string* textalign);
  private:
  const std::string& _internal_textalign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_textalign(const std::string& value);
  std::string* _internal_mutable_textalign();
  public:

  // optional string width = 6;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  const std::string& width() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_width(ArgT0&& arg0, ArgT... args);
  std::string* mutable_width();
  PROTOBUF_MUST_USE_RESULT std::string* release_width();
  void set_allocated_width(std::string* width);
  private:
  const std::string& _internal_width() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_width(const std::string& value);
  std::string* _internal_mutable_width();
  public:

  // optional string accuracy = 7;
  bool has_accuracy() const;
  private:
  bool _internal_has_accuracy() const;
  public:
  void clear_accuracy();
  const std::string& accuracy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accuracy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accuracy();
  PROTOBUF_MUST_USE_RESULT std::string* release_accuracy();
  void set_allocated_accuracy(std::string* accuracy);
  private:
  const std::string& _internal_accuracy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accuracy(const std::string& value);
  std::string* _internal_mutable_accuracy();
  public:

  // optional string remark = 8;
  bool has_remark() const;
  private:
  bool _internal_has_remark() const;
  public:
  void clear_remark();
  const std::string& remark() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remark(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remark();
  PROTOBUF_MUST_USE_RESULT std::string* release_remark();
  void set_allocated_remark(std::string* remark);
  private:
  const std::string& _internal_remark() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remark(const std::string& value);
  std::string* _internal_mutable_remark();
  public:

  // optional bool autoWrap = 5;
  bool has_autowrap() const;
  private:
  bool _internal_has_autowrap() const;
  public:
  void clear_autowrap();
  bool autowrap() const;
  void set_autowrap(bool value);
  private:
  bool _internal_autowrap() const;
  void _internal_set_autowrap(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ShowxColumn)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unit_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr textalign_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr width_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accuracy_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remark_;
  bool autowrap_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class ShowxRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ShowxRow) */ {
 public:
  inline ShowxRow() : ShowxRow(nullptr) {}
  ~ShowxRow() override;
  explicit constexpr ShowxRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowxRow(const ShowxRow& from);
  ShowxRow(ShowxRow&& from) noexcept
    : ShowxRow() {
    *this = ::std::move(from);
  }

  inline ShowxRow& operator=(const ShowxRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowxRow& operator=(ShowxRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShowxRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowxRow* internal_default_instance() {
    return reinterpret_cast<const ShowxRow*>(
               &_ShowxRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ShowxRow& a, ShowxRow& b) {
    a.Swap(&b);
  }
  inline void Swap(ShowxRow* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowxRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShowxRow* New() const final {
    return new ShowxRow();
  }

  ShowxRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShowxRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShowxRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShowxRow& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShowxRow* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ShowxRow";
  }
  protected:
  explicit ShowxRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseNameFieldNumber = 1,
    kTableNameFieldNumber = 2,
    kSignFieldNumber = 3,
    kTimeRangeFieldNumber = 4,
    kPvFieldNumber = 5,
    kPvDiffFieldNumber = 6,
    kAvgFieldNumber = 7,
    kAvgDiffFieldNumber = 8,
  };
  // optional string database_name = 1;
  bool has_database_name() const;
  private:
  bool _internal_has_database_name() const;
  public:
  void clear_database_name();
  const std::string& database_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_database_name();
  void set_allocated_database_name(std::string* database_name);
  private:
  const std::string& _internal_database_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database_name(const std::string& value);
  std::string* _internal_mutable_database_name();
  public:

  // optional string table_name = 2;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional string sign = 3;
  bool has_sign() const;
  private:
  bool _internal_has_sign() const;
  public:
  void clear_sign();
  const std::string& sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sign();
  PROTOBUF_MUST_USE_RESULT std::string* release_sign();
  void set_allocated_sign(std::string* sign);
  private:
  const std::string& _internal_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign(const std::string& value);
  std::string* _internal_mutable_sign();
  public:

  // optional string time_range = 4;
  bool has_time_range() const;
  private:
  bool _internal_has_time_range() const;
  public:
  void clear_time_range();
  const std::string& time_range() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_range(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_range();
  PROTOBUF_MUST_USE_RESULT std::string* release_time_range();
  void set_allocated_time_range(std::string* time_range);
  private:
  const std::string& _internal_time_range() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_range(const std::string& value);
  std::string* _internal_mutable_time_range();
  public:

  // optional int64 pv = 5;
  bool has_pv() const;
  private:
  bool _internal_has_pv() const;
  public:
  void clear_pv();
  ::PROTOBUF_NAMESPACE_ID::int64 pv() const;
  void set_pv(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pv() const;
  void _internal_set_pv(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 pv_diff = 6;
  bool has_pv_diff() const;
  private:
  bool _internal_has_pv_diff() const;
  public:
  void clear_pv_diff();
  ::PROTOBUF_NAMESPACE_ID::int64 pv_diff() const;
  void set_pv_diff(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pv_diff() const;
  void _internal_set_pv_diff(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional float avg = 7;
  bool has_avg() const;
  private:
  bool _internal_has_avg() const;
  public:
  void clear_avg();
  float avg() const;
  void set_avg(float value);
  private:
  float _internal_avg() const;
  void _internal_set_avg(float value);
  public:

  // optional float avg_diff = 8;
  bool has_avg_diff() const;
  private:
  bool _internal_has_avg_diff() const;
  public:
  void clear_avg_diff();
  float avg_diff() const;
  void set_avg_diff(float value);
  private:
  float _internal_avg_diff() const;
  void _internal_set_avg_diff(float value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ShowxRow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_range_;
  ::PROTOBUF_NAMESPACE_ID::int64 pv_;
  ::PROTOBUF_NAMESPACE_ID::int64 pv_diff_;
  float avg_;
  float avg_diff_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class ShowxData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ShowxData) */ {
 public:
  inline ShowxData() : ShowxData(nullptr) {}
  ~ShowxData() override;
  explicit constexpr ShowxData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowxData(const ShowxData& from);
  ShowxData(ShowxData&& from) noexcept
    : ShowxData() {
    *this = ::std::move(from);
  }

  inline ShowxData& operator=(const ShowxData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowxData& operator=(ShowxData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShowxData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowxData* internal_default_instance() {
    return reinterpret_cast<const ShowxData*>(
               &_ShowxData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ShowxData& a, ShowxData& b) {
    a.Swap(&b);
  }
  inline void Swap(ShowxData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowxData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShowxData* New() const final {
    return new ShowxData();
  }

  ShowxData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShowxData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShowxData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShowxData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShowxData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ShowxData";
  }
  protected:
  explicit ShowxData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 1,
    kRowsFieldNumber = 2,
  };
  // repeated .baikaldb.pb.ShowxColumn columns = 1;
  int columns_size() const;
  private:
  int _internal_columns_size() const;
  public:
  void clear_columns();
  ::baikaldb::pb::ShowxColumn* mutable_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ShowxColumn >*
      mutable_columns();
  private:
  const ::baikaldb::pb::ShowxColumn& _internal_columns(int index) const;
  ::baikaldb::pb::ShowxColumn* _internal_add_columns();
  public:
  const ::baikaldb::pb::ShowxColumn& columns(int index) const;
  ::baikaldb::pb::ShowxColumn* add_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ShowxColumn >&
      columns() const;

  // repeated .baikaldb.pb.ShowxRow rows = 2;
  int rows_size() const;
  private:
  int _internal_rows_size() const;
  public:
  void clear_rows();
  ::baikaldb::pb::ShowxRow* mutable_rows(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ShowxRow >*
      mutable_rows();
  private:
  const ::baikaldb::pb::ShowxRow& _internal_rows(int index) const;
  ::baikaldb::pb::ShowxRow* _internal_add_rows();
  public:
  const ::baikaldb::pb::ShowxRow& rows(int index) const;
  ::baikaldb::pb::ShowxRow* add_rows();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ShowxRow >&
      rows() const;

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ShowxData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ShowxColumn > columns_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ShowxRow > rows_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_console_2eproto;
};
// -------------------------------------------------------------------

class ShowxResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ShowxResponse) */ {
 public:
  inline ShowxResponse() : ShowxResponse(nullptr) {}
  ~ShowxResponse() override;
  explicit constexpr ShowxResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShowxResponse(const ShowxResponse& from);
  ShowxResponse(ShowxResponse&& from) noexcept
    : ShowxResponse() {
    *this = ::std::move(from);
  }

  inline ShowxResponse& operator=(const ShowxResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShowxResponse& operator=(ShowxResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShowxResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShowxResponse* internal_default_instance() {
    return reinterpret_cast<const ShowxResponse*>(
               &_ShowxResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ShowxResponse& a, ShowxResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShowxResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShowxResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShowxResponse* New() const final {
    return new ShowxResponse();
  }

  ShowxResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShowxResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShowxResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShowxResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShowxResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ShowxResponse";
  }
  protected:
  explicit ShowxResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kDataFieldNumber = 3,
    kStatusFieldNumber = 1,
    kTotalFieldNumber = 4,
  };
  // optional string msg = 2;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // optional .baikaldb.pb.ShowxData data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::baikaldb::pb::ShowxData& data() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::ShowxData* release_data();
  ::baikaldb::pb::ShowxData* mutable_data();
  void set_allocated_data(::baikaldb::pb::ShowxData* data);
  private:
  const ::baikaldb::pb::ShowxData& _internal_data() const;
  ::baikaldb::pb::ShowxData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::baikaldb::pb::ShowxData* data);
  ::baikaldb::pb::ShowxData* unsafe_arena_release_data();

  // optional int64 status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int64 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 total = 4;
  bool has_total() const;
  private:
  bool _internal_has_total() const;
  public:
  void clear_total();
  ::PROTOBUF_NAMESPACE_ID::int64 total() const;
  void set_total(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_total() const;
  void _internal_set_total(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ShowxResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::baikaldb::pb::ShowxData* data_;
  ::PROTOBUF_NAMESPACE_ID::int64 status_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_;
  friend struct ::TableStruct_console_2eproto;
};
// ===================================================================

class ConsoleService_Stub;

class ConsoleService : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline ConsoleService() {};
 public:
  virtual ~ConsoleService();

  typedef ConsoleService_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void watch(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::ConsoleRequest* request,
                       ::baikaldb::pb::ConsoleResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void showx(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::ShowxRequest* request,
                       ::baikaldb::pb::ShowxResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void delete_database(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::ShowxRequest* request,
                       ::baikaldb::pb::ShowxResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void insert_database(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::ShowxRequest* request,
                       ::baikaldb::pb::ShowxResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void backtrack(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::ShowxRequest* request,
                       ::baikaldb::pb::ShowxResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void query_status(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::QueryStatusRequest* request,
                       ::baikaldb::pb::QueryStatusResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ConsoleService);
};

class ConsoleService_Stub : public ConsoleService {
 public:
  ConsoleService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  ConsoleService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~ConsoleService_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements ConsoleService ------------------------------------------

  void watch(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::ConsoleRequest* request,
                       ::baikaldb::pb::ConsoleResponse* response,
                       ::google::protobuf::Closure* done);
  void showx(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::ShowxRequest* request,
                       ::baikaldb::pb::ShowxResponse* response,
                       ::google::protobuf::Closure* done);
  void delete_database(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::ShowxRequest* request,
                       ::baikaldb::pb::ShowxResponse* response,
                       ::google::protobuf::Closure* done);
  void insert_database(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::ShowxRequest* request,
                       ::baikaldb::pb::ShowxResponse* response,
                       ::google::protobuf::Closure* done);
  void backtrack(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::ShowxRequest* request,
                       ::baikaldb::pb::ShowxResponse* response,
                       ::google::protobuf::Closure* done);
  void query_status(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::QueryStatusRequest* request,
                       ::baikaldb::pb::QueryStatusResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ConsoleService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ConsoleRequest

// optional .baikaldb.pb.WatchOpType op_type = 1;
inline bool ConsoleRequest::_internal_has_op_type() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ConsoleRequest::has_op_type() const {
  return _internal_has_op_type();
}
inline void ConsoleRequest::clear_op_type() {
  op_type_ = 1;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::baikaldb::pb::WatchOpType ConsoleRequest::_internal_op_type() const {
  return static_cast< ::baikaldb::pb::WatchOpType >(op_type_);
}
inline ::baikaldb::pb::WatchOpType ConsoleRequest::op_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleRequest.op_type)
  return _internal_op_type();
}
inline void ConsoleRequest::_internal_set_op_type(::baikaldb::pb::WatchOpType value) {
  assert(::baikaldb::pb::WatchOpType_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  op_type_ = value;
}
inline void ConsoleRequest::set_op_type(::baikaldb::pb::WatchOpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleRequest.op_type)
}

// optional string logical_room = 2;
inline bool ConsoleRequest::_internal_has_logical_room() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConsoleRequest::has_logical_room() const {
  return _internal_has_logical_room();
}
inline void ConsoleRequest::clear_logical_room() {
  logical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConsoleRequest::logical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleRequest.logical_room)
  return _internal_logical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsoleRequest::set_logical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleRequest.logical_room)
}
inline std::string* ConsoleRequest::mutable_logical_room() {
  std::string* _s = _internal_mutable_logical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleRequest.logical_room)
  return _s;
}
inline const std::string& ConsoleRequest::_internal_logical_room() const {
  return logical_room_.Get();
}
inline void ConsoleRequest::_internal_set_logical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConsoleRequest::_internal_mutable_logical_room() {
  _has_bits_[0] |= 0x00000001u;
  return logical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConsoleRequest::release_logical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ConsoleRequest.logical_room)
  if (!_internal_has_logical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return logical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConsoleRequest::set_allocated_logical_room(std::string* logical_room) {
  if (logical_room != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  logical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ConsoleRequest.logical_room)
}

// optional string physical_room = 3;
inline bool ConsoleRequest::_internal_has_physical_room() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConsoleRequest::has_physical_room() const {
  return _internal_has_physical_room();
}
inline void ConsoleRequest::clear_physical_room() {
  physical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConsoleRequest::physical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleRequest.physical_room)
  return _internal_physical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsoleRequest::set_physical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleRequest.physical_room)
}
inline std::string* ConsoleRequest::mutable_physical_room() {
  std::string* _s = _internal_mutable_physical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleRequest.physical_room)
  return _s;
}
inline const std::string& ConsoleRequest::_internal_physical_room() const {
  return physical_room_.Get();
}
inline void ConsoleRequest::_internal_set_physical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConsoleRequest::_internal_mutable_physical_room() {
  _has_bits_[0] |= 0x00000002u;
  return physical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConsoleRequest::release_physical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ConsoleRequest.physical_room)
  if (!_internal_has_physical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return physical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConsoleRequest::set_allocated_physical_room(std::string* physical_room) {
  if (physical_room != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  physical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), physical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ConsoleRequest.physical_room)
}

// optional string instance_address = 4;
inline bool ConsoleRequest::_internal_has_instance_address() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConsoleRequest::has_instance_address() const {
  return _internal_has_instance_address();
}
inline void ConsoleRequest::clear_instance_address() {
  instance_address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConsoleRequest::instance_address() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleRequest.instance_address)
  return _internal_instance_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsoleRequest::set_instance_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 instance_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleRequest.instance_address)
}
inline std::string* ConsoleRequest::mutable_instance_address() {
  std::string* _s = _internal_mutable_instance_address();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleRequest.instance_address)
  return _s;
}
inline const std::string& ConsoleRequest::_internal_instance_address() const {
  return instance_address_.Get();
}
inline void ConsoleRequest::_internal_set_instance_address(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  instance_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConsoleRequest::_internal_mutable_instance_address() {
  _has_bits_[0] |= 0x00000004u;
  return instance_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConsoleRequest::release_instance_address() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ConsoleRequest.instance_address)
  if (!_internal_has_instance_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return instance_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConsoleRequest::set_allocated_instance_address(std::string* instance_address) {
  if (instance_address != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  instance_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), instance_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ConsoleRequest.instance_address)
}

// optional string user_name = 5;
inline bool ConsoleRequest::_internal_has_user_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConsoleRequest::has_user_name() const {
  return _internal_has_user_name();
}
inline void ConsoleRequest::clear_user_name() {
  user_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ConsoleRequest::user_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleRequest.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsoleRequest::set_user_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleRequest.user_name)
}
inline std::string* ConsoleRequest::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleRequest.user_name)
  return _s;
}
inline const std::string& ConsoleRequest::_internal_user_name() const {
  return user_name_.Get();
}
inline void ConsoleRequest::_internal_set_user_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConsoleRequest::_internal_mutable_user_name() {
  _has_bits_[0] |= 0x00000008u;
  return user_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConsoleRequest::release_user_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ConsoleRequest.user_name)
  if (!_internal_has_user_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return user_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConsoleRequest::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  user_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ConsoleRequest.user_name)
}

// optional string namespace_name = 6;
inline bool ConsoleRequest::_internal_has_namespace_name() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConsoleRequest::has_namespace_name() const {
  return _internal_has_namespace_name();
}
inline void ConsoleRequest::clear_namespace_name() {
  namespace_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ConsoleRequest::namespace_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleRequest.namespace_name)
  return _internal_namespace_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsoleRequest::set_namespace_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleRequest.namespace_name)
}
inline std::string* ConsoleRequest::mutable_namespace_name() {
  std::string* _s = _internal_mutable_namespace_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleRequest.namespace_name)
  return _s;
}
inline const std::string& ConsoleRequest::_internal_namespace_name() const {
  return namespace_name_.Get();
}
inline void ConsoleRequest::_internal_set_namespace_name(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConsoleRequest::_internal_mutable_namespace_name() {
  _has_bits_[0] |= 0x00000010u;
  return namespace_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConsoleRequest::release_namespace_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ConsoleRequest.namespace_name)
  if (!_internal_has_namespace_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return namespace_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConsoleRequest::set_allocated_namespace_name(std::string* namespace_name) {
  if (namespace_name != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  namespace_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ConsoleRequest.namespace_name)
}

// optional string database = 7;
inline bool ConsoleRequest::_internal_has_database() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConsoleRequest::has_database() const {
  return _internal_has_database();
}
inline void ConsoleRequest::clear_database() {
  database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ConsoleRequest::database() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleRequest.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsoleRequest::set_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleRequest.database)
}
inline std::string* ConsoleRequest::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleRequest.database)
  return _s;
}
inline const std::string& ConsoleRequest::_internal_database() const {
  return database_.Get();
}
inline void ConsoleRequest::_internal_set_database(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConsoleRequest::_internal_mutable_database() {
  _has_bits_[0] |= 0x00000020u;
  return database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConsoleRequest::release_database() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ConsoleRequest.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConsoleRequest::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ConsoleRequest.database)
}

// optional string table_name = 8;
inline bool ConsoleRequest::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConsoleRequest::has_table_name() const {
  return _internal_has_table_name();
}
inline void ConsoleRequest::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ConsoleRequest::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsoleRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleRequest.table_name)
}
inline std::string* ConsoleRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleRequest.table_name)
  return _s;
}
inline const std::string& ConsoleRequest::_internal_table_name() const {
  return table_name_.Get();
}
inline void ConsoleRequest::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConsoleRequest::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000040u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConsoleRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ConsoleRequest.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConsoleRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ConsoleRequest.table_name)
}

// optional int64 region_id = 9;
inline bool ConsoleRequest::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ConsoleRequest::has_region_id() const {
  return _internal_has_region_id();
}
inline void ConsoleRequest::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ConsoleRequest::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ConsoleRequest::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleRequest.region_id)
  return _internal_region_id();
}
inline void ConsoleRequest::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  region_id_ = value;
}
inline void ConsoleRequest::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleRequest.region_id)
}

// optional string resource_tag = 10;
inline bool ConsoleRequest::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ConsoleRequest::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void ConsoleRequest::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ConsoleRequest::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleRequest.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsoleRequest::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleRequest.resource_tag)
}
inline std::string* ConsoleRequest::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleRequest.resource_tag)
  return _s;
}
inline const std::string& ConsoleRequest::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void ConsoleRequest::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConsoleRequest::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000080u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConsoleRequest::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ConsoleRequest.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConsoleRequest::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ConsoleRequest.resource_tag)
}

// -------------------------------------------------------------------

// ReplicationStatus

// optional int64 region_count = 1;
inline bool ReplicationStatus::_internal_has_region_count() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReplicationStatus::has_region_count() const {
  return _internal_has_region_count();
}
inline void ReplicationStatus::clear_region_count() {
  region_count_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReplicationStatus::_internal_region_count() const {
  return region_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReplicationStatus::region_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ReplicationStatus.region_count)
  return _internal_region_count();
}
inline void ReplicationStatus::_internal_set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  region_count_ = value;
}
inline void ReplicationStatus::set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ReplicationStatus.region_count)
}

// optional int64 row_count = 2;
inline bool ReplicationStatus::_internal_has_row_count() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReplicationStatus::has_row_count() const {
  return _internal_has_row_count();
}
inline void ReplicationStatus::clear_row_count() {
  row_count_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReplicationStatus::_internal_row_count() const {
  return row_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReplicationStatus::row_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ReplicationStatus.row_count)
  return _internal_row_count();
}
inline void ReplicationStatus::_internal_set_row_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  row_count_ = value;
}
inline void ReplicationStatus::set_row_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_row_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ReplicationStatus.row_count)
}

// -------------------------------------------------------------------

// QueryParam

// required .baikaldb.pb.WatchOpType optype = 1;
inline bool QueryParam::_internal_has_optype() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool QueryParam::has_optype() const {
  return _internal_has_optype();
}
inline void QueryParam::clear_optype() {
  optype_ = 1;
  _has_bits_[0] &= ~0x04000000u;
}
inline ::baikaldb::pb::WatchOpType QueryParam::_internal_optype() const {
  return static_cast< ::baikaldb::pb::WatchOpType >(optype_);
}
inline ::baikaldb::pb::WatchOpType QueryParam::optype() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.optype)
  return _internal_optype();
}
inline void QueryParam::_internal_set_optype(::baikaldb::pb::WatchOpType value) {
  assert(::baikaldb::pb::WatchOpType_IsValid(value));
  _has_bits_[0] |= 0x04000000u;
  optype_ = value;
}
inline void QueryParam::set_optype(::baikaldb::pb::WatchOpType value) {
  _internal_set_optype(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.optype)
}

// optional string physical_room = 2;
inline bool QueryParam::_internal_has_physical_room() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryParam::has_physical_room() const {
  return _internal_has_physical_room();
}
inline void QueryParam::clear_physical_room() {
  physical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryParam::physical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.physical_room)
  return _internal_physical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_physical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.physical_room)
}
inline std::string* QueryParam::mutable_physical_room() {
  std::string* _s = _internal_mutable_physical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.physical_room)
  return _s;
}
inline const std::string& QueryParam::_internal_physical_room() const {
  return physical_room_.Get();
}
inline void QueryParam::_internal_set_physical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_physical_room() {
  _has_bits_[0] |= 0x00000001u;
  return physical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_physical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.physical_room)
  if (!_internal_has_physical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return physical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_physical_room(std::string* physical_room) {
  if (physical_room != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  physical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), physical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.physical_room)
}

// optional string instance = 3;
inline bool QueryParam::_internal_has_instance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QueryParam::has_instance() const {
  return _internal_has_instance();
}
inline void QueryParam::clear_instance() {
  instance_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryParam::instance() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.instance)
  return _internal_instance();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_instance(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 instance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.instance)
}
inline std::string* QueryParam::mutable_instance() {
  std::string* _s = _internal_mutable_instance();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.instance)
  return _s;
}
inline const std::string& QueryParam::_internal_instance() const {
  return instance_.Get();
}
inline void QueryParam::_internal_set_instance(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  instance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_instance() {
  _has_bits_[0] |= 0x00000002u;
  return instance_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_instance() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.instance)
  if (!_internal_has_instance()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return instance_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_instance(std::string* instance) {
  if (instance != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  instance_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), instance,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.instance)
}

// optional string resource_tag = 4;
inline bool QueryParam::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QueryParam::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void QueryParam::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& QueryParam::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.resource_tag)
}
inline std::string* QueryParam::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.resource_tag)
  return _s;
}
inline const std::string& QueryParam::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void QueryParam::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000004u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.resource_tag)
}

// optional string table_name = 5;
inline bool QueryParam::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QueryParam::has_table_name() const {
  return _internal_has_table_name();
}
inline void QueryParam::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& QueryParam::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.table_name)
}
inline std::string* QueryParam::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.table_name)
  return _s;
}
inline const std::string& QueryParam::_internal_table_name() const {
  return table_name_.Get();
}
inline void QueryParam::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000008u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.table_name)
}

// optional string region_id = 6;
inline bool QueryParam::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QueryParam::has_region_id() const {
  return _internal_has_region_id();
}
inline void QueryParam::clear_region_id() {
  region_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& QueryParam::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.region_id)
  return _internal_region_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_region_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 region_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.region_id)
}
inline std::string* QueryParam::mutable_region_id() {
  std::string* _s = _internal_mutable_region_id();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.region_id)
  return _s;
}
inline const std::string& QueryParam::_internal_region_id() const {
  return region_id_.Get();
}
inline void QueryParam::_internal_set_region_id(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  region_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_region_id() {
  _has_bits_[0] |= 0x00000010u;
  return region_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_region_id() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.region_id)
  if (!_internal_has_region_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return region_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_region_id(std::string* region_id) {
  if (region_id != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  region_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.region_id)
}

// optional string start = 7;
inline bool QueryParam::_internal_has_start() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool QueryParam::has_start() const {
  return _internal_has_start();
}
inline void QueryParam::clear_start() {
  start_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& QueryParam::start() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.start)
  return _internal_start();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_start(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 start_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.start)
}
inline std::string* QueryParam::mutable_start() {
  std::string* _s = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.start)
  return _s;
}
inline const std::string& QueryParam::_internal_start() const {
  return start_.Get();
}
inline void QueryParam::_internal_set_start(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  start_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_start() {
  _has_bits_[0] |= 0x00000020u;
  return start_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_start() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.start)
  if (!_internal_has_start()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return start_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_start(std::string* start) {
  if (start != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  start_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.start)
}

// optional string limit = 8;
inline bool QueryParam::_internal_has_limit() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool QueryParam::has_limit() const {
  return _internal_has_limit();
}
inline void QueryParam::clear_limit() {
  limit_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& QueryParam::limit() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.limit)
  return _internal_limit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_limit(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 limit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.limit)
}
inline std::string* QueryParam::mutable_limit() {
  std::string* _s = _internal_mutable_limit();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.limit)
  return _s;
}
inline const std::string& QueryParam::_internal_limit() const {
  return limit_.Get();
}
inline void QueryParam::_internal_set_limit(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  limit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_limit() {
  _has_bits_[0] |= 0x00000040u;
  return limit_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_limit() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.limit)
  if (!_internal_has_limit()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return limit_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_limit(std::string* limit) {
  if (limit != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  limit_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), limit,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.limit)
}

// optional string logical_room = 9;
inline bool QueryParam::_internal_has_logical_room() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool QueryParam::has_logical_room() const {
  return _internal_has_logical_room();
}
inline void QueryParam::clear_logical_room() {
  logical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& QueryParam::logical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.logical_room)
  return _internal_logical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_logical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.logical_room)
}
inline std::string* QueryParam::mutable_logical_room() {
  std::string* _s = _internal_mutable_logical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.logical_room)
  return _s;
}
inline const std::string& QueryParam::_internal_logical_room() const {
  return logical_room_.Get();
}
inline void QueryParam::_internal_set_logical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_logical_room() {
  _has_bits_[0] |= 0x00000080u;
  return logical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_logical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.logical_room)
  if (!_internal_has_logical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return logical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_logical_room(std::string* logical_room) {
  if (logical_room != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  logical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.logical_room)
}

// optional string step = 10;
inline bool QueryParam::_internal_has_step() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool QueryParam::has_step() const {
  return _internal_has_step();
}
inline void QueryParam::clear_step() {
  step_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& QueryParam::step() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.step)
  return _internal_step();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_step(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 step_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.step)
}
inline std::string* QueryParam::mutable_step() {
  std::string* _s = _internal_mutable_step();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.step)
  return _s;
}
inline const std::string& QueryParam::_internal_step() const {
  return step_.Get();
}
inline void QueryParam::_internal_set_step(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  step_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_step() {
  _has_bits_[0] |= 0x00000100u;
  return step_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_step() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.step)
  if (!_internal_has_step()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  return step_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_step(std::string* step) {
  if (step != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  step_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), step,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.step)
}

// optional string namespace_name = 11;
inline bool QueryParam::_internal_has_namespace_name() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool QueryParam::has_namespace_name() const {
  return _internal_has_namespace_name();
}
inline void QueryParam::clear_namespace_name() {
  namespace_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& QueryParam::namespace_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.namespace_name)
  return _internal_namespace_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_namespace_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.namespace_name)
}
inline std::string* QueryParam::mutable_namespace_name() {
  std::string* _s = _internal_mutable_namespace_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.namespace_name)
  return _s;
}
inline const std::string& QueryParam::_internal_namespace_name() const {
  return namespace_name_.Get();
}
inline void QueryParam::_internal_set_namespace_name(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_namespace_name() {
  _has_bits_[0] |= 0x00000200u;
  return namespace_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_namespace_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.namespace_name)
  if (!_internal_has_namespace_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  return namespace_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_namespace_name(std::string* namespace_name) {
  if (namespace_name != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  namespace_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.namespace_name)
}

// optional string database = 12;
inline bool QueryParam::_internal_has_database() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool QueryParam::has_database() const {
  return _internal_has_database();
}
inline void QueryParam::clear_database() {
  database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& QueryParam::database() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.database)
}
inline std::string* QueryParam::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.database)
  return _s;
}
inline const std::string& QueryParam::_internal_database() const {
  return database_.Get();
}
inline void QueryParam::_internal_set_database(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_database() {
  _has_bits_[0] |= 0x00000400u;
  return database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_database() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  return database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.database)
}

// optional string table_id = 13;
inline bool QueryParam::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool QueryParam::has_table_id() const {
  return _internal_has_table_id();
}
inline void QueryParam::clear_table_id() {
  table_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000800u;
}
inline const std::string& QueryParam::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.table_id)
  return _internal_table_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_table_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000800u;
 table_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.table_id)
}
inline std::string* QueryParam::mutable_table_id() {
  std::string* _s = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.table_id)
  return _s;
}
inline const std::string& QueryParam::_internal_table_id() const {
  return table_id_.Get();
}
inline void QueryParam::_internal_set_table_id(const std::string& value) {
  _has_bits_[0] |= 0x00000800u;
  table_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_table_id() {
  _has_bits_[0] |= 0x00000800u;
  return table_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_table_id() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.table_id)
  if (!_internal_has_table_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000800u;
  return table_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_table_id(std::string* table_id) {
  if (table_id != nullptr) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  table_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.table_id)
}

// optional string raw_start_key = 14;
inline bool QueryParam::_internal_has_raw_start_key() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool QueryParam::has_raw_start_key() const {
  return _internal_has_raw_start_key();
}
inline void QueryParam::clear_raw_start_key() {
  raw_start_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00001000u;
}
inline const std::string& QueryParam::raw_start_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.raw_start_key)
  return _internal_raw_start_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_raw_start_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00001000u;
 raw_start_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.raw_start_key)
}
inline std::string* QueryParam::mutable_raw_start_key() {
  std::string* _s = _internal_mutable_raw_start_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.raw_start_key)
  return _s;
}
inline const std::string& QueryParam::_internal_raw_start_key() const {
  return raw_start_key_.Get();
}
inline void QueryParam::_internal_set_raw_start_key(const std::string& value) {
  _has_bits_[0] |= 0x00001000u;
  raw_start_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_raw_start_key() {
  _has_bits_[0] |= 0x00001000u;
  return raw_start_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_raw_start_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.raw_start_key)
  if (!_internal_has_raw_start_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00001000u;
  return raw_start_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_raw_start_key(std::string* raw_start_key) {
  if (raw_start_key != nullptr) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  raw_start_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), raw_start_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.raw_start_key)
}

// optional string done_file = 15;
inline bool QueryParam::_internal_has_done_file() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool QueryParam::has_done_file() const {
  return _internal_has_done_file();
}
inline void QueryParam::clear_done_file() {
  done_file_.ClearToEmpty();
  _has_bits_[0] &= ~0x00002000u;
}
inline const std::string& QueryParam::done_file() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.done_file)
  return _internal_done_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_done_file(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00002000u;
 done_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.done_file)
}
inline std::string* QueryParam::mutable_done_file() {
  std::string* _s = _internal_mutable_done_file();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.done_file)
  return _s;
}
inline const std::string& QueryParam::_internal_done_file() const {
  return done_file_.Get();
}
inline void QueryParam::_internal_set_done_file(const std::string& value) {
  _has_bits_[0] |= 0x00002000u;
  done_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_done_file() {
  _has_bits_[0] |= 0x00002000u;
  return done_file_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_done_file() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.done_file)
  if (!_internal_has_done_file()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00002000u;
  return done_file_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_done_file(std::string* done_file) {
  if (done_file != nullptr) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  done_file_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), done_file,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.done_file)
}

// optional string cluster_name = 16;
inline bool QueryParam::_internal_has_cluster_name() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool QueryParam::has_cluster_name() const {
  return _internal_has_cluster_name();
}
inline void QueryParam::clear_cluster_name() {
  cluster_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00004000u;
}
inline const std::string& QueryParam::cluster_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.cluster_name)
  return _internal_cluster_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_cluster_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00004000u;
 cluster_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.cluster_name)
}
inline std::string* QueryParam::mutable_cluster_name() {
  std::string* _s = _internal_mutable_cluster_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.cluster_name)
  return _s;
}
inline const std::string& QueryParam::_internal_cluster_name() const {
  return cluster_name_.Get();
}
inline void QueryParam::_internal_set_cluster_name(const std::string& value) {
  _has_bits_[0] |= 0x00004000u;
  cluster_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_cluster_name() {
  _has_bits_[0] |= 0x00004000u;
  return cluster_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_cluster_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.cluster_name)
  if (!_internal_has_cluster_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00004000u;
  return cluster_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_cluster_name(std::string* cluster_name) {
  if (cluster_name != nullptr) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  cluster_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cluster_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.cluster_name)
}

// optional string ago_days = 17;
inline bool QueryParam::_internal_has_ago_days() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool QueryParam::has_ago_days() const {
  return _internal_has_ago_days();
}
inline void QueryParam::clear_ago_days() {
  ago_days_.ClearToEmpty();
  _has_bits_[0] &= ~0x00008000u;
}
inline const std::string& QueryParam::ago_days() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.ago_days)
  return _internal_ago_days();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_ago_days(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00008000u;
 ago_days_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.ago_days)
}
inline std::string* QueryParam::mutable_ago_days() {
  std::string* _s = _internal_mutable_ago_days();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.ago_days)
  return _s;
}
inline const std::string& QueryParam::_internal_ago_days() const {
  return ago_days_.Get();
}
inline void QueryParam::_internal_set_ago_days(const std::string& value) {
  _has_bits_[0] |= 0x00008000u;
  ago_days_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_ago_days() {
  _has_bits_[0] |= 0x00008000u;
  return ago_days_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_ago_days() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.ago_days)
  if (!_internal_has_ago_days()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00008000u;
  return ago_days_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_ago_days(std::string* ago_days) {
  if (ago_days != nullptr) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  ago_days_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ago_days,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.ago_days)
}

// optional string user_sql = 18;
inline bool QueryParam::_internal_has_user_sql() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool QueryParam::has_user_sql() const {
  return _internal_has_user_sql();
}
inline void QueryParam::clear_user_sql() {
  user_sql_.ClearToEmpty();
  _has_bits_[0] &= ~0x00010000u;
}
inline const std::string& QueryParam::user_sql() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.user_sql)
  return _internal_user_sql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_user_sql(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00010000u;
 user_sql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.user_sql)
}
inline std::string* QueryParam::mutable_user_sql() {
  std::string* _s = _internal_mutable_user_sql();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.user_sql)
  return _s;
}
inline const std::string& QueryParam::_internal_user_sql() const {
  return user_sql_.Get();
}
inline void QueryParam::_internal_set_user_sql(const std::string& value) {
  _has_bits_[0] |= 0x00010000u;
  user_sql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_user_sql() {
  _has_bits_[0] |= 0x00010000u;
  return user_sql_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_user_sql() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.user_sql)
  if (!_internal_has_user_sql()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00010000u;
  return user_sql_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_user_sql(std::string* user_sql) {
  if (user_sql != nullptr) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  user_sql_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_sql,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.user_sql)
}

// optional string modle = 19;
inline bool QueryParam::_internal_has_modle() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool QueryParam::has_modle() const {
  return _internal_has_modle();
}
inline void QueryParam::clear_modle() {
  modle_.ClearToEmpty();
  _has_bits_[0] &= ~0x00020000u;
}
inline const std::string& QueryParam::modle() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.modle)
  return _internal_modle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_modle(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00020000u;
 modle_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.modle)
}
inline std::string* QueryParam::mutable_modle() {
  std::string* _s = _internal_mutable_modle();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.modle)
  return _s;
}
inline const std::string& QueryParam::_internal_modle() const {
  return modle_.Get();
}
inline void QueryParam::_internal_set_modle(const std::string& value) {
  _has_bits_[0] |= 0x00020000u;
  modle_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_modle() {
  _has_bits_[0] |= 0x00020000u;
  return modle_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_modle() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.modle)
  if (!_internal_has_modle()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00020000u;
  return modle_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_modle(std::string* modle) {
  if (modle != nullptr) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  modle_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modle,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.modle)
}

// optional string charset = 20;
inline bool QueryParam::_internal_has_charset() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool QueryParam::has_charset() const {
  return _internal_has_charset();
}
inline void QueryParam::clear_charset() {
  charset_.ClearToEmpty();
  _has_bits_[0] &= ~0x00040000u;
}
inline const std::string& QueryParam::charset() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.charset)
  return _internal_charset();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_charset(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00040000u;
 charset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.charset)
}
inline std::string* QueryParam::mutable_charset() {
  std::string* _s = _internal_mutable_charset();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.charset)
  return _s;
}
inline const std::string& QueryParam::_internal_charset() const {
  return charset_.Get();
}
inline void QueryParam::_internal_set_charset(const std::string& value) {
  _has_bits_[0] |= 0x00040000u;
  charset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_charset() {
  _has_bits_[0] |= 0x00040000u;
  return charset_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_charset() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.charset)
  if (!_internal_has_charset()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00040000u;
  return charset_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_charset(std::string* charset) {
  if (charset != nullptr) {
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  charset_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), charset,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.charset)
}

// optional string interval_days = 21;
inline bool QueryParam::_internal_has_interval_days() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool QueryParam::has_interval_days() const {
  return _internal_has_interval_days();
}
inline void QueryParam::clear_interval_days() {
  interval_days_.ClearToEmpty();
  _has_bits_[0] &= ~0x00080000u;
}
inline const std::string& QueryParam::interval_days() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.interval_days)
  return _internal_interval_days();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_interval_days(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00080000u;
 interval_days_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.interval_days)
}
inline std::string* QueryParam::mutable_interval_days() {
  std::string* _s = _internal_mutable_interval_days();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.interval_days)
  return _s;
}
inline const std::string& QueryParam::_internal_interval_days() const {
  return interval_days_.Get();
}
inline void QueryParam::_internal_set_interval_days(const std::string& value) {
  _has_bits_[0] |= 0x00080000u;
  interval_days_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_interval_days() {
  _has_bits_[0] |= 0x00080000u;
  return interval_days_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_interval_days() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.interval_days)
  if (!_internal_has_interval_days()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00080000u;
  return interval_days_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_interval_days(std::string* interval_days) {
  if (interval_days != nullptr) {
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  interval_days_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), interval_days,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.interval_days)
}

// optional string crud_database = 22;
inline bool QueryParam::_internal_has_crud_database() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool QueryParam::has_crud_database() const {
  return _internal_has_crud_database();
}
inline void QueryParam::clear_crud_database() {
  crud_database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00100000u;
}
inline const std::string& QueryParam::crud_database() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.crud_database)
  return _internal_crud_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_crud_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00100000u;
 crud_database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.crud_database)
}
inline std::string* QueryParam::mutable_crud_database() {
  std::string* _s = _internal_mutable_crud_database();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.crud_database)
  return _s;
}
inline const std::string& QueryParam::_internal_crud_database() const {
  return crud_database_.Get();
}
inline void QueryParam::_internal_set_crud_database(const std::string& value) {
  _has_bits_[0] |= 0x00100000u;
  crud_database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_crud_database() {
  _has_bits_[0] |= 0x00100000u;
  return crud_database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_crud_database() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.crud_database)
  if (!_internal_has_crud_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00100000u;
  return crud_database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_crud_database(std::string* crud_database) {
  if (crud_database != nullptr) {
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  crud_database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), crud_database,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.crud_database)
}

// optional string platform = 23;
inline bool QueryParam::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool QueryParam::has_platform() const {
  return _internal_has_platform();
}
inline void QueryParam::clear_platform() {
  platform_.ClearToEmpty();
  _has_bits_[0] &= ~0x00200000u;
}
inline const std::string& QueryParam::platform() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_platform(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00200000u;
 platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.platform)
}
inline std::string* QueryParam::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.platform)
  return _s;
}
inline const std::string& QueryParam::_internal_platform() const {
  return platform_.Get();
}
inline void QueryParam::_internal_set_platform(const std::string& value) {
  _has_bits_[0] |= 0x00200000u;
  platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_platform() {
  _has_bits_[0] |= 0x00200000u;
  return platform_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_platform() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.platform)
  if (!_internal_has_platform()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00200000u;
  return platform_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  platform_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.platform)
}

// optional string meta_server_bns = 24;
inline bool QueryParam::_internal_has_meta_server_bns() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool QueryParam::has_meta_server_bns() const {
  return _internal_has_meta_server_bns();
}
inline void QueryParam::clear_meta_server_bns() {
  meta_server_bns_.ClearToEmpty();
  _has_bits_[0] &= ~0x00400000u;
}
inline const std::string& QueryParam::meta_server_bns() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.meta_server_bns)
  return _internal_meta_server_bns();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_meta_server_bns(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00400000u;
 meta_server_bns_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.meta_server_bns)
}
inline std::string* QueryParam::mutable_meta_server_bns() {
  std::string* _s = _internal_mutable_meta_server_bns();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.meta_server_bns)
  return _s;
}
inline const std::string& QueryParam::_internal_meta_server_bns() const {
  return meta_server_bns_.Get();
}
inline void QueryParam::_internal_set_meta_server_bns(const std::string& value) {
  _has_bits_[0] |= 0x00400000u;
  meta_server_bns_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_meta_server_bns() {
  _has_bits_[0] |= 0x00400000u;
  return meta_server_bns_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_meta_server_bns() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.meta_server_bns)
  if (!_internal_has_meta_server_bns()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00400000u;
  return meta_server_bns_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_meta_server_bns(std::string* meta_server_bns) {
  if (meta_server_bns != nullptr) {
    _has_bits_[0] |= 0x00400000u;
  } else {
    _has_bits_[0] &= ~0x00400000u;
  }
  meta_server_bns_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), meta_server_bns,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.meta_server_bns)
}

// optional string baikaldb_bns = 25;
inline bool QueryParam::_internal_has_baikaldb_bns() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool QueryParam::has_baikaldb_bns() const {
  return _internal_has_baikaldb_bns();
}
inline void QueryParam::clear_baikaldb_bns() {
  baikaldb_bns_.ClearToEmpty();
  _has_bits_[0] &= ~0x00800000u;
}
inline const std::string& QueryParam::baikaldb_bns() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.baikaldb_bns)
  return _internal_baikaldb_bns();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_baikaldb_bns(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00800000u;
 baikaldb_bns_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.baikaldb_bns)
}
inline std::string* QueryParam::mutable_baikaldb_bns() {
  std::string* _s = _internal_mutable_baikaldb_bns();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.baikaldb_bns)
  return _s;
}
inline const std::string& QueryParam::_internal_baikaldb_bns() const {
  return baikaldb_bns_.Get();
}
inline void QueryParam::_internal_set_baikaldb_bns(const std::string& value) {
  _has_bits_[0] |= 0x00800000u;
  baikaldb_bns_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_baikaldb_bns() {
  _has_bits_[0] |= 0x00800000u;
  return baikaldb_bns_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_baikaldb_bns() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.baikaldb_bns)
  if (!_internal_has_baikaldb_bns()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00800000u;
  return baikaldb_bns_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_baikaldb_bns(std::string* baikaldb_bns) {
  if (baikaldb_bns != nullptr) {
    _has_bits_[0] |= 0x00800000u;
  } else {
    _has_bits_[0] &= ~0x00800000u;
  }
  baikaldb_bns_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), baikaldb_bns,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.baikaldb_bns)
}

// optional string export_time = 26;
inline bool QueryParam::_internal_has_export_time() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool QueryParam::has_export_time() const {
  return _internal_has_export_time();
}
inline void QueryParam::clear_export_time() {
  export_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x01000000u;
}
inline const std::string& QueryParam::export_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.export_time)
  return _internal_export_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_export_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x01000000u;
 export_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.export_time)
}
inline std::string* QueryParam::mutable_export_time() {
  std::string* _s = _internal_mutable_export_time();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.export_time)
  return _s;
}
inline const std::string& QueryParam::_internal_export_time() const {
  return export_time_.Get();
}
inline void QueryParam::_internal_set_export_time(const std::string& value) {
  _has_bits_[0] |= 0x01000000u;
  export_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_export_time() {
  _has_bits_[0] |= 0x01000000u;
  return export_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_export_time() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.export_time)
  if (!_internal_has_export_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x01000000u;
  return export_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_export_time(std::string* export_time) {
  if (export_time != nullptr) {
    _has_bits_[0] |= 0x01000000u;
  } else {
    _has_bits_[0] &= ~0x01000000u;
  }
  export_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), export_time,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.export_time)
}

// optional string partition_id = 27;
inline bool QueryParam::_internal_has_partition_id() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool QueryParam::has_partition_id() const {
  return _internal_has_partition_id();
}
inline void QueryParam::clear_partition_id() {
  partition_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x02000000u;
}
inline const std::string& QueryParam::partition_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryParam.partition_id)
  return _internal_partition_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryParam::set_partition_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x02000000u;
 partition_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryParam.partition_id)
}
inline std::string* QueryParam::mutable_partition_id() {
  std::string* _s = _internal_mutable_partition_id();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryParam.partition_id)
  return _s;
}
inline const std::string& QueryParam::_internal_partition_id() const {
  return partition_id_.Get();
}
inline void QueryParam::_internal_set_partition_id(const std::string& value) {
  _has_bits_[0] |= 0x02000000u;
  partition_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryParam::_internal_mutable_partition_id() {
  _has_bits_[0] |= 0x02000000u;
  return partition_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryParam::release_partition_id() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryParam.partition_id)
  if (!_internal_has_partition_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x02000000u;
  return partition_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryParam::set_allocated_partition_id(std::string* partition_id) {
  if (partition_id != nullptr) {
    _has_bits_[0] |= 0x02000000u;
  } else {
    _has_bits_[0] &= ~0x02000000u;
  }
  partition_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partition_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryParam.partition_id)
}

// -------------------------------------------------------------------

// OverViewInfo

// optional string usage = 1;
inline bool OverViewInfo::_internal_has_usage() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OverViewInfo::has_usage() const {
  return _internal_has_usage();
}
inline void OverViewInfo::clear_usage() {
  usage_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OverViewInfo::usage() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OverViewInfo.usage)
  return _internal_usage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OverViewInfo::set_usage(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 usage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.OverViewInfo.usage)
}
inline std::string* OverViewInfo::mutable_usage() {
  std::string* _s = _internal_mutable_usage();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OverViewInfo.usage)
  return _s;
}
inline const std::string& OverViewInfo::_internal_usage() const {
  return usage_.Get();
}
inline void OverViewInfo::_internal_set_usage(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  usage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OverViewInfo::_internal_mutable_usage() {
  _has_bits_[0] |= 0x00000001u;
  return usage_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OverViewInfo::release_usage() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OverViewInfo.usage)
  if (!_internal_has_usage()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return usage_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OverViewInfo::set_allocated_usage(std::string* usage) {
  if (usage != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  usage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), usage,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OverViewInfo.usage)
}

// optional string instances_status = 2;
inline bool OverViewInfo::_internal_has_instances_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OverViewInfo::has_instances_status() const {
  return _internal_has_instances_status();
}
inline void OverViewInfo::clear_instances_status() {
  instances_status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OverViewInfo::instances_status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OverViewInfo.instances_status)
  return _internal_instances_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OverViewInfo::set_instances_status(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 instances_status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.OverViewInfo.instances_status)
}
inline std::string* OverViewInfo::mutable_instances_status() {
  std::string* _s = _internal_mutable_instances_status();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OverViewInfo.instances_status)
  return _s;
}
inline const std::string& OverViewInfo::_internal_instances_status() const {
  return instances_status_.Get();
}
inline void OverViewInfo::_internal_set_instances_status(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  instances_status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OverViewInfo::_internal_mutable_instances_status() {
  _has_bits_[0] |= 0x00000002u;
  return instances_status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OverViewInfo::release_instances_status() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OverViewInfo.instances_status)
  if (!_internal_has_instances_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return instances_status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OverViewInfo::set_allocated_instances_status(std::string* instances_status) {
  if (instances_status != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  instances_status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), instances_status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OverViewInfo.instances_status)
}

// optional .baikaldb.pb.ReplicationStatus replications_status = 3;
inline bool OverViewInfo::_internal_has_replications_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || replications_status_ != nullptr);
  return value;
}
inline bool OverViewInfo::has_replications_status() const {
  return _internal_has_replications_status();
}
inline void OverViewInfo::clear_replications_status() {
  if (replications_status_ != nullptr) replications_status_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::baikaldb::pb::ReplicationStatus& OverViewInfo::_internal_replications_status() const {
  const ::baikaldb::pb::ReplicationStatus* p = replications_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::ReplicationStatus&>(
      ::baikaldb::pb::_ReplicationStatus_default_instance_);
}
inline const ::baikaldb::pb::ReplicationStatus& OverViewInfo::replications_status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OverViewInfo.replications_status)
  return _internal_replications_status();
}
inline void OverViewInfo::unsafe_arena_set_allocated_replications_status(
    ::baikaldb::pb::ReplicationStatus* replications_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(replications_status_);
  }
  replications_status_ = replications_status;
  if (replications_status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.OverViewInfo.replications_status)
}
inline ::baikaldb::pb::ReplicationStatus* OverViewInfo::release_replications_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::ReplicationStatus* temp = replications_status_;
  replications_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::ReplicationStatus* OverViewInfo::unsafe_arena_release_replications_status() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OverViewInfo.replications_status)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::ReplicationStatus* temp = replications_status_;
  replications_status_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::ReplicationStatus* OverViewInfo::_internal_mutable_replications_status() {
  _has_bits_[0] |= 0x00000004u;
  if (replications_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::ReplicationStatus>(GetArenaForAllocation());
    replications_status_ = p;
  }
  return replications_status_;
}
inline ::baikaldb::pb::ReplicationStatus* OverViewInfo::mutable_replications_status() {
  ::baikaldb::pb::ReplicationStatus* _msg = _internal_mutable_replications_status();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OverViewInfo.replications_status)
  return _msg;
}
inline void OverViewInfo::set_allocated_replications_status(::baikaldb::pb::ReplicationStatus* replications_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete replications_status_;
  }
  if (replications_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::ReplicationStatus>::GetOwningArena(replications_status);
    if (message_arena != submessage_arena) {
      replications_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, replications_status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  replications_status_ = replications_status;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OverViewInfo.replications_status)
}

// -------------------------------------------------------------------

// WatchTableInfo

// optional int64 id = 1;
inline bool WatchTableInfo::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool WatchTableInfo::has_id() const {
  return _internal_has_id();
}
inline void WatchTableInfo::clear_id() {
  id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTableInfo.id)
  return _internal_id();
}
inline void WatchTableInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  id_ = value;
}
inline void WatchTableInfo::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTableInfo.id)
}

// optional int64 table_id = 2;
inline bool WatchTableInfo::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool WatchTableInfo::has_table_id() const {
  return _internal_has_table_id();
}
inline void WatchTableInfo::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTableInfo.table_id)
  return _internal_table_id();
}
inline void WatchTableInfo::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  table_id_ = value;
}
inline void WatchTableInfo::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTableInfo.table_id)
}

// optional string table_name = 3;
inline bool WatchTableInfo::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WatchTableInfo::has_table_name() const {
  return _internal_has_table_name();
}
inline void WatchTableInfo::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WatchTableInfo::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTableInfo.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchTableInfo::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTableInfo.table_name)
}
inline std::string* WatchTableInfo::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchTableInfo.table_name)
  return _s;
}
inline const std::string& WatchTableInfo::_internal_table_name() const {
  return table_name_.Get();
}
inline void WatchTableInfo::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchTableInfo::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000001u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchTableInfo::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchTableInfo.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchTableInfo::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchTableInfo.table_name)
}

// optional string resource_tag = 4;
inline bool WatchTableInfo::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WatchTableInfo::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void WatchTableInfo::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WatchTableInfo::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTableInfo.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchTableInfo::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTableInfo.resource_tag)
}
inline std::string* WatchTableInfo::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchTableInfo.resource_tag)
  return _s;
}
inline const std::string& WatchTableInfo::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void WatchTableInfo::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchTableInfo::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000002u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchTableInfo::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchTableInfo.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchTableInfo::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchTableInfo.resource_tag)
}

// optional int64 max_field_id = 5;
inline bool WatchTableInfo::_internal_has_max_field_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool WatchTableInfo::has_max_field_id() const {
  return _internal_has_max_field_id();
}
inline void WatchTableInfo::clear_max_field_id() {
  max_field_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::_internal_max_field_id() const {
  return max_field_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::max_field_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTableInfo.max_field_id)
  return _internal_max_field_id();
}
inline void WatchTableInfo::_internal_set_max_field_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  max_field_id_ = value;
}
inline void WatchTableInfo::set_max_field_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_max_field_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTableInfo.max_field_id)
}

// optional int64 version = 6;
inline bool WatchTableInfo::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool WatchTableInfo::has_version() const {
  return _internal_has_version();
}
inline void WatchTableInfo::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTableInfo.version)
  return _internal_version();
}
inline void WatchTableInfo::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  version_ = value;
}
inline void WatchTableInfo::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTableInfo.version)
}

// optional .baikaldb.pb.Status status = 7;
inline bool WatchTableInfo::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool WatchTableInfo::has_status() const {
  return _internal_has_status();
}
inline void WatchTableInfo::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::baikaldb::pb::Status WatchTableInfo::_internal_status() const {
  return static_cast< ::baikaldb::pb::Status >(status_);
}
inline ::baikaldb::pb::Status WatchTableInfo::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTableInfo.status)
  return _internal_status();
}
inline void WatchTableInfo::_internal_set_status(::baikaldb::pb::Status value) {
  assert(::baikaldb::pb::Status_IsValid(value));
  _has_bits_[0] |= 0x00008000u;
  status_ = value;
}
inline void WatchTableInfo::set_status(::baikaldb::pb::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTableInfo.status)
}

// optional int64 byte_size_per_record = 8;
inline bool WatchTableInfo::_internal_has_byte_size_per_record() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool WatchTableInfo::has_byte_size_per_record() const {
  return _internal_has_byte_size_per_record();
}
inline void WatchTableInfo::clear_byte_size_per_record() {
  byte_size_per_record_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::_internal_byte_size_per_record() const {
  return byte_size_per_record_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::byte_size_per_record() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTableInfo.byte_size_per_record)
  return _internal_byte_size_per_record();
}
inline void WatchTableInfo::_internal_set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  byte_size_per_record_ = value;
}
inline void WatchTableInfo::set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_byte_size_per_record(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTableInfo.byte_size_per_record)
}

// optional string create_time = 9;
inline bool WatchTableInfo::_internal_has_create_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WatchTableInfo::has_create_time() const {
  return _internal_has_create_time();
}
inline void WatchTableInfo::clear_create_time() {
  create_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& WatchTableInfo::create_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTableInfo.create_time)
  return _internal_create_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchTableInfo::set_create_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 create_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTableInfo.create_time)
}
inline std::string* WatchTableInfo::mutable_create_time() {
  std::string* _s = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchTableInfo.create_time)
  return _s;
}
inline const std::string& WatchTableInfo::_internal_create_time() const {
  return create_time_.Get();
}
inline void WatchTableInfo::_internal_set_create_time(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  create_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchTableInfo::_internal_mutable_create_time() {
  _has_bits_[0] |= 0x00000004u;
  return create_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchTableInfo::release_create_time() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchTableInfo.create_time)
  if (!_internal_has_create_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return create_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchTableInfo::set_allocated_create_time(std::string* create_time) {
  if (create_time != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  create_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), create_time,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchTableInfo.create_time)
}

// optional int64 region_count = 10;
inline bool WatchTableInfo::_internal_has_region_count() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool WatchTableInfo::has_region_count() const {
  return _internal_has_region_count();
}
inline void WatchTableInfo::clear_region_count() {
  region_count_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::_internal_region_count() const {
  return region_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::region_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTableInfo.region_count)
  return _internal_region_count();
}
inline void WatchTableInfo::_internal_set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  region_count_ = value;
}
inline void WatchTableInfo::set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTableInfo.region_count)
}

// optional int64 row_count = 11;
inline bool WatchTableInfo::_internal_has_row_count() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool WatchTableInfo::has_row_count() const {
  return _internal_has_row_count();
}
inline void WatchTableInfo::clear_row_count() {
  row_count_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::_internal_row_count() const {
  return row_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::row_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTableInfo.row_count)
  return _internal_row_count();
}
inline void WatchTableInfo::_internal_set_row_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  row_count_ = value;
}
inline void WatchTableInfo::set_row_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_row_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTableInfo.row_count)
}

// optional int64 region_size = 12;
inline bool WatchTableInfo::_internal_has_region_size() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool WatchTableInfo::has_region_size() const {
  return _internal_has_region_size();
}
inline void WatchTableInfo::clear_region_size() {
  region_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::_internal_region_size() const {
  return region_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::region_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTableInfo.region_size)
  return _internal_region_size();
}
inline void WatchTableInfo::_internal_set_region_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  region_size_ = value;
}
inline void WatchTableInfo::set_region_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTableInfo.region_size)
}

// optional int64 main_table_id = 13;
inline bool WatchTableInfo::_internal_has_main_table_id() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool WatchTableInfo::has_main_table_id() const {
  return _internal_has_main_table_id();
}
inline void WatchTableInfo::clear_main_table_id() {
  main_table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::_internal_main_table_id() const {
  return main_table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::main_table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTableInfo.main_table_id)
  return _internal_main_table_id();
}
inline void WatchTableInfo::_internal_set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00001000u;
  main_table_id_ = value;
}
inline void WatchTableInfo::set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_main_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTableInfo.main_table_id)
}

// optional int64 region_split_lines = 14;
inline bool WatchTableInfo::_internal_has_region_split_lines() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool WatchTableInfo::has_region_split_lines() const {
  return _internal_has_region_split_lines();
}
inline void WatchTableInfo::clear_region_split_lines() {
  region_split_lines_ = int64_t{0};
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::_internal_region_split_lines() const {
  return region_split_lines_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::region_split_lines() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTableInfo.region_split_lines)
  return _internal_region_split_lines();
}
inline void WatchTableInfo::_internal_set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00002000u;
  region_split_lines_ = value;
}
inline void WatchTableInfo::set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_split_lines(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTableInfo.region_split_lines)
}

// optional int64 table_size = 15;
inline bool WatchTableInfo::_internal_has_table_size() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool WatchTableInfo::has_table_size() const {
  return _internal_has_table_size();
}
inline void WatchTableInfo::clear_table_size() {
  table_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::_internal_table_size() const {
  return table_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchTableInfo::table_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTableInfo.table_size)
  return _internal_table_size();
}
inline void WatchTableInfo::_internal_set_table_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00004000u;
  table_size_ = value;
}
inline void WatchTableInfo::set_table_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTableInfo.table_size)
}

// optional string binlog = 16;
inline bool WatchTableInfo::_internal_has_binlog() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool WatchTableInfo::has_binlog() const {
  return _internal_has_binlog();
}
inline void WatchTableInfo::clear_binlog() {
  binlog_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& WatchTableInfo::binlog() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTableInfo.binlog)
  return _internal_binlog();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchTableInfo::set_binlog(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 binlog_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTableInfo.binlog)
}
inline std::string* WatchTableInfo::mutable_binlog() {
  std::string* _s = _internal_mutable_binlog();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchTableInfo.binlog)
  return _s;
}
inline const std::string& WatchTableInfo::_internal_binlog() const {
  return binlog_.Get();
}
inline void WatchTableInfo::_internal_set_binlog(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  binlog_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchTableInfo::_internal_mutable_binlog() {
  _has_bits_[0] |= 0x00000008u;
  return binlog_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchTableInfo::release_binlog() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchTableInfo.binlog)
  if (!_internal_has_binlog()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return binlog_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchTableInfo::set_allocated_binlog(std::string* binlog) {
  if (binlog != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  binlog_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), binlog,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchTableInfo.binlog)
}

// -------------------------------------------------------------------

// WatchUserInfo

// optional string username = 1;
inline bool WatchUserInfo::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WatchUserInfo::has_username() const {
  return _internal_has_username();
}
inline void WatchUserInfo::clear_username() {
  username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WatchUserInfo::username() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchUserInfo.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchUserInfo::set_username(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchUserInfo.username)
}
inline std::string* WatchUserInfo::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchUserInfo.username)
  return _s;
}
inline const std::string& WatchUserInfo::_internal_username() const {
  return username_.Get();
}
inline void WatchUserInfo::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchUserInfo::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchUserInfo::release_username() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchUserInfo.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchUserInfo::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchUserInfo.username)
}

// optional string password = 2;
inline bool WatchUserInfo::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WatchUserInfo::has_password() const {
  return _internal_has_password();
}
inline void WatchUserInfo::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WatchUserInfo::password() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchUserInfo.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchUserInfo::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchUserInfo.password)
}
inline std::string* WatchUserInfo::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchUserInfo.password)
  return _s;
}
inline const std::string& WatchUserInfo::_internal_password() const {
  return password_.Get();
}
inline void WatchUserInfo::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchUserInfo::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchUserInfo::release_password() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchUserInfo.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchUserInfo::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchUserInfo.password)
}

// optional int64 id = 3;
inline bool WatchUserInfo::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool WatchUserInfo::has_id() const {
  return _internal_has_id();
}
inline void WatchUserInfo::clear_id() {
  id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchUserInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchUserInfo::id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchUserInfo.id)
  return _internal_id();
}
inline void WatchUserInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  id_ = value;
}
inline void WatchUserInfo::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchUserInfo.id)
}

// optional string tablename = 4;
inline bool WatchUserInfo::_internal_has_tablename() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WatchUserInfo::has_tablename() const {
  return _internal_has_tablename();
}
inline void WatchUserInfo::clear_tablename() {
  tablename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& WatchUserInfo::tablename() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchUserInfo.tablename)
  return _internal_tablename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchUserInfo::set_tablename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 tablename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchUserInfo.tablename)
}
inline std::string* WatchUserInfo::mutable_tablename() {
  std::string* _s = _internal_mutable_tablename();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchUserInfo.tablename)
  return _s;
}
inline const std::string& WatchUserInfo::_internal_tablename() const {
  return tablename_.Get();
}
inline void WatchUserInfo::_internal_set_tablename(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  tablename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchUserInfo::_internal_mutable_tablename() {
  _has_bits_[0] |= 0x00000004u;
  return tablename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchUserInfo::release_tablename() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchUserInfo.tablename)
  if (!_internal_has_tablename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return tablename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchUserInfo::set_allocated_tablename(std::string* tablename) {
  if (tablename != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  tablename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tablename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchUserInfo.tablename)
}

// optional .baikaldb.pb.RW permission = 5;
inline bool WatchUserInfo::_internal_has_permission() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool WatchUserInfo::has_permission() const {
  return _internal_has_permission();
}
inline void WatchUserInfo::clear_permission() {
  permission_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::baikaldb::pb::RW WatchUserInfo::_internal_permission() const {
  return static_cast< ::baikaldb::pb::RW >(permission_);
}
inline ::baikaldb::pb::RW WatchUserInfo::permission() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchUserInfo.permission)
  return _internal_permission();
}
inline void WatchUserInfo::_internal_set_permission(::baikaldb::pb::RW value) {
  assert(::baikaldb::pb::RW_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  permission_ = value;
}
inline void WatchUserInfo::set_permission(::baikaldb::pb::RW value) {
  _internal_set_permission(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchUserInfo.permission)
}

// optional string namespace_name = 6;
inline bool WatchUserInfo::_internal_has_namespace_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool WatchUserInfo::has_namespace_name() const {
  return _internal_has_namespace_name();
}
inline void WatchUserInfo::clear_namespace_name() {
  namespace_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& WatchUserInfo::namespace_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchUserInfo.namespace_name)
  return _internal_namespace_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchUserInfo::set_namespace_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchUserInfo.namespace_name)
}
inline std::string* WatchUserInfo::mutable_namespace_name() {
  std::string* _s = _internal_mutable_namespace_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchUserInfo.namespace_name)
  return _s;
}
inline const std::string& WatchUserInfo::_internal_namespace_name() const {
  return namespace_name_.Get();
}
inline void WatchUserInfo::_internal_set_namespace_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchUserInfo::_internal_mutable_namespace_name() {
  _has_bits_[0] |= 0x00000008u;
  return namespace_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchUserInfo::release_namespace_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchUserInfo.namespace_name)
  if (!_internal_has_namespace_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return namespace_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchUserInfo::set_allocated_namespace_name(std::string* namespace_name) {
  if (namespace_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  namespace_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchUserInfo.namespace_name)
}

// -------------------------------------------------------------------

// WatchInstanceInfo

// required string address = 1;
inline bool WatchInstanceInfo::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WatchInstanceInfo::has_address() const {
  return _internal_has_address();
}
inline void WatchInstanceInfo::clear_address() {
  address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WatchInstanceInfo::address() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchInstanceInfo.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchInstanceInfo::set_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchInstanceInfo.address)
}
inline std::string* WatchInstanceInfo::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchInstanceInfo.address)
  return _s;
}
inline const std::string& WatchInstanceInfo::_internal_address() const {
  return address_.Get();
}
inline void WatchInstanceInfo::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchInstanceInfo::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchInstanceInfo::release_address() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchInstanceInfo.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchInstanceInfo::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchInstanceInfo.address)
}

// optional int64 capacity = 2;
inline bool WatchInstanceInfo::_internal_has_capacity() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool WatchInstanceInfo::has_capacity() const {
  return _internal_has_capacity();
}
inline void WatchInstanceInfo::clear_capacity() {
  capacity_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchInstanceInfo::_internal_capacity() const {
  return capacity_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchInstanceInfo::capacity() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchInstanceInfo.capacity)
  return _internal_capacity();
}
inline void WatchInstanceInfo::_internal_set_capacity(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  capacity_ = value;
}
inline void WatchInstanceInfo::set_capacity(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchInstanceInfo.capacity)
}

// optional int64 used_size = 3;
inline bool WatchInstanceInfo::_internal_has_used_size() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool WatchInstanceInfo::has_used_size() const {
  return _internal_has_used_size();
}
inline void WatchInstanceInfo::clear_used_size() {
  used_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchInstanceInfo::_internal_used_size() const {
  return used_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchInstanceInfo::used_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchInstanceInfo.used_size)
  return _internal_used_size();
}
inline void WatchInstanceInfo::_internal_set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  used_size_ = value;
}
inline void WatchInstanceInfo::set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_used_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchInstanceInfo.used_size)
}

// optional string resource_tag = 4;
inline bool WatchInstanceInfo::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WatchInstanceInfo::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void WatchInstanceInfo::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WatchInstanceInfo::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchInstanceInfo.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchInstanceInfo::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchInstanceInfo.resource_tag)
}
inline std::string* WatchInstanceInfo::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchInstanceInfo.resource_tag)
  return _s;
}
inline const std::string& WatchInstanceInfo::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void WatchInstanceInfo::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchInstanceInfo::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000002u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchInstanceInfo::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchInstanceInfo.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchInstanceInfo::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchInstanceInfo.resource_tag)
}

// optional .baikaldb.pb.Status status = 5;
inline bool WatchInstanceInfo::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool WatchInstanceInfo::has_status() const {
  return _internal_has_status();
}
inline void WatchInstanceInfo::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::baikaldb::pb::Status WatchInstanceInfo::_internal_status() const {
  return static_cast< ::baikaldb::pb::Status >(status_);
}
inline ::baikaldb::pb::Status WatchInstanceInfo::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchInstanceInfo.status)
  return _internal_status();
}
inline void WatchInstanceInfo::_internal_set_status(::baikaldb::pb::Status value) {
  assert(::baikaldb::pb::Status_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  status_ = value;
}
inline void WatchInstanceInfo::set_status(::baikaldb::pb::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchInstanceInfo.status)
}

// optional string physical_room = 6;
inline bool WatchInstanceInfo::_internal_has_physical_room() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WatchInstanceInfo::has_physical_room() const {
  return _internal_has_physical_room();
}
inline void WatchInstanceInfo::clear_physical_room() {
  physical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& WatchInstanceInfo::physical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchInstanceInfo.physical_room)
  return _internal_physical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchInstanceInfo::set_physical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchInstanceInfo.physical_room)
}
inline std::string* WatchInstanceInfo::mutable_physical_room() {
  std::string* _s = _internal_mutable_physical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchInstanceInfo.physical_room)
  return _s;
}
inline const std::string& WatchInstanceInfo::_internal_physical_room() const {
  return physical_room_.Get();
}
inline void WatchInstanceInfo::_internal_set_physical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchInstanceInfo::_internal_mutable_physical_room() {
  _has_bits_[0] |= 0x00000004u;
  return physical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchInstanceInfo::release_physical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchInstanceInfo.physical_room)
  if (!_internal_has_physical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return physical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchInstanceInfo::set_allocated_physical_room(std::string* physical_room) {
  if (physical_room != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  physical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), physical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchInstanceInfo.physical_room)
}

// optional string logical_room = 7;
inline bool WatchInstanceInfo::_internal_has_logical_room() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool WatchInstanceInfo::has_logical_room() const {
  return _internal_has_logical_room();
}
inline void WatchInstanceInfo::clear_logical_room() {
  logical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& WatchInstanceInfo::logical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchInstanceInfo.logical_room)
  return _internal_logical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchInstanceInfo::set_logical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchInstanceInfo.logical_room)
}
inline std::string* WatchInstanceInfo::mutable_logical_room() {
  std::string* _s = _internal_mutable_logical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchInstanceInfo.logical_room)
  return _s;
}
inline const std::string& WatchInstanceInfo::_internal_logical_room() const {
  return logical_room_.Get();
}
inline void WatchInstanceInfo::_internal_set_logical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchInstanceInfo::_internal_mutable_logical_room() {
  _has_bits_[0] |= 0x00000008u;
  return logical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchInstanceInfo::release_logical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchInstanceInfo.logical_room)
  if (!_internal_has_logical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return logical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchInstanceInfo::set_allocated_logical_room(std::string* logical_room) {
  if (logical_room != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  logical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchInstanceInfo.logical_room)
}

// optional int64 peer_count = 8;
inline bool WatchInstanceInfo::_internal_has_peer_count() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool WatchInstanceInfo::has_peer_count() const {
  return _internal_has_peer_count();
}
inline void WatchInstanceInfo::clear_peer_count() {
  peer_count_ = int64_t{0};
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchInstanceInfo::_internal_peer_count() const {
  return peer_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchInstanceInfo::peer_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchInstanceInfo.peer_count)
  return _internal_peer_count();
}
inline void WatchInstanceInfo::_internal_set_peer_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  peer_count_ = value;
}
inline void WatchInstanceInfo::set_peer_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_peer_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchInstanceInfo.peer_count)
}

// optional int64 leader_count = 9;
inline bool WatchInstanceInfo::_internal_has_leader_count() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool WatchInstanceInfo::has_leader_count() const {
  return _internal_has_leader_count();
}
inline void WatchInstanceInfo::clear_leader_count() {
  leader_count_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchInstanceInfo::_internal_leader_count() const {
  return leader_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchInstanceInfo::leader_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchInstanceInfo.leader_count)
  return _internal_leader_count();
}
inline void WatchInstanceInfo::_internal_set_leader_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  leader_count_ = value;
}
inline void WatchInstanceInfo::set_leader_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_leader_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchInstanceInfo.leader_count)
}

// optional int64 region_count = 10;
inline bool WatchInstanceInfo::_internal_has_region_count() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool WatchInstanceInfo::has_region_count() const {
  return _internal_has_region_count();
}
inline void WatchInstanceInfo::clear_region_count() {
  region_count_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchInstanceInfo::_internal_region_count() const {
  return region_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchInstanceInfo::region_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchInstanceInfo.region_count)
  return _internal_region_count();
}
inline void WatchInstanceInfo::_internal_set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  region_count_ = value;
}
inline void WatchInstanceInfo::set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchInstanceInfo.region_count)
}

// optional int64 id = 11;
inline bool WatchInstanceInfo::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool WatchInstanceInfo::has_id() const {
  return _internal_has_id();
}
inline void WatchInstanceInfo::clear_id() {
  id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchInstanceInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchInstanceInfo::id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchInstanceInfo.id)
  return _internal_id();
}
inline void WatchInstanceInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  id_ = value;
}
inline void WatchInstanceInfo::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchInstanceInfo.id)
}

// optional string version = 12;
inline bool WatchInstanceInfo::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool WatchInstanceInfo::has_version() const {
  return _internal_has_version();
}
inline void WatchInstanceInfo::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& WatchInstanceInfo::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchInstanceInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchInstanceInfo::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchInstanceInfo.version)
}
inline std::string* WatchInstanceInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchInstanceInfo.version)
  return _s;
}
inline const std::string& WatchInstanceInfo::_internal_version() const {
  return version_.Get();
}
inline void WatchInstanceInfo::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchInstanceInfo::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000010u;
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchInstanceInfo::release_version() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchInstanceInfo.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchInstanceInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchInstanceInfo.version)
}

// -------------------------------------------------------------------

// WatchRegionInfo

// required int64 region_id = 1;
inline bool WatchRegionInfo::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_region_id() const {
  return _internal_has_region_id();
}
inline void WatchRegionInfo::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.region_id)
  return _internal_region_id();
}
inline void WatchRegionInfo::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  region_id_ = value;
}
inline void WatchRegionInfo::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.region_id)
}

// optional string table_name = 2;
inline bool WatchRegionInfo::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_table_name() const {
  return _internal_has_table_name();
}
inline void WatchRegionInfo::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WatchRegionInfo::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchRegionInfo::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.table_name)
}
inline std::string* WatchRegionInfo::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchRegionInfo.table_name)
  return _s;
}
inline const std::string& WatchRegionInfo::_internal_table_name() const {
  return table_name_.Get();
}
inline void WatchRegionInfo::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchRegionInfo::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000001u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchRegionInfo::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchRegionInfo.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchRegionInfo::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchRegionInfo.table_name)
}

// optional int64 partition_id = 3;
inline bool WatchRegionInfo::_internal_has_partition_id() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_partition_id() const {
  return _internal_has_partition_id();
}
inline void WatchRegionInfo::clear_partition_id() {
  partition_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::_internal_partition_id() const {
  return partition_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::partition_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.partition_id)
  return _internal_partition_id();
}
inline void WatchRegionInfo::_internal_set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  partition_id_ = value;
}
inline void WatchRegionInfo::set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_partition_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.partition_id)
}

// optional int64 replica_num = 4;
inline bool WatchRegionInfo::_internal_has_replica_num() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_replica_num() const {
  return _internal_has_replica_num();
}
inline void WatchRegionInfo::clear_replica_num() {
  replica_num_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::_internal_replica_num() const {
  return replica_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::replica_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.replica_num)
  return _internal_replica_num();
}
inline void WatchRegionInfo::_internal_set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  replica_num_ = value;
}
inline void WatchRegionInfo::set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_replica_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.replica_num)
}

// optional int64 version = 5;
inline bool WatchRegionInfo::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_version() const {
  return _internal_has_version();
}
inline void WatchRegionInfo::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.version)
  return _internal_version();
}
inline void WatchRegionInfo::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  version_ = value;
}
inline void WatchRegionInfo::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.version)
}

// optional int64 conf_version = 6;
inline bool WatchRegionInfo::_internal_has_conf_version() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_conf_version() const {
  return _internal_has_conf_version();
}
inline void WatchRegionInfo::clear_conf_version() {
  conf_version_ = int64_t{0};
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::_internal_conf_version() const {
  return conf_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::conf_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.conf_version)
  return _internal_conf_version();
}
inline void WatchRegionInfo::_internal_set_conf_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00001000u;
  conf_version_ = value;
}
inline void WatchRegionInfo::set_conf_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_conf_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.conf_version)
}

// optional string start_key = 7;
inline bool WatchRegionInfo::_internal_has_start_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_start_key() const {
  return _internal_has_start_key();
}
inline void WatchRegionInfo::clear_start_key() {
  start_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WatchRegionInfo::start_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.start_key)
  return _internal_start_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchRegionInfo::set_start_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 start_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.start_key)
}
inline std::string* WatchRegionInfo::mutable_start_key() {
  std::string* _s = _internal_mutable_start_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchRegionInfo.start_key)
  return _s;
}
inline const std::string& WatchRegionInfo::_internal_start_key() const {
  return start_key_.Get();
}
inline void WatchRegionInfo::_internal_set_start_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  start_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchRegionInfo::_internal_mutable_start_key() {
  _has_bits_[0] |= 0x00000002u;
  return start_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchRegionInfo::release_start_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchRegionInfo.start_key)
  if (!_internal_has_start_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return start_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchRegionInfo::set_allocated_start_key(std::string* start_key) {
  if (start_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  start_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchRegionInfo.start_key)
}

// optional string end_key = 8;
inline bool WatchRegionInfo::_internal_has_end_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_end_key() const {
  return _internal_has_end_key();
}
inline void WatchRegionInfo::clear_end_key() {
  end_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& WatchRegionInfo::end_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.end_key)
  return _internal_end_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchRegionInfo::set_end_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 end_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.end_key)
}
inline std::string* WatchRegionInfo::mutable_end_key() {
  std::string* _s = _internal_mutable_end_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchRegionInfo.end_key)
  return _s;
}
inline const std::string& WatchRegionInfo::_internal_end_key() const {
  return end_key_.Get();
}
inline void WatchRegionInfo::_internal_set_end_key(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  end_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchRegionInfo::_internal_mutable_end_key() {
  _has_bits_[0] |= 0x00000004u;
  return end_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchRegionInfo::release_end_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchRegionInfo.end_key)
  if (!_internal_has_end_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return end_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchRegionInfo::set_allocated_end_key(std::string* end_key) {
  if (end_key != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  end_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), end_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchRegionInfo.end_key)
}

// optional string peers = 9;
inline bool WatchRegionInfo::_internal_has_peers() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_peers() const {
  return _internal_has_peers();
}
inline void WatchRegionInfo::clear_peers() {
  peers_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& WatchRegionInfo::peers() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.peers)
  return _internal_peers();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchRegionInfo::set_peers(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 peers_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.peers)
}
inline std::string* WatchRegionInfo::mutable_peers() {
  std::string* _s = _internal_mutable_peers();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchRegionInfo.peers)
  return _s;
}
inline const std::string& WatchRegionInfo::_internal_peers() const {
  return peers_.Get();
}
inline void WatchRegionInfo::_internal_set_peers(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  peers_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchRegionInfo::_internal_mutable_peers() {
  _has_bits_[0] |= 0x00000008u;
  return peers_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchRegionInfo::release_peers() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchRegionInfo.peers)
  if (!_internal_has_peers()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return peers_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchRegionInfo::set_allocated_peers(std::string* peers) {
  if (peers != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  peers_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peers,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchRegionInfo.peers)
}

// optional string leader = 10;
inline bool WatchRegionInfo::_internal_has_leader() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_leader() const {
  return _internal_has_leader();
}
inline void WatchRegionInfo::clear_leader() {
  leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& WatchRegionInfo::leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchRegionInfo::set_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.leader)
}
inline std::string* WatchRegionInfo::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchRegionInfo.leader)
  return _s;
}
inline const std::string& WatchRegionInfo::_internal_leader() const {
  return leader_.Get();
}
inline void WatchRegionInfo::_internal_set_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchRegionInfo::_internal_mutable_leader() {
  _has_bits_[0] |= 0x00000010u;
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchRegionInfo::release_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchRegionInfo.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchRegionInfo::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchRegionInfo.leader)
}

// optional .baikaldb.pb.RegionStatus status = 11;
inline bool WatchRegionInfo::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_status() const {
  return _internal_has_status();
}
inline void WatchRegionInfo::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::baikaldb::pb::RegionStatus WatchRegionInfo::_internal_status() const {
  return static_cast< ::baikaldb::pb::RegionStatus >(status_);
}
inline ::baikaldb::pb::RegionStatus WatchRegionInfo::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.status)
  return _internal_status();
}
inline void WatchRegionInfo::_internal_set_status(::baikaldb::pb::RegionStatus value) {
  assert(::baikaldb::pb::RegionStatus_IsValid(value));
  _has_bits_[0] |= 0x00100000u;
  status_ = value;
}
inline void WatchRegionInfo::set_status(::baikaldb::pb::RegionStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.status)
}

// optional int64 used_size = 12;
inline bool WatchRegionInfo::_internal_has_used_size() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_used_size() const {
  return _internal_has_used_size();
}
inline void WatchRegionInfo::clear_used_size() {
  used_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::_internal_used_size() const {
  return used_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::used_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.used_size)
  return _internal_used_size();
}
inline void WatchRegionInfo::_internal_set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00002000u;
  used_size_ = value;
}
inline void WatchRegionInfo::set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_used_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.used_size)
}

// optional int64 log_index = 13;
inline bool WatchRegionInfo::_internal_has_log_index() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_log_index() const {
  return _internal_has_log_index();
}
inline void WatchRegionInfo::clear_log_index() {
  log_index_ = int64_t{0};
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::_internal_log_index() const {
  return log_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::log_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.log_index)
  return _internal_log_index();
}
inline void WatchRegionInfo::_internal_set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00004000u;
  log_index_ = value;
}
inline void WatchRegionInfo::set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_log_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.log_index)
}

// optional string resource_tag = 17;
inline bool WatchRegionInfo::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void WatchRegionInfo::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& WatchRegionInfo::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchRegionInfo::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.resource_tag)
}
inline std::string* WatchRegionInfo::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchRegionInfo.resource_tag)
  return _s;
}
inline const std::string& WatchRegionInfo::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void WatchRegionInfo::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchRegionInfo::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000020u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchRegionInfo::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchRegionInfo.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchRegionInfo::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchRegionInfo.resource_tag)
}

// optional int64 parent = 18;
inline bool WatchRegionInfo::_internal_has_parent() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_parent() const {
  return _internal_has_parent();
}
inline void WatchRegionInfo::clear_parent() {
  parent_ = int64_t{0};
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::_internal_parent() const {
  return parent_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::parent() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.parent)
  return _internal_parent();
}
inline void WatchRegionInfo::_internal_set_parent(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00008000u;
  parent_ = value;
}
inline void WatchRegionInfo::set_parent(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_parent(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.parent)
}

// optional string create_time = 19;
inline bool WatchRegionInfo::_internal_has_create_time() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_create_time() const {
  return _internal_has_create_time();
}
inline void WatchRegionInfo::clear_create_time() {
  create_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& WatchRegionInfo::create_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.create_time)
  return _internal_create_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchRegionInfo::set_create_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 create_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.create_time)
}
inline std::string* WatchRegionInfo::mutable_create_time() {
  std::string* _s = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchRegionInfo.create_time)
  return _s;
}
inline const std::string& WatchRegionInfo::_internal_create_time() const {
  return create_time_.Get();
}
inline void WatchRegionInfo::_internal_set_create_time(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  create_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchRegionInfo::_internal_mutable_create_time() {
  _has_bits_[0] |= 0x00000040u;
  return create_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchRegionInfo::release_create_time() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchRegionInfo.create_time)
  if (!_internal_has_create_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return create_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchRegionInfo::set_allocated_create_time(std::string* create_time) {
  if (create_time != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  create_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), create_time,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchRegionInfo.create_time)
}

// optional int64 table_id = 20;
inline bool WatchRegionInfo::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_table_id() const {
  return _internal_has_table_id();
}
inline void WatchRegionInfo::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.table_id)
  return _internal_table_id();
}
inline void WatchRegionInfo::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00010000u;
  table_id_ = value;
}
inline void WatchRegionInfo::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.table_id)
}

// optional int64 id = 21;
inline bool WatchRegionInfo::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_id() const {
  return _internal_has_id();
}
inline void WatchRegionInfo::clear_id() {
  id_ = int64_t{0};
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.id)
  return _internal_id();
}
inline void WatchRegionInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00020000u;
  id_ = value;
}
inline void WatchRegionInfo::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.id)
}

// optional string raw_start_key = 22;
inline bool WatchRegionInfo::_internal_has_raw_start_key() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_raw_start_key() const {
  return _internal_has_raw_start_key();
}
inline void WatchRegionInfo::clear_raw_start_key() {
  raw_start_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& WatchRegionInfo::raw_start_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.raw_start_key)
  return _internal_raw_start_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchRegionInfo::set_raw_start_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 raw_start_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.raw_start_key)
}
inline std::string* WatchRegionInfo::mutable_raw_start_key() {
  std::string* _s = _internal_mutable_raw_start_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchRegionInfo.raw_start_key)
  return _s;
}
inline const std::string& WatchRegionInfo::_internal_raw_start_key() const {
  return raw_start_key_.Get();
}
inline void WatchRegionInfo::_internal_set_raw_start_key(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  raw_start_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchRegionInfo::_internal_mutable_raw_start_key() {
  _has_bits_[0] |= 0x00000080u;
  return raw_start_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchRegionInfo::release_raw_start_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchRegionInfo.raw_start_key)
  if (!_internal_has_raw_start_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return raw_start_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchRegionInfo::set_allocated_raw_start_key(std::string* raw_start_key) {
  if (raw_start_key != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  raw_start_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), raw_start_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchRegionInfo.raw_start_key)
}

// optional int64 num_table_lines = 23;
inline bool WatchRegionInfo::_internal_has_num_table_lines() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_num_table_lines() const {
  return _internal_has_num_table_lines();
}
inline void WatchRegionInfo::clear_num_table_lines() {
  num_table_lines_ = int64_t{0};
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::_internal_num_table_lines() const {
  return num_table_lines_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::num_table_lines() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.num_table_lines)
  return _internal_num_table_lines();
}
inline void WatchRegionInfo::_internal_set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00040000u;
  num_table_lines_ = value;
}
inline void WatchRegionInfo::set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_num_table_lines(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.num_table_lines)
}

// optional int64 main_table_id = 24;
inline bool WatchRegionInfo::_internal_has_main_table_id() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool WatchRegionInfo::has_main_table_id() const {
  return _internal_has_main_table_id();
}
inline void WatchRegionInfo::clear_main_table_id() {
  main_table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::_internal_main_table_id() const {
  return main_table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchRegionInfo::main_table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchRegionInfo.main_table_id)
  return _internal_main_table_id();
}
inline void WatchRegionInfo::_internal_set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00080000u;
  main_table_id_ = value;
}
inline void WatchRegionInfo::set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_main_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchRegionInfo.main_table_id)
}

// -------------------------------------------------------------------

// WatchNameSpace

// repeated string namespace_name = 1;
inline int WatchNameSpace::_internal_namespace_name_size() const {
  return namespace_name_.size();
}
inline int WatchNameSpace::namespace_name_size() const {
  return _internal_namespace_name_size();
}
inline void WatchNameSpace::clear_namespace_name() {
  namespace_name_.Clear();
}
inline std::string* WatchNameSpace::add_namespace_name() {
  std::string* _s = _internal_add_namespace_name();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.WatchNameSpace.namespace_name)
  return _s;
}
inline const std::string& WatchNameSpace::_internal_namespace_name(int index) const {
  return namespace_name_.Get(index);
}
inline const std::string& WatchNameSpace::namespace_name(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchNameSpace.namespace_name)
  return _internal_namespace_name(index);
}
inline std::string* WatchNameSpace::mutable_namespace_name(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchNameSpace.namespace_name)
  return namespace_name_.Mutable(index);
}
inline void WatchNameSpace::set_namespace_name(int index, const std::string& value) {
  namespace_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchNameSpace.namespace_name)
}
inline void WatchNameSpace::set_namespace_name(int index, std::string&& value) {
  namespace_name_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchNameSpace.namespace_name)
}
inline void WatchNameSpace::set_namespace_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  namespace_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.WatchNameSpace.namespace_name)
}
inline void WatchNameSpace::set_namespace_name(int index, const char* value, size_t size) {
  namespace_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.WatchNameSpace.namespace_name)
}
inline std::string* WatchNameSpace::_internal_add_namespace_name() {
  return namespace_name_.Add();
}
inline void WatchNameSpace::add_namespace_name(const std::string& value) {
  namespace_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.WatchNameSpace.namespace_name)
}
inline void WatchNameSpace::add_namespace_name(std::string&& value) {
  namespace_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.WatchNameSpace.namespace_name)
}
inline void WatchNameSpace::add_namespace_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  namespace_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.WatchNameSpace.namespace_name)
}
inline void WatchNameSpace::add_namespace_name(const char* value, size_t size) {
  namespace_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.WatchNameSpace.namespace_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WatchNameSpace::namespace_name() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.WatchNameSpace.namespace_name)
  return namespace_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WatchNameSpace::mutable_namespace_name() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.WatchNameSpace.namespace_name)
  return &namespace_name_;
}

// -------------------------------------------------------------------

// TableName

// optional string name = 1;
inline bool TableName::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TableName::has_name() const {
  return _internal_has_name();
}
inline void TableName::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TableName::name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TableName.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableName::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.TableName.name)
}
inline std::string* TableName::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TableName.name)
  return _s;
}
inline const std::string& TableName::_internal_name() const {
  return name_.Get();
}
inline void TableName::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TableName::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TableName::release_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TableName.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TableName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TableName.name)
}

// optional int64 id = 2;
inline bool TableName::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TableName::has_id() const {
  return _internal_has_id();
}
inline void TableName::clear_id() {
  id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableName::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableName::id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TableName.id)
  return _internal_id();
}
inline void TableName::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
}
inline void TableName::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TableName.id)
}

// -------------------------------------------------------------------

// WatchDatabaseInfo

// optional string name = 1;
inline bool WatchDatabaseInfo::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WatchDatabaseInfo::has_name() const {
  return _internal_has_name();
}
inline void WatchDatabaseInfo::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WatchDatabaseInfo::name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchDatabaseInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchDatabaseInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchDatabaseInfo.name)
}
inline std::string* WatchDatabaseInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchDatabaseInfo.name)
  return _s;
}
inline const std::string& WatchDatabaseInfo::_internal_name() const {
  return name_.Get();
}
inline void WatchDatabaseInfo::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchDatabaseInfo::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchDatabaseInfo::release_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchDatabaseInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchDatabaseInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchDatabaseInfo.name)
}

// optional int64 id = 2;
inline bool WatchDatabaseInfo::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WatchDatabaseInfo::has_id() const {
  return _internal_has_id();
}
inline void WatchDatabaseInfo::clear_id() {
  id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchDatabaseInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchDatabaseInfo::id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchDatabaseInfo.id)
  return _internal_id();
}
inline void WatchDatabaseInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
}
inline void WatchDatabaseInfo::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchDatabaseInfo.id)
}

// repeated .baikaldb.pb.TableName children = 3;
inline int WatchDatabaseInfo::_internal_children_size() const {
  return children_.size();
}
inline int WatchDatabaseInfo::children_size() const {
  return _internal_children_size();
}
inline void WatchDatabaseInfo::clear_children() {
  children_.Clear();
}
inline ::baikaldb::pb::TableName* WatchDatabaseInfo::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchDatabaseInfo.children)
  return children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TableName >*
WatchDatabaseInfo::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.WatchDatabaseInfo.children)
  return &children_;
}
inline const ::baikaldb::pb::TableName& WatchDatabaseInfo::_internal_children(int index) const {
  return children_.Get(index);
}
inline const ::baikaldb::pb::TableName& WatchDatabaseInfo::children(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchDatabaseInfo.children)
  return _internal_children(index);
}
inline ::baikaldb::pb::TableName* WatchDatabaseInfo::_internal_add_children() {
  return children_.Add();
}
inline ::baikaldb::pb::TableName* WatchDatabaseInfo::add_children() {
  ::baikaldb::pb::TableName* _add = _internal_add_children();
  // @@protoc_insertion_point(field_add:baikaldb.pb.WatchDatabaseInfo.children)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TableName >&
WatchDatabaseInfo::children() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.WatchDatabaseInfo.children)
  return children_;
}

// -------------------------------------------------------------------

// WatchClusterInfo

// optional string name = 1;
inline bool WatchClusterInfo::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WatchClusterInfo::has_name() const {
  return _internal_has_name();
}
inline void WatchClusterInfo::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WatchClusterInfo::name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchClusterInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchClusterInfo::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchClusterInfo.name)
}
inline std::string* WatchClusterInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchClusterInfo.name)
  return _s;
}
inline const std::string& WatchClusterInfo::_internal_name() const {
  return name_.Get();
}
inline void WatchClusterInfo::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchClusterInfo::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchClusterInfo::release_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchClusterInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchClusterInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchClusterInfo.name)
}

// optional int64 id = 2;
inline bool WatchClusterInfo::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WatchClusterInfo::has_id() const {
  return _internal_has_id();
}
inline void WatchClusterInfo::clear_id() {
  id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchClusterInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchClusterInfo::id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchClusterInfo.id)
  return _internal_id();
}
inline void WatchClusterInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
}
inline void WatchClusterInfo::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchClusterInfo.id)
}

// -------------------------------------------------------------------

// WatchImportTask

// optional int64 version = 1;
inline bool WatchImportTask::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool WatchImportTask::has_version() const {
  return _internal_has_version();
}
inline void WatchImportTask::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchImportTask::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchImportTask::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchImportTask.version)
  return _internal_version();
}
inline void WatchImportTask::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  version_ = value;
}
inline void WatchImportTask::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchImportTask.version)
}

// optional string start_time = 2;
inline bool WatchImportTask::_internal_has_start_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WatchImportTask::has_start_time() const {
  return _internal_has_start_time();
}
inline void WatchImportTask::clear_start_time() {
  start_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WatchImportTask::start_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchImportTask.start_time)
  return _internal_start_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchImportTask::set_start_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 start_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchImportTask.start_time)
}
inline std::string* WatchImportTask::mutable_start_time() {
  std::string* _s = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchImportTask.start_time)
  return _s;
}
inline const std::string& WatchImportTask::_internal_start_time() const {
  return start_time_.Get();
}
inline void WatchImportTask::_internal_set_start_time(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  start_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchImportTask::_internal_mutable_start_time() {
  _has_bits_[0] |= 0x00000001u;
  return start_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchImportTask::release_start_time() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchImportTask.start_time)
  if (!_internal_has_start_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return start_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchImportTask::set_allocated_start_time(std::string* start_time) {
  if (start_time != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  start_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start_time,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchImportTask.start_time)
}

// optional string end_time = 3;
inline bool WatchImportTask::_internal_has_end_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WatchImportTask::has_end_time() const {
  return _internal_has_end_time();
}
inline void WatchImportTask::clear_end_time() {
  end_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WatchImportTask::end_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchImportTask.end_time)
  return _internal_end_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchImportTask::set_end_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 end_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchImportTask.end_time)
}
inline std::string* WatchImportTask::mutable_end_time() {
  std::string* _s = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchImportTask.end_time)
  return _s;
}
inline const std::string& WatchImportTask::_internal_end_time() const {
  return end_time_.Get();
}
inline void WatchImportTask::_internal_set_end_time(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  end_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchImportTask::_internal_mutable_end_time() {
  _has_bits_[0] |= 0x00000002u;
  return end_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchImportTask::release_end_time() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchImportTask.end_time)
  if (!_internal_has_end_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return end_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchImportTask::set_allocated_end_time(std::string* end_time) {
  if (end_time != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  end_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), end_time,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchImportTask.end_time)
}

// optional string exec_time = 4;
inline bool WatchImportTask::_internal_has_exec_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WatchImportTask::has_exec_time() const {
  return _internal_has_exec_time();
}
inline void WatchImportTask::clear_exec_time() {
  exec_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& WatchImportTask::exec_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchImportTask.exec_time)
  return _internal_exec_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchImportTask::set_exec_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 exec_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchImportTask.exec_time)
}
inline std::string* WatchImportTask::mutable_exec_time() {
  std::string* _s = _internal_mutable_exec_time();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchImportTask.exec_time)
  return _s;
}
inline const std::string& WatchImportTask::_internal_exec_time() const {
  return exec_time_.Get();
}
inline void WatchImportTask::_internal_set_exec_time(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  exec_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchImportTask::_internal_mutable_exec_time() {
  _has_bits_[0] |= 0x00000004u;
  return exec_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchImportTask::release_exec_time() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchImportTask.exec_time)
  if (!_internal_has_exec_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return exec_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchImportTask::set_allocated_exec_time(std::string* exec_time) {
  if (exec_time != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  exec_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exec_time,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchImportTask.exec_time)
}

// optional int64 import_line = 5;
inline bool WatchImportTask::_internal_has_import_line() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool WatchImportTask::has_import_line() const {
  return _internal_has_import_line();
}
inline void WatchImportTask::clear_import_line() {
  import_line_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchImportTask::_internal_import_line() const {
  return import_line_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 WatchImportTask::import_line() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchImportTask.import_line)
  return _internal_import_line();
}
inline void WatchImportTask::_internal_set_import_line(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  import_line_ = value;
}
inline void WatchImportTask::set_import_line(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_import_line(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchImportTask.import_line)
}

// optional string modle = 6;
inline bool WatchImportTask::_internal_has_modle() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool WatchImportTask::has_modle() const {
  return _internal_has_modle();
}
inline void WatchImportTask::clear_modle() {
  modle_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& WatchImportTask::modle() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchImportTask.modle)
  return _internal_modle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchImportTask::set_modle(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 modle_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchImportTask.modle)
}
inline std::string* WatchImportTask::mutable_modle() {
  std::string* _s = _internal_mutable_modle();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchImportTask.modle)
  return _s;
}
inline const std::string& WatchImportTask::_internal_modle() const {
  return modle_.Get();
}
inline void WatchImportTask::_internal_set_modle(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  modle_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchImportTask::_internal_mutable_modle() {
  _has_bits_[0] |= 0x00000008u;
  return modle_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchImportTask::release_modle() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchImportTask.modle)
  if (!_internal_has_modle()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return modle_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchImportTask::set_allocated_modle(std::string* modle) {
  if (modle != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  modle_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modle,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchImportTask.modle)
}

// optional string status = 7;
inline bool WatchImportTask::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool WatchImportTask::has_status() const {
  return _internal_has_status();
}
inline void WatchImportTask::clear_status() {
  status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& WatchImportTask::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchImportTask.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchImportTask::set_status(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchImportTask.status)
}
inline std::string* WatchImportTask::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchImportTask.status)
  return _s;
}
inline const std::string& WatchImportTask::_internal_status() const {
  return status_.Get();
}
inline void WatchImportTask::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchImportTask::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000010u;
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchImportTask::release_status() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchImportTask.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchImportTask::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchImportTask.status)
}

// -------------------------------------------------------------------

// WatchSSTTask

// optional string database = 1;
inline bool WatchSSTTask::_internal_has_database() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WatchSSTTask::has_database() const {
  return _internal_has_database();
}
inline void WatchSSTTask::clear_database() {
  database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WatchSSTTask::database() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchSSTTask.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchSSTTask::set_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchSSTTask.database)
}
inline std::string* WatchSSTTask::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchSSTTask.database)
  return _s;
}
inline const std::string& WatchSSTTask::_internal_database() const {
  return database_.Get();
}
inline void WatchSSTTask::_internal_set_database(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchSSTTask::_internal_mutable_database() {
  _has_bits_[0] |= 0x00000001u;
  return database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchSSTTask::release_database() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchSSTTask.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchSSTTask::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchSSTTask.database)
}

// optional string table_name = 2;
inline bool WatchSSTTask::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WatchSSTTask::has_table_name() const {
  return _internal_has_table_name();
}
inline void WatchSSTTask::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WatchSSTTask::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchSSTTask.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchSSTTask::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchSSTTask.table_name)
}
inline std::string* WatchSSTTask::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchSSTTask.table_name)
  return _s;
}
inline const std::string& WatchSSTTask::_internal_table_name() const {
  return table_name_.Get();
}
inline void WatchSSTTask::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchSSTTask::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000002u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchSSTTask::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchSSTTask.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchSSTTask::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchSSTTask.table_name)
}

// optional string table_id = 3;
inline bool WatchSSTTask::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WatchSSTTask::has_table_id() const {
  return _internal_has_table_id();
}
inline void WatchSSTTask::clear_table_id() {
  table_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& WatchSSTTask::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchSSTTask.table_id)
  return _internal_table_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchSSTTask::set_table_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 table_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchSSTTask.table_id)
}
inline std::string* WatchSSTTask::mutable_table_id() {
  std::string* _s = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchSSTTask.table_id)
  return _s;
}
inline const std::string& WatchSSTTask::_internal_table_id() const {
  return table_id_.Get();
}
inline void WatchSSTTask::_internal_set_table_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  table_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchSSTTask::_internal_mutable_table_id() {
  _has_bits_[0] |= 0x00000004u;
  return table_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchSSTTask::release_table_id() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchSSTTask.table_id)
  if (!_internal_has_table_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return table_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchSSTTask::set_allocated_table_id(std::string* table_id) {
  if (table_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  table_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchSSTTask.table_id)
}

// optional string start_time = 4;
inline bool WatchSSTTask::_internal_has_start_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool WatchSSTTask::has_start_time() const {
  return _internal_has_start_time();
}
inline void WatchSSTTask::clear_start_time() {
  start_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& WatchSSTTask::start_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchSSTTask.start_time)
  return _internal_start_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchSSTTask::set_start_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 start_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchSSTTask.start_time)
}
inline std::string* WatchSSTTask::mutable_start_time() {
  std::string* _s = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchSSTTask.start_time)
  return _s;
}
inline const std::string& WatchSSTTask::_internal_start_time() const {
  return start_time_.Get();
}
inline void WatchSSTTask::_internal_set_start_time(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  start_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchSSTTask::_internal_mutable_start_time() {
  _has_bits_[0] |= 0x00000008u;
  return start_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchSSTTask::release_start_time() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchSSTTask.start_time)
  if (!_internal_has_start_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return start_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchSSTTask::set_allocated_start_time(std::string* start_time) {
  if (start_time != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  start_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start_time,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchSSTTask.start_time)
}

// optional string end_time = 5;
inline bool WatchSSTTask::_internal_has_end_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool WatchSSTTask::has_end_time() const {
  return _internal_has_end_time();
}
inline void WatchSSTTask::clear_end_time() {
  end_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& WatchSSTTask::end_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchSSTTask.end_time)
  return _internal_end_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchSSTTask::set_end_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 end_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchSSTTask.end_time)
}
inline std::string* WatchSSTTask::mutable_end_time() {
  std::string* _s = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchSSTTask.end_time)
  return _s;
}
inline const std::string& WatchSSTTask::_internal_end_time() const {
  return end_time_.Get();
}
inline void WatchSSTTask::_internal_set_end_time(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  end_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchSSTTask::_internal_mutable_end_time() {
  _has_bits_[0] |= 0x00000010u;
  return end_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchSSTTask::release_end_time() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchSSTTask.end_time)
  if (!_internal_has_end_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return end_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchSSTTask::set_allocated_end_time(std::string* end_time) {
  if (end_time != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  end_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), end_time,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchSSTTask.end_time)
}

// optional string status = 6;
inline bool WatchSSTTask::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool WatchSSTTask::has_status() const {
  return _internal_has_status();
}
inline void WatchSSTTask::clear_status() {
  status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& WatchSSTTask::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchSSTTask.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchSSTTask::set_status(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchSSTTask.status)
}
inline std::string* WatchSSTTask::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchSSTTask.status)
  return _s;
}
inline const std::string& WatchSSTTask::_internal_status() const {
  return status_.Get();
}
inline void WatchSSTTask::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchSSTTask::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000020u;
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchSSTTask::release_status() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchSSTTask.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchSSTTask::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchSSTTask.status)
}

// -------------------------------------------------------------------

// WatchTaskList

// optional string table_info = 1;
inline bool WatchTaskList::_internal_has_table_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WatchTaskList::has_table_info() const {
  return _internal_has_table_info();
}
inline void WatchTaskList::clear_table_info() {
  table_info_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WatchTaskList::table_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTaskList.table_info)
  return _internal_table_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchTaskList::set_table_info(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 table_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTaskList.table_info)
}
inline std::string* WatchTaskList::mutable_table_info() {
  std::string* _s = _internal_mutable_table_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchTaskList.table_info)
  return _s;
}
inline const std::string& WatchTaskList::_internal_table_info() const {
  return table_info_.Get();
}
inline void WatchTaskList::_internal_set_table_info(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  table_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchTaskList::_internal_mutable_table_info() {
  _has_bits_[0] |= 0x00000001u;
  return table_info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchTaskList::release_table_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchTaskList.table_info)
  if (!_internal_has_table_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return table_info_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchTaskList::set_allocated_table_info(std::string* table_info) {
  if (table_info != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_info,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchTaskList.table_info)
}

// optional string cluster_name = 2;
inline bool WatchTaskList::_internal_has_cluster_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WatchTaskList::has_cluster_name() const {
  return _internal_has_cluster_name();
}
inline void WatchTaskList::clear_cluster_name() {
  cluster_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WatchTaskList::cluster_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTaskList.cluster_name)
  return _internal_cluster_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchTaskList::set_cluster_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 cluster_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTaskList.cluster_name)
}
inline std::string* WatchTaskList::mutable_cluster_name() {
  std::string* _s = _internal_mutable_cluster_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchTaskList.cluster_name)
  return _s;
}
inline const std::string& WatchTaskList::_internal_cluster_name() const {
  return cluster_name_.Get();
}
inline void WatchTaskList::_internal_set_cluster_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  cluster_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchTaskList::_internal_mutable_cluster_name() {
  _has_bits_[0] |= 0x00000002u;
  return cluster_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchTaskList::release_cluster_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchTaskList.cluster_name)
  if (!_internal_has_cluster_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return cluster_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchTaskList::set_allocated_cluster_name(std::string* cluster_name) {
  if (cluster_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cluster_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cluster_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchTaskList.cluster_name)
}

// optional string done_file = 3;
inline bool WatchTaskList::_internal_has_done_file() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WatchTaskList::has_done_file() const {
  return _internal_has_done_file();
}
inline void WatchTaskList::clear_done_file() {
  done_file_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& WatchTaskList::done_file() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTaskList.done_file)
  return _internal_done_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchTaskList::set_done_file(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 done_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTaskList.done_file)
}
inline std::string* WatchTaskList::mutable_done_file() {
  std::string* _s = _internal_mutable_done_file();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchTaskList.done_file)
  return _s;
}
inline const std::string& WatchTaskList::_internal_done_file() const {
  return done_file_.Get();
}
inline void WatchTaskList::_internal_set_done_file(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  done_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchTaskList::_internal_mutable_done_file() {
  _has_bits_[0] |= 0x00000004u;
  return done_file_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchTaskList::release_done_file() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchTaskList.done_file)
  if (!_internal_has_done_file()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return done_file_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchTaskList::set_allocated_done_file(std::string* done_file) {
  if (done_file != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  done_file_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), done_file,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchTaskList.done_file)
}

// optional string user_sql = 4;
inline bool WatchTaskList::_internal_has_user_sql() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool WatchTaskList::has_user_sql() const {
  return _internal_has_user_sql();
}
inline void WatchTaskList::clear_user_sql() {
  user_sql_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& WatchTaskList::user_sql() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTaskList.user_sql)
  return _internal_user_sql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchTaskList::set_user_sql(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 user_sql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTaskList.user_sql)
}
inline std::string* WatchTaskList::mutable_user_sql() {
  std::string* _s = _internal_mutable_user_sql();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchTaskList.user_sql)
  return _s;
}
inline const std::string& WatchTaskList::_internal_user_sql() const {
  return user_sql_.Get();
}
inline void WatchTaskList::_internal_set_user_sql(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  user_sql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchTaskList::_internal_mutable_user_sql() {
  _has_bits_[0] |= 0x00000008u;
  return user_sql_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchTaskList::release_user_sql() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchTaskList.user_sql)
  if (!_internal_has_user_sql()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return user_sql_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchTaskList::set_allocated_user_sql(std::string* user_sql) {
  if (user_sql != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  user_sql_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_sql,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchTaskList.user_sql)
}

// optional string ago_days = 5;
inline bool WatchTaskList::_internal_has_ago_days() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool WatchTaskList::has_ago_days() const {
  return _internal_has_ago_days();
}
inline void WatchTaskList::clear_ago_days() {
  ago_days_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& WatchTaskList::ago_days() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTaskList.ago_days)
  return _internal_ago_days();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchTaskList::set_ago_days(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 ago_days_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTaskList.ago_days)
}
inline std::string* WatchTaskList::mutable_ago_days() {
  std::string* _s = _internal_mutable_ago_days();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchTaskList.ago_days)
  return _s;
}
inline const std::string& WatchTaskList::_internal_ago_days() const {
  return ago_days_.Get();
}
inline void WatchTaskList::_internal_set_ago_days(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  ago_days_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchTaskList::_internal_mutable_ago_days() {
  _has_bits_[0] |= 0x00000010u;
  return ago_days_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchTaskList::release_ago_days() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchTaskList.ago_days)
  if (!_internal_has_ago_days()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return ago_days_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchTaskList::set_allocated_ago_days(std::string* ago_days) {
  if (ago_days != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  ago_days_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ago_days,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchTaskList.ago_days)
}

// optional string charset = 6;
inline bool WatchTaskList::_internal_has_charset() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool WatchTaskList::has_charset() const {
  return _internal_has_charset();
}
inline void WatchTaskList::clear_charset() {
  charset_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& WatchTaskList::charset() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTaskList.charset)
  return _internal_charset();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchTaskList::set_charset(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 charset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTaskList.charset)
}
inline std::string* WatchTaskList::mutable_charset() {
  std::string* _s = _internal_mutable_charset();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchTaskList.charset)
  return _s;
}
inline const std::string& WatchTaskList::_internal_charset() const {
  return charset_.Get();
}
inline void WatchTaskList::_internal_set_charset(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  charset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchTaskList::_internal_mutable_charset() {
  _has_bits_[0] |= 0x00000020u;
  return charset_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchTaskList::release_charset() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchTaskList.charset)
  if (!_internal_has_charset()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return charset_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchTaskList::set_allocated_charset(std::string* charset) {
  if (charset != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  charset_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), charset,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchTaskList.charset)
}

// optional string modle = 7;
inline bool WatchTaskList::_internal_has_modle() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool WatchTaskList::has_modle() const {
  return _internal_has_modle();
}
inline void WatchTaskList::clear_modle() {
  modle_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& WatchTaskList::modle() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTaskList.modle)
  return _internal_modle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchTaskList::set_modle(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 modle_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTaskList.modle)
}
inline std::string* WatchTaskList::mutable_modle() {
  std::string* _s = _internal_mutable_modle();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchTaskList.modle)
  return _s;
}
inline const std::string& WatchTaskList::_internal_modle() const {
  return modle_.Get();
}
inline void WatchTaskList::_internal_set_modle(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  modle_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchTaskList::_internal_mutable_modle() {
  _has_bits_[0] |= 0x00000040u;
  return modle_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchTaskList::release_modle() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchTaskList.modle)
  if (!_internal_has_modle()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return modle_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchTaskList::set_allocated_modle(std::string* modle) {
  if (modle != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  modle_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modle,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchTaskList.modle)
}

// optional string status = 8;
inline bool WatchTaskList::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool WatchTaskList::has_status() const {
  return _internal_has_status();
}
inline void WatchTaskList::clear_status() {
  status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& WatchTaskList::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchTaskList.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchTaskList::set_status(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchTaskList.status)
}
inline std::string* WatchTaskList::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchTaskList.status)
  return _s;
}
inline const std::string& WatchTaskList::_internal_status() const {
  return status_.Get();
}
inline void WatchTaskList::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchTaskList::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000080u;
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchTaskList::release_status() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchTaskList.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchTaskList::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchTaskList.status)
}

// -------------------------------------------------------------------

// WatchSchemaInfo

// optional string full_table_name = 1;
inline bool WatchSchemaInfo::_internal_has_full_table_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool WatchSchemaInfo::has_full_table_name() const {
  return _internal_has_full_table_name();
}
inline void WatchSchemaInfo::clear_full_table_name() {
  full_table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WatchSchemaInfo::full_table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchSchemaInfo.full_table_name)
  return _internal_full_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WatchSchemaInfo::set_full_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 full_table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchSchemaInfo.full_table_name)
}
inline std::string* WatchSchemaInfo::mutable_full_table_name() {
  std::string* _s = _internal_mutable_full_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchSchemaInfo.full_table_name)
  return _s;
}
inline const std::string& WatchSchemaInfo::_internal_full_table_name() const {
  return full_table_name_.Get();
}
inline void WatchSchemaInfo::_internal_set_full_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  full_table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WatchSchemaInfo::_internal_mutable_full_table_name() {
  _has_bits_[0] |= 0x00000001u;
  return full_table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WatchSchemaInfo::release_full_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.WatchSchemaInfo.full_table_name)
  if (!_internal_has_full_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return full_table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WatchSchemaInfo::set_allocated_full_table_name(std::string* full_table_name) {
  if (full_table_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  full_table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), full_table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.WatchSchemaInfo.full_table_name)
}

// repeated .baikaldb.pb.QuerySchema schemas = 2;
inline int WatchSchemaInfo::_internal_schemas_size() const {
  return schemas_.size();
}
inline int WatchSchemaInfo::schemas_size() const {
  return _internal_schemas_size();
}
inline ::baikaldb::pb::QuerySchema* WatchSchemaInfo::mutable_schemas(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchSchemaInfo.schemas)
  return schemas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QuerySchema >*
WatchSchemaInfo::mutable_schemas() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.WatchSchemaInfo.schemas)
  return &schemas_;
}
inline const ::baikaldb::pb::QuerySchema& WatchSchemaInfo::_internal_schemas(int index) const {
  return schemas_.Get(index);
}
inline const ::baikaldb::pb::QuerySchema& WatchSchemaInfo::schemas(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchSchemaInfo.schemas)
  return _internal_schemas(index);
}
inline ::baikaldb::pb::QuerySchema* WatchSchemaInfo::_internal_add_schemas() {
  return schemas_.Add();
}
inline ::baikaldb::pb::QuerySchema* WatchSchemaInfo::add_schemas() {
  ::baikaldb::pb::QuerySchema* _add = _internal_add_schemas();
  // @@protoc_insertion_point(field_add:baikaldb.pb.WatchSchemaInfo.schemas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QuerySchema >&
WatchSchemaInfo::schemas() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.WatchSchemaInfo.schemas)
  return schemas_;
}

// -------------------------------------------------------------------

// WatchPlatForm

// repeated string plat_form = 1;
inline int WatchPlatForm::_internal_plat_form_size() const {
  return plat_form_.size();
}
inline int WatchPlatForm::plat_form_size() const {
  return _internal_plat_form_size();
}
inline void WatchPlatForm::clear_plat_form() {
  plat_form_.Clear();
}
inline std::string* WatchPlatForm::add_plat_form() {
  std::string* _s = _internal_add_plat_form();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.WatchPlatForm.plat_form)
  return _s;
}
inline const std::string& WatchPlatForm::_internal_plat_form(int index) const {
  return plat_form_.Get(index);
}
inline const std::string& WatchPlatForm::plat_form(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.WatchPlatForm.plat_form)
  return _internal_plat_form(index);
}
inline std::string* WatchPlatForm::mutable_plat_form(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.WatchPlatForm.plat_form)
  return plat_form_.Mutable(index);
}
inline void WatchPlatForm::set_plat_form(int index, const std::string& value) {
  plat_form_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchPlatForm.plat_form)
}
inline void WatchPlatForm::set_plat_form(int index, std::string&& value) {
  plat_form_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.WatchPlatForm.plat_form)
}
inline void WatchPlatForm::set_plat_form(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  plat_form_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.WatchPlatForm.plat_form)
}
inline void WatchPlatForm::set_plat_form(int index, const char* value, size_t size) {
  plat_form_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.WatchPlatForm.plat_form)
}
inline std::string* WatchPlatForm::_internal_add_plat_form() {
  return plat_form_.Add();
}
inline void WatchPlatForm::add_plat_form(const std::string& value) {
  plat_form_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.WatchPlatForm.plat_form)
}
inline void WatchPlatForm::add_plat_form(std::string&& value) {
  plat_form_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.WatchPlatForm.plat_form)
}
inline void WatchPlatForm::add_plat_form(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  plat_form_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.WatchPlatForm.plat_form)
}
inline void WatchPlatForm::add_plat_form(const char* value, size_t size) {
  plat_form_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.WatchPlatForm.plat_form)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WatchPlatForm::plat_form() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.WatchPlatForm.plat_form)
  return plat_form_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WatchPlatForm::mutable_plat_form() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.WatchPlatForm.plat_form)
  return &plat_form_;
}

// -------------------------------------------------------------------

// ConsoleResponse

// required .baikaldb.pb.ErrCode errcode = 1;
inline bool ConsoleResponse::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ConsoleResponse::has_errcode() const {
  return _internal_has_errcode();
}
inline void ConsoleResponse::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::baikaldb::pb::ErrCode ConsoleResponse::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::ErrCode >(errcode_);
}
inline ::baikaldb::pb::ErrCode ConsoleResponse::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.errcode)
  return _internal_errcode();
}
inline void ConsoleResponse::_internal_set_errcode(::baikaldb::pb::ErrCode value) {
  assert(::baikaldb::pb::ErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  errcode_ = value;
}
inline void ConsoleResponse::set_errcode(::baikaldb::pb::ErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleResponse.errcode)
}

// optional string errmsg = 2;
inline bool ConsoleResponse::_internal_has_errmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConsoleResponse::has_errmsg() const {
  return _internal_has_errmsg();
}
inline void ConsoleResponse::clear_errmsg() {
  errmsg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConsoleResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.errmsg)
  return _internal_errmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsoleResponse::set_errmsg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleResponse.errmsg)
}
inline std::string* ConsoleResponse::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleResponse.errmsg)
  return _s;
}
inline const std::string& ConsoleResponse::_internal_errmsg() const {
  return errmsg_.Get();
}
inline void ConsoleResponse::_internal_set_errmsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConsoleResponse::_internal_mutable_errmsg() {
  _has_bits_[0] |= 0x00000001u;
  return errmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConsoleResponse::release_errmsg() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ConsoleResponse.errmsg)
  if (!_internal_has_errmsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return errmsg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConsoleResponse::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ConsoleResponse.errmsg)
}

// optional int64 itemnum = 3;
inline bool ConsoleResponse::_internal_has_itemnum() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConsoleResponse::has_itemnum() const {
  return _internal_has_itemnum();
}
inline void ConsoleResponse::clear_itemnum() {
  itemnum_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ConsoleResponse::_internal_itemnum() const {
  return itemnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ConsoleResponse::itemnum() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.itemnum)
  return _internal_itemnum();
}
inline void ConsoleResponse::_internal_set_itemnum(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  itemnum_ = value;
}
inline void ConsoleResponse::set_itemnum(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_itemnum(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleResponse.itemnum)
}

// optional .baikaldb.pb.OverViewInfo overview = 4;
inline bool ConsoleResponse::_internal_has_overview() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || overview_ != nullptr);
  return value;
}
inline bool ConsoleResponse::has_overview() const {
  return _internal_has_overview();
}
inline void ConsoleResponse::clear_overview() {
  if (overview_ != nullptr) overview_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::baikaldb::pb::OverViewInfo& ConsoleResponse::_internal_overview() const {
  const ::baikaldb::pb::OverViewInfo* p = overview_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::OverViewInfo&>(
      ::baikaldb::pb::_OverViewInfo_default_instance_);
}
inline const ::baikaldb::pb::OverViewInfo& ConsoleResponse::overview() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.overview)
  return _internal_overview();
}
inline void ConsoleResponse::unsafe_arena_set_allocated_overview(
    ::baikaldb::pb::OverViewInfo* overview) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(overview_);
  }
  overview_ = overview;
  if (overview) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.ConsoleResponse.overview)
}
inline ::baikaldb::pb::OverViewInfo* ConsoleResponse::release_overview() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::OverViewInfo* temp = overview_;
  overview_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::OverViewInfo* ConsoleResponse::unsafe_arena_release_overview() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ConsoleResponse.overview)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::OverViewInfo* temp = overview_;
  overview_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::OverViewInfo* ConsoleResponse::_internal_mutable_overview() {
  _has_bits_[0] |= 0x00000002u;
  if (overview_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::OverViewInfo>(GetArenaForAllocation());
    overview_ = p;
  }
  return overview_;
}
inline ::baikaldb::pb::OverViewInfo* ConsoleResponse::mutable_overview() {
  ::baikaldb::pb::OverViewInfo* _msg = _internal_mutable_overview();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleResponse.overview)
  return _msg;
}
inline void ConsoleResponse::set_allocated_overview(::baikaldb::pb::OverViewInfo* overview) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete overview_;
  }
  if (overview) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::OverViewInfo>::GetOwningArena(overview);
    if (message_arena != submessage_arena) {
      overview = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, overview, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  overview_ = overview;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ConsoleResponse.overview)
}

// repeated .baikaldb.pb.WatchTableInfo table_infos = 5;
inline int ConsoleResponse::_internal_table_infos_size() const {
  return table_infos_.size();
}
inline int ConsoleResponse::table_infos_size() const {
  return _internal_table_infos_size();
}
inline void ConsoleResponse::clear_table_infos() {
  table_infos_.Clear();
}
inline ::baikaldb::pb::WatchTableInfo* ConsoleResponse::mutable_table_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleResponse.table_infos)
  return table_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchTableInfo >*
ConsoleResponse::mutable_table_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ConsoleResponse.table_infos)
  return &table_infos_;
}
inline const ::baikaldb::pb::WatchTableInfo& ConsoleResponse::_internal_table_infos(int index) const {
  return table_infos_.Get(index);
}
inline const ::baikaldb::pb::WatchTableInfo& ConsoleResponse::table_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.table_infos)
  return _internal_table_infos(index);
}
inline ::baikaldb::pb::WatchTableInfo* ConsoleResponse::_internal_add_table_infos() {
  return table_infos_.Add();
}
inline ::baikaldb::pb::WatchTableInfo* ConsoleResponse::add_table_infos() {
  ::baikaldb::pb::WatchTableInfo* _add = _internal_add_table_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ConsoleResponse.table_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchTableInfo >&
ConsoleResponse::table_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ConsoleResponse.table_infos)
  return table_infos_;
}

// repeated .baikaldb.pb.WatchInstanceInfo instance_infos = 6;
inline int ConsoleResponse::_internal_instance_infos_size() const {
  return instance_infos_.size();
}
inline int ConsoleResponse::instance_infos_size() const {
  return _internal_instance_infos_size();
}
inline void ConsoleResponse::clear_instance_infos() {
  instance_infos_.Clear();
}
inline ::baikaldb::pb::WatchInstanceInfo* ConsoleResponse::mutable_instance_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleResponse.instance_infos)
  return instance_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchInstanceInfo >*
ConsoleResponse::mutable_instance_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ConsoleResponse.instance_infos)
  return &instance_infos_;
}
inline const ::baikaldb::pb::WatchInstanceInfo& ConsoleResponse::_internal_instance_infos(int index) const {
  return instance_infos_.Get(index);
}
inline const ::baikaldb::pb::WatchInstanceInfo& ConsoleResponse::instance_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.instance_infos)
  return _internal_instance_infos(index);
}
inline ::baikaldb::pb::WatchInstanceInfo* ConsoleResponse::_internal_add_instance_infos() {
  return instance_infos_.Add();
}
inline ::baikaldb::pb::WatchInstanceInfo* ConsoleResponse::add_instance_infos() {
  ::baikaldb::pb::WatchInstanceInfo* _add = _internal_add_instance_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ConsoleResponse.instance_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchInstanceInfo >&
ConsoleResponse::instance_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ConsoleResponse.instance_infos)
  return instance_infos_;
}

// repeated .baikaldb.pb.WatchUserInfo user_privileges = 7;
inline int ConsoleResponse::_internal_user_privileges_size() const {
  return user_privileges_.size();
}
inline int ConsoleResponse::user_privileges_size() const {
  return _internal_user_privileges_size();
}
inline void ConsoleResponse::clear_user_privileges() {
  user_privileges_.Clear();
}
inline ::baikaldb::pb::WatchUserInfo* ConsoleResponse::mutable_user_privileges(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleResponse.user_privileges)
  return user_privileges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchUserInfo >*
ConsoleResponse::mutable_user_privileges() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ConsoleResponse.user_privileges)
  return &user_privileges_;
}
inline const ::baikaldb::pb::WatchUserInfo& ConsoleResponse::_internal_user_privileges(int index) const {
  return user_privileges_.Get(index);
}
inline const ::baikaldb::pb::WatchUserInfo& ConsoleResponse::user_privileges(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.user_privileges)
  return _internal_user_privileges(index);
}
inline ::baikaldb::pb::WatchUserInfo* ConsoleResponse::_internal_add_user_privileges() {
  return user_privileges_.Add();
}
inline ::baikaldb::pb::WatchUserInfo* ConsoleResponse::add_user_privileges() {
  ::baikaldb::pb::WatchUserInfo* _add = _internal_add_user_privileges();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ConsoleResponse.user_privileges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchUserInfo >&
ConsoleResponse::user_privileges() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ConsoleResponse.user_privileges)
  return user_privileges_;
}

// repeated .baikaldb.pb.WatchRegionInfo region_infos = 8;
inline int ConsoleResponse::_internal_region_infos_size() const {
  return region_infos_.size();
}
inline int ConsoleResponse::region_infos_size() const {
  return _internal_region_infos_size();
}
inline void ConsoleResponse::clear_region_infos() {
  region_infos_.Clear();
}
inline ::baikaldb::pb::WatchRegionInfo* ConsoleResponse::mutable_region_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleResponse.region_infos)
  return region_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchRegionInfo >*
ConsoleResponse::mutable_region_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ConsoleResponse.region_infos)
  return &region_infos_;
}
inline const ::baikaldb::pb::WatchRegionInfo& ConsoleResponse::_internal_region_infos(int index) const {
  return region_infos_.Get(index);
}
inline const ::baikaldb::pb::WatchRegionInfo& ConsoleResponse::region_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.region_infos)
  return _internal_region_infos(index);
}
inline ::baikaldb::pb::WatchRegionInfo* ConsoleResponse::_internal_add_region_infos() {
  return region_infos_.Add();
}
inline ::baikaldb::pb::WatchRegionInfo* ConsoleResponse::add_region_infos() {
  ::baikaldb::pb::WatchRegionInfo* _add = _internal_add_region_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ConsoleResponse.region_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchRegionInfo >&
ConsoleResponse::region_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ConsoleResponse.region_infos)
  return region_infos_;
}

// optional .baikaldb.pb.WatchNameSpace namespaces = 9;
inline bool ConsoleResponse::_internal_has_namespaces() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || namespaces_ != nullptr);
  return value;
}
inline bool ConsoleResponse::has_namespaces() const {
  return _internal_has_namespaces();
}
inline void ConsoleResponse::clear_namespaces() {
  if (namespaces_ != nullptr) namespaces_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::baikaldb::pb::WatchNameSpace& ConsoleResponse::_internal_namespaces() const {
  const ::baikaldb::pb::WatchNameSpace* p = namespaces_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::WatchNameSpace&>(
      ::baikaldb::pb::_WatchNameSpace_default_instance_);
}
inline const ::baikaldb::pb::WatchNameSpace& ConsoleResponse::namespaces() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.namespaces)
  return _internal_namespaces();
}
inline void ConsoleResponse::unsafe_arena_set_allocated_namespaces(
    ::baikaldb::pb::WatchNameSpace* namespaces) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespaces_);
  }
  namespaces_ = namespaces;
  if (namespaces) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.ConsoleResponse.namespaces)
}
inline ::baikaldb::pb::WatchNameSpace* ConsoleResponse::release_namespaces() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::WatchNameSpace* temp = namespaces_;
  namespaces_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::WatchNameSpace* ConsoleResponse::unsafe_arena_release_namespaces() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ConsoleResponse.namespaces)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::WatchNameSpace* temp = namespaces_;
  namespaces_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::WatchNameSpace* ConsoleResponse::_internal_mutable_namespaces() {
  _has_bits_[0] |= 0x00000004u;
  if (namespaces_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::WatchNameSpace>(GetArenaForAllocation());
    namespaces_ = p;
  }
  return namespaces_;
}
inline ::baikaldb::pb::WatchNameSpace* ConsoleResponse::mutable_namespaces() {
  ::baikaldb::pb::WatchNameSpace* _msg = _internal_mutable_namespaces();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleResponse.namespaces)
  return _msg;
}
inline void ConsoleResponse::set_allocated_namespaces(::baikaldb::pb::WatchNameSpace* namespaces) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete namespaces_;
  }
  if (namespaces) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::WatchNameSpace>::GetOwningArena(namespaces);
    if (message_arena != submessage_arena) {
      namespaces = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespaces, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  namespaces_ = namespaces;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ConsoleResponse.namespaces)
}

// repeated .baikaldb.pb.WatchDatabaseInfo databases = 10;
inline int ConsoleResponse::_internal_databases_size() const {
  return databases_.size();
}
inline int ConsoleResponse::databases_size() const {
  return _internal_databases_size();
}
inline void ConsoleResponse::clear_databases() {
  databases_.Clear();
}
inline ::baikaldb::pb::WatchDatabaseInfo* ConsoleResponse::mutable_databases(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleResponse.databases)
  return databases_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchDatabaseInfo >*
ConsoleResponse::mutable_databases() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ConsoleResponse.databases)
  return &databases_;
}
inline const ::baikaldb::pb::WatchDatabaseInfo& ConsoleResponse::_internal_databases(int index) const {
  return databases_.Get(index);
}
inline const ::baikaldb::pb::WatchDatabaseInfo& ConsoleResponse::databases(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.databases)
  return _internal_databases(index);
}
inline ::baikaldb::pb::WatchDatabaseInfo* ConsoleResponse::_internal_add_databases() {
  return databases_.Add();
}
inline ::baikaldb::pb::WatchDatabaseInfo* ConsoleResponse::add_databases() {
  ::baikaldb::pb::WatchDatabaseInfo* _add = _internal_add_databases();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ConsoleResponse.databases)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchDatabaseInfo >&
ConsoleResponse::databases() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ConsoleResponse.databases)
  return databases_;
}

// optional .baikaldb.pb.WatchSchemaInfo table_schemas = 11;
inline bool ConsoleResponse::_internal_has_table_schemas() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || table_schemas_ != nullptr);
  return value;
}
inline bool ConsoleResponse::has_table_schemas() const {
  return _internal_has_table_schemas();
}
inline void ConsoleResponse::clear_table_schemas() {
  if (table_schemas_ != nullptr) table_schemas_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::baikaldb::pb::WatchSchemaInfo& ConsoleResponse::_internal_table_schemas() const {
  const ::baikaldb::pb::WatchSchemaInfo* p = table_schemas_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::WatchSchemaInfo&>(
      ::baikaldb::pb::_WatchSchemaInfo_default_instance_);
}
inline const ::baikaldb::pb::WatchSchemaInfo& ConsoleResponse::table_schemas() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.table_schemas)
  return _internal_table_schemas();
}
inline void ConsoleResponse::unsafe_arena_set_allocated_table_schemas(
    ::baikaldb::pb::WatchSchemaInfo* table_schemas) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_schemas_);
  }
  table_schemas_ = table_schemas;
  if (table_schemas) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.ConsoleResponse.table_schemas)
}
inline ::baikaldb::pb::WatchSchemaInfo* ConsoleResponse::release_table_schemas() {
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::WatchSchemaInfo* temp = table_schemas_;
  table_schemas_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::WatchSchemaInfo* ConsoleResponse::unsafe_arena_release_table_schemas() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ConsoleResponse.table_schemas)
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::WatchSchemaInfo* temp = table_schemas_;
  table_schemas_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::WatchSchemaInfo* ConsoleResponse::_internal_mutable_table_schemas() {
  _has_bits_[0] |= 0x00000008u;
  if (table_schemas_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::WatchSchemaInfo>(GetArenaForAllocation());
    table_schemas_ = p;
  }
  return table_schemas_;
}
inline ::baikaldb::pb::WatchSchemaInfo* ConsoleResponse::mutable_table_schemas() {
  ::baikaldb::pb::WatchSchemaInfo* _msg = _internal_mutable_table_schemas();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleResponse.table_schemas)
  return _msg;
}
inline void ConsoleResponse::set_allocated_table_schemas(::baikaldb::pb::WatchSchemaInfo* table_schemas) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete table_schemas_;
  }
  if (table_schemas) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::WatchSchemaInfo>::GetOwningArena(table_schemas);
    if (message_arena != submessage_arena) {
      table_schemas = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_schemas, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  table_schemas_ = table_schemas;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ConsoleResponse.table_schemas)
}

// repeated .baikaldb.pb.WatchClusterInfo cluster_infos = 12;
inline int ConsoleResponse::_internal_cluster_infos_size() const {
  return cluster_infos_.size();
}
inline int ConsoleResponse::cluster_infos_size() const {
  return _internal_cluster_infos_size();
}
inline void ConsoleResponse::clear_cluster_infos() {
  cluster_infos_.Clear();
}
inline ::baikaldb::pb::WatchClusterInfo* ConsoleResponse::mutable_cluster_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleResponse.cluster_infos)
  return cluster_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchClusterInfo >*
ConsoleResponse::mutable_cluster_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ConsoleResponse.cluster_infos)
  return &cluster_infos_;
}
inline const ::baikaldb::pb::WatchClusterInfo& ConsoleResponse::_internal_cluster_infos(int index) const {
  return cluster_infos_.Get(index);
}
inline const ::baikaldb::pb::WatchClusterInfo& ConsoleResponse::cluster_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.cluster_infos)
  return _internal_cluster_infos(index);
}
inline ::baikaldb::pb::WatchClusterInfo* ConsoleResponse::_internal_add_cluster_infos() {
  return cluster_infos_.Add();
}
inline ::baikaldb::pb::WatchClusterInfo* ConsoleResponse::add_cluster_infos() {
  ::baikaldb::pb::WatchClusterInfo* _add = _internal_add_cluster_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ConsoleResponse.cluster_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchClusterInfo >&
ConsoleResponse::cluster_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ConsoleResponse.cluster_infos)
  return cluster_infos_;
}

// repeated .baikaldb.pb.WatchImportTask import_task = 13;
inline int ConsoleResponse::_internal_import_task_size() const {
  return import_task_.size();
}
inline int ConsoleResponse::import_task_size() const {
  return _internal_import_task_size();
}
inline void ConsoleResponse::clear_import_task() {
  import_task_.Clear();
}
inline ::baikaldb::pb::WatchImportTask* ConsoleResponse::mutable_import_task(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleResponse.import_task)
  return import_task_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchImportTask >*
ConsoleResponse::mutable_import_task() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ConsoleResponse.import_task)
  return &import_task_;
}
inline const ::baikaldb::pb::WatchImportTask& ConsoleResponse::_internal_import_task(int index) const {
  return import_task_.Get(index);
}
inline const ::baikaldb::pb::WatchImportTask& ConsoleResponse::import_task(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.import_task)
  return _internal_import_task(index);
}
inline ::baikaldb::pb::WatchImportTask* ConsoleResponse::_internal_add_import_task() {
  return import_task_.Add();
}
inline ::baikaldb::pb::WatchImportTask* ConsoleResponse::add_import_task() {
  ::baikaldb::pb::WatchImportTask* _add = _internal_add_import_task();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ConsoleResponse.import_task)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchImportTask >&
ConsoleResponse::import_task() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ConsoleResponse.import_task)
  return import_task_;
}

// repeated .baikaldb.pb.WatchTaskList task_list = 14;
inline int ConsoleResponse::_internal_task_list_size() const {
  return task_list_.size();
}
inline int ConsoleResponse::task_list_size() const {
  return _internal_task_list_size();
}
inline void ConsoleResponse::clear_task_list() {
  task_list_.Clear();
}
inline ::baikaldb::pb::WatchTaskList* ConsoleResponse::mutable_task_list(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleResponse.task_list)
  return task_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchTaskList >*
ConsoleResponse::mutable_task_list() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ConsoleResponse.task_list)
  return &task_list_;
}
inline const ::baikaldb::pb::WatchTaskList& ConsoleResponse::_internal_task_list(int index) const {
  return task_list_.Get(index);
}
inline const ::baikaldb::pb::WatchTaskList& ConsoleResponse::task_list(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.task_list)
  return _internal_task_list(index);
}
inline ::baikaldb::pb::WatchTaskList* ConsoleResponse::_internal_add_task_list() {
  return task_list_.Add();
}
inline ::baikaldb::pb::WatchTaskList* ConsoleResponse::add_task_list() {
  ::baikaldb::pb::WatchTaskList* _add = _internal_add_task_list();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ConsoleResponse.task_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchTaskList >&
ConsoleResponse::task_list() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ConsoleResponse.task_list)
  return task_list_;
}

// optional .baikaldb.pb.WatchPlatForm plat_forms = 15;
inline bool ConsoleResponse::_internal_has_plat_forms() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || plat_forms_ != nullptr);
  return value;
}
inline bool ConsoleResponse::has_plat_forms() const {
  return _internal_has_plat_forms();
}
inline void ConsoleResponse::clear_plat_forms() {
  if (plat_forms_ != nullptr) plat_forms_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::baikaldb::pb::WatchPlatForm& ConsoleResponse::_internal_plat_forms() const {
  const ::baikaldb::pb::WatchPlatForm* p = plat_forms_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::WatchPlatForm&>(
      ::baikaldb::pb::_WatchPlatForm_default_instance_);
}
inline const ::baikaldb::pb::WatchPlatForm& ConsoleResponse::plat_forms() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.plat_forms)
  return _internal_plat_forms();
}
inline void ConsoleResponse::unsafe_arena_set_allocated_plat_forms(
    ::baikaldb::pb::WatchPlatForm* plat_forms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(plat_forms_);
  }
  plat_forms_ = plat_forms;
  if (plat_forms) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.ConsoleResponse.plat_forms)
}
inline ::baikaldb::pb::WatchPlatForm* ConsoleResponse::release_plat_forms() {
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::WatchPlatForm* temp = plat_forms_;
  plat_forms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::WatchPlatForm* ConsoleResponse::unsafe_arena_release_plat_forms() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ConsoleResponse.plat_forms)
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::WatchPlatForm* temp = plat_forms_;
  plat_forms_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::WatchPlatForm* ConsoleResponse::_internal_mutable_plat_forms() {
  _has_bits_[0] |= 0x00000010u;
  if (plat_forms_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::WatchPlatForm>(GetArenaForAllocation());
    plat_forms_ = p;
  }
  return plat_forms_;
}
inline ::baikaldb::pb::WatchPlatForm* ConsoleResponse::mutable_plat_forms() {
  ::baikaldb::pb::WatchPlatForm* _msg = _internal_mutable_plat_forms();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleResponse.plat_forms)
  return _msg;
}
inline void ConsoleResponse::set_allocated_plat_forms(::baikaldb::pb::WatchPlatForm* plat_forms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete plat_forms_;
  }
  if (plat_forms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::WatchPlatForm>::GetOwningArena(plat_forms);
    if (message_arena != submessage_arena) {
      plat_forms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, plat_forms, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  plat_forms_ = plat_forms;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ConsoleResponse.plat_forms)
}

// repeated .baikaldb.pb.WatchSSTTask sst_backup_task = 16;
inline int ConsoleResponse::_internal_sst_backup_task_size() const {
  return sst_backup_task_.size();
}
inline int ConsoleResponse::sst_backup_task_size() const {
  return _internal_sst_backup_task_size();
}
inline void ConsoleResponse::clear_sst_backup_task() {
  sst_backup_task_.Clear();
}
inline ::baikaldb::pb::WatchSSTTask* ConsoleResponse::mutable_sst_backup_task(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleResponse.sst_backup_task)
  return sst_backup_task_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchSSTTask >*
ConsoleResponse::mutable_sst_backup_task() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ConsoleResponse.sst_backup_task)
  return &sst_backup_task_;
}
inline const ::baikaldb::pb::WatchSSTTask& ConsoleResponse::_internal_sst_backup_task(int index) const {
  return sst_backup_task_.Get(index);
}
inline const ::baikaldb::pb::WatchSSTTask& ConsoleResponse::sst_backup_task(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.sst_backup_task)
  return _internal_sst_backup_task(index);
}
inline ::baikaldb::pb::WatchSSTTask* ConsoleResponse::_internal_add_sst_backup_task() {
  return sst_backup_task_.Add();
}
inline ::baikaldb::pb::WatchSSTTask* ConsoleResponse::add_sst_backup_task() {
  ::baikaldb::pb::WatchSSTTask* _add = _internal_add_sst_backup_task();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ConsoleResponse.sst_backup_task)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::WatchSSTTask >&
ConsoleResponse::sst_backup_task() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ConsoleResponse.sst_backup_task)
  return sst_backup_task_;
}

// optional int64 partition_num = 17;
inline bool ConsoleResponse::_internal_has_partition_num() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConsoleResponse::has_partition_num() const {
  return _internal_has_partition_num();
}
inline void ConsoleResponse::clear_partition_num() {
  partition_num_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ConsoleResponse::_internal_partition_num() const {
  return partition_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ConsoleResponse::partition_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleResponse.partition_num)
  return _internal_partition_num();
}
inline void ConsoleResponse::_internal_set_partition_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  partition_num_ = value;
}
inline void ConsoleResponse::set_partition_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_partition_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleResponse.partition_num)
}

// -------------------------------------------------------------------

// ShowxCondition

// optional string t = 1;
inline bool ShowxCondition::_internal_has_t() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShowxCondition::has_t() const {
  return _internal_has_t();
}
inline void ShowxCondition::clear_t() {
  t_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShowxCondition::t() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxCondition.t)
  return _internal_t();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowxCondition::set_t(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 t_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxCondition.t)
}
inline std::string* ShowxCondition::mutable_t() {
  std::string* _s = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxCondition.t)
  return _s;
}
inline const std::string& ShowxCondition::_internal_t() const {
  return t_.Get();
}
inline void ShowxCondition::_internal_set_t(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  t_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShowxCondition::_internal_mutable_t() {
  _has_bits_[0] |= 0x00000001u;
  return t_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShowxCondition::release_t() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ShowxCondition.t)
  if (!_internal_has_t()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return t_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShowxCondition::set_allocated_t(std::string* t) {
  if (t != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  t_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), t,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ShowxCondition.t)
}

// optional string k = 2;
inline bool ShowxCondition::_internal_has_k() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShowxCondition::has_k() const {
  return _internal_has_k();
}
inline void ShowxCondition::clear_k() {
  k_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ShowxCondition::k() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxCondition.k)
  return _internal_k();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowxCondition::set_k(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 k_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxCondition.k)
}
inline std::string* ShowxCondition::mutable_k() {
  std::string* _s = _internal_mutable_k();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxCondition.k)
  return _s;
}
inline const std::string& ShowxCondition::_internal_k() const {
  return k_.Get();
}
inline void ShowxCondition::_internal_set_k(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  k_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShowxCondition::_internal_mutable_k() {
  _has_bits_[0] |= 0x00000002u;
  return k_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShowxCondition::release_k() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ShowxCondition.k)
  if (!_internal_has_k()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return k_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShowxCondition::set_allocated_k(std::string* k) {
  if (k != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  k_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), k,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ShowxCondition.k)
}

// optional string v = 3;
inline bool ShowxCondition::_internal_has_v() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShowxCondition::has_v() const {
  return _internal_has_v();
}
inline void ShowxCondition::clear_v() {
  v_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ShowxCondition::v() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxCondition.v)
  return _internal_v();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowxCondition::set_v(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 v_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxCondition.v)
}
inline std::string* ShowxCondition::mutable_v() {
  std::string* _s = _internal_mutable_v();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxCondition.v)
  return _s;
}
inline const std::string& ShowxCondition::_internal_v() const {
  return v_.Get();
}
inline void ShowxCondition::_internal_set_v(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  v_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShowxCondition::_internal_mutable_v() {
  _has_bits_[0] |= 0x00000004u;
  return v_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShowxCondition::release_v() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ShowxCondition.v)
  if (!_internal_has_v()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return v_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShowxCondition::set_allocated_v(std::string* v) {
  if (v != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  v_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), v,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ShowxCondition.v)
}

// -------------------------------------------------------------------

// ShowxRequest

// repeated .baikaldb.pb.ShowxCondition conditions = 1;
inline int ShowxRequest::_internal_conditions_size() const {
  return conditions_.size();
}
inline int ShowxRequest::conditions_size() const {
  return _internal_conditions_size();
}
inline void ShowxRequest::clear_conditions() {
  conditions_.Clear();
}
inline ::baikaldb::pb::ShowxCondition* ShowxRequest::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxRequest.conditions)
  return conditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ShowxCondition >*
ShowxRequest::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ShowxRequest.conditions)
  return &conditions_;
}
inline const ::baikaldb::pb::ShowxCondition& ShowxRequest::_internal_conditions(int index) const {
  return conditions_.Get(index);
}
inline const ::baikaldb::pb::ShowxCondition& ShowxRequest::conditions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxRequest.conditions)
  return _internal_conditions(index);
}
inline ::baikaldb::pb::ShowxCondition* ShowxRequest::_internal_add_conditions() {
  return conditions_.Add();
}
inline ::baikaldb::pb::ShowxCondition* ShowxRequest::add_conditions() {
  ::baikaldb::pb::ShowxCondition* _add = _internal_add_conditions();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ShowxRequest.conditions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ShowxCondition >&
ShowxRequest::conditions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ShowxRequest.conditions)
  return conditions_;
}

// -------------------------------------------------------------------

// QueryStatusRequest

// required string task_name = 1;
inline bool QueryStatusRequest::_internal_has_task_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryStatusRequest::has_task_name() const {
  return _internal_has_task_name();
}
inline void QueryStatusRequest::clear_task_name() {
  task_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryStatusRequest::task_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryStatusRequest.task_name)
  return _internal_task_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryStatusRequest::set_task_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 task_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryStatusRequest.task_name)
}
inline std::string* QueryStatusRequest::mutable_task_name() {
  std::string* _s = _internal_mutable_task_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryStatusRequest.task_name)
  return _s;
}
inline const std::string& QueryStatusRequest::_internal_task_name() const {
  return task_name_.Get();
}
inline void QueryStatusRequest::_internal_set_task_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  task_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryStatusRequest::_internal_mutable_task_name() {
  _has_bits_[0] |= 0x00000001u;
  return task_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryStatusRequest::release_task_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryStatusRequest.task_name)
  if (!_internal_has_task_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return task_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryStatusRequest::set_allocated_task_name(std::string* task_name) {
  if (task_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  task_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), task_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryStatusRequest.task_name)
}

// required string platform = 2;
inline bool QueryStatusRequest::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QueryStatusRequest::has_platform() const {
  return _internal_has_platform();
}
inline void QueryStatusRequest::clear_platform() {
  platform_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryStatusRequest::platform() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryStatusRequest.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryStatusRequest::set_platform(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryStatusRequest.platform)
}
inline std::string* QueryStatusRequest::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryStatusRequest.platform)
  return _s;
}
inline const std::string& QueryStatusRequest::_internal_platform() const {
  return platform_.Get();
}
inline void QueryStatusRequest::_internal_set_platform(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryStatusRequest::_internal_mutable_platform() {
  _has_bits_[0] |= 0x00000002u;
  return platform_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryStatusRequest::release_platform() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryStatusRequest.platform)
  if (!_internal_has_platform()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return platform_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryStatusRequest::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  platform_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryStatusRequest.platform)
}

// required int64 version = 3;
inline bool QueryStatusRequest::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QueryStatusRequest::has_version() const {
  return _internal_has_version();
}
inline void QueryStatusRequest::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryStatusRequest::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryStatusRequest::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryStatusRequest.version)
  return _internal_version();
}
inline void QueryStatusRequest::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  version_ = value;
}
inline void QueryStatusRequest::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryStatusRequest.version)
}

// -------------------------------------------------------------------

// QueryStatusResponse

// required .baikaldb.pb.ErrCode errcode = 1;
inline bool QueryStatusResponse::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QueryStatusResponse::has_errcode() const {
  return _internal_has_errcode();
}
inline void QueryStatusResponse::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::baikaldb::pb::ErrCode QueryStatusResponse::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::ErrCode >(errcode_);
}
inline ::baikaldb::pb::ErrCode QueryStatusResponse::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryStatusResponse.errcode)
  return _internal_errcode();
}
inline void QueryStatusResponse::_internal_set_errcode(::baikaldb::pb::ErrCode value) {
  assert(::baikaldb::pb::ErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  errcode_ = value;
}
inline void QueryStatusResponse::set_errcode(::baikaldb::pb::ErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryStatusResponse.errcode)
}

// optional string status = 2;
inline bool QueryStatusResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryStatusResponse::has_status() const {
  return _internal_has_status();
}
inline void QueryStatusResponse::clear_status() {
  status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryStatusResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryStatusResponse::set_status(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryStatusResponse.status)
}
inline std::string* QueryStatusResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryStatusResponse.status)
  return _s;
}
inline const std::string& QueryStatusResponse::_internal_status() const {
  return status_.Get();
}
inline void QueryStatusResponse::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryStatusResponse::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryStatusResponse::release_status() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryStatusResponse.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryStatusResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryStatusResponse.status)
}

// optional string result = 3;
inline bool QueryStatusResponse::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QueryStatusResponse::has_result() const {
  return _internal_has_result();
}
inline void QueryStatusResponse::clear_result() {
  result_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryStatusResponse::result() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryStatusResponse.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryStatusResponse::set_result(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryStatusResponse.result)
}
inline std::string* QueryStatusResponse::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryStatusResponse.result)
  return _s;
}
inline const std::string& QueryStatusResponse::_internal_result() const {
  return result_.Get();
}
inline void QueryStatusResponse::_internal_set_result(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryStatusResponse::_internal_mutable_result() {
  _has_bits_[0] |= 0x00000002u;
  return result_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryStatusResponse::release_result() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryStatusResponse.result)
  if (!_internal_has_result()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return result_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryStatusResponse::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  result_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryStatusResponse.result)
}

// -------------------------------------------------------------------

// ShowxColumn

// required string name = 1;
inline bool ShowxColumn::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShowxColumn::has_name() const {
  return _internal_has_name();
}
inline void ShowxColumn::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShowxColumn::name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxColumn.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowxColumn::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxColumn.name)
}
inline std::string* ShowxColumn::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxColumn.name)
  return _s;
}
inline const std::string& ShowxColumn::_internal_name() const {
  return name_.Get();
}
inline void ShowxColumn::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShowxColumn::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShowxColumn::release_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ShowxColumn.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShowxColumn::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ShowxColumn.name)
}

// required string id = 2;
inline bool ShowxColumn::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShowxColumn::has_id() const {
  return _internal_has_id();
}
inline void ShowxColumn::clear_id() {
  id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ShowxColumn::id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxColumn.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowxColumn::set_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxColumn.id)
}
inline std::string* ShowxColumn::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxColumn.id)
  return _s;
}
inline const std::string& ShowxColumn::_internal_id() const {
  return id_.Get();
}
inline void ShowxColumn::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShowxColumn::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000002u;
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShowxColumn::release_id() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ShowxColumn.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShowxColumn::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ShowxColumn.id)
}

// optional string unit = 3;
inline bool ShowxColumn::_internal_has_unit() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShowxColumn::has_unit() const {
  return _internal_has_unit();
}
inline void ShowxColumn::clear_unit() {
  unit_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ShowxColumn::unit() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxColumn.unit)
  return _internal_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowxColumn::set_unit(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 unit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxColumn.unit)
}
inline std::string* ShowxColumn::mutable_unit() {
  std::string* _s = _internal_mutable_unit();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxColumn.unit)
  return _s;
}
inline const std::string& ShowxColumn::_internal_unit() const {
  return unit_.Get();
}
inline void ShowxColumn::_internal_set_unit(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  unit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShowxColumn::_internal_mutable_unit() {
  _has_bits_[0] |= 0x00000004u;
  return unit_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShowxColumn::release_unit() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ShowxColumn.unit)
  if (!_internal_has_unit()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return unit_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShowxColumn::set_allocated_unit(std::string* unit) {
  if (unit != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  unit_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unit,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ShowxColumn.unit)
}

// optional string textAlign = 4;
inline bool ShowxColumn::_internal_has_textalign() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ShowxColumn::has_textalign() const {
  return _internal_has_textalign();
}
inline void ShowxColumn::clear_textalign() {
  textalign_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ShowxColumn::textalign() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxColumn.textAlign)
  return _internal_textalign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowxColumn::set_textalign(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 textalign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxColumn.textAlign)
}
inline std::string* ShowxColumn::mutable_textalign() {
  std::string* _s = _internal_mutable_textalign();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxColumn.textAlign)
  return _s;
}
inline const std::string& ShowxColumn::_internal_textalign() const {
  return textalign_.Get();
}
inline void ShowxColumn::_internal_set_textalign(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  textalign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShowxColumn::_internal_mutable_textalign() {
  _has_bits_[0] |= 0x00000008u;
  return textalign_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShowxColumn::release_textalign() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ShowxColumn.textAlign)
  if (!_internal_has_textalign()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return textalign_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShowxColumn::set_allocated_textalign(std::string* textalign) {
  if (textalign != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  textalign_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), textalign,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ShowxColumn.textAlign)
}

// optional bool autoWrap = 5;
inline bool ShowxColumn::_internal_has_autowrap() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ShowxColumn::has_autowrap() const {
  return _internal_has_autowrap();
}
inline void ShowxColumn::clear_autowrap() {
  autowrap_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ShowxColumn::_internal_autowrap() const {
  return autowrap_;
}
inline bool ShowxColumn::autowrap() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxColumn.autoWrap)
  return _internal_autowrap();
}
inline void ShowxColumn::_internal_set_autowrap(bool value) {
  _has_bits_[0] |= 0x00000080u;
  autowrap_ = value;
}
inline void ShowxColumn::set_autowrap(bool value) {
  _internal_set_autowrap(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxColumn.autoWrap)
}

// optional string width = 6;
inline bool ShowxColumn::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ShowxColumn::has_width() const {
  return _internal_has_width();
}
inline void ShowxColumn::clear_width() {
  width_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ShowxColumn::width() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxColumn.width)
  return _internal_width();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowxColumn::set_width(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 width_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxColumn.width)
}
inline std::string* ShowxColumn::mutable_width() {
  std::string* _s = _internal_mutable_width();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxColumn.width)
  return _s;
}
inline const std::string& ShowxColumn::_internal_width() const {
  return width_.Get();
}
inline void ShowxColumn::_internal_set_width(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  width_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShowxColumn::_internal_mutable_width() {
  _has_bits_[0] |= 0x00000010u;
  return width_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShowxColumn::release_width() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ShowxColumn.width)
  if (!_internal_has_width()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return width_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShowxColumn::set_allocated_width(std::string* width) {
  if (width != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  width_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), width,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ShowxColumn.width)
}

// optional string accuracy = 7;
inline bool ShowxColumn::_internal_has_accuracy() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ShowxColumn::has_accuracy() const {
  return _internal_has_accuracy();
}
inline void ShowxColumn::clear_accuracy() {
  accuracy_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ShowxColumn::accuracy() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxColumn.accuracy)
  return _internal_accuracy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowxColumn::set_accuracy(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 accuracy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxColumn.accuracy)
}
inline std::string* ShowxColumn::mutable_accuracy() {
  std::string* _s = _internal_mutable_accuracy();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxColumn.accuracy)
  return _s;
}
inline const std::string& ShowxColumn::_internal_accuracy() const {
  return accuracy_.Get();
}
inline void ShowxColumn::_internal_set_accuracy(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  accuracy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShowxColumn::_internal_mutable_accuracy() {
  _has_bits_[0] |= 0x00000020u;
  return accuracy_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShowxColumn::release_accuracy() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ShowxColumn.accuracy)
  if (!_internal_has_accuracy()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return accuracy_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShowxColumn::set_allocated_accuracy(std::string* accuracy) {
  if (accuracy != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  accuracy_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), accuracy,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ShowxColumn.accuracy)
}

// optional string remark = 8;
inline bool ShowxColumn::_internal_has_remark() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ShowxColumn::has_remark() const {
  return _internal_has_remark();
}
inline void ShowxColumn::clear_remark() {
  remark_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ShowxColumn::remark() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxColumn.remark)
  return _internal_remark();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowxColumn::set_remark(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 remark_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxColumn.remark)
}
inline std::string* ShowxColumn::mutable_remark() {
  std::string* _s = _internal_mutable_remark();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxColumn.remark)
  return _s;
}
inline const std::string& ShowxColumn::_internal_remark() const {
  return remark_.Get();
}
inline void ShowxColumn::_internal_set_remark(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  remark_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShowxColumn::_internal_mutable_remark() {
  _has_bits_[0] |= 0x00000040u;
  return remark_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShowxColumn::release_remark() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ShowxColumn.remark)
  if (!_internal_has_remark()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return remark_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShowxColumn::set_allocated_remark(std::string* remark) {
  if (remark != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  remark_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remark,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ShowxColumn.remark)
}

// -------------------------------------------------------------------

// ShowxRow

// optional string database_name = 1;
inline bool ShowxRow::_internal_has_database_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShowxRow::has_database_name() const {
  return _internal_has_database_name();
}
inline void ShowxRow::clear_database_name() {
  database_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShowxRow::database_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxRow.database_name)
  return _internal_database_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowxRow::set_database_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 database_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxRow.database_name)
}
inline std::string* ShowxRow::mutable_database_name() {
  std::string* _s = _internal_mutable_database_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxRow.database_name)
  return _s;
}
inline const std::string& ShowxRow::_internal_database_name() const {
  return database_name_.Get();
}
inline void ShowxRow::_internal_set_database_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  database_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShowxRow::_internal_mutable_database_name() {
  _has_bits_[0] |= 0x00000001u;
  return database_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShowxRow::release_database_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ShowxRow.database_name)
  if (!_internal_has_database_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return database_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShowxRow::set_allocated_database_name(std::string* database_name) {
  if (database_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  database_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ShowxRow.database_name)
}

// optional string table_name = 2;
inline bool ShowxRow::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ShowxRow::has_table_name() const {
  return _internal_has_table_name();
}
inline void ShowxRow::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ShowxRow::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxRow.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowxRow::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxRow.table_name)
}
inline std::string* ShowxRow::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxRow.table_name)
  return _s;
}
inline const std::string& ShowxRow::_internal_table_name() const {
  return table_name_.Get();
}
inline void ShowxRow::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShowxRow::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000002u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShowxRow::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ShowxRow.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShowxRow::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ShowxRow.table_name)
}

// optional string sign = 3;
inline bool ShowxRow::_internal_has_sign() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShowxRow::has_sign() const {
  return _internal_has_sign();
}
inline void ShowxRow::clear_sign() {
  sign_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ShowxRow::sign() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxRow.sign)
  return _internal_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowxRow::set_sign(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 sign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxRow.sign)
}
inline std::string* ShowxRow::mutable_sign() {
  std::string* _s = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxRow.sign)
  return _s;
}
inline const std::string& ShowxRow::_internal_sign() const {
  return sign_.Get();
}
inline void ShowxRow::_internal_set_sign(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  sign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShowxRow::_internal_mutable_sign() {
  _has_bits_[0] |= 0x00000004u;
  return sign_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShowxRow::release_sign() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ShowxRow.sign)
  if (!_internal_has_sign()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return sign_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShowxRow::set_allocated_sign(std::string* sign) {
  if (sign != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  sign_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sign,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ShowxRow.sign)
}

// optional string time_range = 4;
inline bool ShowxRow::_internal_has_time_range() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ShowxRow::has_time_range() const {
  return _internal_has_time_range();
}
inline void ShowxRow::clear_time_range() {
  time_range_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ShowxRow::time_range() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxRow.time_range)
  return _internal_time_range();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowxRow::set_time_range(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 time_range_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxRow.time_range)
}
inline std::string* ShowxRow::mutable_time_range() {
  std::string* _s = _internal_mutable_time_range();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxRow.time_range)
  return _s;
}
inline const std::string& ShowxRow::_internal_time_range() const {
  return time_range_.Get();
}
inline void ShowxRow::_internal_set_time_range(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  time_range_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShowxRow::_internal_mutable_time_range() {
  _has_bits_[0] |= 0x00000008u;
  return time_range_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShowxRow::release_time_range() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ShowxRow.time_range)
  if (!_internal_has_time_range()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return time_range_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShowxRow::set_allocated_time_range(std::string* time_range) {
  if (time_range != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  time_range_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), time_range,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ShowxRow.time_range)
}

// optional int64 pv = 5;
inline bool ShowxRow::_internal_has_pv() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ShowxRow::has_pv() const {
  return _internal_has_pv();
}
inline void ShowxRow::clear_pv() {
  pv_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ShowxRow::_internal_pv() const {
  return pv_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ShowxRow::pv() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxRow.pv)
  return _internal_pv();
}
inline void ShowxRow::_internal_set_pv(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  pv_ = value;
}
inline void ShowxRow::set_pv(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pv(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxRow.pv)
}

// optional int64 pv_diff = 6;
inline bool ShowxRow::_internal_has_pv_diff() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ShowxRow::has_pv_diff() const {
  return _internal_has_pv_diff();
}
inline void ShowxRow::clear_pv_diff() {
  pv_diff_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ShowxRow::_internal_pv_diff() const {
  return pv_diff_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ShowxRow::pv_diff() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxRow.pv_diff)
  return _internal_pv_diff();
}
inline void ShowxRow::_internal_set_pv_diff(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  pv_diff_ = value;
}
inline void ShowxRow::set_pv_diff(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pv_diff(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxRow.pv_diff)
}

// optional float avg = 7;
inline bool ShowxRow::_internal_has_avg() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ShowxRow::has_avg() const {
  return _internal_has_avg();
}
inline void ShowxRow::clear_avg() {
  avg_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float ShowxRow::_internal_avg() const {
  return avg_;
}
inline float ShowxRow::avg() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxRow.avg)
  return _internal_avg();
}
inline void ShowxRow::_internal_set_avg(float value) {
  _has_bits_[0] |= 0x00000040u;
  avg_ = value;
}
inline void ShowxRow::set_avg(float value) {
  _internal_set_avg(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxRow.avg)
}

// optional float avg_diff = 8;
inline bool ShowxRow::_internal_has_avg_diff() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ShowxRow::has_avg_diff() const {
  return _internal_has_avg_diff();
}
inline void ShowxRow::clear_avg_diff() {
  avg_diff_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float ShowxRow::_internal_avg_diff() const {
  return avg_diff_;
}
inline float ShowxRow::avg_diff() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxRow.avg_diff)
  return _internal_avg_diff();
}
inline void ShowxRow::_internal_set_avg_diff(float value) {
  _has_bits_[0] |= 0x00000080u;
  avg_diff_ = value;
}
inline void ShowxRow::set_avg_diff(float value) {
  _internal_set_avg_diff(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxRow.avg_diff)
}

// -------------------------------------------------------------------

// ShowxData

// repeated .baikaldb.pb.ShowxColumn columns = 1;
inline int ShowxData::_internal_columns_size() const {
  return columns_.size();
}
inline int ShowxData::columns_size() const {
  return _internal_columns_size();
}
inline void ShowxData::clear_columns() {
  columns_.Clear();
}
inline ::baikaldb::pb::ShowxColumn* ShowxData::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxData.columns)
  return columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ShowxColumn >*
ShowxData::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ShowxData.columns)
  return &columns_;
}
inline const ::baikaldb::pb::ShowxColumn& ShowxData::_internal_columns(int index) const {
  return columns_.Get(index);
}
inline const ::baikaldb::pb::ShowxColumn& ShowxData::columns(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxData.columns)
  return _internal_columns(index);
}
inline ::baikaldb::pb::ShowxColumn* ShowxData::_internal_add_columns() {
  return columns_.Add();
}
inline ::baikaldb::pb::ShowxColumn* ShowxData::add_columns() {
  ::baikaldb::pb::ShowxColumn* _add = _internal_add_columns();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ShowxData.columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ShowxColumn >&
ShowxData::columns() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ShowxData.columns)
  return columns_;
}

// repeated .baikaldb.pb.ShowxRow rows = 2;
inline int ShowxData::_internal_rows_size() const {
  return rows_.size();
}
inline int ShowxData::rows_size() const {
  return _internal_rows_size();
}
inline void ShowxData::clear_rows() {
  rows_.Clear();
}
inline ::baikaldb::pb::ShowxRow* ShowxData::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxData.rows)
  return rows_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ShowxRow >*
ShowxData::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ShowxData.rows)
  return &rows_;
}
inline const ::baikaldb::pb::ShowxRow& ShowxData::_internal_rows(int index) const {
  return rows_.Get(index);
}
inline const ::baikaldb::pb::ShowxRow& ShowxData::rows(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxData.rows)
  return _internal_rows(index);
}
inline ::baikaldb::pb::ShowxRow* ShowxData::_internal_add_rows() {
  return rows_.Add();
}
inline ::baikaldb::pb::ShowxRow* ShowxData::add_rows() {
  ::baikaldb::pb::ShowxRow* _add = _internal_add_rows();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ShowxData.rows)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ShowxRow >&
ShowxData::rows() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ShowxData.rows)
  return rows_;
}

// -------------------------------------------------------------------

// ShowxResponse

// optional int64 status = 1;
inline bool ShowxResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ShowxResponse::has_status() const {
  return _internal_has_status();
}
inline void ShowxResponse::clear_status() {
  status_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ShowxResponse::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ShowxResponse::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxResponse.status)
  return _internal_status();
}
inline void ShowxResponse::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  status_ = value;
}
inline void ShowxResponse::set_status(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxResponse.status)
}

// optional string msg = 2;
inline bool ShowxResponse::_internal_has_msg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShowxResponse::has_msg() const {
  return _internal_has_msg();
}
inline void ShowxResponse::clear_msg() {
  msg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShowxResponse::msg() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShowxResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxResponse.msg)
}
inline std::string* ShowxResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxResponse.msg)
  return _s;
}
inline const std::string& ShowxResponse::_internal_msg() const {
  return msg_.Get();
}
inline void ShowxResponse::_internal_set_msg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ShowxResponse::_internal_mutable_msg() {
  _has_bits_[0] |= 0x00000001u;
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ShowxResponse::release_msg() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ShowxResponse.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return msg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ShowxResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ShowxResponse.msg)
}

// optional .baikaldb.pb.ShowxData data = 3;
inline bool ShowxResponse::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || data_ != nullptr);
  return value;
}
inline bool ShowxResponse::has_data() const {
  return _internal_has_data();
}
inline void ShowxResponse::clear_data() {
  if (data_ != nullptr) data_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::baikaldb::pb::ShowxData& ShowxResponse::_internal_data() const {
  const ::baikaldb::pb::ShowxData* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::ShowxData&>(
      ::baikaldb::pb::_ShowxData_default_instance_);
}
inline const ::baikaldb::pb::ShowxData& ShowxResponse::data() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxResponse.data)
  return _internal_data();
}
inline void ShowxResponse::unsafe_arena_set_allocated_data(
    ::baikaldb::pb::ShowxData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.ShowxResponse.data)
}
inline ::baikaldb::pb::ShowxData* ShowxResponse::release_data() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::ShowxData* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::ShowxData* ShowxResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ShowxResponse.data)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::ShowxData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::ShowxData* ShowxResponse::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000002u;
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::ShowxData>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::baikaldb::pb::ShowxData* ShowxResponse::mutable_data() {
  ::baikaldb::pb::ShowxData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ShowxResponse.data)
  return _msg;
}
inline void ShowxResponse::set_allocated_data(::baikaldb::pb::ShowxData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::ShowxData>::GetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ShowxResponse.data)
}

// optional int64 total = 4;
inline bool ShowxResponse::_internal_has_total() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ShowxResponse::has_total() const {
  return _internal_has_total();
}
inline void ShowxResponse::clear_total() {
  total_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ShowxResponse::_internal_total() const {
  return total_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ShowxResponse::total() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ShowxResponse.total)
  return _internal_total();
}
inline void ShowxResponse::_internal_set_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  total_ = value;
}
inline void ShowxResponse::set_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ShowxResponse.total)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace baikaldb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::baikaldb::pb::WatchOpType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::WatchOpType>() {
  return ::baikaldb::pb::WatchOpType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_console_2eproto
