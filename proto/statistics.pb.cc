// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: statistics.proto

#include "statistics.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace baikaldb {
namespace pb {
constexpr BucketInfo::BucketInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : start_(nullptr)
  , end_(nullptr)
  , distinct_cnt_(0)
  , bucket_size_(0){}
struct BucketInfoDefaultTypeInternal {
  constexpr BucketInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BucketInfoDefaultTypeInternal() {}
  union {
    BucketInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BucketInfoDefaultTypeInternal _BucketInfo_default_instance_;
constexpr ColumnInfo::ColumnInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : bucket_infos_()
  , col_type_(0)

  , field_id_(0)
  , distinct_cnt_(0)
  , null_value_cnt_(0){}
struct ColumnInfoDefaultTypeInternal {
  constexpr ColumnInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ColumnInfoDefaultTypeInternal() {}
  union {
    ColumnInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ColumnInfoDefaultTypeInternal _ColumnInfo_default_instance_;
constexpr Histogram::Histogram(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : column_infos_()
  , sample_rows_(int64_t{0})
  , total_rows_(int64_t{0}){}
struct HistogramDefaultTypeInternal {
  constexpr HistogramDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~HistogramDefaultTypeInternal() {}
  union {
    Histogram _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HistogramDefaultTypeInternal _Histogram_default_instance_;
constexpr CMsketchItem::CMsketchItem(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : depth_(0)
  , width_(0)
  , value_(0){}
struct CMsketchItemDefaultTypeInternal {
  constexpr CMsketchItemDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsketchItemDefaultTypeInternal() {}
  union {
    CMsketchItem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsketchItemDefaultTypeInternal _CMsketchItem_default_instance_;
constexpr CMsketchColumn::CMsketchColumn(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : cmitems_()
  , field_id_(0){}
struct CMsketchColumnDefaultTypeInternal {
  constexpr CMsketchColumnDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsketchColumnDefaultTypeInternal() {}
  union {
    CMsketchColumn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsketchColumnDefaultTypeInternal _CMsketchColumn_default_instance_;
constexpr CMsketch::CMsketch(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : cmcolumns_()
  , depth_(0)
  , width_(0){}
struct CMsketchDefaultTypeInternal {
  constexpr CMsketchDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsketchDefaultTypeInternal() {}
  union {
    CMsketch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsketchDefaultTypeInternal _CMsketch_default_instance_;
constexpr HyperLogLogColumn::HyperLogLogColumn(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : hll_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , estimate_count_(uint64_t{0u})
  , field_id_(0){}
struct HyperLogLogColumnDefaultTypeInternal {
  constexpr HyperLogLogColumnDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~HyperLogLogColumnDefaultTypeInternal() {}
  union {
    HyperLogLogColumn _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HyperLogLogColumnDefaultTypeInternal _HyperLogLogColumn_default_instance_;
constexpr HyperLogLog::HyperLogLog(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : hllcolumns_(){}
struct HyperLogLogDefaultTypeInternal {
  constexpr HyperLogLogDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~HyperLogLogDefaultTypeInternal() {}
  union {
    HyperLogLog _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HyperLogLogDefaultTypeInternal _HyperLogLog_default_instance_;
constexpr Statistics::Statistics(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : histogram_(nullptr)
  , cmsketch_(nullptr)
  , hll_(nullptr)
  , table_id_(int64_t{0})
  , version_(int64_t{0})
  , total_rows_(int64_t{0}){}
struct StatisticsDefaultTypeInternal {
  constexpr StatisticsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~StatisticsDefaultTypeInternal() {}
  union {
    Statistics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT StatisticsDefaultTypeInternal _Statistics_default_instance_;
}  // namespace pb
}  // namespace baikaldb
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_statistics_2eproto[9];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_statistics_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_statistics_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_statistics_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BucketInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BucketInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BucketInfo, distinct_cnt_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BucketInfo, bucket_size_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BucketInfo, start_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::BucketInfo, end_),
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ColumnInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ColumnInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ColumnInfo, col_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ColumnInfo, field_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ColumnInfo, distinct_cnt_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ColumnInfo, null_value_cnt_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ColumnInfo, bucket_infos_),
  0,
  1,
  2,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::Histogram, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::Histogram, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::Histogram, sample_rows_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::Histogram, total_rows_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::Histogram, column_infos_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CMsketchItem, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CMsketchItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CMsketchItem, depth_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CMsketchItem, width_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CMsketchItem, value_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CMsketchColumn, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CMsketchColumn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CMsketchColumn, field_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CMsketchColumn, cmitems_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CMsketch, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CMsketch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CMsketch, depth_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CMsketch, width_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::CMsketch, cmcolumns_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::HyperLogLogColumn, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::HyperLogLogColumn, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::HyperLogLogColumn, field_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::HyperLogLogColumn, hll_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::HyperLogLogColumn, estimate_count_),
  2,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::HyperLogLog, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::HyperLogLog, hllcolumns_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::Statistics, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::Statistics, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::Statistics, table_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::Statistics, version_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::Statistics, histogram_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::Statistics, cmsketch_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::Statistics, hll_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::Statistics, total_rows_),
  3,
  4,
  0,
  1,
  2,
  5,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 10, -1, sizeof(::baikaldb::pb::BucketInfo)},
  { 14, 25, -1, sizeof(::baikaldb::pb::ColumnInfo)},
  { 30, 39, -1, sizeof(::baikaldb::pb::Histogram)},
  { 42, 51, -1, sizeof(::baikaldb::pb::CMsketchItem)},
  { 54, 62, -1, sizeof(::baikaldb::pb::CMsketchColumn)},
  { 64, 73, -1, sizeof(::baikaldb::pb::CMsketch)},
  { 76, 85, -1, sizeof(::baikaldb::pb::HyperLogLogColumn)},
  { 88, -1, -1, sizeof(::baikaldb::pb::HyperLogLog)},
  { 95, 107, -1, sizeof(::baikaldb::pb::Statistics)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_BucketInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_ColumnInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_Histogram_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_CMsketchItem_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_CMsketchColumn_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_CMsketch_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_HyperLogLogColumn_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_HyperLogLog_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_Statistics_default_instance_),
};

const char descriptor_table_protodef_statistics_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020statistics.proto\022\013baikaldb.pb\032\014common."
  "proto\"\203\001\n\nBucketInfo\022\024\n\014distinct_cnt\030\001 \002"
  "(\005\022\023\n\013bucket_size\030\002 \002(\005\022%\n\005start\030\003 \002(\0132\026"
  ".baikaldb.pb.ExprValue\022#\n\003end\030\004 \002(\0132\026.ba"
  "ikaldb.pb.ExprValue\"\251\001\n\nColumnInfo\022,\n\010co"
  "l_type\030\001 \002(\0162\032.baikaldb.pb.PrimitiveType"
  "\022\020\n\010field_id\030\002 \002(\005\022\024\n\014distinct_cnt\030\003 \002(\005"
  "\022\026\n\016null_value_cnt\030\004 \002(\005\022-\n\014bucket_infos"
  "\030\005 \003(\0132\027.baikaldb.pb.BucketInfo\"c\n\tHisto"
  "gram\022\023\n\013sample_rows\030\001 \002(\003\022\022\n\ntotal_rows\030"
  "\002 \002(\003\022-\n\014column_infos\030\003 \003(\0132\027.baikaldb.p"
  "b.ColumnInfo\";\n\014CMsketchItem\022\r\n\005depth\030\001 "
  "\002(\005\022\r\n\005width\030\002 \002(\005\022\r\n\005value\030\003 \002(\005\"N\n\016CMs"
  "ketchColumn\022\020\n\010field_id\030\001 \002(\005\022*\n\007cmitems"
  "\030\002 \003(\0132\031.baikaldb.pb.CMsketchItem\"X\n\010CMs"
  "ketch\022\r\n\005depth\030\001 \002(\005\022\r\n\005width\030\002 \002(\005\022.\n\tc"
  "mcolumns\030\003 \003(\0132\033.baikaldb.pb.CMsketchCol"
  "umn\"J\n\021HyperLogLogColumn\022\020\n\010field_id\030\001 \001"
  "(\005\022\013\n\003hll\030\002 \001(\014\022\026\n\016estimate_count\030\003 \001(\004\""
  "A\n\013HyperLogLog\0222\n\nhllcolumns\030\001 \003(\0132\036.bai"
  "kaldb.pb.HyperLogLogColumn\"\276\001\n\nStatistic"
  "s\022\020\n\010table_id\030\001 \002(\003\022\017\n\007version\030\002 \001(\003\022)\n\t"
  "histogram\030\003 \001(\0132\026.baikaldb.pb.Histogram\022"
  "\'\n\010cmsketch\030\004 \001(\0132\025.baikaldb.pb.CMsketch"
  "\022%\n\003hll\030\005 \001(\0132\030.baikaldb.pb.HyperLogLog\022"
  "\022\n\ntotal_rows\030\006 \001(\003"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_statistics_2eproto_deps[1] = {
  &::descriptor_table_common_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_statistics_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_statistics_2eproto = {
  false, false, 1019, descriptor_table_protodef_statistics_2eproto, "statistics.proto", 
  &descriptor_table_statistics_2eproto_once, descriptor_table_statistics_2eproto_deps, 1, 9,
  schemas, file_default_instances, TableStruct_statistics_2eproto::offsets,
  file_level_metadata_statistics_2eproto, file_level_enum_descriptors_statistics_2eproto, file_level_service_descriptors_statistics_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_statistics_2eproto_getter() {
  return &descriptor_table_statistics_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_statistics_2eproto(&descriptor_table_statistics_2eproto);
namespace baikaldb {
namespace pb {

// ===================================================================

class BucketInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<BucketInfo>()._has_bits_);
  static void set_has_distinct_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bucket_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::baikaldb::pb::ExprValue& start(const BucketInfo* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::baikaldb::pb::ExprValue& end(const BucketInfo* msg);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::baikaldb::pb::ExprValue&
BucketInfo::_Internal::start(const BucketInfo* msg) {
  return *msg->start_;
}
const ::baikaldb::pb::ExprValue&
BucketInfo::_Internal::end(const BucketInfo* msg) {
  return *msg->end_;
}
void BucketInfo::clear_start() {
  if (start_ != nullptr) start_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void BucketInfo::clear_end() {
  if (end_ != nullptr) end_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
BucketInfo::BucketInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.BucketInfo)
}
BucketInfo::BucketInfo(const BucketInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_start()) {
    start_ = new ::baikaldb::pb::ExprValue(*from.start_);
  } else {
    start_ = nullptr;
  }
  if (from._internal_has_end()) {
    end_ = new ::baikaldb::pb::ExprValue(*from.end_);
  } else {
    end_ = nullptr;
  }
  ::memcpy(&distinct_cnt_, &from.distinct_cnt_,
    static_cast<size_t>(reinterpret_cast<char*>(&bucket_size_) -
    reinterpret_cast<char*>(&distinct_cnt_)) + sizeof(bucket_size_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.BucketInfo)
}

void BucketInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&start_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&bucket_size_) -
    reinterpret_cast<char*>(&start_)) + sizeof(bucket_size_));
}

BucketInfo::~BucketInfo() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.BucketInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BucketInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete start_;
  if (this != internal_default_instance()) delete end_;
}

void BucketInfo::ArenaDtor(void* object) {
  BucketInfo* _this = reinterpret_cast< BucketInfo* >(object);
  (void)_this;
}
void BucketInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BucketInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BucketInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.BucketInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(start_ != nullptr);
      start_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(end_ != nullptr);
      end_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&distinct_cnt_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&bucket_size_) -
        reinterpret_cast<char*>(&distinct_cnt_)) + sizeof(bucket_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BucketInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 distinct_cnt = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_distinct_cnt(&has_bits);
          distinct_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 bucket_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_bucket_size(&has_bits);
          bucket_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .baikaldb.pb.ExprValue start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .baikaldb.pb.ExprValue end = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BucketInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.BucketInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 distinct_cnt = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_distinct_cnt(), target);
  }

  // required int32 bucket_size = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_bucket_size(), target);
  }

  // required .baikaldb.pb.ExprValue start = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::start(this), target, stream);
  }

  // required .baikaldb.pb.ExprValue end = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::end(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.BucketInfo)
  return target;
}

size_t BucketInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.BucketInfo)
  size_t total_size = 0;

  if (_internal_has_start()) {
    // required .baikaldb.pb.ExprValue start = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *start_);
  }

  if (_internal_has_end()) {
    // required .baikaldb.pb.ExprValue end = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *end_);
  }

  if (_internal_has_distinct_cnt()) {
    // required int32 distinct_cnt = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_distinct_cnt());
  }

  if (_internal_has_bucket_size()) {
    // required int32 bucket_size = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_bucket_size());
  }

  return total_size;
}
size_t BucketInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.BucketInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .baikaldb.pb.ExprValue start = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *start_);

    // required .baikaldb.pb.ExprValue end = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *end_);

    // required int32 distinct_cnt = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_distinct_cnt());

    // required int32 bucket_size = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_bucket_size());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BucketInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BucketInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BucketInfo::GetClassData() const { return &_class_data_; }

void BucketInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BucketInfo *>(to)->MergeFrom(
      static_cast<const BucketInfo &>(from));
}


void BucketInfo::MergeFrom(const BucketInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.BucketInfo)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_start()->::baikaldb::pb::ExprValue::MergeFrom(from._internal_start());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_end()->::baikaldb::pb::ExprValue::MergeFrom(from._internal_end());
    }
    if (cached_has_bits & 0x00000004u) {
      distinct_cnt_ = from.distinct_cnt_;
    }
    if (cached_has_bits & 0x00000008u) {
      bucket_size_ = from.bucket_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BucketInfo::CopyFrom(const BucketInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.BucketInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BucketInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_start()) {
    if (!start_->IsInitialized()) return false;
  }
  if (_internal_has_end()) {
    if (!end_->IsInitialized()) return false;
  }
  return true;
}

void BucketInfo::InternalSwap(BucketInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BucketInfo, bucket_size_)
      + sizeof(BucketInfo::bucket_size_)
      - PROTOBUF_FIELD_OFFSET(BucketInfo, start_)>(
          reinterpret_cast<char*>(&start_),
          reinterpret_cast<char*>(&other->start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BucketInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_statistics_2eproto_getter, &descriptor_table_statistics_2eproto_once,
      file_level_metadata_statistics_2eproto[0]);
}

// ===================================================================

class ColumnInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ColumnInfo>()._has_bits_);
  static void set_has_col_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_field_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_distinct_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_null_value_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

ColumnInfo::ColumnInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  bucket_infos_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.ColumnInfo)
}
ColumnInfo::ColumnInfo(const ColumnInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      bucket_infos_(from.bucket_infos_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&col_type_, &from.col_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&null_value_cnt_) -
    reinterpret_cast<char*>(&col_type_)) + sizeof(null_value_cnt_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.ColumnInfo)
}

void ColumnInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&col_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&null_value_cnt_) -
    reinterpret_cast<char*>(&col_type_)) + sizeof(null_value_cnt_));
}

ColumnInfo::~ColumnInfo() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.ColumnInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ColumnInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ColumnInfo::ArenaDtor(void* object) {
  ColumnInfo* _this = reinterpret_cast< ColumnInfo* >(object);
  (void)_this;
}
void ColumnInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ColumnInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ColumnInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.ColumnInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  bucket_infos_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&col_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&null_value_cnt_) -
        reinterpret_cast<char*>(&col_type_)) + sizeof(null_value_cnt_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ColumnInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.PrimitiveType col_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::PrimitiveType_IsValid(val))) {
            _internal_set_col_type(static_cast<::baikaldb::pb::PrimitiveType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required int32 field_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_field_id(&has_bits);
          field_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 distinct_cnt = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_distinct_cnt(&has_bits);
          distinct_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 null_value_cnt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_null_value_cnt(&has_bits);
          null_value_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.BucketInfo bucket_infos = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_bucket_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ColumnInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.ColumnInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.PrimitiveType col_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_col_type(), target);
  }

  // required int32 field_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_field_id(), target);
  }

  // required int32 distinct_cnt = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_distinct_cnt(), target);
  }

  // required int32 null_value_cnt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_null_value_cnt(), target);
  }

  // repeated .baikaldb.pb.BucketInfo bucket_infos = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_bucket_infos_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_bucket_infos(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.ColumnInfo)
  return target;
}

size_t ColumnInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.ColumnInfo)
  size_t total_size = 0;

  if (_internal_has_col_type()) {
    // required .baikaldb.pb.PrimitiveType col_type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_col_type());
  }

  if (_internal_has_field_id()) {
    // required int32 field_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_field_id());
  }

  if (_internal_has_distinct_cnt()) {
    // required int32 distinct_cnt = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_distinct_cnt());
  }

  if (_internal_has_null_value_cnt()) {
    // required int32 null_value_cnt = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_null_value_cnt());
  }

  return total_size;
}
size_t ColumnInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.ColumnInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .baikaldb.pb.PrimitiveType col_type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_col_type());

    // required int32 field_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_field_id());

    // required int32 distinct_cnt = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_distinct_cnt());

    // required int32 null_value_cnt = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_null_value_cnt());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.BucketInfo bucket_infos = 5;
  total_size += 1UL * this->_internal_bucket_infos_size();
  for (const auto& msg : this->bucket_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ColumnInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ColumnInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ColumnInfo::GetClassData() const { return &_class_data_; }

void ColumnInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ColumnInfo *>(to)->MergeFrom(
      static_cast<const ColumnInfo &>(from));
}


void ColumnInfo::MergeFrom(const ColumnInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.ColumnInfo)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  bucket_infos_.MergeFrom(from.bucket_infos_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      col_type_ = from.col_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      field_id_ = from.field_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      distinct_cnt_ = from.distinct_cnt_;
    }
    if (cached_has_bits & 0x00000008u) {
      null_value_cnt_ = from.null_value_cnt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ColumnInfo::CopyFrom(const ColumnInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.ColumnInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColumnInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(bucket_infos_)) return false;
  return true;
}

void ColumnInfo::InternalSwap(ColumnInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  bucket_infos_.InternalSwap(&other->bucket_infos_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ColumnInfo, null_value_cnt_)
      + sizeof(ColumnInfo::null_value_cnt_)
      - PROTOBUF_FIELD_OFFSET(ColumnInfo, col_type_)>(
          reinterpret_cast<char*>(&col_type_),
          reinterpret_cast<char*>(&other->col_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ColumnInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_statistics_2eproto_getter, &descriptor_table_statistics_2eproto_once,
      file_level_metadata_statistics_2eproto[1]);
}

// ===================================================================

class Histogram::_Internal {
 public:
  using HasBits = decltype(std::declval<Histogram>()._has_bits_);
  static void set_has_sample_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_total_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

Histogram::Histogram(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  column_infos_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.Histogram)
}
Histogram::Histogram(const Histogram& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      column_infos_(from.column_infos_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&sample_rows_, &from.sample_rows_,
    static_cast<size_t>(reinterpret_cast<char*>(&total_rows_) -
    reinterpret_cast<char*>(&sample_rows_)) + sizeof(total_rows_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.Histogram)
}

void Histogram::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sample_rows_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&total_rows_) -
    reinterpret_cast<char*>(&sample_rows_)) + sizeof(total_rows_));
}

Histogram::~Histogram() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.Histogram)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Histogram::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Histogram::ArenaDtor(void* object) {
  Histogram* _this = reinterpret_cast< Histogram* >(object);
  (void)_this;
}
void Histogram::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Histogram::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Histogram::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.Histogram)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  column_infos_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&sample_rows_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&total_rows_) -
        reinterpret_cast<char*>(&sample_rows_)) + sizeof(total_rows_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Histogram::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 sample_rows = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_sample_rows(&has_bits);
          sample_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 total_rows = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_total_rows(&has_bits);
          total_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.ColumnInfo column_infos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_column_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Histogram::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.Histogram)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 sample_rows = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_sample_rows(), target);
  }

  // required int64 total_rows = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_total_rows(), target);
  }

  // repeated .baikaldb.pb.ColumnInfo column_infos = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_column_infos_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_column_infos(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.Histogram)
  return target;
}

size_t Histogram::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.Histogram)
  size_t total_size = 0;

  if (_internal_has_sample_rows()) {
    // required int64 sample_rows = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_sample_rows());
  }

  if (_internal_has_total_rows()) {
    // required int64 total_rows = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_total_rows());
  }

  return total_size;
}
size_t Histogram::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.Histogram)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int64 sample_rows = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_sample_rows());

    // required int64 total_rows = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_total_rows());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.ColumnInfo column_infos = 3;
  total_size += 1UL * this->_internal_column_infos_size();
  for (const auto& msg : this->column_infos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Histogram::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Histogram::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Histogram::GetClassData() const { return &_class_data_; }

void Histogram::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Histogram *>(to)->MergeFrom(
      static_cast<const Histogram &>(from));
}


void Histogram::MergeFrom(const Histogram& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.Histogram)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  column_infos_.MergeFrom(from.column_infos_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sample_rows_ = from.sample_rows_;
    }
    if (cached_has_bits & 0x00000002u) {
      total_rows_ = from.total_rows_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Histogram::CopyFrom(const Histogram& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.Histogram)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Histogram::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(column_infos_)) return false;
  return true;
}

void Histogram::InternalSwap(Histogram* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  column_infos_.InternalSwap(&other->column_infos_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Histogram, total_rows_)
      + sizeof(Histogram::total_rows_)
      - PROTOBUF_FIELD_OFFSET(Histogram, sample_rows_)>(
          reinterpret_cast<char*>(&sample_rows_),
          reinterpret_cast<char*>(&other->sample_rows_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Histogram::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_statistics_2eproto_getter, &descriptor_table_statistics_2eproto_once,
      file_level_metadata_statistics_2eproto[2]);
}

// ===================================================================

class CMsketchItem::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsketchItem>()._has_bits_);
  static void set_has_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

CMsketchItem::CMsketchItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.CMsketchItem)
}
CMsketchItem::CMsketchItem(const CMsketchItem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&depth_, &from.depth_,
    static_cast<size_t>(reinterpret_cast<char*>(&value_) -
    reinterpret_cast<char*>(&depth_)) + sizeof(value_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.CMsketchItem)
}

void CMsketchItem::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&depth_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&value_) -
    reinterpret_cast<char*>(&depth_)) + sizeof(value_));
}

CMsketchItem::~CMsketchItem() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.CMsketchItem)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsketchItem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsketchItem::ArenaDtor(void* object) {
  CMsketchItem* _this = reinterpret_cast< CMsketchItem* >(object);
  (void)_this;
}
void CMsketchItem::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsketchItem::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsketchItem::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.CMsketchItem)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&depth_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&value_) -
        reinterpret_cast<char*>(&depth_)) + sizeof(value_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsketchItem::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 depth = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_depth(&has_bits);
          depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_value(&has_bits);
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsketchItem::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.CMsketchItem)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 depth = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_depth(), target);
  }

  // required int32 width = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_width(), target);
  }

  // required int32 value = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.CMsketchItem)
  return target;
}

size_t CMsketchItem::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.CMsketchItem)
  size_t total_size = 0;

  if (_internal_has_depth()) {
    // required int32 depth = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_depth());
  }

  if (_internal_has_width()) {
    // required int32 width = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_width());
  }

  if (_internal_has_value()) {
    // required int32 value = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_value());
  }

  return total_size;
}
size_t CMsketchItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.CMsketchItem)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required int32 depth = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_depth());

    // required int32 width = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_width());

    // required int32 value = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_value());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsketchItem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsketchItem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsketchItem::GetClassData() const { return &_class_data_; }

void CMsketchItem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsketchItem *>(to)->MergeFrom(
      static_cast<const CMsketchItem &>(from));
}


void CMsketchItem::MergeFrom(const CMsketchItem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.CMsketchItem)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      depth_ = from.depth_;
    }
    if (cached_has_bits & 0x00000002u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000004u) {
      value_ = from.value_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsketchItem::CopyFrom(const CMsketchItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.CMsketchItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsketchItem::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CMsketchItem::InternalSwap(CMsketchItem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsketchItem, value_)
      + sizeof(CMsketchItem::value_)
      - PROTOBUF_FIELD_OFFSET(CMsketchItem, depth_)>(
          reinterpret_cast<char*>(&depth_),
          reinterpret_cast<char*>(&other->depth_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsketchItem::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_statistics_2eproto_getter, &descriptor_table_statistics_2eproto_once,
      file_level_metadata_statistics_2eproto[3]);
}

// ===================================================================

class CMsketchColumn::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsketchColumn>()._has_bits_);
  static void set_has_field_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CMsketchColumn::CMsketchColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  cmitems_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.CMsketchColumn)
}
CMsketchColumn::CMsketchColumn(const CMsketchColumn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      cmitems_(from.cmitems_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  field_id_ = from.field_id_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.CMsketchColumn)
}

void CMsketchColumn::SharedCtor() {
field_id_ = 0;
}

CMsketchColumn::~CMsketchColumn() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.CMsketchColumn)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsketchColumn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsketchColumn::ArenaDtor(void* object) {
  CMsketchColumn* _this = reinterpret_cast< CMsketchColumn* >(object);
  (void)_this;
}
void CMsketchColumn::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsketchColumn::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsketchColumn::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.CMsketchColumn)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cmitems_.Clear();
  field_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsketchColumn::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 field_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_field_id(&has_bits);
          field_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.CMsketchItem cmitems = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cmitems(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsketchColumn::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.CMsketchColumn)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 field_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_field_id(), target);
  }

  // repeated .baikaldb.pb.CMsketchItem cmitems = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cmitems_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_cmitems(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.CMsketchColumn)
  return target;
}

size_t CMsketchColumn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.CMsketchColumn)
  size_t total_size = 0;

  // required int32 field_id = 1;
  if (_internal_has_field_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_field_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.CMsketchItem cmitems = 2;
  total_size += 1UL * this->_internal_cmitems_size();
  for (const auto& msg : this->cmitems_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsketchColumn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsketchColumn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsketchColumn::GetClassData() const { return &_class_data_; }

void CMsketchColumn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsketchColumn *>(to)->MergeFrom(
      static_cast<const CMsketchColumn &>(from));
}


void CMsketchColumn::MergeFrom(const CMsketchColumn& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.CMsketchColumn)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cmitems_.MergeFrom(from.cmitems_);
  if (from._internal_has_field_id()) {
    _internal_set_field_id(from._internal_field_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsketchColumn::CopyFrom(const CMsketchColumn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.CMsketchColumn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsketchColumn::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(cmitems_)) return false;
  return true;
}

void CMsketchColumn::InternalSwap(CMsketchColumn* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  cmitems_.InternalSwap(&other->cmitems_);
  swap(field_id_, other->field_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsketchColumn::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_statistics_2eproto_getter, &descriptor_table_statistics_2eproto_once,
      file_level_metadata_statistics_2eproto[4]);
}

// ===================================================================

class CMsketch::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsketch>()._has_bits_);
  static void set_has_depth(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CMsketch::CMsketch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  cmcolumns_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.CMsketch)
}
CMsketch::CMsketch(const CMsketch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      cmcolumns_(from.cmcolumns_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&depth_, &from.depth_,
    static_cast<size_t>(reinterpret_cast<char*>(&width_) -
    reinterpret_cast<char*>(&depth_)) + sizeof(width_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.CMsketch)
}

void CMsketch::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&depth_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&width_) -
    reinterpret_cast<char*>(&depth_)) + sizeof(width_));
}

CMsketch::~CMsketch() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.CMsketch)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsketch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsketch::ArenaDtor(void* object) {
  CMsketch* _this = reinterpret_cast< CMsketch* >(object);
  (void)_this;
}
void CMsketch::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsketch::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsketch::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.CMsketch)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cmcolumns_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&depth_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&width_) -
        reinterpret_cast<char*>(&depth_)) + sizeof(width_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsketch::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 depth = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_depth(&has_bits);
          depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.CMsketchColumn cmcolumns = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cmcolumns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CMsketch::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.CMsketch)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 depth = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_depth(), target);
  }

  // required int32 width = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_width(), target);
  }

  // repeated .baikaldb.pb.CMsketchColumn cmcolumns = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cmcolumns_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_cmcolumns(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.CMsketch)
  return target;
}

size_t CMsketch::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.CMsketch)
  size_t total_size = 0;

  if (_internal_has_depth()) {
    // required int32 depth = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_depth());
  }

  if (_internal_has_width()) {
    // required int32 width = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_width());
  }

  return total_size;
}
size_t CMsketch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.CMsketch)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 depth = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_depth());

    // required int32 width = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_width());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.CMsketchColumn cmcolumns = 3;
  total_size += 1UL * this->_internal_cmcolumns_size();
  for (const auto& msg : this->cmcolumns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsketch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsketch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsketch::GetClassData() const { return &_class_data_; }

void CMsketch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsketch *>(to)->MergeFrom(
      static_cast<const CMsketch &>(from));
}


void CMsketch::MergeFrom(const CMsketch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.CMsketch)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cmcolumns_.MergeFrom(from.cmcolumns_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      depth_ = from.depth_;
    }
    if (cached_has_bits & 0x00000002u) {
      width_ = from.width_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsketch::CopyFrom(const CMsketch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.CMsketch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsketch::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(cmcolumns_)) return false;
  return true;
}

void CMsketch::InternalSwap(CMsketch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  cmcolumns_.InternalSwap(&other->cmcolumns_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsketch, width_)
      + sizeof(CMsketch::width_)
      - PROTOBUF_FIELD_OFFSET(CMsketch, depth_)>(
          reinterpret_cast<char*>(&depth_),
          reinterpret_cast<char*>(&other->depth_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsketch::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_statistics_2eproto_getter, &descriptor_table_statistics_2eproto_once,
      file_level_metadata_statistics_2eproto[5]);
}

// ===================================================================

class HyperLogLogColumn::_Internal {
 public:
  using HasBits = decltype(std::declval<HyperLogLogColumn>()._has_bits_);
  static void set_has_field_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_hll(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_estimate_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

HyperLogLogColumn::HyperLogLogColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.HyperLogLogColumn)
}
HyperLogLogColumn::HyperLogLogColumn(const HyperLogLogColumn& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  hll_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_hll()) {
    hll_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_hll(), 
      GetArenaForAllocation());
  }
  ::memcpy(&estimate_count_, &from.estimate_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&field_id_) -
    reinterpret_cast<char*>(&estimate_count_)) + sizeof(field_id_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.HyperLogLogColumn)
}

void HyperLogLogColumn::SharedCtor() {
hll_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&estimate_count_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&field_id_) -
    reinterpret_cast<char*>(&estimate_count_)) + sizeof(field_id_));
}

HyperLogLogColumn::~HyperLogLogColumn() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.HyperLogLogColumn)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void HyperLogLogColumn::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  hll_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void HyperLogLogColumn::ArenaDtor(void* object) {
  HyperLogLogColumn* _this = reinterpret_cast< HyperLogLogColumn* >(object);
  (void)_this;
}
void HyperLogLogColumn::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void HyperLogLogColumn::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void HyperLogLogColumn::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.HyperLogLogColumn)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    hll_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&estimate_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&field_id_) -
        reinterpret_cast<char*>(&estimate_count_)) + sizeof(field_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HyperLogLogColumn::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 field_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_field_id(&has_bits);
          field_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes hll = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_hll();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 estimate_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_estimate_count(&has_bits);
          estimate_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* HyperLogLogColumn::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.HyperLogLogColumn)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 field_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_field_id(), target);
  }

  // optional bytes hll = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_hll(), target);
  }

  // optional uint64 estimate_count = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_estimate_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.HyperLogLogColumn)
  return target;
}

size_t HyperLogLogColumn::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.HyperLogLogColumn)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes hll = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hll());
    }

    // optional uint64 estimate_count = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_estimate_count());
    }

    // optional int32 field_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_field_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HyperLogLogColumn::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    HyperLogLogColumn::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HyperLogLogColumn::GetClassData() const { return &_class_data_; }

void HyperLogLogColumn::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<HyperLogLogColumn *>(to)->MergeFrom(
      static_cast<const HyperLogLogColumn &>(from));
}


void HyperLogLogColumn::MergeFrom(const HyperLogLogColumn& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.HyperLogLogColumn)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_hll(from._internal_hll());
    }
    if (cached_has_bits & 0x00000002u) {
      estimate_count_ = from.estimate_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      field_id_ = from.field_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HyperLogLogColumn::CopyFrom(const HyperLogLogColumn& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.HyperLogLogColumn)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HyperLogLogColumn::IsInitialized() const {
  return true;
}

void HyperLogLogColumn::InternalSwap(HyperLogLogColumn* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &hll_, lhs_arena,
      &other->hll_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HyperLogLogColumn, field_id_)
      + sizeof(HyperLogLogColumn::field_id_)
      - PROTOBUF_FIELD_OFFSET(HyperLogLogColumn, estimate_count_)>(
          reinterpret_cast<char*>(&estimate_count_),
          reinterpret_cast<char*>(&other->estimate_count_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HyperLogLogColumn::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_statistics_2eproto_getter, &descriptor_table_statistics_2eproto_once,
      file_level_metadata_statistics_2eproto[6]);
}

// ===================================================================

class HyperLogLog::_Internal {
 public:
};

HyperLogLog::HyperLogLog(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  hllcolumns_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.HyperLogLog)
}
HyperLogLog::HyperLogLog(const HyperLogLog& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      hllcolumns_(from.hllcolumns_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.HyperLogLog)
}

void HyperLogLog::SharedCtor() {
}

HyperLogLog::~HyperLogLog() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.HyperLogLog)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void HyperLogLog::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void HyperLogLog::ArenaDtor(void* object) {
  HyperLogLog* _this = reinterpret_cast< HyperLogLog* >(object);
  (void)_this;
}
void HyperLogLog::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void HyperLogLog::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void HyperLogLog::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.HyperLogLog)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  hllcolumns_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HyperLogLog::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .baikaldb.pb.HyperLogLogColumn hllcolumns = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_hllcolumns(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* HyperLogLog::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.HyperLogLog)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .baikaldb.pb.HyperLogLogColumn hllcolumns = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_hllcolumns_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_hllcolumns(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.HyperLogLog)
  return target;
}

size_t HyperLogLog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.HyperLogLog)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.HyperLogLogColumn hllcolumns = 1;
  total_size += 1UL * this->_internal_hllcolumns_size();
  for (const auto& msg : this->hllcolumns_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HyperLogLog::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    HyperLogLog::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HyperLogLog::GetClassData() const { return &_class_data_; }

void HyperLogLog::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<HyperLogLog *>(to)->MergeFrom(
      static_cast<const HyperLogLog &>(from));
}


void HyperLogLog::MergeFrom(const HyperLogLog& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.HyperLogLog)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  hllcolumns_.MergeFrom(from.hllcolumns_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HyperLogLog::CopyFrom(const HyperLogLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.HyperLogLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HyperLogLog::IsInitialized() const {
  return true;
}

void HyperLogLog::InternalSwap(HyperLogLog* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  hllcolumns_.InternalSwap(&other->hllcolumns_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HyperLogLog::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_statistics_2eproto_getter, &descriptor_table_statistics_2eproto_once,
      file_level_metadata_statistics_2eproto[7]);
}

// ===================================================================

class Statistics::_Internal {
 public:
  using HasBits = decltype(std::declval<Statistics>()._has_bits_);
  static void set_has_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::baikaldb::pb::Histogram& histogram(const Statistics* msg);
  static void set_has_histogram(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::baikaldb::pb::CMsketch& cmsketch(const Statistics* msg);
  static void set_has_cmsketch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::baikaldb::pb::HyperLogLog& hll(const Statistics* msg);
  static void set_has_hll(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_total_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

const ::baikaldb::pb::Histogram&
Statistics::_Internal::histogram(const Statistics* msg) {
  return *msg->histogram_;
}
const ::baikaldb::pb::CMsketch&
Statistics::_Internal::cmsketch(const Statistics* msg) {
  return *msg->cmsketch_;
}
const ::baikaldb::pb::HyperLogLog&
Statistics::_Internal::hll(const Statistics* msg) {
  return *msg->hll_;
}
Statistics::Statistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.Statistics)
}
Statistics::Statistics(const Statistics& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_histogram()) {
    histogram_ = new ::baikaldb::pb::Histogram(*from.histogram_);
  } else {
    histogram_ = nullptr;
  }
  if (from._internal_has_cmsketch()) {
    cmsketch_ = new ::baikaldb::pb::CMsketch(*from.cmsketch_);
  } else {
    cmsketch_ = nullptr;
  }
  if (from._internal_has_hll()) {
    hll_ = new ::baikaldb::pb::HyperLogLog(*from.hll_);
  } else {
    hll_ = nullptr;
  }
  ::memcpy(&table_id_, &from.table_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&total_rows_) -
    reinterpret_cast<char*>(&table_id_)) + sizeof(total_rows_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.Statistics)
}

void Statistics::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&histogram_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&total_rows_) -
    reinterpret_cast<char*>(&histogram_)) + sizeof(total_rows_));
}

Statistics::~Statistics() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.Statistics)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Statistics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete histogram_;
  if (this != internal_default_instance()) delete cmsketch_;
  if (this != internal_default_instance()) delete hll_;
}

void Statistics::ArenaDtor(void* object) {
  Statistics* _this = reinterpret_cast< Statistics* >(object);
  (void)_this;
}
void Statistics::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Statistics::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Statistics::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.Statistics)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(histogram_ != nullptr);
      histogram_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(cmsketch_ != nullptr);
      cmsketch_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(hll_ != nullptr);
      hll_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&table_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&total_rows_) -
        reinterpret_cast<char*>(&table_id_)) + sizeof(total_rows_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Statistics::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 table_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_table_id(&has_bits);
          table_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.Histogram histogram = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_histogram(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.CMsketch cmsketch = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_cmsketch(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.HyperLogLog hll = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_hll(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 total_rows = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_total_rows(&has_bits);
          total_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Statistics::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.Statistics)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 table_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_table_id(), target);
  }

  // optional int64 version = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_version(), target);
  }

  // optional .baikaldb.pb.Histogram histogram = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::histogram(this), target, stream);
  }

  // optional .baikaldb.pb.CMsketch cmsketch = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::cmsketch(this), target, stream);
  }

  // optional .baikaldb.pb.HyperLogLog hll = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::hll(this), target, stream);
  }

  // optional int64 total_rows = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_total_rows(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.Statistics)
  return target;
}

size_t Statistics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.Statistics)
  size_t total_size = 0;

  // required int64 table_id = 1;
  if (_internal_has_table_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_table_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .baikaldb.pb.Histogram histogram = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *histogram_);
    }

    // optional .baikaldb.pb.CMsketch cmsketch = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cmsketch_);
    }

    // optional .baikaldb.pb.HyperLogLog hll = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *hll_);
    }

  }
  if (cached_has_bits & 0x00000030u) {
    // optional int64 version = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_version());
    }

    // optional int64 total_rows = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_total_rows());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Statistics::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Statistics::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Statistics::GetClassData() const { return &_class_data_; }

void Statistics::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Statistics *>(to)->MergeFrom(
      static_cast<const Statistics &>(from));
}


void Statistics::MergeFrom(const Statistics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.Statistics)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_histogram()->::baikaldb::pb::Histogram::MergeFrom(from._internal_histogram());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_cmsketch()->::baikaldb::pb::CMsketch::MergeFrom(from._internal_cmsketch());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_hll()->::baikaldb::pb::HyperLogLog::MergeFrom(from._internal_hll());
    }
    if (cached_has_bits & 0x00000008u) {
      table_id_ = from.table_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000020u) {
      total_rows_ = from.total_rows_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Statistics::CopyFrom(const Statistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.Statistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Statistics::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_histogram()) {
    if (!histogram_->IsInitialized()) return false;
  }
  if (_internal_has_cmsketch()) {
    if (!cmsketch_->IsInitialized()) return false;
  }
  return true;
}

void Statistics::InternalSwap(Statistics* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Statistics, total_rows_)
      + sizeof(Statistics::total_rows_)
      - PROTOBUF_FIELD_OFFSET(Statistics, histogram_)>(
          reinterpret_cast<char*>(&histogram_),
          reinterpret_cast<char*>(&other->histogram_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Statistics::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_statistics_2eproto_getter, &descriptor_table_statistics_2eproto_once,
      file_level_metadata_statistics_2eproto[8]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace pb
}  // namespace baikaldb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::baikaldb::pb::BucketInfo* Arena::CreateMaybeMessage< ::baikaldb::pb::BucketInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::BucketInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::ColumnInfo* Arena::CreateMaybeMessage< ::baikaldb::pb::ColumnInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::ColumnInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::Histogram* Arena::CreateMaybeMessage< ::baikaldb::pb::Histogram >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::Histogram >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::CMsketchItem* Arena::CreateMaybeMessage< ::baikaldb::pb::CMsketchItem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::CMsketchItem >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::CMsketchColumn* Arena::CreateMaybeMessage< ::baikaldb::pb::CMsketchColumn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::CMsketchColumn >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::CMsketch* Arena::CreateMaybeMessage< ::baikaldb::pb::CMsketch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::CMsketch >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::HyperLogLogColumn* Arena::CreateMaybeMessage< ::baikaldb::pb::HyperLogLogColumn >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::HyperLogLogColumn >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::HyperLogLog* Arena::CreateMaybeMessage< ::baikaldb::pb::HyperLogLog >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::HyperLogLog >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::Statistics* Arena::CreateMaybeMessage< ::baikaldb::pb::Statistics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::Statistics >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
