// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2eproto;
namespace baikaldb {
namespace pb {
class CompactionFileInfo;
struct CompactionFileInfoDefaultTypeInternal;
extern CompactionFileInfoDefaultTypeInternal _CompactionFileInfo_default_instance_;
class ExprValue;
struct ExprValueDefaultTypeInternal;
extern ExprValueDefaultTypeInternal _ExprValue_default_instance_;
class FieldSlot;
struct FieldSlotDefaultTypeInternal;
extern FieldSlotDefaultTypeInternal _FieldSlot_default_instance_;
class MysqlInfo;
struct MysqlInfoDefaultTypeInternal;
extern MysqlInfoDefaultTypeInternal _MysqlInfo_default_instance_;
class QueryContext;
struct QueryContextDefaultTypeInternal;
extern QueryContextDefaultTypeInternal _QueryContext_default_instance_;
class RefSlotMapping;
struct RefSlotMappingDefaultTypeInternal;
extern RefSlotMappingDefaultTypeInternal _RefSlotMapping_default_instance_;
class RuntimeState;
struct RuntimeStateDefaultTypeInternal;
extern RuntimeStateDefaultTypeInternal _RuntimeState_default_instance_;
class SchemaConf;
struct SchemaConfDefaultTypeInternal;
extern SchemaConfDefaultTypeInternal _SchemaConf_default_instance_;
class SlotColumn;
struct SlotColumnDefaultTypeInternal;
extern SlotColumnDefaultTypeInternal _SlotColumn_default_instance_;
class SlotDescriptor;
struct SlotDescriptorDefaultTypeInternal;
extern SlotDescriptorDefaultTypeInternal _SlotDescriptor_default_instance_;
class TupleDescriptor;
struct TupleDescriptorDefaultTypeInternal;
extern TupleDescriptorDefaultTypeInternal _TupleDescriptor_default_instance_;
}  // namespace pb
}  // namespace baikaldb
PROTOBUF_NAMESPACE_OPEN
template<> ::baikaldb::pb::CompactionFileInfo* Arena::CreateMaybeMessage<::baikaldb::pb::CompactionFileInfo>(Arena*);
template<> ::baikaldb::pb::ExprValue* Arena::CreateMaybeMessage<::baikaldb::pb::ExprValue>(Arena*);
template<> ::baikaldb::pb::FieldSlot* Arena::CreateMaybeMessage<::baikaldb::pb::FieldSlot>(Arena*);
template<> ::baikaldb::pb::MysqlInfo* Arena::CreateMaybeMessage<::baikaldb::pb::MysqlInfo>(Arena*);
template<> ::baikaldb::pb::QueryContext* Arena::CreateMaybeMessage<::baikaldb::pb::QueryContext>(Arena*);
template<> ::baikaldb::pb::RefSlotMapping* Arena::CreateMaybeMessage<::baikaldb::pb::RefSlotMapping>(Arena*);
template<> ::baikaldb::pb::RuntimeState* Arena::CreateMaybeMessage<::baikaldb::pb::RuntimeState>(Arena*);
template<> ::baikaldb::pb::SchemaConf* Arena::CreateMaybeMessage<::baikaldb::pb::SchemaConf>(Arena*);
template<> ::baikaldb::pb::SlotColumn* Arena::CreateMaybeMessage<::baikaldb::pb::SlotColumn>(Arena*);
template<> ::baikaldb::pb::SlotDescriptor* Arena::CreateMaybeMessage<::baikaldb::pb::SlotDescriptor>(Arena*);
template<> ::baikaldb::pb::TupleDescriptor* Arena::CreateMaybeMessage<::baikaldb::pb::TupleDescriptor>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace baikaldb {
namespace pb {

enum ErrCode : int {
  SUCCESS = 0,
  NOT_LEADER = 1,
  PARSE_FROM_PB_FAIL = 2,
  PARSE_TO_PB_FAIL = 3,
  UNSUPPORT_REQ_TYPE = 4,
  INPUT_PARAM_ERROR = 5,
  GET_VALUE_FAIL = 6,
  PUT_VALUE_FAIL = 7,
  DELETE_VALUE_FAIL = 8,
  INTERNAL_ERROR = 9,
  VERSION_OLD = 10,
  REGION_ERROR_STATUS = 11,
  EXEC_FAIL = 12,
  DISABLE_WRITE_TIMEOUT = 13,
  SPLIT_TIMEOUT = 14,
  REGION_ALREADY_EXIST = 15,
  REGION_NOT_EXIST = 16,
  HAVE_NOT_INIT = 17,
  CANNOT_ADD_PEER = 19,
  PEER_NOT_EQUAL = 20,
  CONNECT_FAIL = 21,
  CANCELLED = 22,
  DDL_UNIQUE_KEY_FAIL = 23,
  TXN_IS_EXISTING = 24,
  TXN_IS_ROLLBACK = 25,
  BACKUP_SAME_LOG_INDEX = 26,
  BACKUP_ERROR = 27,
  RETRY_LATER = 28,
  LESS_THAN_OLDEST_TS = 29,
  IN_PROCESS = 30,
  STORE_BUSY = 31,
  LEARNER_NOT_READY = 32,
  STORE_ROCKS_HANG = 33,
  COMPACTION_FILE_SYSTEM_ERROR = 34,
  REMOTE_COMPACTION_ERROR = 35,
  COMPACTION_FILE_NOT_EXIST = 36
};
bool ErrCode_IsValid(int value);
constexpr ErrCode ErrCode_MIN = SUCCESS;
constexpr ErrCode ErrCode_MAX = COMPACTION_FILE_NOT_EXIST;
constexpr int ErrCode_ARRAYSIZE = ErrCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrCode_descriptor();
template<typename T>
inline const std::string& ErrCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrCode_descriptor(), enum_t_value);
}
inline bool ErrCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrCode>(
    ErrCode_descriptor(), name, value);
}
enum PrimitiveType : int {
  INVALID_TYPE = 0,
  NULL_TYPE = 1,
  BOOL = 2,
  INT8 = 3,
  INT16 = 4,
  INT32 = 5,
  INT64 = 6,
  UINT8 = 7,
  UINT16 = 8,
  UINT32 = 9,
  UINT64 = 10,
  FLOAT = 11,
  DOUBLE = 12,
  STRING = 13,
  DATETIME = 14,
  TIMESTAMP = 15,
  DATE = 16,
  HLL = 17,
  TIME = 18,
  PLACE_HOLDER = 19,
  HEX = 20,
  BITMAP = 21,
  TDIGEST = 22,
  JSON = 23,
  MAXVALUE_TYPE = 24
};
bool PrimitiveType_IsValid(int value);
constexpr PrimitiveType PrimitiveType_MIN = INVALID_TYPE;
constexpr PrimitiveType PrimitiveType_MAX = MAXVALUE_TYPE;
constexpr int PrimitiveType_ARRAYSIZE = PrimitiveType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrimitiveType_descriptor();
template<typename T>
inline const std::string& PrimitiveType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrimitiveType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrimitiveType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrimitiveType_descriptor(), enum_t_value);
}
inline bool PrimitiveType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrimitiveType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrimitiveType>(
    PrimitiveType_descriptor(), name, value);
}
enum SchemaType : int {
  DYNAMIC = 1,
  STATIC = 2
};
bool SchemaType_IsValid(int value);
constexpr SchemaType SchemaType_MIN = DYNAMIC;
constexpr SchemaType SchemaType_MAX = STATIC;
constexpr int SchemaType_ARRAYSIZE = SchemaType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SchemaType_descriptor();
template<typename T>
inline const std::string& SchemaType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SchemaType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SchemaType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SchemaType_descriptor(), enum_t_value);
}
inline bool SchemaType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SchemaType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SchemaType>(
    SchemaType_descriptor(), name, value);
}
enum Charset : int {
  UTF8 = 0,
  GBK = 1,
  CS_UNKNOWN = 2
};
bool Charset_IsValid(int value);
constexpr Charset Charset_MIN = UTF8;
constexpr Charset Charset_MAX = CS_UNKNOWN;
constexpr int Charset_ARRAYSIZE = Charset_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Charset_descriptor();
template<typename T>
inline const std::string& Charset_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Charset>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Charset_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Charset_descriptor(), enum_t_value);
}
inline bool Charset_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Charset* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Charset>(
    Charset_descriptor(), name, value);
}
enum BackupTable : int {
  BT_NONE = 0,
  BT_AUTO = 1,
  BT_READ = 2,
  BT_WRITE = 3,
  BT_LEARNER = 4
};
bool BackupTable_IsValid(int value);
constexpr BackupTable BackupTable_MIN = BT_NONE;
constexpr BackupTable BackupTable_MAX = BT_LEARNER;
constexpr int BackupTable_ARRAYSIZE = BackupTable_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BackupTable_descriptor();
template<typename T>
inline const std::string& BackupTable_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BackupTable>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BackupTable_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BackupTable_descriptor(), enum_t_value);
}
inline bool BackupTable_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BackupTable* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BackupTable>(
    BackupTable_descriptor(), name, value);
}
enum StreamState : int {
  SS_INIT = 0,
  SS_PROCESSING = 1,
  SS_SUCCESS = 2,
  SS_FAIL = 3
};
bool StreamState_IsValid(int value);
constexpr StreamState StreamState_MIN = SS_INIT;
constexpr StreamState StreamState_MAX = SS_FAIL;
constexpr int StreamState_ARRAYSIZE = StreamState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StreamState_descriptor();
template<typename T>
inline const std::string& StreamState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StreamState_descriptor(), enum_t_value);
}
inline bool StreamState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StreamState>(
    StreamState_descriptor(), name, value);
}
enum Engine : int {
  ROCKSDB = 1,
  REDIS = 2,
  ROCKSDB_CSTORE = 3,
  BINLOG = 4,
  INFORMATION_SCHEMA = 5,
  DBLINK = 6
};
bool Engine_IsValid(int value);
constexpr Engine Engine_MIN = ROCKSDB;
constexpr Engine Engine_MAX = DBLINK;
constexpr int Engine_ARRAYSIZE = Engine_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Engine_descriptor();
template<typename T>
inline const std::string& Engine_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Engine>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Engine_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Engine_descriptor(), enum_t_value);
}
inline bool Engine_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Engine* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Engine>(
    Engine_descriptor(), name, value);
}
// ===================================================================

class SchemaConf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.SchemaConf) */ {
 public:
  inline SchemaConf() : SchemaConf(nullptr) {}
  ~SchemaConf() override;
  explicit constexpr SchemaConf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchemaConf(const SchemaConf& from);
  SchemaConf(SchemaConf&& from) noexcept
    : SchemaConf() {
    *this = ::std::move(from);
  }

  inline SchemaConf& operator=(const SchemaConf& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaConf& operator=(SchemaConf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaConf& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaConf* internal_default_instance() {
    return reinterpret_cast<const SchemaConf*>(
               &_SchemaConf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SchemaConf& a, SchemaConf& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaConf* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaConf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchemaConf* New() const final {
    return new SchemaConf();
  }

  SchemaConf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchemaConf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchemaConf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SchemaConf& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaConf* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.SchemaConf";
  }
  protected:
  explicit SchemaConf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpDescFieldNumber = 5,
    kSignBlacklistFieldNumber = 10,
    kSignForcelearnerFieldNumber = 11,
    kSignForceindexFieldNumber = 12,
    kSignRollingFieldNumber = 17,
    kSignExecTypeFieldNumber = 18,
    kSnapshotBlacklistFieldNumber = 19,
    kDelSnapshotBlacklistFieldNumber = 20,
    kOpVersionFieldNumber = 4,
    kNeedMergeFieldNumber = 1,
    kStorageComputeSeparateFieldNumber = 2,
    kSelectIndexByCostFieldNumber = 3,
    kInFastImportFieldNumber = 9,
    kFilterRatioFieldNumber = 6,
    kBackupTableFieldNumber = 7,
    kPkPrefixBalanceFieldNumber = 8,
    kTailSplitNumFieldNumber = 13,
    kTailSplitStepFieldNumber = 14,
    kAutoIncRandMaxFieldNumber = 15,
    kBinlogBackupDaysFieldNumber = 16,
    kOlapPreSplitCntFieldNumber = 23,
    kUseColumnStorageFieldNumber = 21,
    kEnableColumnEngineFieldNumber = 22,
    kColdUseColumnOnlyFieldNumber = 24,
    kForceColumnStorageFieldNumber = 25,
  };
  // optional string op_desc = 5;
  bool has_op_desc() const;
  private:
  bool _internal_has_op_desc() const;
  public:
  void clear_op_desc();
  const std::string& op_desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_op_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_op_desc();
  PROTOBUF_MUST_USE_RESULT std::string* release_op_desc();
  void set_allocated_op_desc(std::string* op_desc);
  private:
  const std::string& _internal_op_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op_desc(const std::string& value);
  std::string* _internal_mutable_op_desc();
  public:

  // optional string sign_blacklist = 10;
  bool has_sign_blacklist() const;
  private:
  bool _internal_has_sign_blacklist() const;
  public:
  void clear_sign_blacklist();
  const std::string& sign_blacklist() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sign_blacklist(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sign_blacklist();
  PROTOBUF_MUST_USE_RESULT std::string* release_sign_blacklist();
  void set_allocated_sign_blacklist(std::string* sign_blacklist);
  private:
  const std::string& _internal_sign_blacklist() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign_blacklist(const std::string& value);
  std::string* _internal_mutable_sign_blacklist();
  public:

  // optional string sign_forcelearner = 11;
  bool has_sign_forcelearner() const;
  private:
  bool _internal_has_sign_forcelearner() const;
  public:
  void clear_sign_forcelearner();
  const std::string& sign_forcelearner() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sign_forcelearner(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sign_forcelearner();
  PROTOBUF_MUST_USE_RESULT std::string* release_sign_forcelearner();
  void set_allocated_sign_forcelearner(std::string* sign_forcelearner);
  private:
  const std::string& _internal_sign_forcelearner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign_forcelearner(const std::string& value);
  std::string* _internal_mutable_sign_forcelearner();
  public:

  // optional string sign_forceindex = 12;
  bool has_sign_forceindex() const;
  private:
  bool _internal_has_sign_forceindex() const;
  public:
  void clear_sign_forceindex();
  const std::string& sign_forceindex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sign_forceindex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sign_forceindex();
  PROTOBUF_MUST_USE_RESULT std::string* release_sign_forceindex();
  void set_allocated_sign_forceindex(std::string* sign_forceindex);
  private:
  const std::string& _internal_sign_forceindex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign_forceindex(const std::string& value);
  std::string* _internal_mutable_sign_forceindex();
  public:

  // optional string sign_rolling = 17;
  bool has_sign_rolling() const;
  private:
  bool _internal_has_sign_rolling() const;
  public:
  void clear_sign_rolling();
  const std::string& sign_rolling() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sign_rolling(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sign_rolling();
  PROTOBUF_MUST_USE_RESULT std::string* release_sign_rolling();
  void set_allocated_sign_rolling(std::string* sign_rolling);
  private:
  const std::string& _internal_sign_rolling() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign_rolling(const std::string& value);
  std::string* _internal_mutable_sign_rolling();
  public:

  // optional string sign_exec_type = 18;
  bool has_sign_exec_type() const;
  private:
  bool _internal_has_sign_exec_type() const;
  public:
  void clear_sign_exec_type();
  const std::string& sign_exec_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sign_exec_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sign_exec_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_sign_exec_type();
  void set_allocated_sign_exec_type(std::string* sign_exec_type);
  private:
  const std::string& _internal_sign_exec_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign_exec_type(const std::string& value);
  std::string* _internal_mutable_sign_exec_type();
  public:

  // optional string snapshot_blacklist = 19;
  bool has_snapshot_blacklist() const;
  private:
  bool _internal_has_snapshot_blacklist() const;
  public:
  void clear_snapshot_blacklist();
  const std::string& snapshot_blacklist() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_snapshot_blacklist(ArgT0&& arg0, ArgT... args);
  std::string* mutable_snapshot_blacklist();
  PROTOBUF_MUST_USE_RESULT std::string* release_snapshot_blacklist();
  void set_allocated_snapshot_blacklist(std::string* snapshot_blacklist);
  private:
  const std::string& _internal_snapshot_blacklist() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_snapshot_blacklist(const std::string& value);
  std::string* _internal_mutable_snapshot_blacklist();
  public:

  // optional string del_snapshot_blacklist = 20;
  bool has_del_snapshot_blacklist() const;
  private:
  bool _internal_has_del_snapshot_blacklist() const;
  public:
  void clear_del_snapshot_blacklist();
  const std::string& del_snapshot_blacklist() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_del_snapshot_blacklist(ArgT0&& arg0, ArgT... args);
  std::string* mutable_del_snapshot_blacklist();
  PROTOBUF_MUST_USE_RESULT std::string* release_del_snapshot_blacklist();
  void set_allocated_del_snapshot_blacklist(std::string* del_snapshot_blacklist);
  private:
  const std::string& _internal_del_snapshot_blacklist() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_del_snapshot_blacklist(const std::string& value);
  std::string* _internal_mutable_del_snapshot_blacklist();
  public:

  // optional int64 op_version = 4;
  bool has_op_version() const;
  private:
  bool _internal_has_op_version() const;
  public:
  void clear_op_version();
  ::PROTOBUF_NAMESPACE_ID::int64 op_version() const;
  void set_op_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_op_version() const;
  void _internal_set_op_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool need_merge = 1;
  bool has_need_merge() const;
  private:
  bool _internal_has_need_merge() const;
  public:
  void clear_need_merge();
  bool need_merge() const;
  void set_need_merge(bool value);
  private:
  bool _internal_need_merge() const;
  void _internal_set_need_merge(bool value);
  public:

  // optional bool storage_compute_separate = 2;
  bool has_storage_compute_separate() const;
  private:
  bool _internal_has_storage_compute_separate() const;
  public:
  void clear_storage_compute_separate();
  bool storage_compute_separate() const;
  void set_storage_compute_separate(bool value);
  private:
  bool _internal_storage_compute_separate() const;
  void _internal_set_storage_compute_separate(bool value);
  public:

  // optional bool select_index_by_cost = 3;
  bool has_select_index_by_cost() const;
  private:
  bool _internal_has_select_index_by_cost() const;
  public:
  void clear_select_index_by_cost();
  bool select_index_by_cost() const;
  void set_select_index_by_cost(bool value);
  private:
  bool _internal_select_index_by_cost() const;
  void _internal_set_select_index_by_cost(bool value);
  public:

  // optional bool in_fast_import = 9;
  bool has_in_fast_import() const;
  private:
  bool _internal_has_in_fast_import() const;
  public:
  void clear_in_fast_import();
  bool in_fast_import() const;
  void set_in_fast_import(bool value);
  private:
  bool _internal_in_fast_import() const;
  void _internal_set_in_fast_import(bool value);
  public:

  // optional float filter_ratio = 6;
  bool has_filter_ratio() const;
  private:
  bool _internal_has_filter_ratio() const;
  public:
  void clear_filter_ratio();
  float filter_ratio() const;
  void set_filter_ratio(float value);
  private:
  float _internal_filter_ratio() const;
  void _internal_set_filter_ratio(float value);
  public:

  // optional .baikaldb.pb.BackupTable backup_table = 7;
  bool has_backup_table() const;
  private:
  bool _internal_has_backup_table() const;
  public:
  void clear_backup_table();
  ::baikaldb::pb::BackupTable backup_table() const;
  void set_backup_table(::baikaldb::pb::BackupTable value);
  private:
  ::baikaldb::pb::BackupTable _internal_backup_table() const;
  void _internal_set_backup_table(::baikaldb::pb::BackupTable value);
  public:

  // optional int32 pk_prefix_balance = 8;
  bool has_pk_prefix_balance() const;
  private:
  bool _internal_has_pk_prefix_balance() const;
  public:
  void clear_pk_prefix_balance();
  ::PROTOBUF_NAMESPACE_ID::int32 pk_prefix_balance() const;
  void set_pk_prefix_balance(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pk_prefix_balance() const;
  void _internal_set_pk_prefix_balance(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 tail_split_num = 13;
  bool has_tail_split_num() const;
  private:
  bool _internal_has_tail_split_num() const;
  public:
  void clear_tail_split_num();
  ::PROTOBUF_NAMESPACE_ID::int32 tail_split_num() const;
  void set_tail_split_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tail_split_num() const;
  void _internal_set_tail_split_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 tail_split_step = 14;
  bool has_tail_split_step() const;
  private:
  bool _internal_has_tail_split_step() const;
  public:
  void clear_tail_split_step();
  ::PROTOBUF_NAMESPACE_ID::int32 tail_split_step() const;
  void set_tail_split_step(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tail_split_step() const;
  void _internal_set_tail_split_step(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int64 auto_inc_rand_max = 15;
  bool has_auto_inc_rand_max() const;
  private:
  bool _internal_has_auto_inc_rand_max() const;
  public:
  void clear_auto_inc_rand_max();
  ::PROTOBUF_NAMESPACE_ID::int64 auto_inc_rand_max() const;
  void set_auto_inc_rand_max(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_auto_inc_rand_max() const;
  void _internal_set_auto_inc_rand_max(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 binlog_backup_days = 16;
  bool has_binlog_backup_days() const;
  private:
  bool _internal_has_binlog_backup_days() const;
  public:
  void clear_binlog_backup_days();
  ::PROTOBUF_NAMESPACE_ID::int32 binlog_backup_days() const;
  void set_binlog_backup_days(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_binlog_backup_days() const;
  void _internal_set_binlog_backup_days(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 olap_pre_split_cnt = 23;
  bool has_olap_pre_split_cnt() const;
  private:
  bool _internal_has_olap_pre_split_cnt() const;
  public:
  void clear_olap_pre_split_cnt();
  ::PROTOBUF_NAMESPACE_ID::int32 olap_pre_split_cnt() const;
  void set_olap_pre_split_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_olap_pre_split_cnt() const;
  void _internal_set_olap_pre_split_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool use_column_storage = 21;
  bool has_use_column_storage() const;
  private:
  bool _internal_has_use_column_storage() const;
  public:
  void clear_use_column_storage();
  bool use_column_storage() const;
  void set_use_column_storage(bool value);
  private:
  bool _internal_use_column_storage() const;
  void _internal_set_use_column_storage(bool value);
  public:

  // optional bool enable_column_engine = 22;
  bool has_enable_column_engine() const;
  private:
  bool _internal_has_enable_column_engine() const;
  public:
  void clear_enable_column_engine();
  bool enable_column_engine() const;
  void set_enable_column_engine(bool value);
  private:
  bool _internal_enable_column_engine() const;
  void _internal_set_enable_column_engine(bool value);
  public:

  // optional bool cold_use_column_only = 24;
  bool has_cold_use_column_only() const;
  private:
  bool _internal_has_cold_use_column_only() const;
  public:
  void clear_cold_use_column_only();
  bool cold_use_column_only() const;
  void set_cold_use_column_only(bool value);
  private:
  bool _internal_cold_use_column_only() const;
  void _internal_set_cold_use_column_only(bool value);
  public:

  // optional bool force_column_storage = 25;
  bool has_force_column_storage() const;
  private:
  bool _internal_has_force_column_storage() const;
  public:
  void clear_force_column_storage();
  bool force_column_storage() const;
  void set_force_column_storage(bool value);
  private:
  bool _internal_force_column_storage() const;
  void _internal_set_force_column_storage(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.SchemaConf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr op_desc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_blacklist_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_forcelearner_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_forceindex_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_rolling_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_exec_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr snapshot_blacklist_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr del_snapshot_blacklist_;
  ::PROTOBUF_NAMESPACE_ID::int64 op_version_;
  bool need_merge_;
  bool storage_compute_separate_;
  bool select_index_by_cost_;
  bool in_fast_import_;
  float filter_ratio_;
  int backup_table_;
  ::PROTOBUF_NAMESPACE_ID::int32 pk_prefix_balance_;
  ::PROTOBUF_NAMESPACE_ID::int32 tail_split_num_;
  ::PROTOBUF_NAMESPACE_ID::int32 tail_split_step_;
  ::PROTOBUF_NAMESPACE_ID::int64 auto_inc_rand_max_;
  ::PROTOBUF_NAMESPACE_ID::int32 binlog_backup_days_;
  ::PROTOBUF_NAMESPACE_ID::int32 olap_pre_split_cnt_;
  bool use_column_storage_;
  bool enable_column_engine_;
  bool cold_use_column_only_;
  bool force_column_storage_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class SlotDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.SlotDescriptor) */ {
 public:
  inline SlotDescriptor() : SlotDescriptor(nullptr) {}
  ~SlotDescriptor() override;
  explicit constexpr SlotDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SlotDescriptor(const SlotDescriptor& from);
  SlotDescriptor(SlotDescriptor&& from) noexcept
    : SlotDescriptor() {
    *this = ::std::move(from);
  }

  inline SlotDescriptor& operator=(const SlotDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline SlotDescriptor& operator=(SlotDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SlotDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const SlotDescriptor* internal_default_instance() {
    return reinterpret_cast<const SlotDescriptor*>(
               &_SlotDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SlotDescriptor& a, SlotDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(SlotDescriptor* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SlotDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SlotDescriptor* New() const final {
    return new SlotDescriptor();
  }

  SlotDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SlotDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SlotDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SlotDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SlotDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.SlotDescriptor";
  }
  protected:
  explicit SlotDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotIdFieldNumber = 1,
    kSlotTypeFieldNumber = 2,
    kTableIdFieldNumber = 4,
    kTupleIdFieldNumber = 3,
    kFieldIdFieldNumber = 5,
    kRefCntFieldNumber = 6,
  };
  // required int32 slot_id = 1;
  bool has_slot_id() const;
  private:
  bool _internal_has_slot_id() const;
  public:
  void clear_slot_id();
  ::PROTOBUF_NAMESPACE_ID::int32 slot_id() const;
  void set_slot_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_slot_id() const;
  void _internal_set_slot_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required .baikaldb.pb.PrimitiveType slot_type = 2;
  bool has_slot_type() const;
  private:
  bool _internal_has_slot_type() const;
  public:
  void clear_slot_type();
  ::baikaldb::pb::PrimitiveType slot_type() const;
  void set_slot_type(::baikaldb::pb::PrimitiveType value);
  private:
  ::baikaldb::pb::PrimitiveType _internal_slot_type() const;
  void _internal_set_slot_type(::baikaldb::pb::PrimitiveType value);
  public:

  // optional int64 table_id = 4;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int32 tuple_id = 3;
  bool has_tuple_id() const;
  private:
  bool _internal_has_tuple_id() const;
  public:
  void clear_tuple_id();
  ::PROTOBUF_NAMESPACE_ID::int32 tuple_id() const;
  void set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tuple_id() const;
  void _internal_set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 field_id = 5;
  bool has_field_id() const;
  private:
  bool _internal_has_field_id() const;
  public:
  void clear_field_id();
  ::PROTOBUF_NAMESPACE_ID::int32 field_id() const;
  void set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_field_id() const;
  void _internal_set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 ref_cnt = 6;
  bool has_ref_cnt() const;
  private:
  bool _internal_has_ref_cnt() const;
  public:
  void clear_ref_cnt();
  ::PROTOBUF_NAMESPACE_ID::int32 ref_cnt() const;
  void set_ref_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ref_cnt() const;
  void _internal_set_ref_cnt(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.SlotDescriptor)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 slot_id_;
  int slot_type_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 tuple_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 field_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 ref_cnt_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class TupleDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TupleDescriptor) */ {
 public:
  inline TupleDescriptor() : TupleDescriptor(nullptr) {}
  ~TupleDescriptor() override;
  explicit constexpr TupleDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TupleDescriptor(const TupleDescriptor& from);
  TupleDescriptor(TupleDescriptor&& from) noexcept
    : TupleDescriptor() {
    *this = ::std::move(from);
  }

  inline TupleDescriptor& operator=(const TupleDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline TupleDescriptor& operator=(TupleDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TupleDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const TupleDescriptor* internal_default_instance() {
    return reinterpret_cast<const TupleDescriptor*>(
               &_TupleDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TupleDescriptor& a, TupleDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(TupleDescriptor* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TupleDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TupleDescriptor* New() const final {
    return new TupleDescriptor();
  }

  TupleDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TupleDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TupleDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TupleDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TupleDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TupleDescriptor";
  }
  protected:
  explicit TupleDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotsFieldNumber = 3,
    kSlotIdxesFieldNumber = 4,
    kTableIdFieldNumber = 2,
    kTupleIdFieldNumber = 1,
  };
  // repeated .baikaldb.pb.SlotDescriptor slots = 3;
  int slots_size() const;
  private:
  int _internal_slots_size() const;
  public:
  void clear_slots();
  ::baikaldb::pb::SlotDescriptor* mutable_slots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >*
      mutable_slots();
  private:
  const ::baikaldb::pb::SlotDescriptor& _internal_slots(int index) const;
  ::baikaldb::pb::SlotDescriptor* _internal_add_slots();
  public:
  const ::baikaldb::pb::SlotDescriptor& slots(int index) const;
  ::baikaldb::pb::SlotDescriptor* add_slots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >&
      slots() const;

  // repeated int32 slot_idxes = 4;
  int slot_idxes_size() const;
  private:
  int _internal_slot_idxes_size() const;
  public:
  void clear_slot_idxes();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_slot_idxes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_slot_idxes() const;
  void _internal_add_slot_idxes(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_slot_idxes();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 slot_idxes(int index) const;
  void set_slot_idxes(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_slot_idxes(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      slot_idxes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_slot_idxes();

  // optional int64 table_id = 2;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int32 tuple_id = 1;
  bool has_tuple_id() const;
  private:
  bool _internal_has_tuple_id() const;
  public:
  void clear_tuple_id();
  ::PROTOBUF_NAMESPACE_ID::int32 tuple_id() const;
  void set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tuple_id() const;
  void _internal_set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TupleDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor > slots_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > slot_idxes_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 tuple_id_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class ExprValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ExprValue) */ {
 public:
  inline ExprValue() : ExprValue(nullptr) {}
  ~ExprValue() override;
  explicit constexpr ExprValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExprValue(const ExprValue& from);
  ExprValue(ExprValue&& from) noexcept
    : ExprValue() {
    *this = ::std::move(from);
  }

  inline ExprValue& operator=(const ExprValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExprValue& operator=(ExprValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExprValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExprValue* internal_default_instance() {
    return reinterpret_cast<const ExprValue*>(
               &_ExprValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ExprValue& a, ExprValue& b) {
    a.Swap(&b);
  }
  inline void Swap(ExprValue* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExprValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExprValue* New() const final {
    return new ExprValue();
  }

  ExprValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExprValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExprValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExprValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExprValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ExprValue";
  }
  protected:
  explicit ExprValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringValFieldNumber = 9,
    kTypeFieldNumber = 1,
    kBoolValFieldNumber = 2,
    kInt32ValFieldNumber = 3,
    kUint32ValFieldNumber = 4,
    kInt64ValFieldNumber = 5,
    kUint64ValFieldNumber = 6,
    kDoubleValFieldNumber = 8,
    kFloatValFieldNumber = 7,
  };
  // optional bytes string_val = 9;
  bool has_string_val() const;
  private:
  bool _internal_has_string_val() const;
  public:
  void clear_string_val();
  const std::string& string_val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_val();
  PROTOBUF_MUST_USE_RESULT std::string* release_string_val();
  void set_allocated_string_val(std::string* string_val);
  private:
  const std::string& _internal_string_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_val(const std::string& value);
  std::string* _internal_mutable_string_val();
  public:

  // required .baikaldb.pb.PrimitiveType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::baikaldb::pb::PrimitiveType type() const;
  void set_type(::baikaldb::pb::PrimitiveType value);
  private:
  ::baikaldb::pb::PrimitiveType _internal_type() const;
  void _internal_set_type(::baikaldb::pb::PrimitiveType value);
  public:

  // optional bool bool_val = 2;
  bool has_bool_val() const;
  private:
  bool _internal_has_bool_val() const;
  public:
  void clear_bool_val();
  bool bool_val() const;
  void set_bool_val(bool value);
  private:
  bool _internal_bool_val() const;
  void _internal_set_bool_val(bool value);
  public:

  // optional int32 int32_val = 3;
  bool has_int32_val() const;
  private:
  bool _internal_has_int32_val() const;
  public:
  void clear_int32_val();
  ::PROTOBUF_NAMESPACE_ID::int32 int32_val() const;
  void set_int32_val(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_int32_val() const;
  void _internal_set_int32_val(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional uint32 uint32_val = 4;
  bool has_uint32_val() const;
  private:
  bool _internal_has_uint32_val() const;
  public:
  void clear_uint32_val();
  ::PROTOBUF_NAMESPACE_ID::uint32 uint32_val() const;
  void set_uint32_val(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_uint32_val() const;
  void _internal_set_uint32_val(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional int64 int64_val = 5;
  bool has_int64_val() const;
  private:
  bool _internal_has_int64_val() const;
  public:
  void clear_int64_val();
  ::PROTOBUF_NAMESPACE_ID::int64 int64_val() const;
  void set_int64_val(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_int64_val() const;
  void _internal_set_int64_val(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint64 uint64_val = 6;
  bool has_uint64_val() const;
  private:
  bool _internal_has_uint64_val() const;
  public:
  void clear_uint64_val();
  ::PROTOBUF_NAMESPACE_ID::uint64 uint64_val() const;
  void set_uint64_val(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_uint64_val() const;
  void _internal_set_uint64_val(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional double double_val = 8;
  bool has_double_val() const;
  private:
  bool _internal_has_double_val() const;
  public:
  void clear_double_val();
  double double_val() const;
  void set_double_val(double value);
  private:
  double _internal_double_val() const;
  void _internal_set_double_val(double value);
  public:

  // optional float float_val = 7;
  bool has_float_val() const;
  private:
  bool _internal_has_float_val() const;
  public:
  void clear_float_val();
  float float_val() const;
  void set_float_val(float value);
  private:
  float _internal_float_val() const;
  void _internal_set_float_val(float value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ExprValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_val_;
  int type_;
  bool bool_val_;
  ::PROTOBUF_NAMESPACE_ID::int32 int32_val_;
  ::PROTOBUF_NAMESPACE_ID::uint32 uint32_val_;
  ::PROTOBUF_NAMESPACE_ID::int64 int64_val_;
  ::PROTOBUF_NAMESPACE_ID::uint64 uint64_val_;
  double double_val_;
  float float_val_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class FieldSlot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.FieldSlot) */ {
 public:
  inline FieldSlot() : FieldSlot(nullptr) {}
  ~FieldSlot() override;
  explicit constexpr FieldSlot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldSlot(const FieldSlot& from);
  FieldSlot(FieldSlot&& from) noexcept
    : FieldSlot() {
    *this = ::std::move(from);
  }

  inline FieldSlot& operator=(const FieldSlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldSlot& operator=(FieldSlot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldSlot& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldSlot* internal_default_instance() {
    return reinterpret_cast<const FieldSlot*>(
               &_FieldSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FieldSlot& a, FieldSlot& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldSlot* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldSlot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FieldSlot* New() const final {
    return new FieldSlot();
  }

  FieldSlot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FieldSlot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldSlot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FieldSlot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldSlot* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.FieldSlot";
  }
  protected:
  explicit FieldSlot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldNameFieldNumber = 1,
    kSlotIdFieldNumber = 2,
  };
  // required string field_name = 1;
  bool has_field_name() const;
  private:
  bool _internal_has_field_name() const;
  public:
  void clear_field_name();
  const std::string& field_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_field_name();
  void set_allocated_field_name(std::string* field_name);
  private:
  const std::string& _internal_field_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field_name(const std::string& value);
  std::string* _internal_mutable_field_name();
  public:

  // required int32 slot_id = 2;
  bool has_slot_id() const;
  private:
  bool _internal_has_slot_id() const;
  public:
  void clear_slot_id();
  ::PROTOBUF_NAMESPACE_ID::int32 slot_id() const;
  void set_slot_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_slot_id() const;
  void _internal_set_slot_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.FieldSlot)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 slot_id_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class SlotColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.SlotColumn) */ {
 public:
  inline SlotColumn() : SlotColumn(nullptr) {}
  ~SlotColumn() override;
  explicit constexpr SlotColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SlotColumn(const SlotColumn& from);
  SlotColumn(SlotColumn&& from) noexcept
    : SlotColumn() {
    *this = ::std::move(from);
  }

  inline SlotColumn& operator=(const SlotColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline SlotColumn& operator=(SlotColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SlotColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const SlotColumn* internal_default_instance() {
    return reinterpret_cast<const SlotColumn*>(
               &_SlotColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SlotColumn& a, SlotColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(SlotColumn* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SlotColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SlotColumn* New() const final {
    return new SlotColumn();
  }

  SlotColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SlotColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SlotColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SlotColumn& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SlotColumn* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.SlotColumn";
  }
  protected:
  explicit SlotColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSlotIdFieldNumber = 1,
    kColumnIdFieldNumber = 2,
  };
  // required int32 slot_id = 1;
  bool has_slot_id() const;
  private:
  bool _internal_has_slot_id() const;
  public:
  void clear_slot_id();
  ::PROTOBUF_NAMESPACE_ID::int32 slot_id() const;
  void set_slot_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_slot_id() const;
  void _internal_set_slot_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 column_id = 2;
  bool has_column_id() const;
  private:
  bool _internal_has_column_id() const;
  public:
  void clear_column_id();
  ::PROTOBUF_NAMESPACE_ID::int32 column_id() const;
  void set_column_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_column_id() const;
  void _internal_set_column_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.SlotColumn)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 slot_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 column_id_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class RefSlotMapping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RefSlotMapping) */ {
 public:
  inline RefSlotMapping() : RefSlotMapping(nullptr) {}
  ~RefSlotMapping() override;
  explicit constexpr RefSlotMapping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RefSlotMapping(const RefSlotMapping& from);
  RefSlotMapping(RefSlotMapping&& from) noexcept
    : RefSlotMapping() {
    *this = ::std::move(from);
  }

  inline RefSlotMapping& operator=(const RefSlotMapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefSlotMapping& operator=(RefSlotMapping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefSlotMapping& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefSlotMapping* internal_default_instance() {
    return reinterpret_cast<const RefSlotMapping*>(
               &_RefSlotMapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RefSlotMapping& a, RefSlotMapping& b) {
    a.Swap(&b);
  }
  inline void Swap(RefSlotMapping* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefSlotMapping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RefSlotMapping* New() const final {
    return new RefSlotMapping();
  }

  RefSlotMapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RefSlotMapping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RefSlotMapping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RefSlotMapping& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RefSlotMapping* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RefSlotMapping";
  }
  protected:
  explicit RefSlotMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldSlotFieldNumber = 2,
    kTupleIdFieldNumber = 1,
  };
  // repeated .baikaldb.pb.FieldSlot field_slot = 2;
  int field_slot_size() const;
  private:
  int _internal_field_slot_size() const;
  public:
  void clear_field_slot();
  ::baikaldb::pb::FieldSlot* mutable_field_slot(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FieldSlot >*
      mutable_field_slot();
  private:
  const ::baikaldb::pb::FieldSlot& _internal_field_slot(int index) const;
  ::baikaldb::pb::FieldSlot* _internal_add_field_slot();
  public:
  const ::baikaldb::pb::FieldSlot& field_slot(int index) const;
  ::baikaldb::pb::FieldSlot* add_field_slot();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FieldSlot >&
      field_slot() const;

  // required int64 tuple_id = 1;
  bool has_tuple_id() const;
  private:
  bool _internal_has_tuple_id() const;
  public:
  void clear_tuple_id();
  ::PROTOBUF_NAMESPACE_ID::int64 tuple_id() const;
  void set_tuple_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tuple_id() const;
  void _internal_set_tuple_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RefSlotMapping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FieldSlot > field_slot_;
  ::PROTOBUF_NAMESPACE_ID::int64 tuple_id_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class QueryContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.QueryContext) */ {
 public:
  inline QueryContext() : QueryContext(nullptr) {}
  ~QueryContext() override;
  explicit constexpr QueryContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryContext(const QueryContext& from);
  QueryContext(QueryContext&& from) noexcept
    : QueryContext() {
    *this = ::std::move(from);
  }

  inline QueryContext& operator=(const QueryContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryContext& operator=(QueryContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryContext* internal_default_instance() {
    return reinterpret_cast<const QueryContext*>(
               &_QueryContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(QueryContext& a, QueryContext& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryContext* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryContext* New() const final {
    return new QueryContext();
  }

  QueryContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryContext& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryContext* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.QueryContext";
  }
  protected:
  explicit QueryContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefSlotIdMappingFieldNumber = 1,
  };
  // repeated .baikaldb.pb.RefSlotMapping ref_slot_id_mapping = 1;
  int ref_slot_id_mapping_size() const;
  private:
  int _internal_ref_slot_id_mapping_size() const;
  public:
  void clear_ref_slot_id_mapping();
  ::baikaldb::pb::RefSlotMapping* mutable_ref_slot_id_mapping(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RefSlotMapping >*
      mutable_ref_slot_id_mapping();
  private:
  const ::baikaldb::pb::RefSlotMapping& _internal_ref_slot_id_mapping(int index) const;
  ::baikaldb::pb::RefSlotMapping* _internal_add_ref_slot_id_mapping();
  public:
  const ::baikaldb::pb::RefSlotMapping& ref_slot_id_mapping(int index) const;
  ::baikaldb::pb::RefSlotMapping* add_ref_slot_id_mapping();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RefSlotMapping >&
      ref_slot_id_mapping() const;

  // @@protoc_insertion_point(class_scope:baikaldb.pb.QueryContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RefSlotMapping > ref_slot_id_mapping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class RuntimeState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RuntimeState) */ {
 public:
  inline RuntimeState() : RuntimeState(nullptr) {}
  ~RuntimeState() override;
  explicit constexpr RuntimeState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RuntimeState(const RuntimeState& from);
  RuntimeState(RuntimeState&& from) noexcept
    : RuntimeState() {
    *this = ::std::move(from);
  }

  inline RuntimeState& operator=(const RuntimeState& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuntimeState& operator=(RuntimeState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuntimeState& default_instance() {
    return *internal_default_instance();
  }
  static inline const RuntimeState* internal_default_instance() {
    return reinterpret_cast<const RuntimeState*>(
               &_RuntimeState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RuntimeState& a, RuntimeState& b) {
    a.Swap(&b);
  }
  inline void Swap(RuntimeState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuntimeState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RuntimeState* New() const final {
    return new RuntimeState();
  }

  RuntimeState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RuntimeState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RuntimeState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RuntimeState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuntimeState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RuntimeState";
  }
  protected:
  explicit RuntimeState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTuplesFieldNumber = 1,
    kQueryContextFieldNumber = 2,
    kLogIdFieldNumber = 3,
    kSignFieldNumber = 4,
    kSignExecTypeFieldNumber = 5,
  };
  // repeated .baikaldb.pb.TupleDescriptor tuples = 1;
  int tuples_size() const;
  private:
  int _internal_tuples_size() const;
  public:
  void clear_tuples();
  ::baikaldb::pb::TupleDescriptor* mutable_tuples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TupleDescriptor >*
      mutable_tuples();
  private:
  const ::baikaldb::pb::TupleDescriptor& _internal_tuples(int index) const;
  ::baikaldb::pb::TupleDescriptor* _internal_add_tuples();
  public:
  const ::baikaldb::pb::TupleDescriptor& tuples(int index) const;
  ::baikaldb::pb::TupleDescriptor* add_tuples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TupleDescriptor >&
      tuples() const;

  // optional .baikaldb.pb.QueryContext query_context = 2;
  bool has_query_context() const;
  private:
  bool _internal_has_query_context() const;
  public:
  void clear_query_context();
  const ::baikaldb::pb::QueryContext& query_context() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::QueryContext* release_query_context();
  ::baikaldb::pb::QueryContext* mutable_query_context();
  void set_allocated_query_context(::baikaldb::pb::QueryContext* query_context);
  private:
  const ::baikaldb::pb::QueryContext& _internal_query_context() const;
  ::baikaldb::pb::QueryContext* _internal_mutable_query_context();
  public:
  void unsafe_arena_set_allocated_query_context(
      ::baikaldb::pb::QueryContext* query_context);
  ::baikaldb::pb::QueryContext* unsafe_arena_release_query_context();

  // optional uint64 log_id = 3;
  bool has_log_id() const;
  private:
  bool _internal_has_log_id() const;
  public:
  void clear_log_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 log_id() const;
  void set_log_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_log_id() const;
  void _internal_set_log_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 sign = 4;
  bool has_sign() const;
  private:
  bool _internal_has_sign() const;
  public:
  void clear_sign();
  ::PROTOBUF_NAMESPACE_ID::uint64 sign() const;
  void set_sign(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sign() const;
  void _internal_set_sign(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 sign_exec_type = 5;
  bool has_sign_exec_type() const;
  private:
  bool _internal_has_sign_exec_type() const;
  public:
  void clear_sign_exec_type();
  ::PROTOBUF_NAMESPACE_ID::uint64 sign_exec_type() const;
  void set_sign_exec_type(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sign_exec_type() const;
  void _internal_set_sign_exec_type(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RuntimeState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TupleDescriptor > tuples_;
  ::baikaldb::pb::QueryContext* query_context_;
  ::PROTOBUF_NAMESPACE_ID::uint64 log_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sign_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sign_exec_type_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class CompactionFileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.CompactionFileInfo) */ {
 public:
  inline CompactionFileInfo() : CompactionFileInfo(nullptr) {}
  ~CompactionFileInfo() override;
  explicit constexpr CompactionFileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompactionFileInfo(const CompactionFileInfo& from);
  CompactionFileInfo(CompactionFileInfo&& from) noexcept
    : CompactionFileInfo() {
    *this = ::std::move(from);
  }

  inline CompactionFileInfo& operator=(const CompactionFileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompactionFileInfo& operator=(CompactionFileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompactionFileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompactionFileInfo* internal_default_instance() {
    return reinterpret_cast<const CompactionFileInfo*>(
               &_CompactionFileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CompactionFileInfo& a, CompactionFileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CompactionFileInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompactionFileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CompactionFileInfo* New() const final {
    return new CompactionFileInfo();
  }

  CompactionFileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CompactionFileInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompactionFileInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CompactionFileInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompactionFileInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.CompactionFileInfo";
  }
  protected:
  explicit CompactionFileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilePathFieldNumber = 1,
    kFileSizeFieldNumber = 2,
    kFileMtimeFieldNumber = 3,
  };
  // required string file_path = 1;
  bool has_file_path() const;
  private:
  bool _internal_has_file_path() const;
  public:
  void clear_file_path();
  const std::string& file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_file_path();
  void set_allocated_file_path(std::string* file_path);
  private:
  const std::string& _internal_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(const std::string& value);
  std::string* _internal_mutable_file_path();
  public:

  // optional uint64 file_size = 2;
  bool has_file_size() const;
  private:
  bool _internal_has_file_size() const;
  public:
  void clear_file_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 file_size() const;
  void set_file_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_file_size() const;
  void _internal_set_file_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 file_mtime = 3;
  bool has_file_mtime() const;
  private:
  bool _internal_has_file_mtime() const;
  public:
  void clear_file_mtime();
  ::PROTOBUF_NAMESPACE_ID::uint64 file_mtime() const;
  void set_file_mtime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_file_mtime() const;
  void _internal_set_file_mtime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.CompactionFileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
  ::PROTOBUF_NAMESPACE_ID::uint64 file_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 file_mtime_;
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class MysqlInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.MysqlInfo) */ {
 public:
  inline MysqlInfo() : MysqlInfo(nullptr) {}
  ~MysqlInfo() override;
  explicit constexpr MysqlInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MysqlInfo(const MysqlInfo& from);
  MysqlInfo(MysqlInfo&& from) noexcept
    : MysqlInfo() {
    *this = ::std::move(from);
  }

  inline MysqlInfo& operator=(const MysqlInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MysqlInfo& operator=(MysqlInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MysqlInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MysqlInfo* internal_default_instance() {
    return reinterpret_cast<const MysqlInfo*>(
               &_MysqlInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MysqlInfo& a, MysqlInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MysqlInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MysqlInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MysqlInfo* New() const final {
    return new MysqlInfo();
  }

  MysqlInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MysqlInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MysqlInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MysqlInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MysqlInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.MysqlInfo";
  }
  protected:
  explicit MysqlInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kDatabaseNameFieldNumber = 4,
    kTableNameFieldNumber = 5,
    kCharsetFieldNumber = 6,
  };
  // optional bytes addr = 1;
  bool has_addr() const;
  private:
  bool _internal_has_addr() const;
  public:
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_MUST_USE_RESULT std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // optional bytes username = 2;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional bytes password = 3;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional bytes database_name = 4;
  bool has_database_name() const;
  private:
  bool _internal_has_database_name() const;
  public:
  void clear_database_name();
  const std::string& database_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_database_name();
  void set_allocated_database_name(std::string* database_name);
  private:
  const std::string& _internal_database_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database_name(const std::string& value);
  std::string* _internal_mutable_database_name();
  public:

  // optional bytes table_name = 5;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional bytes charset = 6;
  bool has_charset() const;
  private:
  bool _internal_has_charset() const;
  public:
  void clear_charset();
  const std::string& charset() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_charset(ArgT0&& arg0, ArgT... args);
  std::string* mutable_charset();
  PROTOBUF_MUST_USE_RESULT std::string* release_charset();
  void set_allocated_charset(std::string* charset);
  private:
  const std::string& _internal_charset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_charset(const std::string& value);
  std::string* _internal_mutable_charset();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.MysqlInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr charset_;
  friend struct ::TableStruct_common_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SchemaConf

// optional bool need_merge = 1;
inline bool SchemaConf::_internal_has_need_merge() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool SchemaConf::has_need_merge() const {
  return _internal_has_need_merge();
}
inline void SchemaConf::clear_need_merge() {
  need_merge_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool SchemaConf::_internal_need_merge() const {
  return need_merge_;
}
inline bool SchemaConf::need_merge() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.need_merge)
  return _internal_need_merge();
}
inline void SchemaConf::_internal_set_need_merge(bool value) {
  _has_bits_[0] |= 0x00000200u;
  need_merge_ = value;
}
inline void SchemaConf::set_need_merge(bool value) {
  _internal_set_need_merge(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.need_merge)
}

// optional bool storage_compute_separate = 2;
inline bool SchemaConf::_internal_has_storage_compute_separate() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool SchemaConf::has_storage_compute_separate() const {
  return _internal_has_storage_compute_separate();
}
inline void SchemaConf::clear_storage_compute_separate() {
  storage_compute_separate_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool SchemaConf::_internal_storage_compute_separate() const {
  return storage_compute_separate_;
}
inline bool SchemaConf::storage_compute_separate() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.storage_compute_separate)
  return _internal_storage_compute_separate();
}
inline void SchemaConf::_internal_set_storage_compute_separate(bool value) {
  _has_bits_[0] |= 0x00000400u;
  storage_compute_separate_ = value;
}
inline void SchemaConf::set_storage_compute_separate(bool value) {
  _internal_set_storage_compute_separate(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.storage_compute_separate)
}

// optional bool select_index_by_cost = 3;
inline bool SchemaConf::_internal_has_select_index_by_cost() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool SchemaConf::has_select_index_by_cost() const {
  return _internal_has_select_index_by_cost();
}
inline void SchemaConf::clear_select_index_by_cost() {
  select_index_by_cost_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool SchemaConf::_internal_select_index_by_cost() const {
  return select_index_by_cost_;
}
inline bool SchemaConf::select_index_by_cost() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.select_index_by_cost)
  return _internal_select_index_by_cost();
}
inline void SchemaConf::_internal_set_select_index_by_cost(bool value) {
  _has_bits_[0] |= 0x00000800u;
  select_index_by_cost_ = value;
}
inline void SchemaConf::set_select_index_by_cost(bool value) {
  _internal_set_select_index_by_cost(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.select_index_by_cost)
}

// optional int64 op_version = 4;
inline bool SchemaConf::_internal_has_op_version() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SchemaConf::has_op_version() const {
  return _internal_has_op_version();
}
inline void SchemaConf::clear_op_version() {
  op_version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaConf::_internal_op_version() const {
  return op_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaConf::op_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.op_version)
  return _internal_op_version();
}
inline void SchemaConf::_internal_set_op_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  op_version_ = value;
}
inline void SchemaConf::set_op_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_op_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.op_version)
}

// optional string op_desc = 5;
inline bool SchemaConf::_internal_has_op_desc() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchemaConf::has_op_desc() const {
  return _internal_has_op_desc();
}
inline void SchemaConf::clear_op_desc() {
  op_desc_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchemaConf::op_desc() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.op_desc)
  return _internal_op_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaConf::set_op_desc(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 op_desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.op_desc)
}
inline std::string* SchemaConf::mutable_op_desc() {
  std::string* _s = _internal_mutable_op_desc();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaConf.op_desc)
  return _s;
}
inline const std::string& SchemaConf::_internal_op_desc() const {
  return op_desc_.Get();
}
inline void SchemaConf::_internal_set_op_desc(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  op_desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaConf::_internal_mutable_op_desc() {
  _has_bits_[0] |= 0x00000001u;
  return op_desc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaConf::release_op_desc() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaConf.op_desc)
  if (!_internal_has_op_desc()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return op_desc_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaConf::set_allocated_op_desc(std::string* op_desc) {
  if (op_desc != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  op_desc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), op_desc,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaConf.op_desc)
}

// optional float filter_ratio = 6;
inline bool SchemaConf::_internal_has_filter_ratio() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool SchemaConf::has_filter_ratio() const {
  return _internal_has_filter_ratio();
}
inline void SchemaConf::clear_filter_ratio() {
  filter_ratio_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline float SchemaConf::_internal_filter_ratio() const {
  return filter_ratio_;
}
inline float SchemaConf::filter_ratio() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.filter_ratio)
  return _internal_filter_ratio();
}
inline void SchemaConf::_internal_set_filter_ratio(float value) {
  _has_bits_[0] |= 0x00002000u;
  filter_ratio_ = value;
}
inline void SchemaConf::set_filter_ratio(float value) {
  _internal_set_filter_ratio(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.filter_ratio)
}

// optional .baikaldb.pb.BackupTable backup_table = 7;
inline bool SchemaConf::_internal_has_backup_table() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool SchemaConf::has_backup_table() const {
  return _internal_has_backup_table();
}
inline void SchemaConf::clear_backup_table() {
  backup_table_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::baikaldb::pb::BackupTable SchemaConf::_internal_backup_table() const {
  return static_cast< ::baikaldb::pb::BackupTable >(backup_table_);
}
inline ::baikaldb::pb::BackupTable SchemaConf::backup_table() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.backup_table)
  return _internal_backup_table();
}
inline void SchemaConf::_internal_set_backup_table(::baikaldb::pb::BackupTable value) {
  assert(::baikaldb::pb::BackupTable_IsValid(value));
  _has_bits_[0] |= 0x00004000u;
  backup_table_ = value;
}
inline void SchemaConf::set_backup_table(::baikaldb::pb::BackupTable value) {
  _internal_set_backup_table(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.backup_table)
}

// optional int32 pk_prefix_balance = 8;
inline bool SchemaConf::_internal_has_pk_prefix_balance() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool SchemaConf::has_pk_prefix_balance() const {
  return _internal_has_pk_prefix_balance();
}
inline void SchemaConf::clear_pk_prefix_balance() {
  pk_prefix_balance_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaConf::_internal_pk_prefix_balance() const {
  return pk_prefix_balance_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaConf::pk_prefix_balance() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.pk_prefix_balance)
  return _internal_pk_prefix_balance();
}
inline void SchemaConf::_internal_set_pk_prefix_balance(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00008000u;
  pk_prefix_balance_ = value;
}
inline void SchemaConf::set_pk_prefix_balance(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pk_prefix_balance(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.pk_prefix_balance)
}

// optional bool in_fast_import = 9;
inline bool SchemaConf::_internal_has_in_fast_import() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool SchemaConf::has_in_fast_import() const {
  return _internal_has_in_fast_import();
}
inline void SchemaConf::clear_in_fast_import() {
  in_fast_import_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool SchemaConf::_internal_in_fast_import() const {
  return in_fast_import_;
}
inline bool SchemaConf::in_fast_import() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.in_fast_import)
  return _internal_in_fast_import();
}
inline void SchemaConf::_internal_set_in_fast_import(bool value) {
  _has_bits_[0] |= 0x00001000u;
  in_fast_import_ = value;
}
inline void SchemaConf::set_in_fast_import(bool value) {
  _internal_set_in_fast_import(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.in_fast_import)
}

// optional string sign_blacklist = 10;
inline bool SchemaConf::_internal_has_sign_blacklist() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchemaConf::has_sign_blacklist() const {
  return _internal_has_sign_blacklist();
}
inline void SchemaConf::clear_sign_blacklist() {
  sign_blacklist_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SchemaConf::sign_blacklist() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.sign_blacklist)
  return _internal_sign_blacklist();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaConf::set_sign_blacklist(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 sign_blacklist_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.sign_blacklist)
}
inline std::string* SchemaConf::mutable_sign_blacklist() {
  std::string* _s = _internal_mutable_sign_blacklist();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaConf.sign_blacklist)
  return _s;
}
inline const std::string& SchemaConf::_internal_sign_blacklist() const {
  return sign_blacklist_.Get();
}
inline void SchemaConf::_internal_set_sign_blacklist(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sign_blacklist_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaConf::_internal_mutable_sign_blacklist() {
  _has_bits_[0] |= 0x00000002u;
  return sign_blacklist_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaConf::release_sign_blacklist() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaConf.sign_blacklist)
  if (!_internal_has_sign_blacklist()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return sign_blacklist_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaConf::set_allocated_sign_blacklist(std::string* sign_blacklist) {
  if (sign_blacklist != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sign_blacklist_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sign_blacklist,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaConf.sign_blacklist)
}

// optional string sign_forcelearner = 11;
inline bool SchemaConf::_internal_has_sign_forcelearner() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchemaConf::has_sign_forcelearner() const {
  return _internal_has_sign_forcelearner();
}
inline void SchemaConf::clear_sign_forcelearner() {
  sign_forcelearner_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SchemaConf::sign_forcelearner() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.sign_forcelearner)
  return _internal_sign_forcelearner();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaConf::set_sign_forcelearner(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 sign_forcelearner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.sign_forcelearner)
}
inline std::string* SchemaConf::mutable_sign_forcelearner() {
  std::string* _s = _internal_mutable_sign_forcelearner();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaConf.sign_forcelearner)
  return _s;
}
inline const std::string& SchemaConf::_internal_sign_forcelearner() const {
  return sign_forcelearner_.Get();
}
inline void SchemaConf::_internal_set_sign_forcelearner(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  sign_forcelearner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaConf::_internal_mutable_sign_forcelearner() {
  _has_bits_[0] |= 0x00000004u;
  return sign_forcelearner_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaConf::release_sign_forcelearner() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaConf.sign_forcelearner)
  if (!_internal_has_sign_forcelearner()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return sign_forcelearner_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaConf::set_allocated_sign_forcelearner(std::string* sign_forcelearner) {
  if (sign_forcelearner != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  sign_forcelearner_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sign_forcelearner,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaConf.sign_forcelearner)
}

// optional string sign_forceindex = 12;
inline bool SchemaConf::_internal_has_sign_forceindex() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SchemaConf::has_sign_forceindex() const {
  return _internal_has_sign_forceindex();
}
inline void SchemaConf::clear_sign_forceindex() {
  sign_forceindex_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SchemaConf::sign_forceindex() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.sign_forceindex)
  return _internal_sign_forceindex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaConf::set_sign_forceindex(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 sign_forceindex_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.sign_forceindex)
}
inline std::string* SchemaConf::mutable_sign_forceindex() {
  std::string* _s = _internal_mutable_sign_forceindex();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaConf.sign_forceindex)
  return _s;
}
inline const std::string& SchemaConf::_internal_sign_forceindex() const {
  return sign_forceindex_.Get();
}
inline void SchemaConf::_internal_set_sign_forceindex(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  sign_forceindex_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaConf::_internal_mutable_sign_forceindex() {
  _has_bits_[0] |= 0x00000008u;
  return sign_forceindex_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaConf::release_sign_forceindex() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaConf.sign_forceindex)
  if (!_internal_has_sign_forceindex()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return sign_forceindex_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaConf::set_allocated_sign_forceindex(std::string* sign_forceindex) {
  if (sign_forceindex != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  sign_forceindex_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sign_forceindex,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaConf.sign_forceindex)
}

// optional int32 tail_split_num = 13;
inline bool SchemaConf::_internal_has_tail_split_num() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool SchemaConf::has_tail_split_num() const {
  return _internal_has_tail_split_num();
}
inline void SchemaConf::clear_tail_split_num() {
  tail_split_num_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaConf::_internal_tail_split_num() const {
  return tail_split_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaConf::tail_split_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.tail_split_num)
  return _internal_tail_split_num();
}
inline void SchemaConf::_internal_set_tail_split_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00010000u;
  tail_split_num_ = value;
}
inline void SchemaConf::set_tail_split_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tail_split_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.tail_split_num)
}

// optional int32 tail_split_step = 14;
inline bool SchemaConf::_internal_has_tail_split_step() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool SchemaConf::has_tail_split_step() const {
  return _internal_has_tail_split_step();
}
inline void SchemaConf::clear_tail_split_step() {
  tail_split_step_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaConf::_internal_tail_split_step() const {
  return tail_split_step_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaConf::tail_split_step() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.tail_split_step)
  return _internal_tail_split_step();
}
inline void SchemaConf::_internal_set_tail_split_step(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00020000u;
  tail_split_step_ = value;
}
inline void SchemaConf::set_tail_split_step(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tail_split_step(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.tail_split_step)
}

// optional int64 auto_inc_rand_max = 15;
inline bool SchemaConf::_internal_has_auto_inc_rand_max() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool SchemaConf::has_auto_inc_rand_max() const {
  return _internal_has_auto_inc_rand_max();
}
inline void SchemaConf::clear_auto_inc_rand_max() {
  auto_inc_rand_max_ = int64_t{0};
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaConf::_internal_auto_inc_rand_max() const {
  return auto_inc_rand_max_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaConf::auto_inc_rand_max() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.auto_inc_rand_max)
  return _internal_auto_inc_rand_max();
}
inline void SchemaConf::_internal_set_auto_inc_rand_max(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00040000u;
  auto_inc_rand_max_ = value;
}
inline void SchemaConf::set_auto_inc_rand_max(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_auto_inc_rand_max(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.auto_inc_rand_max)
}

// optional int32 binlog_backup_days = 16;
inline bool SchemaConf::_internal_has_binlog_backup_days() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool SchemaConf::has_binlog_backup_days() const {
  return _internal_has_binlog_backup_days();
}
inline void SchemaConf::clear_binlog_backup_days() {
  binlog_backup_days_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaConf::_internal_binlog_backup_days() const {
  return binlog_backup_days_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaConf::binlog_backup_days() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.binlog_backup_days)
  return _internal_binlog_backup_days();
}
inline void SchemaConf::_internal_set_binlog_backup_days(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00080000u;
  binlog_backup_days_ = value;
}
inline void SchemaConf::set_binlog_backup_days(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_binlog_backup_days(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.binlog_backup_days)
}

// optional string sign_rolling = 17;
inline bool SchemaConf::_internal_has_sign_rolling() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SchemaConf::has_sign_rolling() const {
  return _internal_has_sign_rolling();
}
inline void SchemaConf::clear_sign_rolling() {
  sign_rolling_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& SchemaConf::sign_rolling() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.sign_rolling)
  return _internal_sign_rolling();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaConf::set_sign_rolling(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 sign_rolling_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.sign_rolling)
}
inline std::string* SchemaConf::mutable_sign_rolling() {
  std::string* _s = _internal_mutable_sign_rolling();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaConf.sign_rolling)
  return _s;
}
inline const std::string& SchemaConf::_internal_sign_rolling() const {
  return sign_rolling_.Get();
}
inline void SchemaConf::_internal_set_sign_rolling(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  sign_rolling_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaConf::_internal_mutable_sign_rolling() {
  _has_bits_[0] |= 0x00000010u;
  return sign_rolling_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaConf::release_sign_rolling() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaConf.sign_rolling)
  if (!_internal_has_sign_rolling()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return sign_rolling_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaConf::set_allocated_sign_rolling(std::string* sign_rolling) {
  if (sign_rolling != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  sign_rolling_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sign_rolling,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaConf.sign_rolling)
}

// optional string sign_exec_type = 18;
inline bool SchemaConf::_internal_has_sign_exec_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SchemaConf::has_sign_exec_type() const {
  return _internal_has_sign_exec_type();
}
inline void SchemaConf::clear_sign_exec_type() {
  sign_exec_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& SchemaConf::sign_exec_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.sign_exec_type)
  return _internal_sign_exec_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaConf::set_sign_exec_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 sign_exec_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.sign_exec_type)
}
inline std::string* SchemaConf::mutable_sign_exec_type() {
  std::string* _s = _internal_mutable_sign_exec_type();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaConf.sign_exec_type)
  return _s;
}
inline const std::string& SchemaConf::_internal_sign_exec_type() const {
  return sign_exec_type_.Get();
}
inline void SchemaConf::_internal_set_sign_exec_type(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  sign_exec_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaConf::_internal_mutable_sign_exec_type() {
  _has_bits_[0] |= 0x00000020u;
  return sign_exec_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaConf::release_sign_exec_type() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaConf.sign_exec_type)
  if (!_internal_has_sign_exec_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return sign_exec_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaConf::set_allocated_sign_exec_type(std::string* sign_exec_type) {
  if (sign_exec_type != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  sign_exec_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sign_exec_type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaConf.sign_exec_type)
}

// optional string snapshot_blacklist = 19;
inline bool SchemaConf::_internal_has_snapshot_blacklist() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SchemaConf::has_snapshot_blacklist() const {
  return _internal_has_snapshot_blacklist();
}
inline void SchemaConf::clear_snapshot_blacklist() {
  snapshot_blacklist_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& SchemaConf::snapshot_blacklist() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.snapshot_blacklist)
  return _internal_snapshot_blacklist();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaConf::set_snapshot_blacklist(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 snapshot_blacklist_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.snapshot_blacklist)
}
inline std::string* SchemaConf::mutable_snapshot_blacklist() {
  std::string* _s = _internal_mutable_snapshot_blacklist();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaConf.snapshot_blacklist)
  return _s;
}
inline const std::string& SchemaConf::_internal_snapshot_blacklist() const {
  return snapshot_blacklist_.Get();
}
inline void SchemaConf::_internal_set_snapshot_blacklist(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  snapshot_blacklist_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaConf::_internal_mutable_snapshot_blacklist() {
  _has_bits_[0] |= 0x00000040u;
  return snapshot_blacklist_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaConf::release_snapshot_blacklist() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaConf.snapshot_blacklist)
  if (!_internal_has_snapshot_blacklist()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return snapshot_blacklist_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaConf::set_allocated_snapshot_blacklist(std::string* snapshot_blacklist) {
  if (snapshot_blacklist != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  snapshot_blacklist_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), snapshot_blacklist,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaConf.snapshot_blacklist)
}

// optional string del_snapshot_blacklist = 20;
inline bool SchemaConf::_internal_has_del_snapshot_blacklist() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SchemaConf::has_del_snapshot_blacklist() const {
  return _internal_has_del_snapshot_blacklist();
}
inline void SchemaConf::clear_del_snapshot_blacklist() {
  del_snapshot_blacklist_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& SchemaConf::del_snapshot_blacklist() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.del_snapshot_blacklist)
  return _internal_del_snapshot_blacklist();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaConf::set_del_snapshot_blacklist(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 del_snapshot_blacklist_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.del_snapshot_blacklist)
}
inline std::string* SchemaConf::mutable_del_snapshot_blacklist() {
  std::string* _s = _internal_mutable_del_snapshot_blacklist();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaConf.del_snapshot_blacklist)
  return _s;
}
inline const std::string& SchemaConf::_internal_del_snapshot_blacklist() const {
  return del_snapshot_blacklist_.Get();
}
inline void SchemaConf::_internal_set_del_snapshot_blacklist(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  del_snapshot_blacklist_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaConf::_internal_mutable_del_snapshot_blacklist() {
  _has_bits_[0] |= 0x00000080u;
  return del_snapshot_blacklist_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaConf::release_del_snapshot_blacklist() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaConf.del_snapshot_blacklist)
  if (!_internal_has_del_snapshot_blacklist()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return del_snapshot_blacklist_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaConf::set_allocated_del_snapshot_blacklist(std::string* del_snapshot_blacklist) {
  if (del_snapshot_blacklist != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  del_snapshot_blacklist_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), del_snapshot_blacklist,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaConf.del_snapshot_blacklist)
}

// optional bool use_column_storage = 21;
inline bool SchemaConf::_internal_has_use_column_storage() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool SchemaConf::has_use_column_storage() const {
  return _internal_has_use_column_storage();
}
inline void SchemaConf::clear_use_column_storage() {
  use_column_storage_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool SchemaConf::_internal_use_column_storage() const {
  return use_column_storage_;
}
inline bool SchemaConf::use_column_storage() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.use_column_storage)
  return _internal_use_column_storage();
}
inline void SchemaConf::_internal_set_use_column_storage(bool value) {
  _has_bits_[0] |= 0x00200000u;
  use_column_storage_ = value;
}
inline void SchemaConf::set_use_column_storage(bool value) {
  _internal_set_use_column_storage(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.use_column_storage)
}

// optional bool enable_column_engine = 22;
inline bool SchemaConf::_internal_has_enable_column_engine() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool SchemaConf::has_enable_column_engine() const {
  return _internal_has_enable_column_engine();
}
inline void SchemaConf::clear_enable_column_engine() {
  enable_column_engine_ = false;
  _has_bits_[0] &= ~0x00400000u;
}
inline bool SchemaConf::_internal_enable_column_engine() const {
  return enable_column_engine_;
}
inline bool SchemaConf::enable_column_engine() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.enable_column_engine)
  return _internal_enable_column_engine();
}
inline void SchemaConf::_internal_set_enable_column_engine(bool value) {
  _has_bits_[0] |= 0x00400000u;
  enable_column_engine_ = value;
}
inline void SchemaConf::set_enable_column_engine(bool value) {
  _internal_set_enable_column_engine(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.enable_column_engine)
}

// optional int32 olap_pre_split_cnt = 23;
inline bool SchemaConf::_internal_has_olap_pre_split_cnt() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool SchemaConf::has_olap_pre_split_cnt() const {
  return _internal_has_olap_pre_split_cnt();
}
inline void SchemaConf::clear_olap_pre_split_cnt() {
  olap_pre_split_cnt_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaConf::_internal_olap_pre_split_cnt() const {
  return olap_pre_split_cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaConf::olap_pre_split_cnt() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.olap_pre_split_cnt)
  return _internal_olap_pre_split_cnt();
}
inline void SchemaConf::_internal_set_olap_pre_split_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00100000u;
  olap_pre_split_cnt_ = value;
}
inline void SchemaConf::set_olap_pre_split_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_olap_pre_split_cnt(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.olap_pre_split_cnt)
}

// optional bool cold_use_column_only = 24;
inline bool SchemaConf::_internal_has_cold_use_column_only() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool SchemaConf::has_cold_use_column_only() const {
  return _internal_has_cold_use_column_only();
}
inline void SchemaConf::clear_cold_use_column_only() {
  cold_use_column_only_ = false;
  _has_bits_[0] &= ~0x00800000u;
}
inline bool SchemaConf::_internal_cold_use_column_only() const {
  return cold_use_column_only_;
}
inline bool SchemaConf::cold_use_column_only() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.cold_use_column_only)
  return _internal_cold_use_column_only();
}
inline void SchemaConf::_internal_set_cold_use_column_only(bool value) {
  _has_bits_[0] |= 0x00800000u;
  cold_use_column_only_ = value;
}
inline void SchemaConf::set_cold_use_column_only(bool value) {
  _internal_set_cold_use_column_only(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.cold_use_column_only)
}

// optional bool force_column_storage = 25;
inline bool SchemaConf::_internal_has_force_column_storage() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool SchemaConf::has_force_column_storage() const {
  return _internal_has_force_column_storage();
}
inline void SchemaConf::clear_force_column_storage() {
  force_column_storage_ = false;
  _has_bits_[0] &= ~0x01000000u;
}
inline bool SchemaConf::_internal_force_column_storage() const {
  return force_column_storage_;
}
inline bool SchemaConf::force_column_storage() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaConf.force_column_storage)
  return _internal_force_column_storage();
}
inline void SchemaConf::_internal_set_force_column_storage(bool value) {
  _has_bits_[0] |= 0x01000000u;
  force_column_storage_ = value;
}
inline void SchemaConf::set_force_column_storage(bool value) {
  _internal_set_force_column_storage(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaConf.force_column_storage)
}

// -------------------------------------------------------------------

// SlotDescriptor

// required int32 slot_id = 1;
inline bool SlotDescriptor::_internal_has_slot_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SlotDescriptor::has_slot_id() const {
  return _internal_has_slot_id();
}
inline void SlotDescriptor::clear_slot_id() {
  slot_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SlotDescriptor::_internal_slot_id() const {
  return slot_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SlotDescriptor::slot_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SlotDescriptor.slot_id)
  return _internal_slot_id();
}
inline void SlotDescriptor::_internal_set_slot_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  slot_id_ = value;
}
inline void SlotDescriptor::set_slot_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_slot_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SlotDescriptor.slot_id)
}

// required .baikaldb.pb.PrimitiveType slot_type = 2;
inline bool SlotDescriptor::_internal_has_slot_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SlotDescriptor::has_slot_type() const {
  return _internal_has_slot_type();
}
inline void SlotDescriptor::clear_slot_type() {
  slot_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::baikaldb::pb::PrimitiveType SlotDescriptor::_internal_slot_type() const {
  return static_cast< ::baikaldb::pb::PrimitiveType >(slot_type_);
}
inline ::baikaldb::pb::PrimitiveType SlotDescriptor::slot_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SlotDescriptor.slot_type)
  return _internal_slot_type();
}
inline void SlotDescriptor::_internal_set_slot_type(::baikaldb::pb::PrimitiveType value) {
  assert(::baikaldb::pb::PrimitiveType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  slot_type_ = value;
}
inline void SlotDescriptor::set_slot_type(::baikaldb::pb::PrimitiveType value) {
  _internal_set_slot_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SlotDescriptor.slot_type)
}

// required int32 tuple_id = 3;
inline bool SlotDescriptor::_internal_has_tuple_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SlotDescriptor::has_tuple_id() const {
  return _internal_has_tuple_id();
}
inline void SlotDescriptor::clear_tuple_id() {
  tuple_id_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SlotDescriptor::_internal_tuple_id() const {
  return tuple_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SlotDescriptor::tuple_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SlotDescriptor.tuple_id)
  return _internal_tuple_id();
}
inline void SlotDescriptor::_internal_set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  tuple_id_ = value;
}
inline void SlotDescriptor::set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tuple_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SlotDescriptor.tuple_id)
}

// optional int64 table_id = 4;
inline bool SlotDescriptor::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SlotDescriptor::has_table_id() const {
  return _internal_has_table_id();
}
inline void SlotDescriptor::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SlotDescriptor::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SlotDescriptor::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SlotDescriptor.table_id)
  return _internal_table_id();
}
inline void SlotDescriptor::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  table_id_ = value;
}
inline void SlotDescriptor::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SlotDescriptor.table_id)
}

// optional int32 field_id = 5;
inline bool SlotDescriptor::_internal_has_field_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SlotDescriptor::has_field_id() const {
  return _internal_has_field_id();
}
inline void SlotDescriptor::clear_field_id() {
  field_id_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SlotDescriptor::_internal_field_id() const {
  return field_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SlotDescriptor::field_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SlotDescriptor.field_id)
  return _internal_field_id();
}
inline void SlotDescriptor::_internal_set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  field_id_ = value;
}
inline void SlotDescriptor::set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_field_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SlotDescriptor.field_id)
}

// optional int32 ref_cnt = 6;
inline bool SlotDescriptor::_internal_has_ref_cnt() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SlotDescriptor::has_ref_cnt() const {
  return _internal_has_ref_cnt();
}
inline void SlotDescriptor::clear_ref_cnt() {
  ref_cnt_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SlotDescriptor::_internal_ref_cnt() const {
  return ref_cnt_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SlotDescriptor::ref_cnt() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SlotDescriptor.ref_cnt)
  return _internal_ref_cnt();
}
inline void SlotDescriptor::_internal_set_ref_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  ref_cnt_ = value;
}
inline void SlotDescriptor::set_ref_cnt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ref_cnt(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SlotDescriptor.ref_cnt)
}

// -------------------------------------------------------------------

// TupleDescriptor

// required int32 tuple_id = 1;
inline bool TupleDescriptor::_internal_has_tuple_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TupleDescriptor::has_tuple_id() const {
  return _internal_has_tuple_id();
}
inline void TupleDescriptor::clear_tuple_id() {
  tuple_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TupleDescriptor::_internal_tuple_id() const {
  return tuple_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TupleDescriptor::tuple_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TupleDescriptor.tuple_id)
  return _internal_tuple_id();
}
inline void TupleDescriptor::_internal_set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  tuple_id_ = value;
}
inline void TupleDescriptor::set_tuple_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tuple_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TupleDescriptor.tuple_id)
}

// optional int64 table_id = 2;
inline bool TupleDescriptor::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TupleDescriptor::has_table_id() const {
  return _internal_has_table_id();
}
inline void TupleDescriptor::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TupleDescriptor::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TupleDescriptor::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TupleDescriptor.table_id)
  return _internal_table_id();
}
inline void TupleDescriptor::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  table_id_ = value;
}
inline void TupleDescriptor::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TupleDescriptor.table_id)
}

// repeated .baikaldb.pb.SlotDescriptor slots = 3;
inline int TupleDescriptor::_internal_slots_size() const {
  return slots_.size();
}
inline int TupleDescriptor::slots_size() const {
  return _internal_slots_size();
}
inline void TupleDescriptor::clear_slots() {
  slots_.Clear();
}
inline ::baikaldb::pb::SlotDescriptor* TupleDescriptor::mutable_slots(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TupleDescriptor.slots)
  return slots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >*
TupleDescriptor::mutable_slots() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.TupleDescriptor.slots)
  return &slots_;
}
inline const ::baikaldb::pb::SlotDescriptor& TupleDescriptor::_internal_slots(int index) const {
  return slots_.Get(index);
}
inline const ::baikaldb::pb::SlotDescriptor& TupleDescriptor::slots(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TupleDescriptor.slots)
  return _internal_slots(index);
}
inline ::baikaldb::pb::SlotDescriptor* TupleDescriptor::_internal_add_slots() {
  return slots_.Add();
}
inline ::baikaldb::pb::SlotDescriptor* TupleDescriptor::add_slots() {
  ::baikaldb::pb::SlotDescriptor* _add = _internal_add_slots();
  // @@protoc_insertion_point(field_add:baikaldb.pb.TupleDescriptor.slots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SlotDescriptor >&
TupleDescriptor::slots() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.TupleDescriptor.slots)
  return slots_;
}

// repeated int32 slot_idxes = 4;
inline int TupleDescriptor::_internal_slot_idxes_size() const {
  return slot_idxes_.size();
}
inline int TupleDescriptor::slot_idxes_size() const {
  return _internal_slot_idxes_size();
}
inline void TupleDescriptor::clear_slot_idxes() {
  slot_idxes_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TupleDescriptor::_internal_slot_idxes(int index) const {
  return slot_idxes_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TupleDescriptor::slot_idxes(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TupleDescriptor.slot_idxes)
  return _internal_slot_idxes(index);
}
inline void TupleDescriptor::set_slot_idxes(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  slot_idxes_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TupleDescriptor.slot_idxes)
}
inline void TupleDescriptor::_internal_add_slot_idxes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  slot_idxes_.Add(value);
}
inline void TupleDescriptor::add_slot_idxes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_slot_idxes(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.TupleDescriptor.slot_idxes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TupleDescriptor::_internal_slot_idxes() const {
  return slot_idxes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TupleDescriptor::slot_idxes() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.TupleDescriptor.slot_idxes)
  return _internal_slot_idxes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TupleDescriptor::_internal_mutable_slot_idxes() {
  return &slot_idxes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TupleDescriptor::mutable_slot_idxes() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.TupleDescriptor.slot_idxes)
  return _internal_mutable_slot_idxes();
}

// -------------------------------------------------------------------

// ExprValue

// required .baikaldb.pb.PrimitiveType type = 1;
inline bool ExprValue::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExprValue::has_type() const {
  return _internal_has_type();
}
inline void ExprValue::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::baikaldb::pb::PrimitiveType ExprValue::_internal_type() const {
  return static_cast< ::baikaldb::pb::PrimitiveType >(type_);
}
inline ::baikaldb::pb::PrimitiveType ExprValue::type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExprValue.type)
  return _internal_type();
}
inline void ExprValue::_internal_set_type(::baikaldb::pb::PrimitiveType value) {
  assert(::baikaldb::pb::PrimitiveType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void ExprValue::set_type(::baikaldb::pb::PrimitiveType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExprValue.type)
}

// optional bool bool_val = 2;
inline bool ExprValue::_internal_has_bool_val() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExprValue::has_bool_val() const {
  return _internal_has_bool_val();
}
inline void ExprValue::clear_bool_val() {
  bool_val_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ExprValue::_internal_bool_val() const {
  return bool_val_;
}
inline bool ExprValue::bool_val() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExprValue.bool_val)
  return _internal_bool_val();
}
inline void ExprValue::_internal_set_bool_val(bool value) {
  _has_bits_[0] |= 0x00000004u;
  bool_val_ = value;
}
inline void ExprValue::set_bool_val(bool value) {
  _internal_set_bool_val(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExprValue.bool_val)
}

// optional int32 int32_val = 3;
inline bool ExprValue::_internal_has_int32_val() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExprValue::has_int32_val() const {
  return _internal_has_int32_val();
}
inline void ExprValue::clear_int32_val() {
  int32_val_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExprValue::_internal_int32_val() const {
  return int32_val_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExprValue::int32_val() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExprValue.int32_val)
  return _internal_int32_val();
}
inline void ExprValue::_internal_set_int32_val(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  int32_val_ = value;
}
inline void ExprValue::set_int32_val(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_int32_val(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExprValue.int32_val)
}

// optional uint32 uint32_val = 4;
inline bool ExprValue::_internal_has_uint32_val() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ExprValue::has_uint32_val() const {
  return _internal_has_uint32_val();
}
inline void ExprValue::clear_uint32_val() {
  uint32_val_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExprValue::_internal_uint32_val() const {
  return uint32_val_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ExprValue::uint32_val() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExprValue.uint32_val)
  return _internal_uint32_val();
}
inline void ExprValue::_internal_set_uint32_val(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  uint32_val_ = value;
}
inline void ExprValue::set_uint32_val(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_uint32_val(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExprValue.uint32_val)
}

// optional int64 int64_val = 5;
inline bool ExprValue::_internal_has_int64_val() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExprValue::has_int64_val() const {
  return _internal_has_int64_val();
}
inline void ExprValue::clear_int64_val() {
  int64_val_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExprValue::_internal_int64_val() const {
  return int64_val_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExprValue::int64_val() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExprValue.int64_val)
  return _internal_int64_val();
}
inline void ExprValue::_internal_set_int64_val(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  int64_val_ = value;
}
inline void ExprValue::set_int64_val(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_int64_val(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExprValue.int64_val)
}

// optional uint64 uint64_val = 6;
inline bool ExprValue::_internal_has_uint64_val() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ExprValue::has_uint64_val() const {
  return _internal_has_uint64_val();
}
inline void ExprValue::clear_uint64_val() {
  uint64_val_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExprValue::_internal_uint64_val() const {
  return uint64_val_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExprValue::uint64_val() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExprValue.uint64_val)
  return _internal_uint64_val();
}
inline void ExprValue::_internal_set_uint64_val(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  uint64_val_ = value;
}
inline void ExprValue::set_uint64_val(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_uint64_val(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExprValue.uint64_val)
}

// optional float float_val = 7;
inline bool ExprValue::_internal_has_float_val() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ExprValue::has_float_val() const {
  return _internal_has_float_val();
}
inline void ExprValue::clear_float_val() {
  float_val_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float ExprValue::_internal_float_val() const {
  return float_val_;
}
inline float ExprValue::float_val() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExprValue.float_val)
  return _internal_float_val();
}
inline void ExprValue::_internal_set_float_val(float value) {
  _has_bits_[0] |= 0x00000100u;
  float_val_ = value;
}
inline void ExprValue::set_float_val(float value) {
  _internal_set_float_val(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExprValue.float_val)
}

// optional double double_val = 8;
inline bool ExprValue::_internal_has_double_val() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ExprValue::has_double_val() const {
  return _internal_has_double_val();
}
inline void ExprValue::clear_double_val() {
  double_val_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline double ExprValue::_internal_double_val() const {
  return double_val_;
}
inline double ExprValue::double_val() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExprValue.double_val)
  return _internal_double_val();
}
inline void ExprValue::_internal_set_double_val(double value) {
  _has_bits_[0] |= 0x00000080u;
  double_val_ = value;
}
inline void ExprValue::set_double_val(double value) {
  _internal_set_double_val(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExprValue.double_val)
}

// optional bytes string_val = 9;
inline bool ExprValue::_internal_has_string_val() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExprValue::has_string_val() const {
  return _internal_has_string_val();
}
inline void ExprValue::clear_string_val() {
  string_val_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExprValue::string_val() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ExprValue.string_val)
  return _internal_string_val();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExprValue::set_string_val(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 string_val_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ExprValue.string_val)
}
inline std::string* ExprValue::mutable_string_val() {
  std::string* _s = _internal_mutable_string_val();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ExprValue.string_val)
  return _s;
}
inline const std::string& ExprValue::_internal_string_val() const {
  return string_val_.Get();
}
inline void ExprValue::_internal_set_string_val(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  string_val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExprValue::_internal_mutable_string_val() {
  _has_bits_[0] |= 0x00000001u;
  return string_val_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExprValue::release_string_val() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ExprValue.string_val)
  if (!_internal_has_string_val()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return string_val_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExprValue::set_allocated_string_val(std::string* string_val) {
  if (string_val != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  string_val_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), string_val,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ExprValue.string_val)
}

// -------------------------------------------------------------------

// FieldSlot

// required string field_name = 1;
inline bool FieldSlot::_internal_has_field_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FieldSlot::has_field_name() const {
  return _internal_has_field_name();
}
inline void FieldSlot::clear_field_name() {
  field_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FieldSlot::field_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldSlot.field_name)
  return _internal_field_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldSlot::set_field_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 field_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldSlot.field_name)
}
inline std::string* FieldSlot::mutable_field_name() {
  std::string* _s = _internal_mutable_field_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FieldSlot.field_name)
  return _s;
}
inline const std::string& FieldSlot::_internal_field_name() const {
  return field_name_.Get();
}
inline void FieldSlot::_internal_set_field_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  field_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldSlot::_internal_mutable_field_name() {
  _has_bits_[0] |= 0x00000001u;
  return field_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldSlot::release_field_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.FieldSlot.field_name)
  if (!_internal_has_field_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return field_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldSlot::set_allocated_field_name(std::string* field_name) {
  if (field_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  field_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), field_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.FieldSlot.field_name)
}

// required int32 slot_id = 2;
inline bool FieldSlot::_internal_has_slot_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FieldSlot::has_slot_id() const {
  return _internal_has_slot_id();
}
inline void FieldSlot::clear_slot_id() {
  slot_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FieldSlot::_internal_slot_id() const {
  return slot_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FieldSlot::slot_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldSlot.slot_id)
  return _internal_slot_id();
}
inline void FieldSlot::_internal_set_slot_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  slot_id_ = value;
}
inline void FieldSlot::set_slot_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_slot_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldSlot.slot_id)
}

// -------------------------------------------------------------------

// SlotColumn

// required int32 slot_id = 1;
inline bool SlotColumn::_internal_has_slot_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SlotColumn::has_slot_id() const {
  return _internal_has_slot_id();
}
inline void SlotColumn::clear_slot_id() {
  slot_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SlotColumn::_internal_slot_id() const {
  return slot_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SlotColumn::slot_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SlotColumn.slot_id)
  return _internal_slot_id();
}
inline void SlotColumn::_internal_set_slot_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  slot_id_ = value;
}
inline void SlotColumn::set_slot_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_slot_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SlotColumn.slot_id)
}

// required int32 column_id = 2;
inline bool SlotColumn::_internal_has_column_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SlotColumn::has_column_id() const {
  return _internal_has_column_id();
}
inline void SlotColumn::clear_column_id() {
  column_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SlotColumn::_internal_column_id() const {
  return column_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SlotColumn::column_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SlotColumn.column_id)
  return _internal_column_id();
}
inline void SlotColumn::_internal_set_column_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  column_id_ = value;
}
inline void SlotColumn::set_column_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_column_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SlotColumn.column_id)
}

// -------------------------------------------------------------------

// RefSlotMapping

// required int64 tuple_id = 1;
inline bool RefSlotMapping::_internal_has_tuple_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RefSlotMapping::has_tuple_id() const {
  return _internal_has_tuple_id();
}
inline void RefSlotMapping::clear_tuple_id() {
  tuple_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RefSlotMapping::_internal_tuple_id() const {
  return tuple_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RefSlotMapping::tuple_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RefSlotMapping.tuple_id)
  return _internal_tuple_id();
}
inline void RefSlotMapping::_internal_set_tuple_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  tuple_id_ = value;
}
inline void RefSlotMapping::set_tuple_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tuple_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RefSlotMapping.tuple_id)
}

// repeated .baikaldb.pb.FieldSlot field_slot = 2;
inline int RefSlotMapping::_internal_field_slot_size() const {
  return field_slot_.size();
}
inline int RefSlotMapping::field_slot_size() const {
  return _internal_field_slot_size();
}
inline void RefSlotMapping::clear_field_slot() {
  field_slot_.Clear();
}
inline ::baikaldb::pb::FieldSlot* RefSlotMapping::mutable_field_slot(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RefSlotMapping.field_slot)
  return field_slot_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FieldSlot >*
RefSlotMapping::mutable_field_slot() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RefSlotMapping.field_slot)
  return &field_slot_;
}
inline const ::baikaldb::pb::FieldSlot& RefSlotMapping::_internal_field_slot(int index) const {
  return field_slot_.Get(index);
}
inline const ::baikaldb::pb::FieldSlot& RefSlotMapping::field_slot(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RefSlotMapping.field_slot)
  return _internal_field_slot(index);
}
inline ::baikaldb::pb::FieldSlot* RefSlotMapping::_internal_add_field_slot() {
  return field_slot_.Add();
}
inline ::baikaldb::pb::FieldSlot* RefSlotMapping::add_field_slot() {
  ::baikaldb::pb::FieldSlot* _add = _internal_add_field_slot();
  // @@protoc_insertion_point(field_add:baikaldb.pb.RefSlotMapping.field_slot)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FieldSlot >&
RefSlotMapping::field_slot() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RefSlotMapping.field_slot)
  return field_slot_;
}

// -------------------------------------------------------------------

// QueryContext

// repeated .baikaldb.pb.RefSlotMapping ref_slot_id_mapping = 1;
inline int QueryContext::_internal_ref_slot_id_mapping_size() const {
  return ref_slot_id_mapping_.size();
}
inline int QueryContext::ref_slot_id_mapping_size() const {
  return _internal_ref_slot_id_mapping_size();
}
inline void QueryContext::clear_ref_slot_id_mapping() {
  ref_slot_id_mapping_.Clear();
}
inline ::baikaldb::pb::RefSlotMapping* QueryContext::mutable_ref_slot_id_mapping(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryContext.ref_slot_id_mapping)
  return ref_slot_id_mapping_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RefSlotMapping >*
QueryContext::mutable_ref_slot_id_mapping() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryContext.ref_slot_id_mapping)
  return &ref_slot_id_mapping_;
}
inline const ::baikaldb::pb::RefSlotMapping& QueryContext::_internal_ref_slot_id_mapping(int index) const {
  return ref_slot_id_mapping_.Get(index);
}
inline const ::baikaldb::pb::RefSlotMapping& QueryContext::ref_slot_id_mapping(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryContext.ref_slot_id_mapping)
  return _internal_ref_slot_id_mapping(index);
}
inline ::baikaldb::pb::RefSlotMapping* QueryContext::_internal_add_ref_slot_id_mapping() {
  return ref_slot_id_mapping_.Add();
}
inline ::baikaldb::pb::RefSlotMapping* QueryContext::add_ref_slot_id_mapping() {
  ::baikaldb::pb::RefSlotMapping* _add = _internal_add_ref_slot_id_mapping();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryContext.ref_slot_id_mapping)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RefSlotMapping >&
QueryContext::ref_slot_id_mapping() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryContext.ref_slot_id_mapping)
  return ref_slot_id_mapping_;
}

// -------------------------------------------------------------------

// RuntimeState

// repeated .baikaldb.pb.TupleDescriptor tuples = 1;
inline int RuntimeState::_internal_tuples_size() const {
  return tuples_.size();
}
inline int RuntimeState::tuples_size() const {
  return _internal_tuples_size();
}
inline void RuntimeState::clear_tuples() {
  tuples_.Clear();
}
inline ::baikaldb::pb::TupleDescriptor* RuntimeState::mutable_tuples(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RuntimeState.tuples)
  return tuples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TupleDescriptor >*
RuntimeState::mutable_tuples() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RuntimeState.tuples)
  return &tuples_;
}
inline const ::baikaldb::pb::TupleDescriptor& RuntimeState::_internal_tuples(int index) const {
  return tuples_.Get(index);
}
inline const ::baikaldb::pb::TupleDescriptor& RuntimeState::tuples(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RuntimeState.tuples)
  return _internal_tuples(index);
}
inline ::baikaldb::pb::TupleDescriptor* RuntimeState::_internal_add_tuples() {
  return tuples_.Add();
}
inline ::baikaldb::pb::TupleDescriptor* RuntimeState::add_tuples() {
  ::baikaldb::pb::TupleDescriptor* _add = _internal_add_tuples();
  // @@protoc_insertion_point(field_add:baikaldb.pb.RuntimeState.tuples)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TupleDescriptor >&
RuntimeState::tuples() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RuntimeState.tuples)
  return tuples_;
}

// optional .baikaldb.pb.QueryContext query_context = 2;
inline bool RuntimeState::_internal_has_query_context() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || query_context_ != nullptr);
  return value;
}
inline bool RuntimeState::has_query_context() const {
  return _internal_has_query_context();
}
inline void RuntimeState::clear_query_context() {
  if (query_context_ != nullptr) query_context_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::QueryContext& RuntimeState::_internal_query_context() const {
  const ::baikaldb::pb::QueryContext* p = query_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::QueryContext&>(
      ::baikaldb::pb::_QueryContext_default_instance_);
}
inline const ::baikaldb::pb::QueryContext& RuntimeState::query_context() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RuntimeState.query_context)
  return _internal_query_context();
}
inline void RuntimeState::unsafe_arena_set_allocated_query_context(
    ::baikaldb::pb::QueryContext* query_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(query_context_);
  }
  query_context_ = query_context;
  if (query_context) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.RuntimeState.query_context)
}
inline ::baikaldb::pb::QueryContext* RuntimeState::release_query_context() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::QueryContext* temp = query_context_;
  query_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::QueryContext* RuntimeState::unsafe_arena_release_query_context() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RuntimeState.query_context)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::QueryContext* temp = query_context_;
  query_context_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::QueryContext* RuntimeState::_internal_mutable_query_context() {
  _has_bits_[0] |= 0x00000001u;
  if (query_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::QueryContext>(GetArenaForAllocation());
    query_context_ = p;
  }
  return query_context_;
}
inline ::baikaldb::pb::QueryContext* RuntimeState::mutable_query_context() {
  ::baikaldb::pb::QueryContext* _msg = _internal_mutable_query_context();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RuntimeState.query_context)
  return _msg;
}
inline void RuntimeState::set_allocated_query_context(::baikaldb::pb::QueryContext* query_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete query_context_;
  }
  if (query_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::QueryContext>::GetOwningArena(query_context);
    if (message_arena != submessage_arena) {
      query_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_context, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  query_context_ = query_context;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RuntimeState.query_context)
}

// optional uint64 log_id = 3;
inline bool RuntimeState::_internal_has_log_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RuntimeState::has_log_id() const {
  return _internal_has_log_id();
}
inline void RuntimeState::clear_log_id() {
  log_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RuntimeState::_internal_log_id() const {
  return log_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RuntimeState::log_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RuntimeState.log_id)
  return _internal_log_id();
}
inline void RuntimeState::_internal_set_log_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  log_id_ = value;
}
inline void RuntimeState::set_log_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_log_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RuntimeState.log_id)
}

// optional uint64 sign = 4;
inline bool RuntimeState::_internal_has_sign() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RuntimeState::has_sign() const {
  return _internal_has_sign();
}
inline void RuntimeState::clear_sign() {
  sign_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RuntimeState::_internal_sign() const {
  return sign_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RuntimeState::sign() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RuntimeState.sign)
  return _internal_sign();
}
inline void RuntimeState::_internal_set_sign(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  sign_ = value;
}
inline void RuntimeState::set_sign(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_sign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RuntimeState.sign)
}

// optional uint64 sign_exec_type = 5;
inline bool RuntimeState::_internal_has_sign_exec_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RuntimeState::has_sign_exec_type() const {
  return _internal_has_sign_exec_type();
}
inline void RuntimeState::clear_sign_exec_type() {
  sign_exec_type_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RuntimeState::_internal_sign_exec_type() const {
  return sign_exec_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RuntimeState::sign_exec_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RuntimeState.sign_exec_type)
  return _internal_sign_exec_type();
}
inline void RuntimeState::_internal_set_sign_exec_type(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  sign_exec_type_ = value;
}
inline void RuntimeState::set_sign_exec_type(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_sign_exec_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RuntimeState.sign_exec_type)
}

// -------------------------------------------------------------------

// CompactionFileInfo

// required string file_path = 1;
inline bool CompactionFileInfo::_internal_has_file_path() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CompactionFileInfo::has_file_path() const {
  return _internal_has_file_path();
}
inline void CompactionFileInfo::clear_file_path() {
  file_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CompactionFileInfo::file_path() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CompactionFileInfo.file_path)
  return _internal_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompactionFileInfo::set_file_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.CompactionFileInfo.file_path)
}
inline std::string* CompactionFileInfo::mutable_file_path() {
  std::string* _s = _internal_mutable_file_path();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.CompactionFileInfo.file_path)
  return _s;
}
inline const std::string& CompactionFileInfo::_internal_file_path() const {
  return file_path_.Get();
}
inline void CompactionFileInfo::_internal_set_file_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CompactionFileInfo::_internal_mutable_file_path() {
  _has_bits_[0] |= 0x00000001u;
  return file_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CompactionFileInfo::release_file_path() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.CompactionFileInfo.file_path)
  if (!_internal_has_file_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return file_path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CompactionFileInfo::set_allocated_file_path(std::string* file_path) {
  if (file_path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  file_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.CompactionFileInfo.file_path)
}

// optional uint64 file_size = 2;
inline bool CompactionFileInfo::_internal_has_file_size() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CompactionFileInfo::has_file_size() const {
  return _internal_has_file_size();
}
inline void CompactionFileInfo::clear_file_size() {
  file_size_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CompactionFileInfo::_internal_file_size() const {
  return file_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CompactionFileInfo::file_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CompactionFileInfo.file_size)
  return _internal_file_size();
}
inline void CompactionFileInfo::_internal_set_file_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  file_size_ = value;
}
inline void CompactionFileInfo::set_file_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CompactionFileInfo.file_size)
}

// optional uint64 file_mtime = 3;
inline bool CompactionFileInfo::_internal_has_file_mtime() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CompactionFileInfo::has_file_mtime() const {
  return _internal_has_file_mtime();
}
inline void CompactionFileInfo::clear_file_mtime() {
  file_mtime_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CompactionFileInfo::_internal_file_mtime() const {
  return file_mtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 CompactionFileInfo::file_mtime() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CompactionFileInfo.file_mtime)
  return _internal_file_mtime();
}
inline void CompactionFileInfo::_internal_set_file_mtime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  file_mtime_ = value;
}
inline void CompactionFileInfo::set_file_mtime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_file_mtime(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CompactionFileInfo.file_mtime)
}

// -------------------------------------------------------------------

// MysqlInfo

// optional bytes addr = 1;
inline bool MysqlInfo::_internal_has_addr() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MysqlInfo::has_addr() const {
  return _internal_has_addr();
}
inline void MysqlInfo::clear_addr() {
  addr_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MysqlInfo::addr() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MysqlInfo.addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MysqlInfo::set_addr(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 addr_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MysqlInfo.addr)
}
inline std::string* MysqlInfo::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MysqlInfo.addr)
  return _s;
}
inline const std::string& MysqlInfo::_internal_addr() const {
  return addr_.Get();
}
inline void MysqlInfo::_internal_set_addr(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MysqlInfo::_internal_mutable_addr() {
  _has_bits_[0] |= 0x00000001u;
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MysqlInfo::release_addr() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MysqlInfo.addr)
  if (!_internal_has_addr()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return addr_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MysqlInfo::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MysqlInfo.addr)
}

// optional bytes username = 2;
inline bool MysqlInfo::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MysqlInfo::has_username() const {
  return _internal_has_username();
}
inline void MysqlInfo::clear_username() {
  username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MysqlInfo::username() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MysqlInfo.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MysqlInfo::set_username(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 username_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MysqlInfo.username)
}
inline std::string* MysqlInfo::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MysqlInfo.username)
  return _s;
}
inline const std::string& MysqlInfo::_internal_username() const {
  return username_.Get();
}
inline void MysqlInfo::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MysqlInfo::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000002u;
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MysqlInfo::release_username() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MysqlInfo.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MysqlInfo::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MysqlInfo.username)
}

// optional bytes password = 3;
inline bool MysqlInfo::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MysqlInfo::has_password() const {
  return _internal_has_password();
}
inline void MysqlInfo::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MysqlInfo::password() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MysqlInfo.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MysqlInfo::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 password_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MysqlInfo.password)
}
inline std::string* MysqlInfo::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MysqlInfo.password)
  return _s;
}
inline const std::string& MysqlInfo::_internal_password() const {
  return password_.Get();
}
inline void MysqlInfo::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MysqlInfo::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000004u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MysqlInfo::release_password() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MysqlInfo.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MysqlInfo::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MysqlInfo.password)
}

// optional bytes database_name = 4;
inline bool MysqlInfo::_internal_has_database_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MysqlInfo::has_database_name() const {
  return _internal_has_database_name();
}
inline void MysqlInfo::clear_database_name() {
  database_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MysqlInfo::database_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MysqlInfo.database_name)
  return _internal_database_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MysqlInfo::set_database_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 database_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MysqlInfo.database_name)
}
inline std::string* MysqlInfo::mutable_database_name() {
  std::string* _s = _internal_mutable_database_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MysqlInfo.database_name)
  return _s;
}
inline const std::string& MysqlInfo::_internal_database_name() const {
  return database_name_.Get();
}
inline void MysqlInfo::_internal_set_database_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  database_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MysqlInfo::_internal_mutable_database_name() {
  _has_bits_[0] |= 0x00000008u;
  return database_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MysqlInfo::release_database_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MysqlInfo.database_name)
  if (!_internal_has_database_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return database_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MysqlInfo::set_allocated_database_name(std::string* database_name) {
  if (database_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  database_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MysqlInfo.database_name)
}

// optional bytes table_name = 5;
inline bool MysqlInfo::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MysqlInfo::has_table_name() const {
  return _internal_has_table_name();
}
inline void MysqlInfo::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MysqlInfo::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MysqlInfo.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MysqlInfo::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 table_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MysqlInfo.table_name)
}
inline std::string* MysqlInfo::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MysqlInfo.table_name)
  return _s;
}
inline const std::string& MysqlInfo::_internal_table_name() const {
  return table_name_.Get();
}
inline void MysqlInfo::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MysqlInfo::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000010u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MysqlInfo::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MysqlInfo.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MysqlInfo::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MysqlInfo.table_name)
}

// optional bytes charset = 6;
inline bool MysqlInfo::_internal_has_charset() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MysqlInfo::has_charset() const {
  return _internal_has_charset();
}
inline void MysqlInfo::clear_charset() {
  charset_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& MysqlInfo::charset() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MysqlInfo.charset)
  return _internal_charset();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MysqlInfo::set_charset(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 charset_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MysqlInfo.charset)
}
inline std::string* MysqlInfo::mutable_charset() {
  std::string* _s = _internal_mutable_charset();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MysqlInfo.charset)
  return _s;
}
inline const std::string& MysqlInfo::_internal_charset() const {
  return charset_.Get();
}
inline void MysqlInfo::_internal_set_charset(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  charset_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MysqlInfo::_internal_mutable_charset() {
  _has_bits_[0] |= 0x00000020u;
  return charset_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MysqlInfo::release_charset() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MysqlInfo.charset)
  if (!_internal_has_charset()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return charset_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MysqlInfo::set_allocated_charset(std::string* charset) {
  if (charset != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  charset_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), charset,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MysqlInfo.charset)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace baikaldb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::baikaldb::pb::ErrCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::ErrCode>() {
  return ::baikaldb::pb::ErrCode_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::PrimitiveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::PrimitiveType>() {
  return ::baikaldb::pb::PrimitiveType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::SchemaType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::SchemaType>() {
  return ::baikaldb::pb::SchemaType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::Charset> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::Charset>() {
  return ::baikaldb::pb::Charset_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::BackupTable> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::BackupTable>() {
  return ::baikaldb::pb::BackupTable_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::StreamState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::StreamState>() {
  return ::baikaldb::pb::StreamState_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::Engine> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::Engine>() {
  return ::baikaldb::pb::Engine_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2eproto
