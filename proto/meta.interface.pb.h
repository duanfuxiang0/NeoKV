// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: meta.interface.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_meta_2einterface_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_meta_2einterface_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "optype.pb.h"
#include "raft.pb.h"
#include "statistics.pb.h"
#include "expr.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_meta_2einterface_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_meta_2einterface_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[90]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_meta_2einterface_2eproto;
namespace baikaldb {
namespace pb {
class AddPeer;
struct AddPeerDefaultTypeInternal;
extern AddPeerDefaultTypeInternal _AddPeer_default_instance_;
class AlterTableRequest;
struct AlterTableRequestDefaultTypeInternal;
extern AlterTableRequestDefaultTypeInternal _AlterTableRequest_default_instance_;
class AutoIncrementRequest;
struct AutoIncrementRequestDefaultTypeInternal;
extern AutoIncrementRequestDefaultTypeInternal _AutoIncrementRequest_default_instance_;
class BaikalHeartBeatRequest;
struct BaikalHeartBeatRequestDefaultTypeInternal;
extern BaikalHeartBeatRequestDefaultTypeInternal _BaikalHeartBeatRequest_default_instance_;
class BaikalHeartBeatResponse;
struct BaikalHeartBeatResponseDefaultTypeInternal;
extern BaikalHeartBeatResponseDefaultTypeInternal _BaikalHeartBeatResponse_default_instance_;
class BaikalHeartBeatTable;
struct BaikalHeartBeatTableDefaultTypeInternal;
extern BaikalHeartBeatTableDefaultTypeInternal _BaikalHeartBeatTable_default_instance_;
class BaikalOtherHeartBeat;
struct BaikalOtherHeartBeatDefaultTypeInternal;
extern BaikalOtherHeartBeatDefaultTypeInternal _BaikalOtherHeartBeat_default_instance_;
class BaikalOtherHeartBeatRequest;
struct BaikalOtherHeartBeatRequestDefaultTypeInternal;
extern BaikalOtherHeartBeatRequestDefaultTypeInternal _BaikalOtherHeartBeatRequest_default_instance_;
class BaikalOtherHeartBeatResponse;
struct BaikalOtherHeartBeatResponseDefaultTypeInternal;
extern BaikalOtherHeartBeatResponseDefaultTypeInternal _BaikalOtherHeartBeatResponse_default_instance_;
class BaikalSchemaHeartBeat;
struct BaikalSchemaHeartBeatDefaultTypeInternal;
extern BaikalSchemaHeartBeatDefaultTypeInternal _BaikalSchemaHeartBeat_default_instance_;
class BaikalStatus;
struct BaikalStatusDefaultTypeInternal;
extern BaikalStatusDefaultTypeInternal _BaikalStatus_default_instance_;
class BinlogInfo;
struct BinlogInfoDefaultTypeInternal;
extern BinlogInfoDefaultTypeInternal _BinlogInfo_default_instance_;
class BinlogPeerState;
struct BinlogPeerStateDefaultTypeInternal;
extern BinlogPeerStateDefaultTypeInternal _BinlogPeerState_default_instance_;
class BinlogRegionInfo;
struct BinlogRegionInfoDefaultTypeInternal;
extern BinlogRegionInfoDefaultTypeInternal _BinlogRegionInfo_default_instance_;
class ConsoleHeartBeatRequest;
struct ConsoleHeartBeatRequestDefaultTypeInternal;
extern ConsoleHeartBeatRequestDefaultTypeInternal _ConsoleHeartBeatRequest_default_instance_;
class ConsoleHeartBeatResponse;
struct ConsoleHeartBeatResponseDefaultTypeInternal;
extern ConsoleHeartBeatResponseDefaultTypeInternal _ConsoleHeartBeatResponse_default_instance_;
class CreateTableResponse;
struct CreateTableResponseDefaultTypeInternal;
extern CreateTableResponseDefaultTypeInternal _CreateTableResponse_default_instance_;
class DBLinkInfo;
struct DBLinkInfoDefaultTypeInternal;
extern DBLinkInfoDefaultTypeInternal _DBLinkInfo_default_instance_;
class DataBaseInfo;
struct DataBaseInfoDefaultTypeInternal;
extern DataBaseInfoDefaultTypeInternal _DataBaseInfo_default_instance_;
class DdlPeerInfo;
struct DdlPeerInfoDefaultTypeInternal;
extern DdlPeerInfoDefaultTypeInternal _DdlPeerInfo_default_instance_;
class DdlRegionInfo;
struct DdlRegionInfoDefaultTypeInternal;
extern DdlRegionInfoDefaultTypeInternal _DdlRegionInfo_default_instance_;
class DdlWorkInfo;
struct DdlWorkInfoDefaultTypeInternal;
extern DdlWorkInfoDefaultTypeInternal _DdlWorkInfo_default_instance_;
class DdlWorkInfoHeartBeat;
struct DdlWorkInfoHeartBeatDefaultTypeInternal;
extern DdlWorkInfoHeartBeatDefaultTypeInternal _DdlWorkInfoHeartBeat_default_instance_;
class DynamicPartitionAttr;
struct DynamicPartitionAttrDefaultTypeInternal;
extern DynamicPartitionAttrDefaultTypeInternal _DynamicPartitionAttr_default_instance_;
class FieldInfo;
struct FieldInfoDefaultTypeInternal;
extern FieldInfoDefaultTypeInternal _FieldInfo_default_instance_;
class IdcInfo;
struct IdcInfoDefaultTypeInternal;
extern IdcInfoDefaultTypeInternal _IdcInfo_default_instance_;
class IndexDdlRequest;
struct IndexDdlRequestDefaultTypeInternal;
extern IndexDdlRequestDefaultTypeInternal _IndexDdlRequest_default_instance_;
class IndexInfo;
struct IndexInfoDefaultTypeInternal;
extern IndexInfoDefaultTypeInternal _IndexInfo_default_instance_;
class InstanceInfo;
struct InstanceInfoDefaultTypeInternal;
extern InstanceInfoDefaultTypeInternal _InstanceInfo_default_instance_;
class InstanceParam;
struct InstanceParamDefaultTypeInternal;
extern InstanceParamDefaultTypeInternal _InstanceParam_default_instance_;
class LeaderHeartBeat;
struct LeaderHeartBeatDefaultTypeInternal;
extern LeaderHeartBeatDefaultTypeInternal _LeaderHeartBeat_default_instance_;
class LearnerHeartBeat;
struct LearnerHeartBeatDefaultTypeInternal;
extern LearnerHeartBeatDefaultTypeInternal _LearnerHeartBeat_default_instance_;
class LogicalRoom;
struct LogicalRoomDefaultTypeInternal;
extern LogicalRoomDefaultTypeInternal _LogicalRoom_default_instance_;
class MetaManagerRequest;
struct MetaManagerRequestDefaultTypeInternal;
extern MetaManagerRequestDefaultTypeInternal _MetaManagerRequest_default_instance_;
class MetaManagerResponse;
struct MetaManagerResponseDefaultTypeInternal;
extern MetaManagerResponseDefaultTypeInternal _MetaManagerResponse_default_instance_;
class MigrateData;
struct MigrateDataDefaultTypeInternal;
extern MigrateDataDefaultTypeInternal _MigrateData_default_instance_;
class MigrateInstance;
struct MigrateInstanceDefaultTypeInternal;
extern MigrateInstanceDefaultTypeInternal _MigrateInstance_default_instance_;
class MigrateRequest;
struct MigrateRequestDefaultTypeInternal;
extern MigrateRequestDefaultTypeInternal _MigrateRequest_default_instance_;
class MigrateResponse;
struct MigrateResponseDefaultTypeInternal;
extern MigrateResponseDefaultTypeInternal _MigrateResponse_default_instance_;
class MovePhysicalRequest;
struct MovePhysicalRequestDefaultTypeInternal;
extern MovePhysicalRequestDefaultTypeInternal _MovePhysicalRequest_default_instance_;
class MultiSplitRegion;
struct MultiSplitRegionDefaultTypeInternal;
extern MultiSplitRegionDefaultTypeInternal _MultiSplitRegion_default_instance_;
class NameSpaceInfo;
struct NameSpaceInfoDefaultTypeInternal;
extern NameSpaceInfoDefaultTypeInternal _NameSpaceInfo_default_instance_;
class ParamDesc;
struct ParamDescDefaultTypeInternal;
extern ParamDescDefaultTypeInternal _ParamDesc_default_instance_;
class PartitionInfo;
struct PartitionInfoDefaultTypeInternal;
extern PartitionInfoDefaultTypeInternal _PartitionInfo_default_instance_;
class PartitionRange;
struct PartitionRangeDefaultTypeInternal;
extern PartitionRangeDefaultTypeInternal _PartitionRange_default_instance_;
class PartitionRegion;
struct PartitionRegionDefaultTypeInternal;
extern PartitionRegionDefaultTypeInternal _PartitionRegion_default_instance_;
class PeerHeartBeat;
struct PeerHeartBeatDefaultTypeInternal;
extern PeerHeartBeatDefaultTypeInternal _PeerHeartBeat_default_instance_;
class PeerStateInfo;
struct PeerStateInfoDefaultTypeInternal;
extern PeerStateInfoDefaultTypeInternal _PeerStateInfo_default_instance_;
class PhysicalInstance;
struct PhysicalInstanceDefaultTypeInternal;
extern PhysicalInstanceDefaultTypeInternal _PhysicalInstance_default_instance_;
class PhysicalRoom;
struct PhysicalRoomDefaultTypeInternal;
extern PhysicalRoomDefaultTypeInternal _PhysicalRoom_default_instance_;
class PrivilegeDatabase;
struct PrivilegeDatabaseDefaultTypeInternal;
extern PrivilegeDatabaseDefaultTypeInternal _PrivilegeDatabase_default_instance_;
class PrivilegeTable;
struct PrivilegeTableDefaultTypeInternal;
extern PrivilegeTableDefaultTypeInternal _PrivilegeTable_default_instance_;
class QueryDdlInfo;
struct QueryDdlInfoDefaultTypeInternal;
extern QueryDdlInfoDefaultTypeInternal _QueryDdlInfo_default_instance_;
class QueryInstance;
struct QueryInstanceDefaultTypeInternal;
extern QueryInstanceDefaultTypeInternal _QueryInstance_default_instance_;
class QueryRegion;
struct QueryRegionDefaultTypeInternal;
extern QueryRegionDefaultTypeInternal _QueryRegion_default_instance_;
class QueryRequest;
struct QueryRequestDefaultTypeInternal;
extern QueryRequestDefaultTypeInternal _QueryRequest_default_instance_;
class QueryResponse;
struct QueryResponseDefaultTypeInternal;
extern QueryResponseDefaultTypeInternal _QueryResponse_default_instance_;
class QuerySchema;
struct QuerySchemaDefaultTypeInternal;
extern QuerySchemaDefaultTypeInternal _QuerySchema_default_instance_;
class QueryTable;
struct QueryTableDefaultTypeInternal;
extern QueryTableDefaultTypeInternal _QueryTable_default_instance_;
class QueryUserPrivilege;
struct QueryUserPrivilegeDefaultTypeInternal;
extern QueryUserPrivilegeDefaultTypeInternal _QueryUserPrivilege_default_instance_;
class RangePartitionInfo;
struct RangePartitionInfoDefaultTypeInternal;
extern RangePartitionInfoDefaultTypeInternal _RangePartitionInfo_default_instance_;
class RegionChangeInfo;
struct RegionChangeInfoDefaultTypeInternal;
extern RegionChangeInfoDefaultTypeInternal _RegionChangeInfo_default_instance_;
class RegionDdlWork;
struct RegionDdlWorkDefaultTypeInternal;
extern RegionDdlWorkDefaultTypeInternal _RegionDdlWork_default_instance_;
class RegionHeartBeat;
struct RegionHeartBeatDefaultTypeInternal;
extern RegionHeartBeatDefaultTypeInternal _RegionHeartBeat_default_instance_;
class RegionInfo;
struct RegionInfoDefaultTypeInternal;
extern RegionInfoDefaultTypeInternal _RegionInfo_default_instance_;
class RegionMergeRequest;
struct RegionMergeRequestDefaultTypeInternal;
extern RegionMergeRequestDefaultTypeInternal _RegionMergeRequest_default_instance_;
class RegionMergeResponse;
struct RegionMergeResponseDefaultTypeInternal;
extern RegionMergeResponseDefaultTypeInternal _RegionMergeResponse_default_instance_;
class RegionRecoverResponse;
struct RegionRecoverResponseDefaultTypeInternal;
extern RegionRecoverResponseDefaultTypeInternal _RegionRecoverResponse_default_instance_;
class RegionSplitRequest;
struct RegionSplitRequestDefaultTypeInternal;
extern RegionSplitRequestDefaultTypeInternal _RegionSplitRequest_default_instance_;
class RegionSplitResponse;
struct RegionSplitResponseDefaultTypeInternal;
extern RegionSplitResponseDefaultTypeInternal _RegionSplitResponse_default_instance_;
class RegionStateInfo;
struct RegionStateInfoDefaultTypeInternal;
extern RegionStateInfoDefaultTypeInternal _RegionStateInfo_default_instance_;
class ReplicaDist;
struct ReplicaDistDefaultTypeInternal;
extern ReplicaDistDefaultTypeInternal _ReplicaDist_default_instance_;
class ResourceTagInfo;
struct ResourceTagInfoDefaultTypeInternal;
extern ResourceTagInfoDefaultTypeInternal _ResourceTagInfo_default_instance_;
class RestoreRegionRequest;
struct RestoreRegionRequestDefaultTypeInternal;
extern RestoreRegionRequestDefaultTypeInternal _RestoreRegionRequest_default_instance_;
class SchemaHeartBeat;
struct SchemaHeartBeatDefaultTypeInternal;
extern SchemaHeartBeatDefaultTypeInternal _SchemaHeartBeat_default_instance_;
class SchemaInfo;
struct SchemaInfoDefaultTypeInternal;
extern SchemaInfoDefaultTypeInternal _SchemaInfo_default_instance_;
class SplitKey;
struct SplitKeyDefaultTypeInternal;
extern SplitKeyDefaultTypeInternal _SplitKey_default_instance_;
class StoreHeartBeatRequest;
struct StoreHeartBeatRequestDefaultTypeInternal;
extern StoreHeartBeatRequestDefaultTypeInternal _StoreHeartBeatRequest_default_instance_;
class StoreHeartBeatResponse;
struct StoreHeartBeatResponseDefaultTypeInternal;
extern StoreHeartBeatResponseDefaultTypeInternal _StoreHeartBeatResponse_default_instance_;
class StoreRegionDdlInfo;
struct StoreRegionDdlInfoDefaultTypeInternal;
extern StoreRegionDdlInfoDefaultTypeInternal _StoreRegionDdlInfo_default_instance_;
class TableHeartBeat;
struct TableHeartBeatDefaultTypeInternal;
extern TableHeartBeatDefaultTypeInternal _TableHeartBeat_default_instance_;
class TableInfo;
struct TableInfoDefaultTypeInternal;
extern TableInfoDefaultTypeInternal _TableInfo_default_instance_;
class TargetsList;
struct TargetsListDefaultTypeInternal;
extern TargetsListDefaultTypeInternal _TargetsList_default_instance_;
class TransLeaderRequest;
struct TransLeaderRequestDefaultTypeInternal;
extern TransLeaderRequestDefaultTypeInternal _TransLeaderRequest_default_instance_;
class TsoRequest;
struct TsoRequestDefaultTypeInternal;
extern TsoRequestDefaultTypeInternal _TsoRequest_default_instance_;
class TsoResponse;
struct TsoResponseDefaultTypeInternal;
extern TsoResponseDefaultTypeInternal _TsoResponse_default_instance_;
class TsoTimestamp;
struct TsoTimestampDefaultTypeInternal;
extern TsoTimestampDefaultTypeInternal _TsoTimestamp_default_instance_;
class UserPrivilege;
struct UserPrivilegeDefaultTypeInternal;
extern UserPrivilegeDefaultTypeInternal _UserPrivilege_default_instance_;
class VirtualIndexInfluence;
struct VirtualIndexInfluenceDefaultTypeInternal;
extern VirtualIndexInfluenceDefaultTypeInternal _VirtualIndexInfluence_default_instance_;
class VirtualInfoAndSqls;
struct VirtualInfoAndSqlsDefaultTypeInternal;
extern VirtualInfoAndSqlsDefaultTypeInternal _VirtualInfoAndSqls_default_instance_;
}  // namespace pb
}  // namespace baikaldb
PROTOBUF_NAMESPACE_OPEN
template<> ::baikaldb::pb::AddPeer* Arena::CreateMaybeMessage<::baikaldb::pb::AddPeer>(Arena*);
template<> ::baikaldb::pb::AlterTableRequest* Arena::CreateMaybeMessage<::baikaldb::pb::AlterTableRequest>(Arena*);
template<> ::baikaldb::pb::AutoIncrementRequest* Arena::CreateMaybeMessage<::baikaldb::pb::AutoIncrementRequest>(Arena*);
template<> ::baikaldb::pb::BaikalHeartBeatRequest* Arena::CreateMaybeMessage<::baikaldb::pb::BaikalHeartBeatRequest>(Arena*);
template<> ::baikaldb::pb::BaikalHeartBeatResponse* Arena::CreateMaybeMessage<::baikaldb::pb::BaikalHeartBeatResponse>(Arena*);
template<> ::baikaldb::pb::BaikalHeartBeatTable* Arena::CreateMaybeMessage<::baikaldb::pb::BaikalHeartBeatTable>(Arena*);
template<> ::baikaldb::pb::BaikalOtherHeartBeat* Arena::CreateMaybeMessage<::baikaldb::pb::BaikalOtherHeartBeat>(Arena*);
template<> ::baikaldb::pb::BaikalOtherHeartBeatRequest* Arena::CreateMaybeMessage<::baikaldb::pb::BaikalOtherHeartBeatRequest>(Arena*);
template<> ::baikaldb::pb::BaikalOtherHeartBeatResponse* Arena::CreateMaybeMessage<::baikaldb::pb::BaikalOtherHeartBeatResponse>(Arena*);
template<> ::baikaldb::pb::BaikalSchemaHeartBeat* Arena::CreateMaybeMessage<::baikaldb::pb::BaikalSchemaHeartBeat>(Arena*);
template<> ::baikaldb::pb::BaikalStatus* Arena::CreateMaybeMessage<::baikaldb::pb::BaikalStatus>(Arena*);
template<> ::baikaldb::pb::BinlogInfo* Arena::CreateMaybeMessage<::baikaldb::pb::BinlogInfo>(Arena*);
template<> ::baikaldb::pb::BinlogPeerState* Arena::CreateMaybeMessage<::baikaldb::pb::BinlogPeerState>(Arena*);
template<> ::baikaldb::pb::BinlogRegionInfo* Arena::CreateMaybeMessage<::baikaldb::pb::BinlogRegionInfo>(Arena*);
template<> ::baikaldb::pb::ConsoleHeartBeatRequest* Arena::CreateMaybeMessage<::baikaldb::pb::ConsoleHeartBeatRequest>(Arena*);
template<> ::baikaldb::pb::ConsoleHeartBeatResponse* Arena::CreateMaybeMessage<::baikaldb::pb::ConsoleHeartBeatResponse>(Arena*);
template<> ::baikaldb::pb::CreateTableResponse* Arena::CreateMaybeMessage<::baikaldb::pb::CreateTableResponse>(Arena*);
template<> ::baikaldb::pb::DBLinkInfo* Arena::CreateMaybeMessage<::baikaldb::pb::DBLinkInfo>(Arena*);
template<> ::baikaldb::pb::DataBaseInfo* Arena::CreateMaybeMessage<::baikaldb::pb::DataBaseInfo>(Arena*);
template<> ::baikaldb::pb::DdlPeerInfo* Arena::CreateMaybeMessage<::baikaldb::pb::DdlPeerInfo>(Arena*);
template<> ::baikaldb::pb::DdlRegionInfo* Arena::CreateMaybeMessage<::baikaldb::pb::DdlRegionInfo>(Arena*);
template<> ::baikaldb::pb::DdlWorkInfo* Arena::CreateMaybeMessage<::baikaldb::pb::DdlWorkInfo>(Arena*);
template<> ::baikaldb::pb::DdlWorkInfoHeartBeat* Arena::CreateMaybeMessage<::baikaldb::pb::DdlWorkInfoHeartBeat>(Arena*);
template<> ::baikaldb::pb::DynamicPartitionAttr* Arena::CreateMaybeMessage<::baikaldb::pb::DynamicPartitionAttr>(Arena*);
template<> ::baikaldb::pb::FieldInfo* Arena::CreateMaybeMessage<::baikaldb::pb::FieldInfo>(Arena*);
template<> ::baikaldb::pb::IdcInfo* Arena::CreateMaybeMessage<::baikaldb::pb::IdcInfo>(Arena*);
template<> ::baikaldb::pb::IndexDdlRequest* Arena::CreateMaybeMessage<::baikaldb::pb::IndexDdlRequest>(Arena*);
template<> ::baikaldb::pb::IndexInfo* Arena::CreateMaybeMessage<::baikaldb::pb::IndexInfo>(Arena*);
template<> ::baikaldb::pb::InstanceInfo* Arena::CreateMaybeMessage<::baikaldb::pb::InstanceInfo>(Arena*);
template<> ::baikaldb::pb::InstanceParam* Arena::CreateMaybeMessage<::baikaldb::pb::InstanceParam>(Arena*);
template<> ::baikaldb::pb::LeaderHeartBeat* Arena::CreateMaybeMessage<::baikaldb::pb::LeaderHeartBeat>(Arena*);
template<> ::baikaldb::pb::LearnerHeartBeat* Arena::CreateMaybeMessage<::baikaldb::pb::LearnerHeartBeat>(Arena*);
template<> ::baikaldb::pb::LogicalRoom* Arena::CreateMaybeMessage<::baikaldb::pb::LogicalRoom>(Arena*);
template<> ::baikaldb::pb::MetaManagerRequest* Arena::CreateMaybeMessage<::baikaldb::pb::MetaManagerRequest>(Arena*);
template<> ::baikaldb::pb::MetaManagerResponse* Arena::CreateMaybeMessage<::baikaldb::pb::MetaManagerResponse>(Arena*);
template<> ::baikaldb::pb::MigrateData* Arena::CreateMaybeMessage<::baikaldb::pb::MigrateData>(Arena*);
template<> ::baikaldb::pb::MigrateInstance* Arena::CreateMaybeMessage<::baikaldb::pb::MigrateInstance>(Arena*);
template<> ::baikaldb::pb::MigrateRequest* Arena::CreateMaybeMessage<::baikaldb::pb::MigrateRequest>(Arena*);
template<> ::baikaldb::pb::MigrateResponse* Arena::CreateMaybeMessage<::baikaldb::pb::MigrateResponse>(Arena*);
template<> ::baikaldb::pb::MovePhysicalRequest* Arena::CreateMaybeMessage<::baikaldb::pb::MovePhysicalRequest>(Arena*);
template<> ::baikaldb::pb::MultiSplitRegion* Arena::CreateMaybeMessage<::baikaldb::pb::MultiSplitRegion>(Arena*);
template<> ::baikaldb::pb::NameSpaceInfo* Arena::CreateMaybeMessage<::baikaldb::pb::NameSpaceInfo>(Arena*);
template<> ::baikaldb::pb::ParamDesc* Arena::CreateMaybeMessage<::baikaldb::pb::ParamDesc>(Arena*);
template<> ::baikaldb::pb::PartitionInfo* Arena::CreateMaybeMessage<::baikaldb::pb::PartitionInfo>(Arena*);
template<> ::baikaldb::pb::PartitionRange* Arena::CreateMaybeMessage<::baikaldb::pb::PartitionRange>(Arena*);
template<> ::baikaldb::pb::PartitionRegion* Arena::CreateMaybeMessage<::baikaldb::pb::PartitionRegion>(Arena*);
template<> ::baikaldb::pb::PeerHeartBeat* Arena::CreateMaybeMessage<::baikaldb::pb::PeerHeartBeat>(Arena*);
template<> ::baikaldb::pb::PeerStateInfo* Arena::CreateMaybeMessage<::baikaldb::pb::PeerStateInfo>(Arena*);
template<> ::baikaldb::pb::PhysicalInstance* Arena::CreateMaybeMessage<::baikaldb::pb::PhysicalInstance>(Arena*);
template<> ::baikaldb::pb::PhysicalRoom* Arena::CreateMaybeMessage<::baikaldb::pb::PhysicalRoom>(Arena*);
template<> ::baikaldb::pb::PrivilegeDatabase* Arena::CreateMaybeMessage<::baikaldb::pb::PrivilegeDatabase>(Arena*);
template<> ::baikaldb::pb::PrivilegeTable* Arena::CreateMaybeMessage<::baikaldb::pb::PrivilegeTable>(Arena*);
template<> ::baikaldb::pb::QueryDdlInfo* Arena::CreateMaybeMessage<::baikaldb::pb::QueryDdlInfo>(Arena*);
template<> ::baikaldb::pb::QueryInstance* Arena::CreateMaybeMessage<::baikaldb::pb::QueryInstance>(Arena*);
template<> ::baikaldb::pb::QueryRegion* Arena::CreateMaybeMessage<::baikaldb::pb::QueryRegion>(Arena*);
template<> ::baikaldb::pb::QueryRequest* Arena::CreateMaybeMessage<::baikaldb::pb::QueryRequest>(Arena*);
template<> ::baikaldb::pb::QueryResponse* Arena::CreateMaybeMessage<::baikaldb::pb::QueryResponse>(Arena*);
template<> ::baikaldb::pb::QuerySchema* Arena::CreateMaybeMessage<::baikaldb::pb::QuerySchema>(Arena*);
template<> ::baikaldb::pb::QueryTable* Arena::CreateMaybeMessage<::baikaldb::pb::QueryTable>(Arena*);
template<> ::baikaldb::pb::QueryUserPrivilege* Arena::CreateMaybeMessage<::baikaldb::pb::QueryUserPrivilege>(Arena*);
template<> ::baikaldb::pb::RangePartitionInfo* Arena::CreateMaybeMessage<::baikaldb::pb::RangePartitionInfo>(Arena*);
template<> ::baikaldb::pb::RegionChangeInfo* Arena::CreateMaybeMessage<::baikaldb::pb::RegionChangeInfo>(Arena*);
template<> ::baikaldb::pb::RegionDdlWork* Arena::CreateMaybeMessage<::baikaldb::pb::RegionDdlWork>(Arena*);
template<> ::baikaldb::pb::RegionHeartBeat* Arena::CreateMaybeMessage<::baikaldb::pb::RegionHeartBeat>(Arena*);
template<> ::baikaldb::pb::RegionInfo* Arena::CreateMaybeMessage<::baikaldb::pb::RegionInfo>(Arena*);
template<> ::baikaldb::pb::RegionMergeRequest* Arena::CreateMaybeMessage<::baikaldb::pb::RegionMergeRequest>(Arena*);
template<> ::baikaldb::pb::RegionMergeResponse* Arena::CreateMaybeMessage<::baikaldb::pb::RegionMergeResponse>(Arena*);
template<> ::baikaldb::pb::RegionRecoverResponse* Arena::CreateMaybeMessage<::baikaldb::pb::RegionRecoverResponse>(Arena*);
template<> ::baikaldb::pb::RegionSplitRequest* Arena::CreateMaybeMessage<::baikaldb::pb::RegionSplitRequest>(Arena*);
template<> ::baikaldb::pb::RegionSplitResponse* Arena::CreateMaybeMessage<::baikaldb::pb::RegionSplitResponse>(Arena*);
template<> ::baikaldb::pb::RegionStateInfo* Arena::CreateMaybeMessage<::baikaldb::pb::RegionStateInfo>(Arena*);
template<> ::baikaldb::pb::ReplicaDist* Arena::CreateMaybeMessage<::baikaldb::pb::ReplicaDist>(Arena*);
template<> ::baikaldb::pb::ResourceTagInfo* Arena::CreateMaybeMessage<::baikaldb::pb::ResourceTagInfo>(Arena*);
template<> ::baikaldb::pb::RestoreRegionRequest* Arena::CreateMaybeMessage<::baikaldb::pb::RestoreRegionRequest>(Arena*);
template<> ::baikaldb::pb::SchemaHeartBeat* Arena::CreateMaybeMessage<::baikaldb::pb::SchemaHeartBeat>(Arena*);
template<> ::baikaldb::pb::SchemaInfo* Arena::CreateMaybeMessage<::baikaldb::pb::SchemaInfo>(Arena*);
template<> ::baikaldb::pb::SplitKey* Arena::CreateMaybeMessage<::baikaldb::pb::SplitKey>(Arena*);
template<> ::baikaldb::pb::StoreHeartBeatRequest* Arena::CreateMaybeMessage<::baikaldb::pb::StoreHeartBeatRequest>(Arena*);
template<> ::baikaldb::pb::StoreHeartBeatResponse* Arena::CreateMaybeMessage<::baikaldb::pb::StoreHeartBeatResponse>(Arena*);
template<> ::baikaldb::pb::StoreRegionDdlInfo* Arena::CreateMaybeMessage<::baikaldb::pb::StoreRegionDdlInfo>(Arena*);
template<> ::baikaldb::pb::TableHeartBeat* Arena::CreateMaybeMessage<::baikaldb::pb::TableHeartBeat>(Arena*);
template<> ::baikaldb::pb::TableInfo* Arena::CreateMaybeMessage<::baikaldb::pb::TableInfo>(Arena*);
template<> ::baikaldb::pb::TargetsList* Arena::CreateMaybeMessage<::baikaldb::pb::TargetsList>(Arena*);
template<> ::baikaldb::pb::TransLeaderRequest* Arena::CreateMaybeMessage<::baikaldb::pb::TransLeaderRequest>(Arena*);
template<> ::baikaldb::pb::TsoRequest* Arena::CreateMaybeMessage<::baikaldb::pb::TsoRequest>(Arena*);
template<> ::baikaldb::pb::TsoResponse* Arena::CreateMaybeMessage<::baikaldb::pb::TsoResponse>(Arena*);
template<> ::baikaldb::pb::TsoTimestamp* Arena::CreateMaybeMessage<::baikaldb::pb::TsoTimestamp>(Arena*);
template<> ::baikaldb::pb::UserPrivilege* Arena::CreateMaybeMessage<::baikaldb::pb::UserPrivilege>(Arena*);
template<> ::baikaldb::pb::VirtualIndexInfluence* Arena::CreateMaybeMessage<::baikaldb::pb::VirtualIndexInfluence>(Arena*);
template<> ::baikaldb::pb::VirtualInfoAndSqls* Arena::CreateMaybeMessage<::baikaldb::pb::VirtualInfoAndSqls>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace baikaldb {
namespace pb {

enum Status : int {
  NORMAL = 1,
  FAULTY = 2,
  DEAD = 3,
  MIGRATE = 4,
  FULL = 5,
  SLOW = 6,
  BUSY = 7
};
bool Status_IsValid(int value);
constexpr Status Status_MIN = NORMAL;
constexpr Status Status_MAX = BUSY;
constexpr int Status_ARRAYSIZE = Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Status_descriptor();
template<typename T>
inline const std::string& Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Status_descriptor(), enum_t_value);
}
inline bool Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
enum RegionStatus : int {
  IDLE = 1,
  DOING = 2
};
bool RegionStatus_IsValid(int value);
constexpr RegionStatus RegionStatus_MIN = IDLE;
constexpr RegionStatus RegionStatus_MAX = DOING;
constexpr int RegionStatus_ARRAYSIZE = RegionStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegionStatus_descriptor();
template<typename T>
inline const std::string& RegionStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegionStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegionStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RegionStatus_descriptor(), enum_t_value);
}
inline bool RegionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RegionStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RegionStatus>(
    RegionStatus_descriptor(), name, value);
}
enum IndexState : int {
  IS_PUBLIC = 1,
  IS_WRITE_LOCAL = 2,
  IS_WRITE_ONLY = 3,
  IS_DELETE_ONLY = 4,
  IS_DELETE_LOCAL = 5,
  IS_NONE = 6,
  IS_UNKNOWN = 7
};
bool IndexState_IsValid(int value);
constexpr IndexState IndexState_MIN = IS_PUBLIC;
constexpr IndexState IndexState_MAX = IS_UNKNOWN;
constexpr int IndexState_ARRAYSIZE = IndexState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndexState_descriptor();
template<typename T>
inline const std::string& IndexState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IndexState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IndexState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IndexState_descriptor(), enum_t_value);
}
inline bool IndexState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IndexState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IndexState>(
    IndexState_descriptor(), name, value);
}
enum IndexHintStatus : int {
  IHS_NORMAL = 1,
  IHS_DISABLE = 2,
  IHS_VIRTUAL = 3
};
bool IndexHintStatus_IsValid(int value);
constexpr IndexHintStatus IndexHintStatus_MIN = IHS_NORMAL;
constexpr IndexHintStatus IndexHintStatus_MAX = IHS_VIRTUAL;
constexpr int IndexHintStatus_ARRAYSIZE = IndexHintStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndexHintStatus_descriptor();
template<typename T>
inline const std::string& IndexHintStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IndexHintStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IndexHintStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IndexHintStatus_descriptor(), enum_t_value);
}
inline bool IndexHintStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IndexHintStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IndexHintStatus>(
    IndexHintStatus_descriptor(), name, value);
}
enum RollupType : int {
  SUM = 1
};
bool RollupType_IsValid(int value);
constexpr RollupType RollupType_MIN = SUM;
constexpr RollupType RollupType_MAX = SUM;
constexpr int RollupType_ARRAYSIZE = RollupType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RollupType_descriptor();
template<typename T>
inline const std::string& RollupType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RollupType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RollupType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RollupType_descriptor(), enum_t_value);
}
inline bool RollupType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RollupType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RollupType>(
    RollupType_descriptor(), name, value);
}
enum PartitionType : int {
  PT_HASH = 1,
  PT_RANGE = 2
};
bool PartitionType_IsValid(int value);
constexpr PartitionType PartitionType_MIN = PT_HASH;
constexpr PartitionType PartitionType_MAX = PT_RANGE;
constexpr int PartitionType_ARRAYSIZE = PartitionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PartitionType_descriptor();
template<typename T>
inline const std::string& PartitionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PartitionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PartitionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PartitionType_descriptor(), enum_t_value);
}
inline bool PartitionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PartitionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PartitionType>(
    PartitionType_descriptor(), name, value);
}
enum RangePartitionType : int {
  RPT_DEFAULT = 0,
  RPT_NEW_StatsEngine = 1,
  RPT_ADDITIONAL = 2
};
bool RangePartitionType_IsValid(int value);
constexpr RangePartitionType RangePartitionType_MIN = RPT_DEFAULT;
constexpr RangePartitionType RangePartitionType_MAX = RPT_ADDITIONAL;
constexpr int RangePartitionType_ARRAYSIZE = RangePartitionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RangePartitionType_descriptor();
template<typename T>
inline const std::string& RangePartitionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RangePartitionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RangePartitionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RangePartitionType_descriptor(), enum_t_value);
}
inline bool RangePartitionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RangePartitionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RangePartitionType>(
    RangePartitionType_descriptor(), name, value);
}
enum DBLinkType : int {
  LT_BAIKALDB = 1,
  LT_MYSQL = 2
};
bool DBLinkType_IsValid(int value);
constexpr DBLinkType DBLinkType_MIN = LT_BAIKALDB;
constexpr DBLinkType DBLinkType_MAX = LT_MYSQL;
constexpr int DBLinkType_ARRAYSIZE = DBLinkType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DBLinkType_descriptor();
template<typename T>
inline const std::string& DBLinkType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DBLinkType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DBLinkType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DBLinkType_descriptor(), enum_t_value);
}
inline bool DBLinkType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DBLinkType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DBLinkType>(
    DBLinkType_descriptor(), name, value);
}
enum IndexType : int {
  I_NONE = 0,
  I_PRIMARY = 1,
  I_UNIQ = 2,
  I_KEY = 3,
  I_FULLTEXT = 4,
  I_VECTOR = 5,
  I_ROLLUP = 6
};
bool IndexType_IsValid(int value);
constexpr IndexType IndexType_MIN = I_NONE;
constexpr IndexType IndexType_MAX = I_ROLLUP;
constexpr int IndexType_ARRAYSIZE = IndexType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndexType_descriptor();
template<typename T>
inline const std::string& IndexType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IndexType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IndexType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IndexType_descriptor(), enum_t_value);
}
inline bool IndexType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IndexType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IndexType>(
    IndexType_descriptor(), name, value);
}
enum SegmentType : int {
  S_DEFAULT = 0,
  S_NO_SEGMENT = 1,
  S_WORDRANK = 2,
  S_WORDSEG_BASIC = 3,
  S_UNIGRAMS = 4,
  S_BIGRAMS = 5,
  S_ES_STANDARD = 6,
  S_WORDRANK_Q2B_ICASE = 7,
  S_WORDWEIGHT = 8,
  S_WORDWEIGHT_NO_FILTER = 9,
  S_WORDRANK_Q2B_ICASE_UNLIMIT = 10,
  S_WORDWEIGHT_NO_FILTER_SAME_WEIGHT = 11
};
bool SegmentType_IsValid(int value);
constexpr SegmentType SegmentType_MIN = S_DEFAULT;
constexpr SegmentType SegmentType_MAX = S_WORDWEIGHT_NO_FILTER_SAME_WEIGHT;
constexpr int SegmentType_ARRAYSIZE = SegmentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SegmentType_descriptor();
template<typename T>
inline const std::string& SegmentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SegmentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SegmentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SegmentType_descriptor(), enum_t_value);
}
inline bool SegmentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SegmentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SegmentType>(
    SegmentType_descriptor(), name, value);
}
enum StorageType : int {
  ST_PROTOBUF_OR_FORMAT1 = 0,
  ST_ARROW = 1,
  ST_FORMAT2 = 2,
  ST_UNKNOWN = 3
};
bool StorageType_IsValid(int value);
constexpr StorageType StorageType_MIN = ST_PROTOBUF_OR_FORMAT1;
constexpr StorageType StorageType_MAX = ST_UNKNOWN;
constexpr int StorageType_ARRAYSIZE = StorageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StorageType_descriptor();
template<typename T>
inline const std::string& StorageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StorageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StorageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StorageType_descriptor(), enum_t_value);
}
inline bool StorageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StorageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StorageType>(
    StorageType_descriptor(), name, value);
}
enum MetricType : int {
  METRIC_INNER_PRODUCT = 0,
  METRIC_L2 = 1
};
bool MetricType_IsValid(int value);
constexpr MetricType MetricType_MIN = METRIC_INNER_PRODUCT;
constexpr MetricType MetricType_MAX = METRIC_L2;
constexpr int MetricType_ARRAYSIZE = MetricType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MetricType_descriptor();
template<typename T>
inline const std::string& MetricType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MetricType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MetricType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MetricType_descriptor(), enum_t_value);
}
inline bool MetricType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MetricType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MetricType>(
    MetricType_descriptor(), name, value);
}
enum RW : int {
  READ = 1,
  WRITE = 2
};
bool RW_IsValid(int value);
constexpr RW RW_MIN = READ;
constexpr RW RW_MAX = WRITE;
constexpr int RW_ARRAYSIZE = RW_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RW_descriptor();
template<typename T>
inline const std::string& RW_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RW>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RW_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RW_descriptor(), enum_t_value);
}
inline bool RW_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RW* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RW>(
    RW_descriptor(), name, value);
}
enum RecoverOpt : int {
  DO_NONE = 0,
  DO_REMOVE_ILLEGAL_PEER = 1,
  DO_REMOVE_PEER = 2,
  DO_SET_PEER = 3,
  DO_INIT_REGION = 4
};
bool RecoverOpt_IsValid(int value);
constexpr RecoverOpt RecoverOpt_MIN = DO_NONE;
constexpr RecoverOpt RecoverOpt_MAX = DO_INIT_REGION;
constexpr int RecoverOpt_ARRAYSIZE = RecoverOpt_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecoverOpt_descriptor();
template<typename T>
inline const std::string& RecoverOpt_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RecoverOpt>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RecoverOpt_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RecoverOpt_descriptor(), enum_t_value);
}
inline bool RecoverOpt_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RecoverOpt* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecoverOpt>(
    RecoverOpt_descriptor(), name, value);
}
enum PeerStatus : int {
  STATUS_NORMAL = 0,
  STATUS_UNSTABLE = 1,
  STATUS_ERROR = 3,
  STATUS_ILLEGAL_PEER = 4,
  STATUS_NOT_HEARTBEAT = 5,
  STATUS_NO_LEADER = 6,
  STATUS_SET_PEER = 7,
  STATUS_INITED = 8
};
bool PeerStatus_IsValid(int value);
constexpr PeerStatus PeerStatus_MIN = STATUS_NORMAL;
constexpr PeerStatus PeerStatus_MAX = STATUS_INITED;
constexpr int PeerStatus_ARRAYSIZE = PeerStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PeerStatus_descriptor();
template<typename T>
inline const std::string& PeerStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PeerStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PeerStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PeerStatus_descriptor(), enum_t_value);
}
inline bool PeerStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PeerStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PeerStatus>(
    PeerStatus_descriptor(), name, value);
}
enum QueryOpType : int {
  QUERY_LOGICAL = 1,
  QUERY_PHYSICAL = 2,
  QUERY_INSTANCE = 3,
  QUERY_USERPRIVILEG = 4,
  QUERY_NAMESPACE = 5,
  QUERY_DATABASE = 6,
  QUERY_SCHEMA = 7,
  QUERY_REGION = 8,
  QUERY_INSTANCE_FLATTEN = 101,
  QUERY_PRIVILEGE_FLATTEN = 102,
  QUERY_REGION_FLATTEN = 103,
  QUERY_TABLE_FLATTEN = 104,
  QUERY_SCHEMA_FLATTEN = 105,
  QUERY_TRANSFER_LEADER = 201,
  QUERY_SET_PEER = 202,
  QUERY_DIFF_REGION_IDS = 301,
  QUERY_REGION_IDS = 302,
  QUERY_DDLWORK = 303,
  QUERY_REGION_PEER_STATUS = 304,
  QUERY_INSTANCE_PARAM = 305,
  QUERY_INDEX_DDL_WORK = 306,
  QUERY_NETWORK_SEGMENT = 307,
  QUERY_RESOURCE_TAG_SWITCH = 308,
  QUERY_SHOW_VIRINDX_INFO_SQL = 309,
  QUERY_REGION_LEARNER_STATUS = 310,
  QUERY_FAST_IMPORTER_TABLES = 311,
  QUERY_BINLOG_TIMESTAMPS = 312
};
bool QueryOpType_IsValid(int value);
constexpr QueryOpType QueryOpType_MIN = QUERY_LOGICAL;
constexpr QueryOpType QueryOpType_MAX = QUERY_BINLOG_TIMESTAMPS;
constexpr int QueryOpType_ARRAYSIZE = QueryOpType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QueryOpType_descriptor();
template<typename T>
inline const std::string& QueryOpType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QueryOpType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QueryOpType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QueryOpType_descriptor(), enum_t_value);
}
inline bool QueryOpType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, QueryOpType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QueryOpType>(
    QueryOpType_descriptor(), name, value);
}
enum DdlWorkStatus : int {
  DdlWorkIdle = 1,
  DdlWorkDoing = 2,
  DdlWorkDone = 3,
  DdlWorkFail = 4,
  DdlWorkDupUniq = 5,
  DdlWorkError = 6
};
bool DdlWorkStatus_IsValid(int value);
constexpr DdlWorkStatus DdlWorkStatus_MIN = DdlWorkIdle;
constexpr DdlWorkStatus DdlWorkStatus_MAX = DdlWorkError;
constexpr int DdlWorkStatus_ARRAYSIZE = DdlWorkStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DdlWorkStatus_descriptor();
template<typename T>
inline const std::string& DdlWorkStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DdlWorkStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DdlWorkStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DdlWorkStatus_descriptor(), enum_t_value);
}
inline bool DdlWorkStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DdlWorkStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DdlWorkStatus>(
    DdlWorkStatus_descriptor(), name, value);
}
// ===================================================================

class NameSpaceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.NameSpaceInfo) */ {
 public:
  inline NameSpaceInfo() : NameSpaceInfo(nullptr) {}
  ~NameSpaceInfo() override;
  explicit constexpr NameSpaceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NameSpaceInfo(const NameSpaceInfo& from);
  NameSpaceInfo(NameSpaceInfo&& from) noexcept
    : NameSpaceInfo() {
    *this = ::std::move(from);
  }

  inline NameSpaceInfo& operator=(const NameSpaceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NameSpaceInfo& operator=(NameSpaceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NameSpaceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NameSpaceInfo* internal_default_instance() {
    return reinterpret_cast<const NameSpaceInfo*>(
               &_NameSpaceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NameSpaceInfo& a, NameSpaceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NameSpaceInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NameSpaceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NameSpaceInfo* New() const final {
    return new NameSpaceInfo();
  }

  NameSpaceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NameSpaceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NameSpaceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NameSpaceInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NameSpaceInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.NameSpaceInfo";
  }
  protected:
  explicit NameSpaceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDistsFieldNumber = 14,
    kLearnerResourceTagsFieldNumber = 16,
    kBinlogInfosFieldNumber = 17,
    kNamespaceNameFieldNumber = 1,
    kResourceTagFieldNumber = 6,
    kMainLogicalRoomFieldNumber = 15,
    kNamespaceIdFieldNumber = 2,
    kQuotaFieldNumber = 3,
    kVersionFieldNumber = 4,
    kCharsetFieldNumber = 8,
    kDeletedFieldNumber = 5,
    kIfExistFieldNumber = 13,
    kByteSizePerRecordFieldNumber = 9,
    kReplicaNumFieldNumber = 10,
    kRegionSplitLinesFieldNumber = 11,
    kEngineFieldNumber = 7,
  };
  // repeated .baikaldb.pb.ReplicaDist dists = 14;
  int dists_size() const;
  private:
  int _internal_dists_size() const;
  public:
  void clear_dists();
  ::baikaldb::pb::ReplicaDist* mutable_dists(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ReplicaDist >*
      mutable_dists();
  private:
  const ::baikaldb::pb::ReplicaDist& _internal_dists(int index) const;
  ::baikaldb::pb::ReplicaDist* _internal_add_dists();
  public:
  const ::baikaldb::pb::ReplicaDist& dists(int index) const;
  ::baikaldb::pb::ReplicaDist* add_dists();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ReplicaDist >&
      dists() const;

  // repeated string learner_resource_tags = 16;
  int learner_resource_tags_size() const;
  private:
  int _internal_learner_resource_tags_size() const;
  public:
  void clear_learner_resource_tags();
  const std::string& learner_resource_tags(int index) const;
  std::string* mutable_learner_resource_tags(int index);
  void set_learner_resource_tags(int index, const std::string& value);
  void set_learner_resource_tags(int index, std::string&& value);
  void set_learner_resource_tags(int index, const char* value);
  void set_learner_resource_tags(int index, const char* value, size_t size);
  std::string* add_learner_resource_tags();
  void add_learner_resource_tags(const std::string& value);
  void add_learner_resource_tags(std::string&& value);
  void add_learner_resource_tags(const char* value);
  void add_learner_resource_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& learner_resource_tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_learner_resource_tags();
  private:
  const std::string& _internal_learner_resource_tags(int index) const;
  std::string* _internal_add_learner_resource_tags();
  public:

  // repeated .baikaldb.pb.BinlogInfo binlog_infos = 17;
  int binlog_infos_size() const;
  private:
  int _internal_binlog_infos_size() const;
  public:
  void clear_binlog_infos();
  ::baikaldb::pb::BinlogInfo* mutable_binlog_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogInfo >*
      mutable_binlog_infos();
  private:
  const ::baikaldb::pb::BinlogInfo& _internal_binlog_infos(int index) const;
  ::baikaldb::pb::BinlogInfo* _internal_add_binlog_infos();
  public:
  const ::baikaldb::pb::BinlogInfo& binlog_infos(int index) const;
  ::baikaldb::pb::BinlogInfo* add_binlog_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogInfo >&
      binlog_infos() const;

  // required string namespace_name = 1;
  bool has_namespace_name() const;
  private:
  bool _internal_has_namespace_name() const;
  public:
  void clear_namespace_name();
  const std::string& namespace_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_namespace_name();
  void set_allocated_namespace_name(std::string* namespace_name);
  private:
  const std::string& _internal_namespace_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_name(const std::string& value);
  std::string* _internal_mutable_namespace_name();
  public:

  // optional string resource_tag = 6;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional string main_logical_room = 15;
  bool has_main_logical_room() const;
  private:
  bool _internal_has_main_logical_room() const;
  public:
  void clear_main_logical_room();
  const std::string& main_logical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_main_logical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_main_logical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_main_logical_room();
  void set_allocated_main_logical_room(std::string* main_logical_room);
  private:
  const std::string& _internal_main_logical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_main_logical_room(const std::string& value);
  std::string* _internal_mutable_main_logical_room();
  public:

  // optional int64 namespace_id = 2;
  bool has_namespace_id() const;
  private:
  bool _internal_has_namespace_id() const;
  public:
  void clear_namespace_id();
  ::PROTOBUF_NAMESPACE_ID::int64 namespace_id() const;
  void set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_namespace_id() const;
  void _internal_set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 quota = 3;
  bool has_quota() const;
  private:
  bool _internal_has_quota() const;
  public:
  void clear_quota();
  ::PROTOBUF_NAMESPACE_ID::int64 quota() const;
  void set_quota(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_quota() const;
  void _internal_set_quota(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 version = 4;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.Charset charset = 8;
  bool has_charset() const;
  private:
  bool _internal_has_charset() const;
  public:
  void clear_charset();
  ::baikaldb::pb::Charset charset() const;
  void set_charset(::baikaldb::pb::Charset value);
  private:
  ::baikaldb::pb::Charset _internal_charset() const;
  void _internal_set_charset(::baikaldb::pb::Charset value);
  public:

  // optional bool deleted = 5;
  bool has_deleted() const;
  private:
  bool _internal_has_deleted() const;
  public:
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // optional bool if_exist = 13;
  bool has_if_exist() const;
  private:
  bool _internal_has_if_exist() const;
  public:
  void clear_if_exist();
  bool if_exist() const;
  void set_if_exist(bool value);
  private:
  bool _internal_if_exist() const;
  void _internal_set_if_exist(bool value);
  public:

  // optional int64 byte_size_per_record = 9;
  bool has_byte_size_per_record() const;
  private:
  bool _internal_has_byte_size_per_record() const;
  public:
  void clear_byte_size_per_record();
  ::PROTOBUF_NAMESPACE_ID::int64 byte_size_per_record() const;
  void set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_byte_size_per_record() const;
  void _internal_set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 replica_num = 10;
  bool has_replica_num() const;
  private:
  bool _internal_has_replica_num() const;
  public:
  void clear_replica_num();
  ::PROTOBUF_NAMESPACE_ID::int64 replica_num() const;
  void set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_replica_num() const;
  void _internal_set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_split_lines = 11;
  bool has_region_split_lines() const;
  private:
  bool _internal_has_region_split_lines() const;
  public:
  void clear_region_split_lines();
  ::PROTOBUF_NAMESPACE_ID::int64 region_split_lines() const;
  void set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_split_lines() const;
  void _internal_set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.Engine engine = 7;
  bool has_engine() const;
  private:
  bool _internal_has_engine() const;
  public:
  void clear_engine();
  ::baikaldb::pb::Engine engine() const;
  void set_engine(::baikaldb::pb::Engine value);
  private:
  ::baikaldb::pb::Engine _internal_engine() const;
  void _internal_set_engine(::baikaldb::pb::Engine value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.NameSpaceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ReplicaDist > dists_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> learner_resource_tags_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogInfo > binlog_infos_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr main_logical_room_;
  ::PROTOBUF_NAMESPACE_ID::int64 namespace_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 quota_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  int charset_;
  bool deleted_;
  bool if_exist_;
  ::PROTOBUF_NAMESPACE_ID::int64 byte_size_per_record_;
  ::PROTOBUF_NAMESPACE_ID::int64 replica_num_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_split_lines_;
  int engine_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class DataBaseInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.DataBaseInfo) */ {
 public:
  inline DataBaseInfo() : DataBaseInfo(nullptr) {}
  ~DataBaseInfo() override;
  explicit constexpr DataBaseInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataBaseInfo(const DataBaseInfo& from);
  DataBaseInfo(DataBaseInfo&& from) noexcept
    : DataBaseInfo() {
    *this = ::std::move(from);
  }

  inline DataBaseInfo& operator=(const DataBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataBaseInfo& operator=(DataBaseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataBaseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataBaseInfo* internal_default_instance() {
    return reinterpret_cast<const DataBaseInfo*>(
               &_DataBaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DataBaseInfo& a, DataBaseInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DataBaseInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataBaseInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataBaseInfo* New() const final {
    return new DataBaseInfo();
  }

  DataBaseInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataBaseInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataBaseInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataBaseInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataBaseInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.DataBaseInfo";
  }
  protected:
  explicit DataBaseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDistsFieldNumber = 14,
    kLearnerResourceTagsFieldNumber = 16,
    kBinlogInfosFieldNumber = 17,
    kDatabaseFieldNumber = 1,
    kNamespaceNameFieldNumber = 3,
    kResourceTagFieldNumber = 8,
    kMainLogicalRoomFieldNumber = 15,
    kPartitionInfoStrFieldNumber = 18,
    kDatabaseIdFieldNumber = 2,
    kNamespaceIdFieldNumber = 4,
    kQuotaFieldNumber = 5,
    kVersionFieldNumber = 6,
    kDeletedFieldNumber = 7,
    kCharsetFieldNumber = 10,
    kByteSizePerRecordFieldNumber = 11,
    kReplicaNumFieldNumber = 12,
    kRegionSplitLinesFieldNumber = 13,
    kEngineFieldNumber = 9,
  };
  // repeated .baikaldb.pb.ReplicaDist dists = 14;
  int dists_size() const;
  private:
  int _internal_dists_size() const;
  public:
  void clear_dists();
  ::baikaldb::pb::ReplicaDist* mutable_dists(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ReplicaDist >*
      mutable_dists();
  private:
  const ::baikaldb::pb::ReplicaDist& _internal_dists(int index) const;
  ::baikaldb::pb::ReplicaDist* _internal_add_dists();
  public:
  const ::baikaldb::pb::ReplicaDist& dists(int index) const;
  ::baikaldb::pb::ReplicaDist* add_dists();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ReplicaDist >&
      dists() const;

  // repeated string learner_resource_tags = 16;
  int learner_resource_tags_size() const;
  private:
  int _internal_learner_resource_tags_size() const;
  public:
  void clear_learner_resource_tags();
  const std::string& learner_resource_tags(int index) const;
  std::string* mutable_learner_resource_tags(int index);
  void set_learner_resource_tags(int index, const std::string& value);
  void set_learner_resource_tags(int index, std::string&& value);
  void set_learner_resource_tags(int index, const char* value);
  void set_learner_resource_tags(int index, const char* value, size_t size);
  std::string* add_learner_resource_tags();
  void add_learner_resource_tags(const std::string& value);
  void add_learner_resource_tags(std::string&& value);
  void add_learner_resource_tags(const char* value);
  void add_learner_resource_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& learner_resource_tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_learner_resource_tags();
  private:
  const std::string& _internal_learner_resource_tags(int index) const;
  std::string* _internal_add_learner_resource_tags();
  public:

  // repeated .baikaldb.pb.BinlogInfo binlog_infos = 17;
  int binlog_infos_size() const;
  private:
  int _internal_binlog_infos_size() const;
  public:
  void clear_binlog_infos();
  ::baikaldb::pb::BinlogInfo* mutable_binlog_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogInfo >*
      mutable_binlog_infos();
  private:
  const ::baikaldb::pb::BinlogInfo& _internal_binlog_infos(int index) const;
  ::baikaldb::pb::BinlogInfo* _internal_add_binlog_infos();
  public:
  const ::baikaldb::pb::BinlogInfo& binlog_infos(int index) const;
  ::baikaldb::pb::BinlogInfo* add_binlog_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogInfo >&
      binlog_infos() const;

  // required string database = 1;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_MUST_USE_RESULT std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // required string namespace_name = 3;
  bool has_namespace_name() const;
  private:
  bool _internal_has_namespace_name() const;
  public:
  void clear_namespace_name();
  const std::string& namespace_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_namespace_name();
  void set_allocated_namespace_name(std::string* namespace_name);
  private:
  const std::string& _internal_namespace_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_name(const std::string& value);
  std::string* _internal_mutable_namespace_name();
  public:

  // optional string resource_tag = 8;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional string main_logical_room = 15;
  bool has_main_logical_room() const;
  private:
  bool _internal_has_main_logical_room() const;
  public:
  void clear_main_logical_room();
  const std::string& main_logical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_main_logical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_main_logical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_main_logical_room();
  void set_allocated_main_logical_room(std::string* main_logical_room);
  private:
  const std::string& _internal_main_logical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_main_logical_room(const std::string& value);
  std::string* _internal_mutable_main_logical_room();
  public:

  // optional string partition_info_str = 18;
  bool has_partition_info_str() const;
  private:
  bool _internal_has_partition_info_str() const;
  public:
  void clear_partition_info_str();
  const std::string& partition_info_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partition_info_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partition_info_str();
  PROTOBUF_MUST_USE_RESULT std::string* release_partition_info_str();
  void set_allocated_partition_info_str(std::string* partition_info_str);
  private:
  const std::string& _internal_partition_info_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_info_str(const std::string& value);
  std::string* _internal_mutable_partition_info_str();
  public:

  // optional int64 database_id = 2;
  bool has_database_id() const;
  private:
  bool _internal_has_database_id() const;
  public:
  void clear_database_id();
  ::PROTOBUF_NAMESPACE_ID::int64 database_id() const;
  void set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_database_id() const;
  void _internal_set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 namespace_id = 4;
  bool has_namespace_id() const;
  private:
  bool _internal_has_namespace_id() const;
  public:
  void clear_namespace_id();
  ::PROTOBUF_NAMESPACE_ID::int64 namespace_id() const;
  void set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_namespace_id() const;
  void _internal_set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 quota = 5;
  bool has_quota() const;
  private:
  bool _internal_has_quota() const;
  public:
  void clear_quota();
  ::PROTOBUF_NAMESPACE_ID::int64 quota() const;
  void set_quota(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_quota() const;
  void _internal_set_quota(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 version = 6;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool deleted = 7;
  bool has_deleted() const;
  private:
  bool _internal_has_deleted() const;
  public:
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // optional .baikaldb.pb.Charset charset = 10;
  bool has_charset() const;
  private:
  bool _internal_has_charset() const;
  public:
  void clear_charset();
  ::baikaldb::pb::Charset charset() const;
  void set_charset(::baikaldb::pb::Charset value);
  private:
  ::baikaldb::pb::Charset _internal_charset() const;
  void _internal_set_charset(::baikaldb::pb::Charset value);
  public:

  // optional int64 byte_size_per_record = 11;
  bool has_byte_size_per_record() const;
  private:
  bool _internal_has_byte_size_per_record() const;
  public:
  void clear_byte_size_per_record();
  ::PROTOBUF_NAMESPACE_ID::int64 byte_size_per_record() const;
  void set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_byte_size_per_record() const;
  void _internal_set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 replica_num = 12;
  bool has_replica_num() const;
  private:
  bool _internal_has_replica_num() const;
  public:
  void clear_replica_num();
  ::PROTOBUF_NAMESPACE_ID::int64 replica_num() const;
  void set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_replica_num() const;
  void _internal_set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_split_lines = 13;
  bool has_region_split_lines() const;
  private:
  bool _internal_has_region_split_lines() const;
  public:
  void clear_region_split_lines();
  ::PROTOBUF_NAMESPACE_ID::int64 region_split_lines() const;
  void set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_split_lines() const;
  void _internal_set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.Engine engine = 9;
  bool has_engine() const;
  private:
  bool _internal_has_engine() const;
  public:
  void clear_engine();
  ::baikaldb::pb::Engine engine() const;
  void set_engine(::baikaldb::pb::Engine value);
  private:
  ::baikaldb::pb::Engine _internal_engine() const;
  void _internal_set_engine(::baikaldb::pb::Engine value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.DataBaseInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ReplicaDist > dists_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> learner_resource_tags_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogInfo > binlog_infos_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr main_logical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_info_str_;
  ::PROTOBUF_NAMESPACE_ID::int64 database_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 namespace_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 quota_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  bool deleted_;
  int charset_;
  ::PROTOBUF_NAMESPACE_ID::int64 byte_size_per_record_;
  ::PROTOBUF_NAMESPACE_ID::int64 replica_num_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_split_lines_;
  int engine_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class ReplicaDist final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ReplicaDist) */ {
 public:
  inline ReplicaDist() : ReplicaDist(nullptr) {}
  ~ReplicaDist() override;
  explicit constexpr ReplicaDist(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplicaDist(const ReplicaDist& from);
  ReplicaDist(ReplicaDist&& from) noexcept
    : ReplicaDist() {
    *this = ::std::move(from);
  }

  inline ReplicaDist& operator=(const ReplicaDist& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicaDist& operator=(ReplicaDist&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplicaDist& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplicaDist* internal_default_instance() {
    return reinterpret_cast<const ReplicaDist*>(
               &_ReplicaDist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ReplicaDist& a, ReplicaDist& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplicaDist* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplicaDist* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReplicaDist* New() const final {
    return new ReplicaDist();
  }

  ReplicaDist* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReplicaDist>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplicaDist& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReplicaDist& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplicaDist* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ReplicaDist";
  }
  protected:
  explicit ReplicaDist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalRoomFieldNumber = 1,
    kResourceTagFieldNumber = 3,
    kPhysicalRoomFieldNumber = 4,
    kCountFieldNumber = 2,
  };
  // optional string logical_room = 1;
  bool has_logical_room() const;
  private:
  bool _internal_has_logical_room() const;
  public:
  void clear_logical_room();
  const std::string& logical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_logical_room();
  void set_allocated_logical_room(std::string* logical_room);
  private:
  const std::string& _internal_logical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logical_room(const std::string& value);
  std::string* _internal_mutable_logical_room();
  public:

  // optional string resource_tag = 3;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional string physical_room = 4;
  bool has_physical_room() const;
  private:
  bool _internal_has_physical_room() const;
  public:
  void clear_physical_room();
  const std::string& physical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_physical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_physical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_physical_room();
  void set_allocated_physical_room(std::string* physical_room);
  private:
  const std::string& _internal_physical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_physical_room(const std::string& value);
  std::string* _internal_mutable_physical_room();
  public:

  // required int64 count = 2;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int64 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ReplicaDist)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr physical_room_;
  ::PROTOBUF_NAMESPACE_ID::int64 count_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class SplitKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.SplitKey) */ {
 public:
  inline SplitKey() : SplitKey(nullptr) {}
  ~SplitKey() override;
  explicit constexpr SplitKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SplitKey(const SplitKey& from);
  SplitKey(SplitKey&& from) noexcept
    : SplitKey() {
    *this = ::std::move(from);
  }

  inline SplitKey& operator=(const SplitKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline SplitKey& operator=(SplitKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SplitKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const SplitKey* internal_default_instance() {
    return reinterpret_cast<const SplitKey*>(
               &_SplitKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SplitKey& a, SplitKey& b) {
    a.Swap(&b);
  }
  inline void Swap(SplitKey* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SplitKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SplitKey* New() const final {
    return new SplitKey();
  }

  SplitKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SplitKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SplitKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SplitKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SplitKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.SplitKey";
  }
  protected:
  explicit SplitKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSplitKeysFieldNumber = 2,
    kIndexNameFieldNumber = 1,
  };
  // repeated bytes split_keys = 2;
  int split_keys_size() const;
  private:
  int _internal_split_keys_size() const;
  public:
  void clear_split_keys();
  const std::string& split_keys(int index) const;
  std::string* mutable_split_keys(int index);
  void set_split_keys(int index, const std::string& value);
  void set_split_keys(int index, std::string&& value);
  void set_split_keys(int index, const char* value);
  void set_split_keys(int index, const void* value, size_t size);
  std::string* add_split_keys();
  void add_split_keys(const std::string& value);
  void add_split_keys(std::string&& value);
  void add_split_keys(const char* value);
  void add_split_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& split_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_split_keys();
  private:
  const std::string& _internal_split_keys(int index) const;
  std::string* _internal_add_split_keys();
  public:

  // optional bytes index_name = 1;
  bool has_index_name() const;
  private:
  bool _internal_has_index_name() const;
  public:
  void clear_index_name();
  const std::string& index_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_index_name();
  void set_allocated_index_name(std::string* index_name);
  private:
  const std::string& _internal_index_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index_name(const std::string& value);
  std::string* _internal_mutable_index_name();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.SplitKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> split_keys_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_name_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BinlogInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BinlogInfo) */ {
 public:
  inline BinlogInfo() : BinlogInfo(nullptr) {}
  ~BinlogInfo() override;
  explicit constexpr BinlogInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinlogInfo(const BinlogInfo& from);
  BinlogInfo(BinlogInfo&& from) noexcept
    : BinlogInfo() {
    *this = ::std::move(from);
  }

  inline BinlogInfo& operator=(const BinlogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinlogInfo& operator=(BinlogInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinlogInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinlogInfo* internal_default_instance() {
    return reinterpret_cast<const BinlogInfo*>(
               &_BinlogInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BinlogInfo& a, BinlogInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BinlogInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinlogInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinlogInfo* New() const final {
    return new BinlogInfo();
  }

  BinlogInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinlogInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinlogInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BinlogInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinlogInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BinlogInfo";
  }
  protected:
  explicit BinlogInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetTableIdsFieldNumber = 1,
    kDatabaseFieldNumber = 5,
    kTableNameFieldNumber = 6,
    kLinkFieldFieldNumber = 3,
    kBinlogTableIdFieldNumber = 2,
    kPartitionIsSameHintFieldNumber = 4,
  };
  // repeated int64 target_table_ids = 1;
  int target_table_ids_size() const;
  private:
  int _internal_target_table_ids_size() const;
  public:
  void clear_target_table_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_target_table_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_target_table_ids() const;
  void _internal_add_target_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_target_table_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 target_table_ids(int index) const;
  void set_target_table_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_target_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      target_table_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_target_table_ids();

  // optional string database = 5;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_MUST_USE_RESULT std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // optional string table_name = 6;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional .baikaldb.pb.FieldInfo link_field = 3;
  bool has_link_field() const;
  private:
  bool _internal_has_link_field() const;
  public:
  void clear_link_field();
  const ::baikaldb::pb::FieldInfo& link_field() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::FieldInfo* release_link_field();
  ::baikaldb::pb::FieldInfo* mutable_link_field();
  void set_allocated_link_field(::baikaldb::pb::FieldInfo* link_field);
  private:
  const ::baikaldb::pb::FieldInfo& _internal_link_field() const;
  ::baikaldb::pb::FieldInfo* _internal_mutable_link_field();
  public:
  void unsafe_arena_set_allocated_link_field(
      ::baikaldb::pb::FieldInfo* link_field);
  ::baikaldb::pb::FieldInfo* unsafe_arena_release_link_field();

  // optional int64 binlog_table_id = 2;
  bool has_binlog_table_id() const;
  private:
  bool _internal_has_binlog_table_id() const;
  public:
  void clear_binlog_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 binlog_table_id() const;
  void set_binlog_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_binlog_table_id() const;
  void _internal_set_binlog_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool partition_is_same_hint = 4;
  bool has_partition_is_same_hint() const;
  private:
  bool _internal_has_partition_is_same_hint() const;
  public:
  void clear_partition_is_same_hint();
  bool partition_is_same_hint() const;
  void set_partition_is_same_hint(bool value);
  private:
  bool _internal_partition_is_same_hint() const;
  void _internal_set_partition_is_same_hint(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BinlogInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > target_table_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::baikaldb::pb::FieldInfo* link_field_;
  ::PROTOBUF_NAMESPACE_ID::int64 binlog_table_id_;
  bool partition_is_same_hint_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class PartitionRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.PartitionRange) */ {
 public:
  inline PartitionRange() : PartitionRange(nullptr) {}
  ~PartitionRange() override;
  explicit constexpr PartitionRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionRange(const PartitionRange& from);
  PartitionRange(PartitionRange&& from) noexcept
    : PartitionRange() {
    *this = ::std::move(from);
  }

  inline PartitionRange& operator=(const PartitionRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionRange& operator=(PartitionRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionRange* internal_default_instance() {
    return reinterpret_cast<const PartitionRange*>(
               &_PartitionRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PartitionRange& a, PartitionRange& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionRange* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartitionRange* New() const final {
    return new PartitionRange();
  }

  PartitionRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartitionRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartitionRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PartitionRange& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.PartitionRange";
  }
  protected:
  explicit PartitionRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftValueFieldNumber = 1,
    kRightValueFieldNumber = 2,
  };
  // optional .baikaldb.pb.Expr left_value = 1;
  bool has_left_value() const;
  private:
  bool _internal_has_left_value() const;
  public:
  void clear_left_value();
  const ::baikaldb::pb::Expr& left_value() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::Expr* release_left_value();
  ::baikaldb::pb::Expr* mutable_left_value();
  void set_allocated_left_value(::baikaldb::pb::Expr* left_value);
  private:
  const ::baikaldb::pb::Expr& _internal_left_value() const;
  ::baikaldb::pb::Expr* _internal_mutable_left_value();
  public:
  void unsafe_arena_set_allocated_left_value(
      ::baikaldb::pb::Expr* left_value);
  ::baikaldb::pb::Expr* unsafe_arena_release_left_value();

  // optional .baikaldb.pb.Expr right_value = 2;
  bool has_right_value() const;
  private:
  bool _internal_has_right_value() const;
  public:
  void clear_right_value();
  const ::baikaldb::pb::Expr& right_value() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::Expr* release_right_value();
  ::baikaldb::pb::Expr* mutable_right_value();
  void set_allocated_right_value(::baikaldb::pb::Expr* right_value);
  private:
  const ::baikaldb::pb::Expr& _internal_right_value() const;
  ::baikaldb::pb::Expr* _internal_mutable_right_value();
  public:
  void unsafe_arena_set_allocated_right_value(
      ::baikaldb::pb::Expr* right_value);
  ::baikaldb::pb::Expr* unsafe_arena_release_right_value();

  // @@protoc_insertion_point(class_scope:baikaldb.pb.PartitionRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::Expr* left_value_;
  ::baikaldb::pb::Expr* right_value_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RangePartitionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RangePartitionInfo) */ {
 public:
  inline RangePartitionInfo() : RangePartitionInfo(nullptr) {}
  ~RangePartitionInfo() override;
  explicit constexpr RangePartitionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RangePartitionInfo(const RangePartitionInfo& from);
  RangePartitionInfo(RangePartitionInfo&& from) noexcept
    : RangePartitionInfo() {
    *this = ::std::move(from);
  }

  inline RangePartitionInfo& operator=(const RangePartitionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangePartitionInfo& operator=(RangePartitionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangePartitionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangePartitionInfo* internal_default_instance() {
    return reinterpret_cast<const RangePartitionInfo*>(
               &_RangePartitionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RangePartitionInfo& a, RangePartitionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RangePartitionInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangePartitionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RangePartitionInfo* New() const final {
    return new RangePartitionInfo();
  }

  RangePartitionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RangePartitionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RangePartitionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RangePartitionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangePartitionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RangePartitionInfo";
  }
  protected:
  explicit RangePartitionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSplitKeysFieldNumber = 7,
    kPartitionNameFieldNumber = 2,
    kResourceTagFieldNumber = 5,
    kLessValueFieldNumber = 3,
    kRangeFieldNumber = 4,
    kPartitionIdFieldNumber = 1,
    kIsColdFieldNumber = 6,
    kIsPreSplitFieldNumber = 9,
    kTypeFieldNumber = 8,
  };
  // repeated .baikaldb.pb.SplitKey split_keys = 7;
  int split_keys_size() const;
  private:
  int _internal_split_keys_size() const;
  public:
  void clear_split_keys();
  ::baikaldb::pb::SplitKey* mutable_split_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SplitKey >*
      mutable_split_keys();
  private:
  const ::baikaldb::pb::SplitKey& _internal_split_keys(int index) const;
  ::baikaldb::pb::SplitKey* _internal_add_split_keys();
  public:
  const ::baikaldb::pb::SplitKey& split_keys(int index) const;
  ::baikaldb::pb::SplitKey* add_split_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SplitKey >&
      split_keys() const;

  // optional string partition_name = 2;
  bool has_partition_name() const;
  private:
  bool _internal_has_partition_name() const;
  public:
  void clear_partition_name();
  const std::string& partition_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partition_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partition_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_partition_name();
  void set_allocated_partition_name(std::string* partition_name);
  private:
  const std::string& _internal_partition_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_name(const std::string& value);
  std::string* _internal_mutable_partition_name();
  public:

  // optional string resource_tag = 5;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional .baikaldb.pb.Expr less_value = 3;
  bool has_less_value() const;
  private:
  bool _internal_has_less_value() const;
  public:
  void clear_less_value();
  const ::baikaldb::pb::Expr& less_value() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::Expr* release_less_value();
  ::baikaldb::pb::Expr* mutable_less_value();
  void set_allocated_less_value(::baikaldb::pb::Expr* less_value);
  private:
  const ::baikaldb::pb::Expr& _internal_less_value() const;
  ::baikaldb::pb::Expr* _internal_mutable_less_value();
  public:
  void unsafe_arena_set_allocated_less_value(
      ::baikaldb::pb::Expr* less_value);
  ::baikaldb::pb::Expr* unsafe_arena_release_less_value();

  // optional .baikaldb.pb.PartitionRange range = 4;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::baikaldb::pb::PartitionRange& range() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::PartitionRange* release_range();
  ::baikaldb::pb::PartitionRange* mutable_range();
  void set_allocated_range(::baikaldb::pb::PartitionRange* range);
  private:
  const ::baikaldb::pb::PartitionRange& _internal_range() const;
  ::baikaldb::pb::PartitionRange* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::baikaldb::pb::PartitionRange* range);
  ::baikaldb::pb::PartitionRange* unsafe_arena_release_range();

  // optional int64 partition_id = 1;
  bool has_partition_id() const;
  private:
  bool _internal_has_partition_id() const;
  public:
  void clear_partition_id();
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id() const;
  void set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_partition_id() const;
  void _internal_set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool is_cold = 6;
  bool has_is_cold() const;
  private:
  bool _internal_has_is_cold() const;
  public:
  void clear_is_cold();
  bool is_cold() const;
  void set_is_cold(bool value);
  private:
  bool _internal_is_cold() const;
  void _internal_set_is_cold(bool value);
  public:

  // optional bool is_pre_split = 9;
  bool has_is_pre_split() const;
  private:
  bool _internal_has_is_pre_split() const;
  public:
  void clear_is_pre_split();
  bool is_pre_split() const;
  void set_is_pre_split(bool value);
  private:
  bool _internal_is_pre_split() const;
  void _internal_set_is_pre_split(bool value);
  public:

  // optional .baikaldb.pb.RangePartitionType type = 8;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::baikaldb::pb::RangePartitionType type() const;
  void set_type(::baikaldb::pb::RangePartitionType value);
  private:
  ::baikaldb::pb::RangePartitionType _internal_type() const;
  void _internal_set_type(::baikaldb::pb::RangePartitionType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RangePartitionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SplitKey > split_keys_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::baikaldb::pb::Expr* less_value_;
  ::baikaldb::pb::PartitionRange* range_;
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id_;
  bool is_cold_;
  bool is_pre_split_;
  int type_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class DynamicPartitionAttr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.DynamicPartitionAttr) */ {
 public:
  inline DynamicPartitionAttr() : DynamicPartitionAttr(nullptr) {}
  ~DynamicPartitionAttr() override;
  explicit constexpr DynamicPartitionAttr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DynamicPartitionAttr(const DynamicPartitionAttr& from);
  DynamicPartitionAttr(DynamicPartitionAttr&& from) noexcept
    : DynamicPartitionAttr() {
    *this = ::std::move(from);
  }

  inline DynamicPartitionAttr& operator=(const DynamicPartitionAttr& from) {
    CopyFrom(from);
    return *this;
  }
  inline DynamicPartitionAttr& operator=(DynamicPartitionAttr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DynamicPartitionAttr& default_instance() {
    return *internal_default_instance();
  }
  static inline const DynamicPartitionAttr* internal_default_instance() {
    return reinterpret_cast<const DynamicPartitionAttr*>(
               &_DynamicPartitionAttr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DynamicPartitionAttr& a, DynamicPartitionAttr& b) {
    a.Swap(&b);
  }
  inline void Swap(DynamicPartitionAttr* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DynamicPartitionAttr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DynamicPartitionAttr* New() const final {
    return new DynamicPartitionAttr();
  }

  DynamicPartitionAttr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DynamicPartitionAttr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DynamicPartitionAttr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DynamicPartitionAttr& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DynamicPartitionAttr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.DynamicPartitionAttr";
  }
  protected:
  explicit DynamicPartitionAttr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeUnitFieldNumber = 2,
    kPrefixFieldNumber = 6,
    kIsolationFieldNumber = 8,
    kEnableFieldNumber = 1,
    kStartFieldNumber = 3,
    kColdFieldNumber = 4,
    kEndFieldNumber = 5,
    kStartDayOfMonthFieldNumber = 7,
  };
  // optional string time_unit = 2;
  bool has_time_unit() const;
  private:
  bool _internal_has_time_unit() const;
  public:
  void clear_time_unit();
  const std::string& time_unit() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_unit(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_unit();
  PROTOBUF_MUST_USE_RESULT std::string* release_time_unit();
  void set_allocated_time_unit(std::string* time_unit);
  private:
  const std::string& _internal_time_unit() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_unit(const std::string& value);
  std::string* _internal_mutable_time_unit();
  public:

  // optional string prefix = 6;
  bool has_prefix() const;
  private:
  bool _internal_has_prefix() const;
  public:
  void clear_prefix();
  const std::string& prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prefix();
  PROTOBUF_MUST_USE_RESULT std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);
  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const std::string& value);
  std::string* _internal_mutable_prefix();
  public:

  // optional string isolation = 8;
  bool has_isolation() const;
  private:
  bool _internal_has_isolation() const;
  public:
  void clear_isolation();
  const std::string& isolation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_isolation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_isolation();
  PROTOBUF_MUST_USE_RESULT std::string* release_isolation();
  void set_allocated_isolation(std::string* isolation);
  private:
  const std::string& _internal_isolation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_isolation(const std::string& value);
  std::string* _internal_mutable_isolation();
  public:

  // optional bool enable = 1;
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // optional int32 start = 3;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::int32 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start() const;
  void _internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 cold = 4;
  bool has_cold() const;
  private:
  bool _internal_has_cold() const;
  public:
  void clear_cold();
  ::PROTOBUF_NAMESPACE_ID::int32 cold() const;
  void set_cold(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cold() const;
  void _internal_set_cold(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 end = 5;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int32 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 start_day_of_month = 7;
  bool has_start_day_of_month() const;
  private:
  bool _internal_has_start_day_of_month() const;
  public:
  void clear_start_day_of_month();
  ::PROTOBUF_NAMESPACE_ID::int32 start_day_of_month() const;
  void set_start_day_of_month(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start_day_of_month() const;
  void _internal_set_start_day_of_month(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.DynamicPartitionAttr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_unit_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr isolation_;
  bool enable_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_;
  ::PROTOBUF_NAMESPACE_ID::int32 cold_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_day_of_month_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class PartitionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.PartitionInfo) */ {
 public:
  inline PartitionInfo() : PartitionInfo(nullptr) {}
  ~PartitionInfo() override;
  explicit constexpr PartitionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionInfo(const PartitionInfo& from);
  PartitionInfo(PartitionInfo&& from) noexcept
    : PartitionInfo() {
    *this = ::std::move(from);
  }

  inline PartitionInfo& operator=(const PartitionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionInfo& operator=(PartitionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionInfo* internal_default_instance() {
    return reinterpret_cast<const PartitionInfo*>(
               &_PartitionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PartitionInfo& a, PartitionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartitionInfo* New() const final {
    return new PartitionInfo();
  }

  PartitionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartitionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartitionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PartitionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.PartitionInfo";
  }
  protected:
  explicit PartitionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRangePartitionValuesFieldNumber = 5,
    kPartitionNamesFieldNumber = 6,
    kRangePartitionInfosFieldNumber = 9,
    kGenRangePartitionTypesFieldNumber = 12,
    kExprStringFieldNumber = 8,
    kFieldInfoFieldNumber = 2,
    kRangePartitionFieldFieldNumber = 4,
    kHashExprValueFieldNumber = 7,
    kDynamicPartitionAttrFieldNumber = 10,
    kPartitionFieldFieldNumber = 3,
    kPrimaryRangePartitionTypeFieldNumber = 13,
    kMaxRangePartitionIdFieldNumber = 11,
    kTypeFieldNumber = 1,
  };
  // repeated .baikaldb.pb.Expr range_partition_values = 5;
  int range_partition_values_size() const;
  private:
  int _internal_range_partition_values_size() const;
  public:
  void clear_range_partition_values();
  ::baikaldb::pb::Expr* mutable_range_partition_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
      mutable_range_partition_values();
  private:
  const ::baikaldb::pb::Expr& _internal_range_partition_values(int index) const;
  ::baikaldb::pb::Expr* _internal_add_range_partition_values();
  public:
  const ::baikaldb::pb::Expr& range_partition_values(int index) const;
  ::baikaldb::pb::Expr* add_range_partition_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
      range_partition_values() const;

  // repeated string partition_names = 6;
  int partition_names_size() const;
  private:
  int _internal_partition_names_size() const;
  public:
  void clear_partition_names();
  const std::string& partition_names(int index) const;
  std::string* mutable_partition_names(int index);
  void set_partition_names(int index, const std::string& value);
  void set_partition_names(int index, std::string&& value);
  void set_partition_names(int index, const char* value);
  void set_partition_names(int index, const char* value, size_t size);
  std::string* add_partition_names();
  void add_partition_names(const std::string& value);
  void add_partition_names(std::string&& value);
  void add_partition_names(const char* value);
  void add_partition_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& partition_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_partition_names();
  private:
  const std::string& _internal_partition_names(int index) const;
  std::string* _internal_add_partition_names();
  public:

  // repeated .baikaldb.pb.RangePartitionInfo range_partition_infos = 9;
  int range_partition_infos_size() const;
  private:
  int _internal_range_partition_infos_size() const;
  public:
  void clear_range_partition_infos();
  ::baikaldb::pb::RangePartitionInfo* mutable_range_partition_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RangePartitionInfo >*
      mutable_range_partition_infos();
  private:
  const ::baikaldb::pb::RangePartitionInfo& _internal_range_partition_infos(int index) const;
  ::baikaldb::pb::RangePartitionInfo* _internal_add_range_partition_infos();
  public:
  const ::baikaldb::pb::RangePartitionInfo& range_partition_infos(int index) const;
  ::baikaldb::pb::RangePartitionInfo* add_range_partition_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RangePartitionInfo >&
      range_partition_infos() const;

  // repeated .baikaldb.pb.RangePartitionType gen_range_partition_types = 12;
  int gen_range_partition_types_size() const;
  private:
  int _internal_gen_range_partition_types_size() const;
  public:
  void clear_gen_range_partition_types();
  private:
  ::baikaldb::pb::RangePartitionType _internal_gen_range_partition_types(int index) const;
  void _internal_add_gen_range_partition_types(::baikaldb::pb::RangePartitionType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_gen_range_partition_types();
  public:
  ::baikaldb::pb::RangePartitionType gen_range_partition_types(int index) const;
  void set_gen_range_partition_types(int index, ::baikaldb::pb::RangePartitionType value);
  void add_gen_range_partition_types(::baikaldb::pb::RangePartitionType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& gen_range_partition_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_gen_range_partition_types();

  // optional string expr_string = 8;
  bool has_expr_string() const;
  private:
  bool _internal_has_expr_string() const;
  public:
  void clear_expr_string();
  const std::string& expr_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expr_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expr_string();
  PROTOBUF_MUST_USE_RESULT std::string* release_expr_string();
  void set_allocated_expr_string(std::string* expr_string);
  private:
  const std::string& _internal_expr_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expr_string(const std::string& value);
  std::string* _internal_mutable_expr_string();
  public:

  // optional .baikaldb.pb.FieldInfo field_info = 2;
  bool has_field_info() const;
  private:
  bool _internal_has_field_info() const;
  public:
  void clear_field_info();
  const ::baikaldb::pb::FieldInfo& field_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::FieldInfo* release_field_info();
  ::baikaldb::pb::FieldInfo* mutable_field_info();
  void set_allocated_field_info(::baikaldb::pb::FieldInfo* field_info);
  private:
  const ::baikaldb::pb::FieldInfo& _internal_field_info() const;
  ::baikaldb::pb::FieldInfo* _internal_mutable_field_info();
  public:
  void unsafe_arena_set_allocated_field_info(
      ::baikaldb::pb::FieldInfo* field_info);
  ::baikaldb::pb::FieldInfo* unsafe_arena_release_field_info();

  // optional .baikaldb.pb.Expr range_partition_field = 4;
  bool has_range_partition_field() const;
  private:
  bool _internal_has_range_partition_field() const;
  public:
  void clear_range_partition_field();
  const ::baikaldb::pb::Expr& range_partition_field() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::Expr* release_range_partition_field();
  ::baikaldb::pb::Expr* mutable_range_partition_field();
  void set_allocated_range_partition_field(::baikaldb::pb::Expr* range_partition_field);
  private:
  const ::baikaldb::pb::Expr& _internal_range_partition_field() const;
  ::baikaldb::pb::Expr* _internal_mutable_range_partition_field();
  public:
  void unsafe_arena_set_allocated_range_partition_field(
      ::baikaldb::pb::Expr* range_partition_field);
  ::baikaldb::pb::Expr* unsafe_arena_release_range_partition_field();

  // optional .baikaldb.pb.Expr hash_expr_value = 7;
  bool has_hash_expr_value() const;
  private:
  bool _internal_has_hash_expr_value() const;
  public:
  void clear_hash_expr_value();
  const ::baikaldb::pb::Expr& hash_expr_value() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::Expr* release_hash_expr_value();
  ::baikaldb::pb::Expr* mutable_hash_expr_value();
  void set_allocated_hash_expr_value(::baikaldb::pb::Expr* hash_expr_value);
  private:
  const ::baikaldb::pb::Expr& _internal_hash_expr_value() const;
  ::baikaldb::pb::Expr* _internal_mutable_hash_expr_value();
  public:
  void unsafe_arena_set_allocated_hash_expr_value(
      ::baikaldb::pb::Expr* hash_expr_value);
  ::baikaldb::pb::Expr* unsafe_arena_release_hash_expr_value();

  // optional .baikaldb.pb.DynamicPartitionAttr dynamic_partition_attr = 10;
  bool has_dynamic_partition_attr() const;
  private:
  bool _internal_has_dynamic_partition_attr() const;
  public:
  void clear_dynamic_partition_attr();
  const ::baikaldb::pb::DynamicPartitionAttr& dynamic_partition_attr() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::DynamicPartitionAttr* release_dynamic_partition_attr();
  ::baikaldb::pb::DynamicPartitionAttr* mutable_dynamic_partition_attr();
  void set_allocated_dynamic_partition_attr(::baikaldb::pb::DynamicPartitionAttr* dynamic_partition_attr);
  private:
  const ::baikaldb::pb::DynamicPartitionAttr& _internal_dynamic_partition_attr() const;
  ::baikaldb::pb::DynamicPartitionAttr* _internal_mutable_dynamic_partition_attr();
  public:
  void unsafe_arena_set_allocated_dynamic_partition_attr(
      ::baikaldb::pb::DynamicPartitionAttr* dynamic_partition_attr);
  ::baikaldb::pb::DynamicPartitionAttr* unsafe_arena_release_dynamic_partition_attr();

  // optional int32 partition_field = 3;
  bool has_partition_field() const;
  private:
  bool _internal_has_partition_field() const;
  public:
  void clear_partition_field();
  ::PROTOBUF_NAMESPACE_ID::int32 partition_field() const;
  void set_partition_field(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_partition_field() const;
  void _internal_set_partition_field(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .baikaldb.pb.RangePartitionType primary_range_partition_type = 13;
  bool has_primary_range_partition_type() const;
  private:
  bool _internal_has_primary_range_partition_type() const;
  public:
  void clear_primary_range_partition_type();
  ::baikaldb::pb::RangePartitionType primary_range_partition_type() const;
  void set_primary_range_partition_type(::baikaldb::pb::RangePartitionType value);
  private:
  ::baikaldb::pb::RangePartitionType _internal_primary_range_partition_type() const;
  void _internal_set_primary_range_partition_type(::baikaldb::pb::RangePartitionType value);
  public:

  // optional int64 max_range_partition_id = 11;
  bool has_max_range_partition_id() const;
  private:
  bool _internal_has_max_range_partition_id() const;
  public:
  void clear_max_range_partition_id();
  ::PROTOBUF_NAMESPACE_ID::int64 max_range_partition_id() const;
  void set_max_range_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_max_range_partition_id() const;
  void _internal_set_max_range_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required .baikaldb.pb.PartitionType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::baikaldb::pb::PartitionType type() const;
  void set_type(::baikaldb::pb::PartitionType value);
  private:
  ::baikaldb::pb::PartitionType _internal_type() const;
  void _internal_set_type(::baikaldb::pb::PartitionType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.PartitionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr > range_partition_values_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> partition_names_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RangePartitionInfo > range_partition_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> gen_range_partition_types_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expr_string_;
  ::baikaldb::pb::FieldInfo* field_info_;
  ::baikaldb::pb::Expr* range_partition_field_;
  ::baikaldb::pb::Expr* hash_expr_value_;
  ::baikaldb::pb::DynamicPartitionAttr* dynamic_partition_attr_;
  ::PROTOBUF_NAMESPACE_ID::int32 partition_field_;
  int primary_range_partition_type_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_range_partition_id_;
  int type_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class DBLinkInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.DBLinkInfo) */ {
 public:
  inline DBLinkInfo() : DBLinkInfo(nullptr) {}
  ~DBLinkInfo() override;
  explicit constexpr DBLinkInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DBLinkInfo(const DBLinkInfo& from);
  DBLinkInfo(DBLinkInfo&& from) noexcept
    : DBLinkInfo() {
    *this = ::std::move(from);
  }

  inline DBLinkInfo& operator=(const DBLinkInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DBLinkInfo& operator=(DBLinkInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DBLinkInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DBLinkInfo* internal_default_instance() {
    return reinterpret_cast<const DBLinkInfo*>(
               &_DBLinkInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DBLinkInfo& a, DBLinkInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DBLinkInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DBLinkInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DBLinkInfo* New() const final {
    return new DBLinkInfo();
  }

  DBLinkInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DBLinkInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DBLinkInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DBLinkInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DBLinkInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.DBLinkInfo";
  }
  protected:
  explicit DBLinkInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetaNameFieldNumber = 2,
    kNamespaceNameFieldNumber = 3,
    kDatabaseNameFieldNumber = 4,
    kTableNameFieldNumber = 5,
    kMysqlInfoFieldNumber = 7,
    kMetaIdFieldNumber = 6,
    kTypeFieldNumber = 1,
  };
  // optional string meta_name = 2;
  bool has_meta_name() const;
  private:
  bool _internal_has_meta_name() const;
  public:
  void clear_meta_name();
  const std::string& meta_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_meta_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_meta_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_meta_name();
  void set_allocated_meta_name(std::string* meta_name);
  private:
  const std::string& _internal_meta_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_meta_name(const std::string& value);
  std::string* _internal_mutable_meta_name();
  public:

  // optional string namespace_name = 3;
  bool has_namespace_name() const;
  private:
  bool _internal_has_namespace_name() const;
  public:
  void clear_namespace_name();
  const std::string& namespace_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_namespace_name();
  void set_allocated_namespace_name(std::string* namespace_name);
  private:
  const std::string& _internal_namespace_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_name(const std::string& value);
  std::string* _internal_mutable_namespace_name();
  public:

  // optional string database_name = 4;
  bool has_database_name() const;
  private:
  bool _internal_has_database_name() const;
  public:
  void clear_database_name();
  const std::string& database_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_database_name();
  void set_allocated_database_name(std::string* database_name);
  private:
  const std::string& _internal_database_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database_name(const std::string& value);
  std::string* _internal_mutable_database_name();
  public:

  // optional string table_name = 5;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional .baikaldb.pb.MysqlInfo mysql_info = 7;
  bool has_mysql_info() const;
  private:
  bool _internal_has_mysql_info() const;
  public:
  void clear_mysql_info();
  const ::baikaldb::pb::MysqlInfo& mysql_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::MysqlInfo* release_mysql_info();
  ::baikaldb::pb::MysqlInfo* mutable_mysql_info();
  void set_allocated_mysql_info(::baikaldb::pb::MysqlInfo* mysql_info);
  private:
  const ::baikaldb::pb::MysqlInfo& _internal_mysql_info() const;
  ::baikaldb::pb::MysqlInfo* _internal_mutable_mysql_info();
  public:
  void unsafe_arena_set_allocated_mysql_info(
      ::baikaldb::pb::MysqlInfo* mysql_info);
  ::baikaldb::pb::MysqlInfo* unsafe_arena_release_mysql_info();

  // optional int64 meta_id = 6;
  bool has_meta_id() const;
  private:
  bool _internal_has_meta_id() const;
  public:
  void clear_meta_id();
  ::PROTOBUF_NAMESPACE_ID::int64 meta_id() const;
  void set_meta_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_meta_id() const;
  void _internal_set_meta_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.DBLinkType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::baikaldb::pb::DBLinkType type() const;
  void set_type(::baikaldb::pb::DBLinkType value);
  private:
  ::baikaldb::pb::DBLinkType _internal_type() const;
  void _internal_set_type(::baikaldb::pb::DBLinkType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.DBLinkInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr meta_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::baikaldb::pb::MysqlInfo* mysql_info_;
  ::PROTOBUF_NAMESPACE_ID::int64 meta_id_;
  int type_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class SchemaInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.SchemaInfo) */ {
 public:
  inline SchemaInfo() : SchemaInfo(nullptr) {}
  ~SchemaInfo() override;
  explicit constexpr SchemaInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchemaInfo(const SchemaInfo& from);
  SchemaInfo(SchemaInfo&& from) noexcept
    : SchemaInfo() {
    *this = ::std::move(from);
  }

  inline SchemaInfo& operator=(const SchemaInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaInfo& operator=(SchemaInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaInfo* internal_default_instance() {
    return reinterpret_cast<const SchemaInfo*>(
               &_SchemaInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SchemaInfo& a, SchemaInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchemaInfo* New() const final {
    return new SchemaInfo();
  }

  SchemaInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchemaInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchemaInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SchemaInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.SchemaInfo";
  }
  protected:
  explicit SchemaInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowerTableIdsFieldNumber = 7,
    kRegionsFieldNumber = 14,
    kFieldsFieldNumber = 17,
    kIndexsFieldNumber = 18,
    kInitStoreFieldNumber = 25,
    kDistsFieldNumber = 32,
    kSplitKeysFieldNumber = 36,
    kLearnerResourceTagsFieldNumber = 44,
    kBinlogInfosFieldNumber = 49,
    kTableNameFieldNumber = 2,
    kNewTableNameFieldNumber = 3,
    kUpperTableNameFieldNumber = 4,
    kDatabaseFieldNumber = 8,
    kNamespaceNameFieldNumber = 10,
    kPartitionExpFieldNumber = 13,
    kResourceTagFieldNumber = 19,
    kMainLogicalRoomFieldNumber = 33,
    kCommentFieldNumber = 46,
    kViewSelectStmtFieldNumber = 52,
    kSchemaConfFieldNumber = 37,
    kBinlogInfoFieldNumber = 39,
    kPartitionInfoFieldNumber = 40,
    kLinkFieldFieldNumber = 42,
    kDblinkInfoFieldNumber = 50,
    kTableIdFieldNumber = 1,
    kUpperTableIdFieldNumber = 5,
    kTopTableIdFieldNumber = 6,
    kDatabaseIdFieldNumber = 9,
    kNamespaceIdFieldNumber = 11,
    kPartitionNumFieldNumber = 12,
    kRegionSizeFieldNumber = 15,
    kReplicaNumFieldNumber = 16,
    kVersionFieldNumber = 21,
    kMaxFieldIdFieldNumber = 20,
    kTimestampFieldNumber = 30,
    kByteSizePerRecordFieldNumber = 28,
    kAutoIncrementIncrementFieldNumber = 29,
    kRegionSplitLinesFieldNumber = 34,
    kTtlDurationFieldNumber = 38,
    kCharsetFieldNumber = 31,
    kDeletedFieldNumber = 27,
    kIsBinlogFieldNumber = 41,
    kIfExistFieldNumber = 47,
    kPartitionIsSameHintFieldNumber = 48,
    kOnlineTtlExpireTimeUsFieldNumber = 45,
    kRegionNumFieldNumber = 43,
    kOrReplaceFieldNumber = 51,
    kEngineFieldNumber = 24,
    kStatusFieldNumber = 22,
    kSchemaTypeFieldNumber = 23,
  };
  // repeated int64 lower_table_ids = 7;
  int lower_table_ids_size() const;
  private:
  int _internal_lower_table_ids_size() const;
  public:
  void clear_lower_table_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_lower_table_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_lower_table_ids() const;
  void _internal_add_lower_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_lower_table_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 lower_table_ids(int index) const;
  void set_lower_table_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_lower_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      lower_table_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_lower_table_ids();

  // repeated .baikaldb.pb.PartitionRegion regions = 14;
  int regions_size() const;
  private:
  int _internal_regions_size() const;
  public:
  void clear_regions();
  ::baikaldb::pb::PartitionRegion* mutable_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PartitionRegion >*
      mutable_regions();
  private:
  const ::baikaldb::pb::PartitionRegion& _internal_regions(int index) const;
  ::baikaldb::pb::PartitionRegion* _internal_add_regions();
  public:
  const ::baikaldb::pb::PartitionRegion& regions(int index) const;
  ::baikaldb::pb::PartitionRegion* add_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PartitionRegion >&
      regions() const;

  // repeated .baikaldb.pb.FieldInfo fields = 17;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::baikaldb::pb::FieldInfo* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FieldInfo >*
      mutable_fields();
  private:
  const ::baikaldb::pb::FieldInfo& _internal_fields(int index) const;
  ::baikaldb::pb::FieldInfo* _internal_add_fields();
  public:
  const ::baikaldb::pb::FieldInfo& fields(int index) const;
  ::baikaldb::pb::FieldInfo* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FieldInfo >&
      fields() const;

  // repeated .baikaldb.pb.IndexInfo indexs = 18;
  int indexs_size() const;
  private:
  int _internal_indexs_size() const;
  public:
  void clear_indexs();
  ::baikaldb::pb::IndexInfo* mutable_indexs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::IndexInfo >*
      mutable_indexs();
  private:
  const ::baikaldb::pb::IndexInfo& _internal_indexs(int index) const;
  ::baikaldb::pb::IndexInfo* _internal_add_indexs();
  public:
  const ::baikaldb::pb::IndexInfo& indexs(int index) const;
  ::baikaldb::pb::IndexInfo* add_indexs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::IndexInfo >&
      indexs() const;

  // repeated string init_store = 25;
  int init_store_size() const;
  private:
  int _internal_init_store_size() const;
  public:
  void clear_init_store();
  const std::string& init_store(int index) const;
  std::string* mutable_init_store(int index);
  void set_init_store(int index, const std::string& value);
  void set_init_store(int index, std::string&& value);
  void set_init_store(int index, const char* value);
  void set_init_store(int index, const char* value, size_t size);
  std::string* add_init_store();
  void add_init_store(const std::string& value);
  void add_init_store(std::string&& value);
  void add_init_store(const char* value);
  void add_init_store(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& init_store() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_init_store();
  private:
  const std::string& _internal_init_store(int index) const;
  std::string* _internal_add_init_store();
  public:

  // repeated .baikaldb.pb.ReplicaDist dists = 32;
  int dists_size() const;
  private:
  int _internal_dists_size() const;
  public:
  void clear_dists();
  ::baikaldb::pb::ReplicaDist* mutable_dists(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ReplicaDist >*
      mutable_dists();
  private:
  const ::baikaldb::pb::ReplicaDist& _internal_dists(int index) const;
  ::baikaldb::pb::ReplicaDist* _internal_add_dists();
  public:
  const ::baikaldb::pb::ReplicaDist& dists(int index) const;
  ::baikaldb::pb::ReplicaDist* add_dists();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ReplicaDist >&
      dists() const;

  // repeated .baikaldb.pb.SplitKey split_keys = 36;
  int split_keys_size() const;
  private:
  int _internal_split_keys_size() const;
  public:
  void clear_split_keys();
  ::baikaldb::pb::SplitKey* mutable_split_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SplitKey >*
      mutable_split_keys();
  private:
  const ::baikaldb::pb::SplitKey& _internal_split_keys(int index) const;
  ::baikaldb::pb::SplitKey* _internal_add_split_keys();
  public:
  const ::baikaldb::pb::SplitKey& split_keys(int index) const;
  ::baikaldb::pb::SplitKey* add_split_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SplitKey >&
      split_keys() const;

  // repeated string learner_resource_tags = 44;
  int learner_resource_tags_size() const;
  private:
  int _internal_learner_resource_tags_size() const;
  public:
  void clear_learner_resource_tags();
  const std::string& learner_resource_tags(int index) const;
  std::string* mutable_learner_resource_tags(int index);
  void set_learner_resource_tags(int index, const std::string& value);
  void set_learner_resource_tags(int index, std::string&& value);
  void set_learner_resource_tags(int index, const char* value);
  void set_learner_resource_tags(int index, const char* value, size_t size);
  std::string* add_learner_resource_tags();
  void add_learner_resource_tags(const std::string& value);
  void add_learner_resource_tags(std::string&& value);
  void add_learner_resource_tags(const char* value);
  void add_learner_resource_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& learner_resource_tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_learner_resource_tags();
  private:
  const std::string& _internal_learner_resource_tags(int index) const;
  std::string* _internal_add_learner_resource_tags();
  public:

  // repeated .baikaldb.pb.BinlogInfo binlog_infos = 49;
  int binlog_infos_size() const;
  private:
  int _internal_binlog_infos_size() const;
  public:
  void clear_binlog_infos();
  ::baikaldb::pb::BinlogInfo* mutable_binlog_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogInfo >*
      mutable_binlog_infos();
  private:
  const ::baikaldb::pb::BinlogInfo& _internal_binlog_infos(int index) const;
  ::baikaldb::pb::BinlogInfo* _internal_add_binlog_infos();
  public:
  const ::baikaldb::pb::BinlogInfo& binlog_infos(int index) const;
  ::baikaldb::pb::BinlogInfo* add_binlog_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogInfo >&
      binlog_infos() const;

  // required string table_name = 2;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional string new_table_name = 3;
  bool has_new_table_name() const;
  private:
  bool _internal_has_new_table_name() const;
  public:
  void clear_new_table_name();
  const std::string& new_table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_new_table_name();
  void set_allocated_new_table_name(std::string* new_table_name);
  private:
  const std::string& _internal_new_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_table_name(const std::string& value);
  std::string* _internal_mutable_new_table_name();
  public:

  // optional string upper_table_name = 4;
  bool has_upper_table_name() const;
  private:
  bool _internal_has_upper_table_name() const;
  public:
  void clear_upper_table_name();
  const std::string& upper_table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_upper_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_upper_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_upper_table_name();
  void set_allocated_upper_table_name(std::string* upper_table_name);
  private:
  const std::string& _internal_upper_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_upper_table_name(const std::string& value);
  std::string* _internal_mutable_upper_table_name();
  public:

  // required string database = 8;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_MUST_USE_RESULT std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // required string namespace_name = 10;
  bool has_namespace_name() const;
  private:
  bool _internal_has_namespace_name() const;
  public:
  void clear_namespace_name();
  const std::string& namespace_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_namespace_name();
  void set_allocated_namespace_name(std::string* namespace_name);
  private:
  const std::string& _internal_namespace_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_name(const std::string& value);
  std::string* _internal_mutable_namespace_name();
  public:

  // optional string partition_exp = 13;
  bool has_partition_exp() const;
  private:
  bool _internal_has_partition_exp() const;
  public:
  void clear_partition_exp();
  const std::string& partition_exp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_partition_exp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_partition_exp();
  PROTOBUF_MUST_USE_RESULT std::string* release_partition_exp();
  void set_allocated_partition_exp(std::string* partition_exp);
  private:
  const std::string& _internal_partition_exp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_partition_exp(const std::string& value);
  std::string* _internal_mutable_partition_exp();
  public:

  // optional string resource_tag = 19;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional string main_logical_room = 33;
  bool has_main_logical_room() const;
  private:
  bool _internal_has_main_logical_room() const;
  public:
  void clear_main_logical_room();
  const std::string& main_logical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_main_logical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_main_logical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_main_logical_room();
  void set_allocated_main_logical_room(std::string* main_logical_room);
  private:
  const std::string& _internal_main_logical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_main_logical_room(const std::string& value);
  std::string* _internal_mutable_main_logical_room();
  public:

  // optional string comment = 46;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_MUST_USE_RESULT std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // optional string view_select_stmt = 52;
  bool has_view_select_stmt() const;
  private:
  bool _internal_has_view_select_stmt() const;
  public:
  void clear_view_select_stmt();
  const std::string& view_select_stmt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_select_stmt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_select_stmt();
  PROTOBUF_MUST_USE_RESULT std::string* release_view_select_stmt();
  void set_allocated_view_select_stmt(std::string* view_select_stmt);
  private:
  const std::string& _internal_view_select_stmt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_select_stmt(const std::string& value);
  std::string* _internal_mutable_view_select_stmt();
  public:

  // optional .baikaldb.pb.SchemaConf schema_conf = 37;
  bool has_schema_conf() const;
  private:
  bool _internal_has_schema_conf() const;
  public:
  void clear_schema_conf();
  const ::baikaldb::pb::SchemaConf& schema_conf() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::SchemaConf* release_schema_conf();
  ::baikaldb::pb::SchemaConf* mutable_schema_conf();
  void set_allocated_schema_conf(::baikaldb::pb::SchemaConf* schema_conf);
  private:
  const ::baikaldb::pb::SchemaConf& _internal_schema_conf() const;
  ::baikaldb::pb::SchemaConf* _internal_mutable_schema_conf();
  public:
  void unsafe_arena_set_allocated_schema_conf(
      ::baikaldb::pb::SchemaConf* schema_conf);
  ::baikaldb::pb::SchemaConf* unsafe_arena_release_schema_conf();

  // optional .baikaldb.pb.BinlogInfo binlog_info = 39;
  bool has_binlog_info() const;
  private:
  bool _internal_has_binlog_info() const;
  public:
  void clear_binlog_info();
  const ::baikaldb::pb::BinlogInfo& binlog_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::BinlogInfo* release_binlog_info();
  ::baikaldb::pb::BinlogInfo* mutable_binlog_info();
  void set_allocated_binlog_info(::baikaldb::pb::BinlogInfo* binlog_info);
  private:
  const ::baikaldb::pb::BinlogInfo& _internal_binlog_info() const;
  ::baikaldb::pb::BinlogInfo* _internal_mutable_binlog_info();
  public:
  void unsafe_arena_set_allocated_binlog_info(
      ::baikaldb::pb::BinlogInfo* binlog_info);
  ::baikaldb::pb::BinlogInfo* unsafe_arena_release_binlog_info();

  // optional .baikaldb.pb.PartitionInfo partition_info = 40;
  bool has_partition_info() const;
  private:
  bool _internal_has_partition_info() const;
  public:
  void clear_partition_info();
  const ::baikaldb::pb::PartitionInfo& partition_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::PartitionInfo* release_partition_info();
  ::baikaldb::pb::PartitionInfo* mutable_partition_info();
  void set_allocated_partition_info(::baikaldb::pb::PartitionInfo* partition_info);
  private:
  const ::baikaldb::pb::PartitionInfo& _internal_partition_info() const;
  ::baikaldb::pb::PartitionInfo* _internal_mutable_partition_info();
  public:
  void unsafe_arena_set_allocated_partition_info(
      ::baikaldb::pb::PartitionInfo* partition_info);
  ::baikaldb::pb::PartitionInfo* unsafe_arena_release_partition_info();

  // optional .baikaldb.pb.FieldInfo link_field = 42;
  bool has_link_field() const;
  private:
  bool _internal_has_link_field() const;
  public:
  void clear_link_field();
  const ::baikaldb::pb::FieldInfo& link_field() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::FieldInfo* release_link_field();
  ::baikaldb::pb::FieldInfo* mutable_link_field();
  void set_allocated_link_field(::baikaldb::pb::FieldInfo* link_field);
  private:
  const ::baikaldb::pb::FieldInfo& _internal_link_field() const;
  ::baikaldb::pb::FieldInfo* _internal_mutable_link_field();
  public:
  void unsafe_arena_set_allocated_link_field(
      ::baikaldb::pb::FieldInfo* link_field);
  ::baikaldb::pb::FieldInfo* unsafe_arena_release_link_field();

  // optional .baikaldb.pb.DBLinkInfo dblink_info = 50;
  bool has_dblink_info() const;
  private:
  bool _internal_has_dblink_info() const;
  public:
  void clear_dblink_info();
  const ::baikaldb::pb::DBLinkInfo& dblink_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::DBLinkInfo* release_dblink_info();
  ::baikaldb::pb::DBLinkInfo* mutable_dblink_info();
  void set_allocated_dblink_info(::baikaldb::pb::DBLinkInfo* dblink_info);
  private:
  const ::baikaldb::pb::DBLinkInfo& _internal_dblink_info() const;
  ::baikaldb::pb::DBLinkInfo* _internal_mutable_dblink_info();
  public:
  void unsafe_arena_set_allocated_dblink_info(
      ::baikaldb::pb::DBLinkInfo* dblink_info);
  ::baikaldb::pb::DBLinkInfo* unsafe_arena_release_dblink_info();

  // optional int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 upper_table_id = 5;
  bool has_upper_table_id() const;
  private:
  bool _internal_has_upper_table_id() const;
  public:
  void clear_upper_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 upper_table_id() const;
  void set_upper_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_upper_table_id() const;
  void _internal_set_upper_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 top_table_id = 6;
  bool has_top_table_id() const;
  private:
  bool _internal_has_top_table_id() const;
  public:
  void clear_top_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 top_table_id() const;
  void set_top_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_top_table_id() const;
  void _internal_set_top_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 database_id = 9;
  bool has_database_id() const;
  private:
  bool _internal_has_database_id() const;
  public:
  void clear_database_id();
  ::PROTOBUF_NAMESPACE_ID::int64 database_id() const;
  void set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_database_id() const;
  void _internal_set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 namespace_id = 11;
  bool has_namespace_id() const;
  private:
  bool _internal_has_namespace_id() const;
  public:
  void clear_namespace_id();
  ::PROTOBUF_NAMESPACE_ID::int64 namespace_id() const;
  void set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_namespace_id() const;
  void _internal_set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 partition_num = 12;
  bool has_partition_num() const;
  private:
  bool _internal_has_partition_num() const;
  public:
  void clear_partition_num();
  ::PROTOBUF_NAMESPACE_ID::int64 partition_num() const;
  void set_partition_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_partition_num() const;
  void _internal_set_partition_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_size = 15;
  bool has_region_size() const;
  private:
  bool _internal_has_region_size() const;
  public:
  void clear_region_size();
  ::PROTOBUF_NAMESPACE_ID::int64 region_size() const;
  void set_region_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_size() const;
  void _internal_set_region_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 replica_num = 16;
  bool has_replica_num() const;
  private:
  bool _internal_has_replica_num() const;
  public:
  void clear_replica_num();
  ::PROTOBUF_NAMESPACE_ID::int64 replica_num() const;
  void set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_replica_num() const;
  void _internal_set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 version = 21;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 max_field_id = 20;
  bool has_max_field_id() const;
  private:
  bool _internal_has_max_field_id() const;
  public:
  void clear_max_field_id();
  ::PROTOBUF_NAMESPACE_ID::int32 max_field_id() const;
  void set_max_field_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_field_id() const;
  void _internal_set_max_field_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional uint32 timestamp = 30;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional int64 byte_size_per_record = 28;
  bool has_byte_size_per_record() const;
  private:
  bool _internal_has_byte_size_per_record() const;
  public:
  void clear_byte_size_per_record();
  ::PROTOBUF_NAMESPACE_ID::int64 byte_size_per_record() const;
  void set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_byte_size_per_record() const;
  void _internal_set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint64 auto_increment_increment = 29;
  bool has_auto_increment_increment() const;
  private:
  bool _internal_has_auto_increment_increment() const;
  public:
  void clear_auto_increment_increment();
  ::PROTOBUF_NAMESPACE_ID::uint64 auto_increment_increment() const;
  void set_auto_increment_increment(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_auto_increment_increment() const;
  void _internal_set_auto_increment_increment(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int64 region_split_lines = 34;
  bool has_region_split_lines() const;
  private:
  bool _internal_has_region_split_lines() const;
  public:
  void clear_region_split_lines();
  ::PROTOBUF_NAMESPACE_ID::int64 region_split_lines() const;
  void set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_split_lines() const;
  void _internal_set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 ttl_duration = 38;
  bool has_ttl_duration() const;
  private:
  bool _internal_has_ttl_duration() const;
  public:
  void clear_ttl_duration();
  ::PROTOBUF_NAMESPACE_ID::int64 ttl_duration() const;
  void set_ttl_duration(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ttl_duration() const;
  void _internal_set_ttl_duration(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.Charset charset = 31;
  bool has_charset() const;
  private:
  bool _internal_has_charset() const;
  public:
  void clear_charset();
  ::baikaldb::pb::Charset charset() const;
  void set_charset(::baikaldb::pb::Charset value);
  private:
  ::baikaldb::pb::Charset _internal_charset() const;
  void _internal_set_charset(::baikaldb::pb::Charset value);
  public:

  // optional bool deleted = 27;
  bool has_deleted() const;
  private:
  bool _internal_has_deleted() const;
  public:
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // optional bool is_binlog = 41;
  bool has_is_binlog() const;
  private:
  bool _internal_has_is_binlog() const;
  public:
  void clear_is_binlog();
  bool is_binlog() const;
  void set_is_binlog(bool value);
  private:
  bool _internal_is_binlog() const;
  void _internal_set_is_binlog(bool value);
  public:

  // optional bool if_exist = 47;
  bool has_if_exist() const;
  private:
  bool _internal_has_if_exist() const;
  public:
  void clear_if_exist();
  bool if_exist() const;
  void set_if_exist(bool value);
  private:
  bool _internal_if_exist() const;
  void _internal_set_if_exist(bool value);
  public:

  // optional bool partition_is_same_hint = 48;
  bool has_partition_is_same_hint() const;
  private:
  bool _internal_has_partition_is_same_hint() const;
  public:
  void clear_partition_is_same_hint();
  bool partition_is_same_hint() const;
  void set_partition_is_same_hint(bool value);
  private:
  bool _internal_partition_is_same_hint() const;
  void _internal_set_partition_is_same_hint(bool value);
  public:

  // optional int64 online_ttl_expire_time_us = 45;
  bool has_online_ttl_expire_time_us() const;
  private:
  bool _internal_has_online_ttl_expire_time_us() const;
  public:
  void clear_online_ttl_expire_time_us();
  ::PROTOBUF_NAMESPACE_ID::int64 online_ttl_expire_time_us() const;
  void set_online_ttl_expire_time_us(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_online_ttl_expire_time_us() const;
  void _internal_set_online_ttl_expire_time_us(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 region_num = 43;
  bool has_region_num() const;
  private:
  bool _internal_has_region_num() const;
  public:
  void clear_region_num();
  ::PROTOBUF_NAMESPACE_ID::int32 region_num() const;
  void set_region_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_region_num() const;
  void _internal_set_region_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool or_replace = 51;
  bool has_or_replace() const;
  private:
  bool _internal_has_or_replace() const;
  public:
  void clear_or_replace();
  bool or_replace() const;
  void set_or_replace(bool value);
  private:
  bool _internal_or_replace() const;
  void _internal_set_or_replace(bool value);
  public:

  // optional .baikaldb.pb.Engine engine = 24;
  bool has_engine() const;
  private:
  bool _internal_has_engine() const;
  public:
  void clear_engine();
  ::baikaldb::pb::Engine engine() const;
  void set_engine(::baikaldb::pb::Engine value);
  private:
  ::baikaldb::pb::Engine _internal_engine() const;
  void _internal_set_engine(::baikaldb::pb::Engine value);
  public:

  // optional .baikaldb.pb.Status status = 22;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::baikaldb::pb::Status status() const;
  void set_status(::baikaldb::pb::Status value);
  private:
  ::baikaldb::pb::Status _internal_status() const;
  void _internal_set_status(::baikaldb::pb::Status value);
  public:

  // optional .baikaldb.pb.SchemaType schema_type = 23;
  bool has_schema_type() const;
  private:
  bool _internal_has_schema_type() const;
  public:
  void clear_schema_type();
  ::baikaldb::pb::SchemaType schema_type() const;
  void set_schema_type(::baikaldb::pb::SchemaType value);
  private:
  ::baikaldb::pb::SchemaType _internal_schema_type() const;
  void _internal_set_schema_type(::baikaldb::pb::SchemaType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.SchemaInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > lower_table_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PartitionRegion > regions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FieldInfo > fields_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::IndexInfo > indexs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> init_store_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ReplicaDist > dists_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SplitKey > split_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> learner_resource_tags_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogInfo > binlog_infos_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr upper_table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr partition_exp_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr main_logical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_select_stmt_;
  ::baikaldb::pb::SchemaConf* schema_conf_;
  ::baikaldb::pb::BinlogInfo* binlog_info_;
  ::baikaldb::pb::PartitionInfo* partition_info_;
  ::baikaldb::pb::FieldInfo* link_field_;
  ::baikaldb::pb::DBLinkInfo* dblink_info_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 upper_table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 top_table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 database_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 namespace_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 partition_num_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 replica_num_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_field_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int64 byte_size_per_record_;
  ::PROTOBUF_NAMESPACE_ID::uint64 auto_increment_increment_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_split_lines_;
  ::PROTOBUF_NAMESPACE_ID::int64 ttl_duration_;
  int charset_;
  bool deleted_;
  bool is_binlog_;
  bool if_exist_;
  bool partition_is_same_hint_;
  ::PROTOBUF_NAMESPACE_ID::int64 online_ttl_expire_time_us_;
  ::PROTOBUF_NAMESPACE_ID::int32 region_num_;
  bool or_replace_;
  int engine_;
  int status_;
  int schema_type_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class PartitionRegion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.PartitionRegion) */ {
 public:
  inline PartitionRegion() : PartitionRegion(nullptr) {}
  ~PartitionRegion() override;
  explicit constexpr PartitionRegion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionRegion(const PartitionRegion& from);
  PartitionRegion(PartitionRegion&& from) noexcept
    : PartitionRegion() {
    *this = ::std::move(from);
  }

  inline PartitionRegion& operator=(const PartitionRegion& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionRegion& operator=(PartitionRegion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionRegion& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionRegion* internal_default_instance() {
    return reinterpret_cast<const PartitionRegion*>(
               &_PartitionRegion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PartitionRegion& a, PartitionRegion& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionRegion* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionRegion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartitionRegion* New() const final {
    return new PartitionRegion();
  }

  PartitionRegion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartitionRegion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartitionRegion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PartitionRegion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionRegion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.PartitionRegion";
  }
  protected:
  explicit PartitionRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 2,
    kPartitionIdFieldNumber = 1,
  };
  // repeated int64 region_id = 2;
  int region_id_size() const;
  private:
  int _internal_region_id_size() const;
  public:
  void clear_region_id();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_region_id() const;
  void _internal_add_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_region_id();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 region_id(int index) const;
  void set_region_id(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      region_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_region_id();

  // required int64 partition_id = 1;
  bool has_partition_id() const;
  private:
  bool _internal_has_partition_id() const;
  public:
  void clear_partition_id();
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id() const;
  void set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_partition_id() const;
  void _internal_set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.PartitionRegion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class FieldInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.FieldInfo) */ {
 public:
  inline FieldInfo() : FieldInfo(nullptr) {}
  ~FieldInfo() override;
  explicit constexpr FieldInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldInfo(const FieldInfo& from);
  FieldInfo(FieldInfo&& from) noexcept
    : FieldInfo() {
    *this = ::std::move(from);
  }

  inline FieldInfo& operator=(const FieldInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldInfo& operator=(FieldInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldInfo* internal_default_instance() {
    return reinterpret_cast<const FieldInfo*>(
               &_FieldInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FieldInfo& a, FieldInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FieldInfo* New() const final {
    return new FieldInfo();
  }

  FieldInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FieldInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FieldInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.FieldInfo";
  }
  protected:
  explicit FieldInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldNameFieldNumber = 1,
    kNewFieldNameFieldNumber = 2,
    kDefaultValueFieldNumber = 8,
    kCommentFieldNumber = 9,
    kOnUpdateValueFieldNumber = 10,
    kEncryptFieldNumber = 11,
    kDefaultLiteralFieldNumber = 13,
    kMysqlTypeFieldNumber = 3,
    kFieldIdFieldNumber = 5,
    kCanNullFieldNumber = 4,
    kAutoIncrementFieldNumber = 6,
    kDeletedFieldNumber = 7,
    kIsUniqueIndicatorFieldNumber = 14,
    kFlagFieldNumber = 12,
    kFloatTotalLenFieldNumber = 15,
    kFloatPrecisionLenFieldNumber = 16,
  };
  // required string field_name = 1;
  bool has_field_name() const;
  private:
  bool _internal_has_field_name() const;
  public:
  void clear_field_name();
  const std::string& field_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_field_name();
  void set_allocated_field_name(std::string* field_name);
  private:
  const std::string& _internal_field_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field_name(const std::string& value);
  std::string* _internal_mutable_field_name();
  public:

  // optional string new_field_name = 2;
  bool has_new_field_name() const;
  private:
  bool _internal_has_new_field_name() const;
  public:
  void clear_new_field_name();
  const std::string& new_field_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_field_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_field_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_new_field_name();
  void set_allocated_new_field_name(std::string* new_field_name);
  private:
  const std::string& _internal_new_field_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_field_name(const std::string& value);
  std::string* _internal_mutable_new_field_name();
  public:

  // optional bytes default_value = 8;
  bool has_default_value() const;
  private:
  bool _internal_has_default_value() const;
  public:
  void clear_default_value();
  const std::string& default_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_default_value();
  void set_allocated_default_value(std::string* default_value);
  private:
  const std::string& _internal_default_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_value(const std::string& value);
  std::string* _internal_mutable_default_value();
  public:

  // optional bytes comment = 9;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_MUST_USE_RESULT std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // optional bytes on_update_value = 10;
  bool has_on_update_value() const;
  private:
  bool _internal_has_on_update_value() const;
  public:
  void clear_on_update_value();
  const std::string& on_update_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_on_update_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_on_update_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_on_update_value();
  void set_allocated_on_update_value(std::string* on_update_value);
  private:
  const std::string& _internal_on_update_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_on_update_value(const std::string& value);
  std::string* _internal_mutable_on_update_value();
  public:

  // optional bytes encrypt = 11;
  bool has_encrypt() const;
  private:
  bool _internal_has_encrypt() const;
  public:
  void clear_encrypt();
  const std::string& encrypt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encrypt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encrypt();
  PROTOBUF_MUST_USE_RESULT std::string* release_encrypt();
  void set_allocated_encrypt(std::string* encrypt);
  private:
  const std::string& _internal_encrypt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypt(const std::string& value);
  std::string* _internal_mutable_encrypt();
  public:

  // optional bytes default_literal = 13;
  bool has_default_literal() const;
  private:
  bool _internal_has_default_literal() const;
  public:
  void clear_default_literal();
  const std::string& default_literal() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_literal(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_literal();
  PROTOBUF_MUST_USE_RESULT std::string* release_default_literal();
  void set_allocated_default_literal(std::string* default_literal);
  private:
  const std::string& _internal_default_literal() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_literal(const std::string& value);
  std::string* _internal_mutable_default_literal();
  public:

  // optional .baikaldb.pb.PrimitiveType mysql_type = 3;
  bool has_mysql_type() const;
  private:
  bool _internal_has_mysql_type() const;
  public:
  void clear_mysql_type();
  ::baikaldb::pb::PrimitiveType mysql_type() const;
  void set_mysql_type(::baikaldb::pb::PrimitiveType value);
  private:
  ::baikaldb::pb::PrimitiveType _internal_mysql_type() const;
  void _internal_set_mysql_type(::baikaldb::pb::PrimitiveType value);
  public:

  // optional int32 field_id = 5;
  bool has_field_id() const;
  private:
  bool _internal_has_field_id() const;
  public:
  void clear_field_id();
  ::PROTOBUF_NAMESPACE_ID::int32 field_id() const;
  void set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_field_id() const;
  void _internal_set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool can_null = 4;
  bool has_can_null() const;
  private:
  bool _internal_has_can_null() const;
  public:
  void clear_can_null();
  bool can_null() const;
  void set_can_null(bool value);
  private:
  bool _internal_can_null() const;
  void _internal_set_can_null(bool value);
  public:

  // optional bool auto_increment = 6;
  bool has_auto_increment() const;
  private:
  bool _internal_has_auto_increment() const;
  public:
  void clear_auto_increment();
  bool auto_increment() const;
  void set_auto_increment(bool value);
  private:
  bool _internal_auto_increment() const;
  void _internal_set_auto_increment(bool value);
  public:

  // optional bool deleted = 7;
  bool has_deleted() const;
  private:
  bool _internal_has_deleted() const;
  public:
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // optional bool is_unique_indicator = 14;
  bool has_is_unique_indicator() const;
  private:
  bool _internal_has_is_unique_indicator() const;
  public:
  void clear_is_unique_indicator();
  bool is_unique_indicator() const;
  void set_is_unique_indicator(bool value);
  private:
  bool _internal_is_unique_indicator() const;
  void _internal_set_is_unique_indicator(bool value);
  public:

  // optional uint32 flag = 12;
  bool has_flag() const;
  private:
  bool _internal_has_flag() const;
  public:
  void clear_flag();
  ::PROTOBUF_NAMESPACE_ID::uint32 flag() const;
  void set_flag(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_flag() const;
  void _internal_set_flag(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional int32 float_total_len = 15;
  bool has_float_total_len() const;
  private:
  bool _internal_has_float_total_len() const;
  public:
  void clear_float_total_len();
  ::PROTOBUF_NAMESPACE_ID::int32 float_total_len() const;
  void set_float_total_len(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_float_total_len() const;
  void _internal_set_float_total_len(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 float_precision_len = 16;
  bool has_float_precision_len() const;
  private:
  bool _internal_has_float_precision_len() const;
  public:
  void clear_float_precision_len();
  ::PROTOBUF_NAMESPACE_ID::int32 float_precision_len() const;
  void set_float_precision_len(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_float_precision_len() const;
  void _internal_set_float_precision_len(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.FieldInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_field_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr on_update_value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypt_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_literal_;
  int mysql_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 field_id_;
  bool can_null_;
  bool auto_increment_;
  bool deleted_;
  bool is_unique_indicator_;
  ::PROTOBUF_NAMESPACE_ID::uint32 flag_;
  ::PROTOBUF_NAMESPACE_ID::int32 float_total_len_;
  ::PROTOBUF_NAMESPACE_ID::int32 float_precision_len_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class IndexInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.IndexInfo) */ {
 public:
  inline IndexInfo() : IndexInfo(nullptr) {}
  ~IndexInfo() override;
  explicit constexpr IndexInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexInfo(const IndexInfo& from);
  IndexInfo(IndexInfo&& from) noexcept
    : IndexInfo() {
    *this = ::std::move(from);
  }

  inline IndexInfo& operator=(const IndexInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexInfo& operator=(IndexInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexInfo* internal_default_instance() {
    return reinterpret_cast<const IndexInfo*>(
               &_IndexInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(IndexInfo& a, IndexInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IndexInfo* New() const final {
    return new IndexInfo();
  }

  IndexInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IndexInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IndexInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.IndexInfo";
  }
  protected:
  explicit IndexInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldNamesFieldNumber = 4,
    kFieldIdsFieldNumber = 5,
    kIndexNameFieldNumber = 1,
    kNewIndexNameFieldNumber = 2,
    kVectorDescriptionFieldNumber = 13,
    kIndexTypeFieldNumber = 3,
    kIsGlobalFieldNumber = 6,
    kIndexIdFieldNumber = 7,
    kSegmentTypeFieldNumber = 8,
    kStorageTypeFieldNumber = 10,
    kDropTimestampFieldNumber = 12,
    kDimensionFieldNumber = 14,
    kMetricTypeFieldNumber = 15,
    kNprobeFieldNumber = 16,
    kEfsearchFieldNumber = 17,
    kPublishTimestampFieldNumber = 20,
    kEfconstructionFieldNumber = 18,
    kRollupTypeFieldNumber = 19,
    kStateFieldNumber = 9,
    kHintStatusFieldNumber = 11,
  };
  // repeated string field_names = 4;
  int field_names_size() const;
  private:
  int _internal_field_names_size() const;
  public:
  void clear_field_names();
  const std::string& field_names(int index) const;
  std::string* mutable_field_names(int index);
  void set_field_names(int index, const std::string& value);
  void set_field_names(int index, std::string&& value);
  void set_field_names(int index, const char* value);
  void set_field_names(int index, const char* value, size_t size);
  std::string* add_field_names();
  void add_field_names(const std::string& value);
  void add_field_names(std::string&& value);
  void add_field_names(const char* value);
  void add_field_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& field_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_field_names();
  private:
  const std::string& _internal_field_names(int index) const;
  std::string* _internal_add_field_names();
  public:

  // repeated int32 field_ids = 5;
  int field_ids_size() const;
  private:
  int _internal_field_ids_size() const;
  public:
  void clear_field_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_field_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_field_ids() const;
  void _internal_add_field_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_field_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 field_ids(int index) const;
  void set_field_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_field_ids(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      field_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_field_ids();

  // required string index_name = 1;
  bool has_index_name() const;
  private:
  bool _internal_has_index_name() const;
  public:
  void clear_index_name();
  const std::string& index_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_index_name();
  void set_allocated_index_name(std::string* index_name);
  private:
  const std::string& _internal_index_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index_name(const std::string& value);
  std::string* _internal_mutable_index_name();
  public:

  // optional string new_index_name = 2;
  bool has_new_index_name() const;
  private:
  bool _internal_has_new_index_name() const;
  public:
  void clear_new_index_name();
  const std::string& new_index_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_index_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_index_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_new_index_name();
  void set_allocated_new_index_name(std::string* new_index_name);
  private:
  const std::string& _internal_new_index_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_index_name(const std::string& value);
  std::string* _internal_mutable_new_index_name();
  public:

  // optional string vector_description = 13;
  bool has_vector_description() const;
  private:
  bool _internal_has_vector_description() const;
  public:
  void clear_vector_description();
  const std::string& vector_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vector_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vector_description();
  PROTOBUF_MUST_USE_RESULT std::string* release_vector_description();
  void set_allocated_vector_description(std::string* vector_description);
  private:
  const std::string& _internal_vector_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vector_description(const std::string& value);
  std::string* _internal_mutable_vector_description();
  public:

  // optional .baikaldb.pb.IndexType index_type = 3;
  bool has_index_type() const;
  private:
  bool _internal_has_index_type() const;
  public:
  void clear_index_type();
  ::baikaldb::pb::IndexType index_type() const;
  void set_index_type(::baikaldb::pb::IndexType value);
  private:
  ::baikaldb::pb::IndexType _internal_index_type() const;
  void _internal_set_index_type(::baikaldb::pb::IndexType value);
  public:

  // optional bool is_global = 6;
  bool has_is_global() const;
  private:
  bool _internal_has_is_global() const;
  public:
  void clear_is_global();
  bool is_global() const;
  void set_is_global(bool value);
  private:
  bool _internal_is_global() const;
  void _internal_set_is_global(bool value);
  public:

  // optional int64 index_id = 7;
  bool has_index_id() const;
  private:
  bool _internal_has_index_id() const;
  public:
  void clear_index_id();
  ::PROTOBUF_NAMESPACE_ID::int64 index_id() const;
  void set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_index_id() const;
  void _internal_set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.SegmentType segment_type = 8;
  bool has_segment_type() const;
  private:
  bool _internal_has_segment_type() const;
  public:
  void clear_segment_type();
  ::baikaldb::pb::SegmentType segment_type() const;
  void set_segment_type(::baikaldb::pb::SegmentType value);
  private:
  ::baikaldb::pb::SegmentType _internal_segment_type() const;
  void _internal_set_segment_type(::baikaldb::pb::SegmentType value);
  public:

  // optional .baikaldb.pb.StorageType storage_type = 10;
  bool has_storage_type() const;
  private:
  bool _internal_has_storage_type() const;
  public:
  void clear_storage_type();
  ::baikaldb::pb::StorageType storage_type() const;
  void set_storage_type(::baikaldb::pb::StorageType value);
  private:
  ::baikaldb::pb::StorageType _internal_storage_type() const;
  void _internal_set_storage_type(::baikaldb::pb::StorageType value);
  public:

  // optional int64 drop_timestamp = 12;
  bool has_drop_timestamp() const;
  private:
  bool _internal_has_drop_timestamp() const;
  public:
  void clear_drop_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 drop_timestamp() const;
  void set_drop_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_drop_timestamp() const;
  void _internal_set_drop_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 dimension = 14;
  bool has_dimension() const;
  private:
  bool _internal_has_dimension() const;
  public:
  void clear_dimension();
  ::PROTOBUF_NAMESPACE_ID::int32 dimension() const;
  void set_dimension(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dimension() const;
  void _internal_set_dimension(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .baikaldb.pb.MetricType metric_type = 15;
  bool has_metric_type() const;
  private:
  bool _internal_has_metric_type() const;
  public:
  void clear_metric_type();
  ::baikaldb::pb::MetricType metric_type() const;
  void set_metric_type(::baikaldb::pb::MetricType value);
  private:
  ::baikaldb::pb::MetricType _internal_metric_type() const;
  void _internal_set_metric_type(::baikaldb::pb::MetricType value);
  public:

  // optional int32 nprobe = 16;
  bool has_nprobe() const;
  private:
  bool _internal_has_nprobe() const;
  public:
  void clear_nprobe();
  ::PROTOBUF_NAMESPACE_ID::int32 nprobe() const;
  void set_nprobe(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_nprobe() const;
  void _internal_set_nprobe(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 efsearch = 17;
  bool has_efsearch() const;
  private:
  bool _internal_has_efsearch() const;
  public:
  void clear_efsearch();
  ::PROTOBUF_NAMESPACE_ID::int32 efsearch() const;
  void set_efsearch(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_efsearch() const;
  void _internal_set_efsearch(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int64 publish_timestamp = 20;
  bool has_publish_timestamp() const;
  private:
  bool _internal_has_publish_timestamp() const;
  public:
  void clear_publish_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 publish_timestamp() const;
  void set_publish_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_publish_timestamp() const;
  void _internal_set_publish_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 efconstruction = 18;
  bool has_efconstruction() const;
  private:
  bool _internal_has_efconstruction() const;
  public:
  void clear_efconstruction();
  ::PROTOBUF_NAMESPACE_ID::int32 efconstruction() const;
  void set_efconstruction(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_efconstruction() const;
  void _internal_set_efconstruction(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .baikaldb.pb.RollupType rollup_type = 19;
  bool has_rollup_type() const;
  private:
  bool _internal_has_rollup_type() const;
  public:
  void clear_rollup_type();
  ::baikaldb::pb::RollupType rollup_type() const;
  void set_rollup_type(::baikaldb::pb::RollupType value);
  private:
  ::baikaldb::pb::RollupType _internal_rollup_type() const;
  void _internal_set_rollup_type(::baikaldb::pb::RollupType value);
  public:

  // optional .baikaldb.pb.IndexState state = 9;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::baikaldb::pb::IndexState state() const;
  void set_state(::baikaldb::pb::IndexState value);
  private:
  ::baikaldb::pb::IndexState _internal_state() const;
  void _internal_set_state(::baikaldb::pb::IndexState value);
  public:

  // optional .baikaldb.pb.IndexHintStatus hint_status = 11;
  bool has_hint_status() const;
  private:
  bool _internal_has_hint_status() const;
  public:
  void clear_hint_status();
  ::baikaldb::pb::IndexHintStatus hint_status() const;
  void set_hint_status(::baikaldb::pb::IndexHintStatus value);
  private:
  ::baikaldb::pb::IndexHintStatus _internal_hint_status() const;
  void _internal_set_hint_status(::baikaldb::pb::IndexHintStatus value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.IndexInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> field_names_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > field_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_index_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vector_description_;
  int index_type_;
  bool is_global_;
  ::PROTOBUF_NAMESPACE_ID::int64 index_id_;
  int segment_type_;
  int storage_type_;
  ::PROTOBUF_NAMESPACE_ID::int64 drop_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int32 dimension_;
  int metric_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 nprobe_;
  ::PROTOBUF_NAMESPACE_ID::int32 efsearch_;
  ::PROTOBUF_NAMESPACE_ID::int64 publish_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int32 efconstruction_;
  int rollup_type_;
  int state_;
  int hint_status_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RegionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RegionInfo) */ {
 public:
  inline RegionInfo() : RegionInfo(nullptr) {}
  ~RegionInfo() override;
  explicit constexpr RegionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionInfo(const RegionInfo& from);
  RegionInfo(RegionInfo&& from) noexcept
    : RegionInfo() {
    *this = ::std::move(from);
  }

  inline RegionInfo& operator=(const RegionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionInfo& operator=(RegionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionInfo* internal_default_instance() {
    return reinterpret_cast<const RegionInfo*>(
               &_RegionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RegionInfo& a, RegionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionInfo* New() const final {
    return new RegionInfo();
  }

  RegionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RegionInfo";
  }
  protected:
  explicit RegionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 10,
    kLearnersFieldNumber = 23,
    kTableNameFieldNumber = 2,
    kStartKeyFieldNumber = 8,
    kEndKeyFieldNumber = 9,
    kLeaderFieldNumber = 11,
    kRegionIdFieldNumber = 1,
    kTableIdFieldNumber = 3,
    kPartitionIdFieldNumber = 4,
    kReplicaNumFieldNumber = 5,
    kVersionFieldNumber = 6,
    kConfVersionFieldNumber = 7,
    kUsedSizeFieldNumber = 13,
    kLogIndexFieldNumber = 14,
    kParentFieldNumber = 17,
    kTimestampFieldNumber = 18,
    kDeletedFieldNumber = 15,
    kCanAddPeerFieldNumber = 16,
    kIsBinlogRegionFieldNumber = 21,
    kIsLearnerFieldNumber = 24,
    kNumTableLinesFieldNumber = 19,
    kMainTableIdFieldNumber = 20,
    kPartitionNumFieldNumber = 22,
    kStatusFieldNumber = 12,
  };
  // repeated string peers = 10;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  const std::string& peers(int index) const;
  std::string* mutable_peers(int index);
  void set_peers(int index, const std::string& value);
  void set_peers(int index, std::string&& value);
  void set_peers(int index, const char* value);
  void set_peers(int index, const char* value, size_t size);
  std::string* add_peers();
  void add_peers(const std::string& value);
  void add_peers(std::string&& value);
  void add_peers(const char* value);
  void add_peers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& peers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_peers();
  private:
  const std::string& _internal_peers(int index) const;
  std::string* _internal_add_peers();
  public:

  // repeated string learners = 23;
  int learners_size() const;
  private:
  int _internal_learners_size() const;
  public:
  void clear_learners();
  const std::string& learners(int index) const;
  std::string* mutable_learners(int index);
  void set_learners(int index, const std::string& value);
  void set_learners(int index, std::string&& value);
  void set_learners(int index, const char* value);
  void set_learners(int index, const char* value, size_t size);
  std::string* add_learners();
  void add_learners(const std::string& value);
  void add_learners(std::string&& value);
  void add_learners(const char* value);
  void add_learners(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& learners() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_learners();
  private:
  const std::string& _internal_learners(int index) const;
  std::string* _internal_add_learners();
  public:

  // optional string table_name = 2;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional bytes start_key = 8;
  bool has_start_key() const;
  private:
  bool _internal_has_start_key() const;
  public:
  void clear_start_key();
  const std::string& start_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_start_key();
  void set_allocated_start_key(std::string* start_key);
  private:
  const std::string& _internal_start_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_key(const std::string& value);
  std::string* _internal_mutable_start_key();
  public:

  // optional bytes end_key = 9;
  bool has_end_key() const;
  private:
  bool _internal_has_end_key() const;
  public:
  void clear_end_key();
  const std::string& end_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_end_key();
  void set_allocated_end_key(std::string* end_key);
  private:
  const std::string& _internal_end_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_key(const std::string& value);
  std::string* _internal_mutable_end_key();
  public:

  // optional string leader = 11;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // required int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 table_id = 3;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 partition_id = 4;
  bool has_partition_id() const;
  private:
  bool _internal_has_partition_id() const;
  public:
  void clear_partition_id();
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id() const;
  void set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_partition_id() const;
  void _internal_set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 replica_num = 5;
  bool has_replica_num() const;
  private:
  bool _internal_has_replica_num() const;
  public:
  void clear_replica_num();
  ::PROTOBUF_NAMESPACE_ID::int64 replica_num() const;
  void set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_replica_num() const;
  void _internal_set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 version = 6;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 conf_version = 7;
  bool has_conf_version() const;
  private:
  bool _internal_has_conf_version() const;
  public:
  void clear_conf_version();
  ::PROTOBUF_NAMESPACE_ID::int64 conf_version() const;
  void set_conf_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_conf_version() const;
  void _internal_set_conf_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 used_size = 13;
  bool has_used_size() const;
  private:
  bool _internal_has_used_size() const;
  public:
  void clear_used_size();
  ::PROTOBUF_NAMESPACE_ID::int64 used_size() const;
  void set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_used_size() const;
  void _internal_set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 log_index = 14;
  bool has_log_index() const;
  private:
  bool _internal_has_log_index() const;
  public:
  void clear_log_index();
  ::PROTOBUF_NAMESPACE_ID::int64 log_index() const;
  void set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_log_index() const;
  void _internal_set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 parent = 17;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  ::PROTOBUF_NAMESPACE_ID::int64 parent() const;
  void set_parent(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_parent() const;
  void _internal_set_parent(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint32 timestamp = 18;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool deleted = 15;
  bool has_deleted() const;
  private:
  bool _internal_has_deleted() const;
  public:
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // optional bool can_add_peer = 16;
  bool has_can_add_peer() const;
  private:
  bool _internal_has_can_add_peer() const;
  public:
  void clear_can_add_peer();
  bool can_add_peer() const;
  void set_can_add_peer(bool value);
  private:
  bool _internal_can_add_peer() const;
  void _internal_set_can_add_peer(bool value);
  public:

  // optional bool is_binlog_region = 21;
  bool has_is_binlog_region() const;
  private:
  bool _internal_has_is_binlog_region() const;
  public:
  void clear_is_binlog_region();
  bool is_binlog_region() const;
  void set_is_binlog_region(bool value);
  private:
  bool _internal_is_binlog_region() const;
  void _internal_set_is_binlog_region(bool value);
  public:

  // optional bool is_learner = 24;
  bool has_is_learner() const;
  private:
  bool _internal_has_is_learner() const;
  public:
  void clear_is_learner();
  bool is_learner() const;
  void set_is_learner(bool value);
  private:
  bool _internal_is_learner() const;
  void _internal_set_is_learner(bool value);
  public:

  // optional int64 num_table_lines = 19;
  bool has_num_table_lines() const;
  private:
  bool _internal_has_num_table_lines() const;
  public:
  void clear_num_table_lines();
  ::PROTOBUF_NAMESPACE_ID::int64 num_table_lines() const;
  void set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_num_table_lines() const;
  void _internal_set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 main_table_id = 20;
  bool has_main_table_id() const;
  private:
  bool _internal_has_main_table_id() const;
  public:
  void clear_main_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 main_table_id() const;
  void set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_main_table_id() const;
  void _internal_set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 partition_num = 22;
  bool has_partition_num() const;
  private:
  bool _internal_has_partition_num() const;
  public:
  void clear_partition_num();
  ::PROTOBUF_NAMESPACE_ID::int64 partition_num() const;
  void set_partition_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_partition_num() const;
  void _internal_set_partition_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.RegionStatus status = 12;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::baikaldb::pb::RegionStatus status() const;
  void set_status(::baikaldb::pb::RegionStatus value);
  private:
  ::baikaldb::pb::RegionStatus _internal_status() const;
  void _internal_set_status(::baikaldb::pb::RegionStatus value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RegionInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> peers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> learners_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 replica_num_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  ::PROTOBUF_NAMESPACE_ID::int64 conf_version_;
  ::PROTOBUF_NAMESPACE_ID::int64 used_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 log_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 parent_;
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp_;
  bool deleted_;
  bool can_add_peer_;
  bool is_binlog_region_;
  bool is_learner_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_table_lines_;
  ::PROTOBUF_NAMESPACE_ID::int64 main_table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 partition_num_;
  int status_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class StoreRegionDdlInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.StoreRegionDdlInfo) */ {
 public:
  inline StoreRegionDdlInfo() : StoreRegionDdlInfo(nullptr) {}
  ~StoreRegionDdlInfo() override;
  explicit constexpr StoreRegionDdlInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreRegionDdlInfo(const StoreRegionDdlInfo& from);
  StoreRegionDdlInfo(StoreRegionDdlInfo&& from) noexcept
    : StoreRegionDdlInfo() {
    *this = ::std::move(from);
  }

  inline StoreRegionDdlInfo& operator=(const StoreRegionDdlInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreRegionDdlInfo& operator=(StoreRegionDdlInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreRegionDdlInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreRegionDdlInfo* internal_default_instance() {
    return reinterpret_cast<const StoreRegionDdlInfo*>(
               &_StoreRegionDdlInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StoreRegionDdlInfo& a, StoreRegionDdlInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreRegionDdlInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreRegionDdlInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StoreRegionDdlInfo* New() const final {
    return new StoreRegionDdlInfo();
  }

  StoreRegionDdlInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StoreRegionDdlInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreRegionDdlInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreRegionDdlInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreRegionDdlInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.StoreRegionDdlInfo";
  }
  protected:
  explicit StoreRegionDdlInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDdlworkInfosFieldNumber = 2,
    kRegionIdFieldNumber = 1,
  };
  // repeated .baikaldb.pb.DdlWorkInfo ddlwork_infos = 2;
  int ddlwork_infos_size() const;
  private:
  int _internal_ddlwork_infos_size() const;
  public:
  void clear_ddlwork_infos();
  ::baikaldb::pb::DdlWorkInfo* mutable_ddlwork_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >*
      mutable_ddlwork_infos();
  private:
  const ::baikaldb::pb::DdlWorkInfo& _internal_ddlwork_infos(int index) const;
  ::baikaldb::pb::DdlWorkInfo* _internal_add_ddlwork_infos();
  public:
  const ::baikaldb::pb::DdlWorkInfo& ddlwork_infos(int index) const;
  ::baikaldb::pb::DdlWorkInfo* add_ddlwork_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >&
      ddlwork_infos() const;

  // required int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.StoreRegionDdlInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo > ddlwork_infos_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class PrivilegeDatabase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.PrivilegeDatabase) */ {
 public:
  inline PrivilegeDatabase() : PrivilegeDatabase(nullptr) {}
  ~PrivilegeDatabase() override;
  explicit constexpr PrivilegeDatabase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivilegeDatabase(const PrivilegeDatabase& from);
  PrivilegeDatabase(PrivilegeDatabase&& from) noexcept
    : PrivilegeDatabase() {
    *this = ::std::move(from);
  }

  inline PrivilegeDatabase& operator=(const PrivilegeDatabase& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivilegeDatabase& operator=(PrivilegeDatabase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrivilegeDatabase& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivilegeDatabase* internal_default_instance() {
    return reinterpret_cast<const PrivilegeDatabase*>(
               &_PrivilegeDatabase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PrivilegeDatabase& a, PrivilegeDatabase& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivilegeDatabase* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivilegeDatabase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PrivilegeDatabase* New() const final {
    return new PrivilegeDatabase();
  }

  PrivilegeDatabase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PrivilegeDatabase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrivilegeDatabase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PrivilegeDatabase& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrivilegeDatabase* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.PrivilegeDatabase";
  }
  protected:
  explicit PrivilegeDatabase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseFieldNumber = 1,
    kDatabaseIdFieldNumber = 2,
    kForceFieldNumber = 4,
    kAclFieldNumber = 5,
    kDatabaseRwFieldNumber = 3,
  };
  // required string database = 1;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_MUST_USE_RESULT std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // optional int64 database_id = 2;
  bool has_database_id() const;
  private:
  bool _internal_has_database_id() const;
  public:
  void clear_database_id();
  ::PROTOBUF_NAMESPACE_ID::int64 database_id() const;
  void set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_database_id() const;
  void _internal_set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool force = 4;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // optional uint32 acl = 5;
  bool has_acl() const;
  private:
  bool _internal_has_acl() const;
  public:
  void clear_acl();
  ::PROTOBUF_NAMESPACE_ID::uint32 acl() const;
  void set_acl(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_acl() const;
  void _internal_set_acl(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .baikaldb.pb.RW database_rw = 3;
  bool has_database_rw() const;
  private:
  bool _internal_has_database_rw() const;
  public:
  void clear_database_rw();
  ::baikaldb::pb::RW database_rw() const;
  void set_database_rw(::baikaldb::pb::RW value);
  private:
  ::baikaldb::pb::RW _internal_database_rw() const;
  void _internal_set_database_rw(::baikaldb::pb::RW value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.PrivilegeDatabase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
  ::PROTOBUF_NAMESPACE_ID::int64 database_id_;
  bool force_;
  ::PROTOBUF_NAMESPACE_ID::uint32 acl_;
  int database_rw_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class PrivilegeTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.PrivilegeTable) */ {
 public:
  inline PrivilegeTable() : PrivilegeTable(nullptr) {}
  ~PrivilegeTable() override;
  explicit constexpr PrivilegeTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrivilegeTable(const PrivilegeTable& from);
  PrivilegeTable(PrivilegeTable&& from) noexcept
    : PrivilegeTable() {
    *this = ::std::move(from);
  }

  inline PrivilegeTable& operator=(const PrivilegeTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrivilegeTable& operator=(PrivilegeTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrivilegeTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrivilegeTable* internal_default_instance() {
    return reinterpret_cast<const PrivilegeTable*>(
               &_PrivilegeTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PrivilegeTable& a, PrivilegeTable& b) {
    a.Swap(&b);
  }
  inline void Swap(PrivilegeTable* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrivilegeTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PrivilegeTable* New() const final {
    return new PrivilegeTable();
  }

  PrivilegeTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PrivilegeTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrivilegeTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PrivilegeTable& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrivilegeTable* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.PrivilegeTable";
  }
  protected:
  explicit PrivilegeTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatabaseFieldNumber = 1,
    kTableNameFieldNumber = 3,
    kDatabaseIdFieldNumber = 2,
    kTableIdFieldNumber = 4,
    kForceFieldNumber = 6,
    kAclFieldNumber = 7,
    kTableRwFieldNumber = 5,
  };
  // required string database = 1;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_MUST_USE_RESULT std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // required string table_name = 3;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional int64 database_id = 2;
  bool has_database_id() const;
  private:
  bool _internal_has_database_id() const;
  public:
  void clear_database_id();
  ::PROTOBUF_NAMESPACE_ID::int64 database_id() const;
  void set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_database_id() const;
  void _internal_set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 table_id = 4;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool force = 6;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // optional uint32 acl = 7;
  bool has_acl() const;
  private:
  bool _internal_has_acl() const;
  public:
  void clear_acl();
  ::PROTOBUF_NAMESPACE_ID::uint32 acl() const;
  void set_acl(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_acl() const;
  void _internal_set_acl(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .baikaldb.pb.RW table_rw = 5;
  bool has_table_rw() const;
  private:
  bool _internal_has_table_rw() const;
  public:
  void clear_table_rw();
  ::baikaldb::pb::RW table_rw() const;
  void set_table_rw(::baikaldb::pb::RW value);
  private:
  ::baikaldb::pb::RW _internal_table_rw() const;
  void _internal_set_table_rw(::baikaldb::pb::RW value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.PrivilegeTable)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::int64 database_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  bool force_;
  ::PROTOBUF_NAMESPACE_ID::uint32 acl_;
  int table_rw_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class UserPrivilege final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.UserPrivilege) */ {
 public:
  inline UserPrivilege() : UserPrivilege(nullptr) {}
  ~UserPrivilege() override;
  explicit constexpr UserPrivilege(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserPrivilege(const UserPrivilege& from);
  UserPrivilege(UserPrivilege&& from) noexcept
    : UserPrivilege() {
    *this = ::std::move(from);
  }

  inline UserPrivilege& operator=(const UserPrivilege& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserPrivilege& operator=(UserPrivilege&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserPrivilege& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserPrivilege* internal_default_instance() {
    return reinterpret_cast<const UserPrivilege*>(
               &_UserPrivilege_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UserPrivilege& a, UserPrivilege& b) {
    a.Swap(&b);
  }
  inline void Swap(UserPrivilege* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserPrivilege* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserPrivilege* New() const final {
    return new UserPrivilege();
  }

  UserPrivilege* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserPrivilege>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserPrivilege& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserPrivilege& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserPrivilege* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.UserPrivilege";
  }
  protected:
  explicit UserPrivilege(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrivilegeDatabaseFieldNumber = 5,
    kPrivilegeTableFieldNumber = 6,
    kBnsFieldNumber = 7,
    kIpFieldNumber = 8,
    kSwitchTablesFieldNumber = 19,
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kNamespaceNameFieldNumber = 3,
    kResourceTagFieldNumber = 12,
    kNamespaceIdFieldNumber = 4,
    kVersionFieldNumber = 9,
    kEncryptFieldNumber = 10,
    kNeedAuthAddrFieldNumber = 11,
    kDdlPermissionFieldNumber = 13,
    kUseReadIndexFieldNumber = 15,
    kRequestRangePartitionTypeFieldNumber = 17,
    kTxnLockTimeoutFieldNumber = 14,
    kEnablePlanCacheFieldNumber = 16,
    kIsSuperFieldNumber = 18,
    kIfExistFieldNumber = 21,
    kIsRequestAdditionalFieldNumber = 24,
    kAclFieldNumber = 20,
  };
  // repeated .baikaldb.pb.PrivilegeDatabase privilege_database = 5;
  int privilege_database_size() const;
  private:
  int _internal_privilege_database_size() const;
  public:
  void clear_privilege_database();
  ::baikaldb::pb::PrivilegeDatabase* mutable_privilege_database(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PrivilegeDatabase >*
      mutable_privilege_database();
  private:
  const ::baikaldb::pb::PrivilegeDatabase& _internal_privilege_database(int index) const;
  ::baikaldb::pb::PrivilegeDatabase* _internal_add_privilege_database();
  public:
  const ::baikaldb::pb::PrivilegeDatabase& privilege_database(int index) const;
  ::baikaldb::pb::PrivilegeDatabase* add_privilege_database();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PrivilegeDatabase >&
      privilege_database() const;

  // repeated .baikaldb.pb.PrivilegeTable privilege_table = 6;
  int privilege_table_size() const;
  private:
  int _internal_privilege_table_size() const;
  public:
  void clear_privilege_table();
  ::baikaldb::pb::PrivilegeTable* mutable_privilege_table(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PrivilegeTable >*
      mutable_privilege_table();
  private:
  const ::baikaldb::pb::PrivilegeTable& _internal_privilege_table(int index) const;
  ::baikaldb::pb::PrivilegeTable* _internal_add_privilege_table();
  public:
  const ::baikaldb::pb::PrivilegeTable& privilege_table(int index) const;
  ::baikaldb::pb::PrivilegeTable* add_privilege_table();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PrivilegeTable >&
      privilege_table() const;

  // repeated string bns = 7;
  int bns_size() const;
  private:
  int _internal_bns_size() const;
  public:
  void clear_bns();
  const std::string& bns(int index) const;
  std::string* mutable_bns(int index);
  void set_bns(int index, const std::string& value);
  void set_bns(int index, std::string&& value);
  void set_bns(int index, const char* value);
  void set_bns(int index, const char* value, size_t size);
  std::string* add_bns();
  void add_bns(const std::string& value);
  void add_bns(std::string&& value);
  void add_bns(const char* value);
  void add_bns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bns();
  private:
  const std::string& _internal_bns(int index) const;
  std::string* _internal_add_bns();
  public:

  // repeated string ip = 8;
  int ip_size() const;
  private:
  int _internal_ip_size() const;
  public:
  void clear_ip();
  const std::string& ip(int index) const;
  std::string* mutable_ip(int index);
  void set_ip(int index, const std::string& value);
  void set_ip(int index, std::string&& value);
  void set_ip(int index, const char* value);
  void set_ip(int index, const char* value, size_t size);
  std::string* add_ip();
  void add_ip(const std::string& value);
  void add_ip(std::string&& value);
  void add_ip(const char* value);
  void add_ip(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ip() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ip();
  private:
  const std::string& _internal_ip(int index) const;
  std::string* _internal_add_ip();
  public:

  // repeated int64 switch_tables = 19;
  int switch_tables_size() const;
  private:
  int _internal_switch_tables_size() const;
  public:
  void clear_switch_tables();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_switch_tables(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_switch_tables() const;
  void _internal_add_switch_tables(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_switch_tables();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 switch_tables(int index) const;
  void set_switch_tables(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_switch_tables(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      switch_tables() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_switch_tables();

  // required string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string password = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // required string namespace_name = 3;
  bool has_namespace_name() const;
  private:
  bool _internal_has_namespace_name() const;
  public:
  void clear_namespace_name();
  const std::string& namespace_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_namespace_name();
  void set_allocated_namespace_name(std::string* namespace_name);
  private:
  const std::string& _internal_namespace_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_name(const std::string& value);
  std::string* _internal_mutable_namespace_name();
  public:

  // optional string resource_tag = 12;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional int64 namespace_id = 4;
  bool has_namespace_id() const;
  private:
  bool _internal_has_namespace_id() const;
  public:
  void clear_namespace_id();
  ::PROTOBUF_NAMESPACE_ID::int64 namespace_id() const;
  void set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_namespace_id() const;
  void _internal_set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 version = 9;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool encrypt = 10;
  bool has_encrypt() const;
  private:
  bool _internal_has_encrypt() const;
  public:
  void clear_encrypt();
  bool encrypt() const;
  void set_encrypt(bool value);
  private:
  bool _internal_encrypt() const;
  void _internal_set_encrypt(bool value);
  public:

  // optional bool need_auth_addr = 11;
  bool has_need_auth_addr() const;
  private:
  bool _internal_has_need_auth_addr() const;
  public:
  void clear_need_auth_addr();
  bool need_auth_addr() const;
  void set_need_auth_addr(bool value);
  private:
  bool _internal_need_auth_addr() const;
  void _internal_set_need_auth_addr(bool value);
  public:

  // optional bool ddl_permission = 13;
  bool has_ddl_permission() const;
  private:
  bool _internal_has_ddl_permission() const;
  public:
  void clear_ddl_permission();
  bool ddl_permission() const;
  void set_ddl_permission(bool value);
  private:
  bool _internal_ddl_permission() const;
  void _internal_set_ddl_permission(bool value);
  public:

  // optional bool use_read_index = 15;
  bool has_use_read_index() const;
  private:
  bool _internal_has_use_read_index() const;
  public:
  void clear_use_read_index();
  bool use_read_index() const;
  void set_use_read_index(bool value);
  private:
  bool _internal_use_read_index() const;
  void _internal_set_use_read_index(bool value);
  public:

  // optional .baikaldb.pb.RangePartitionType request_range_partition_type = 17;
  bool has_request_range_partition_type() const;
  private:
  bool _internal_has_request_range_partition_type() const;
  public:
  void clear_request_range_partition_type();
  ::baikaldb::pb::RangePartitionType request_range_partition_type() const;
  void set_request_range_partition_type(::baikaldb::pb::RangePartitionType value);
  private:
  ::baikaldb::pb::RangePartitionType _internal_request_range_partition_type() const;
  void _internal_set_request_range_partition_type(::baikaldb::pb::RangePartitionType value);
  public:

  // optional int64 txn_lock_timeout = 14;
  bool has_txn_lock_timeout() const;
  private:
  bool _internal_has_txn_lock_timeout() const;
  public:
  void clear_txn_lock_timeout();
  ::PROTOBUF_NAMESPACE_ID::int64 txn_lock_timeout() const;
  void set_txn_lock_timeout(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_txn_lock_timeout() const;
  void _internal_set_txn_lock_timeout(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool enable_plan_cache = 16;
  bool has_enable_plan_cache() const;
  private:
  bool _internal_has_enable_plan_cache() const;
  public:
  void clear_enable_plan_cache();
  bool enable_plan_cache() const;
  void set_enable_plan_cache(bool value);
  private:
  bool _internal_enable_plan_cache() const;
  void _internal_set_enable_plan_cache(bool value);
  public:

  // optional bool is_super = 18;
  bool has_is_super() const;
  private:
  bool _internal_has_is_super() const;
  public:
  void clear_is_super();
  bool is_super() const;
  void set_is_super(bool value);
  private:
  bool _internal_is_super() const;
  void _internal_set_is_super(bool value);
  public:

  // optional bool if_exist = 21;
  bool has_if_exist() const;
  private:
  bool _internal_has_if_exist() const;
  public:
  void clear_if_exist();
  bool if_exist() const;
  void set_if_exist(bool value);
  private:
  bool _internal_if_exist() const;
  void _internal_set_if_exist(bool value);
  public:

  // optional bool is_request_additional = 24;
  bool has_is_request_additional() const;
  private:
  bool _internal_has_is_request_additional() const;
  public:
  void clear_is_request_additional();
  bool is_request_additional() const;
  void set_is_request_additional(bool value);
  private:
  bool _internal_is_request_additional() const;
  void _internal_set_is_request_additional(bool value);
  public:

  // optional uint32 acl = 20;
  bool has_acl() const;
  private:
  bool _internal_has_acl() const;
  public:
  void clear_acl();
  ::PROTOBUF_NAMESPACE_ID::uint32 acl() const;
  void set_acl(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_acl() const;
  void _internal_set_acl(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.UserPrivilege)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PrivilegeDatabase > privilege_database_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PrivilegeTable > privilege_table_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bns_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ip_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > switch_tables_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::int64 namespace_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  bool encrypt_;
  bool need_auth_addr_;
  bool ddl_permission_;
  bool use_read_index_;
  int request_range_partition_type_;
  ::PROTOBUF_NAMESPACE_ID::int64 txn_lock_timeout_;
  bool enable_plan_cache_;
  bool is_super_;
  bool if_exist_;
  bool is_request_additional_;
  ::PROTOBUF_NAMESPACE_ID::uint32 acl_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class LogicalRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.LogicalRoom) */ {
 public:
  inline LogicalRoom() : LogicalRoom(nullptr) {}
  ~LogicalRoom() override;
  explicit constexpr LogicalRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogicalRoom(const LogicalRoom& from);
  LogicalRoom(LogicalRoom&& from) noexcept
    : LogicalRoom() {
    *this = ::std::move(from);
  }

  inline LogicalRoom& operator=(const LogicalRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogicalRoom& operator=(LogicalRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogicalRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogicalRoom* internal_default_instance() {
    return reinterpret_cast<const LogicalRoom*>(
               &_LogicalRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(LogicalRoom& a, LogicalRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(LogicalRoom* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogicalRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogicalRoom* New() const final {
    return new LogicalRoom();
  }

  LogicalRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogicalRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogicalRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogicalRoom& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicalRoom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.LogicalRoom";
  }
  protected:
  explicit LogicalRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalRoomsFieldNumber = 1,
  };
  // repeated string logical_rooms = 1;
  int logical_rooms_size() const;
  private:
  int _internal_logical_rooms_size() const;
  public:
  void clear_logical_rooms();
  const std::string& logical_rooms(int index) const;
  std::string* mutable_logical_rooms(int index);
  void set_logical_rooms(int index, const std::string& value);
  void set_logical_rooms(int index, std::string&& value);
  void set_logical_rooms(int index, const char* value);
  void set_logical_rooms(int index, const char* value, size_t size);
  std::string* add_logical_rooms();
  void add_logical_rooms(const std::string& value);
  void add_logical_rooms(std::string&& value);
  void add_logical_rooms(const char* value);
  void add_logical_rooms(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& logical_rooms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_logical_rooms();
  private:
  const std::string& _internal_logical_rooms(int index) const;
  std::string* _internal_add_logical_rooms();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.LogicalRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> logical_rooms_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class PhysicalRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.PhysicalRoom) */ {
 public:
  inline PhysicalRoom() : PhysicalRoom(nullptr) {}
  ~PhysicalRoom() override;
  explicit constexpr PhysicalRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhysicalRoom(const PhysicalRoom& from);
  PhysicalRoom(PhysicalRoom&& from) noexcept
    : PhysicalRoom() {
    *this = ::std::move(from);
  }

  inline PhysicalRoom& operator=(const PhysicalRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhysicalRoom& operator=(PhysicalRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhysicalRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhysicalRoom* internal_default_instance() {
    return reinterpret_cast<const PhysicalRoom*>(
               &_PhysicalRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PhysicalRoom& a, PhysicalRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(PhysicalRoom* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhysicalRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PhysicalRoom* New() const final {
    return new PhysicalRoom();
  }

  PhysicalRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PhysicalRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhysicalRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PhysicalRoom& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicalRoom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.PhysicalRoom";
  }
  protected:
  explicit PhysicalRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhysicalRoomsFieldNumber = 2,
    kLogicalRoomFieldNumber = 1,
  };
  // repeated string physical_rooms = 2;
  int physical_rooms_size() const;
  private:
  int _internal_physical_rooms_size() const;
  public:
  void clear_physical_rooms();
  const std::string& physical_rooms(int index) const;
  std::string* mutable_physical_rooms(int index);
  void set_physical_rooms(int index, const std::string& value);
  void set_physical_rooms(int index, std::string&& value);
  void set_physical_rooms(int index, const char* value);
  void set_physical_rooms(int index, const char* value, size_t size);
  std::string* add_physical_rooms();
  void add_physical_rooms(const std::string& value);
  void add_physical_rooms(std::string&& value);
  void add_physical_rooms(const char* value);
  void add_physical_rooms(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& physical_rooms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_physical_rooms();
  private:
  const std::string& _internal_physical_rooms(int index) const;
  std::string* _internal_add_physical_rooms();
  public:

  // required string logical_room = 1;
  bool has_logical_room() const;
  private:
  bool _internal_has_logical_room() const;
  public:
  void clear_logical_room();
  const std::string& logical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_logical_room();
  void set_allocated_logical_room(std::string* logical_room);
  private:
  const std::string& _internal_logical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logical_room(const std::string& value);
  std::string* _internal_mutable_logical_room();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.PhysicalRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> physical_rooms_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logical_room_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class InstanceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.InstanceInfo) */ {
 public:
  inline InstanceInfo() : InstanceInfo(nullptr) {}
  ~InstanceInfo() override;
  explicit constexpr InstanceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstanceInfo(const InstanceInfo& from);
  InstanceInfo(InstanceInfo&& from) noexcept
    : InstanceInfo() {
    *this = ::std::move(from);
  }

  inline InstanceInfo& operator=(const InstanceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstanceInfo& operator=(InstanceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstanceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstanceInfo* internal_default_instance() {
    return reinterpret_cast<const InstanceInfo*>(
               &_InstanceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(InstanceInfo& a, InstanceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(InstanceInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstanceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InstanceInfo* New() const final {
    return new InstanceInfo();
  }

  InstanceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InstanceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstanceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InstanceInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstanceInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.InstanceInfo";
  }
  protected:
  explicit InstanceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kResourceTagFieldNumber = 4,
    kPhysicalRoomFieldNumber = 5,
    kLogicalRoomFieldNumber = 7,
    kVersionFieldNumber = 8,
    kNetworkSegmentFieldNumber = 15,
    kContainerIdFieldNumber = 16,
    kInitAddressFieldNumber = 18,
    kCapacityFieldNumber = 2,
    kUsedSizeFieldNumber = 3,
    kDmlLatencyFieldNumber = 9,
    kDmlQpsFieldNumber = 10,
    kRaftTotalLatencyFieldNumber = 11,
    kRaftTotalQpsFieldNumber = 12,
    kSelectLatencyFieldNumber = 13,
    kSelectQpsFieldNumber = 14,
    kRocksHangCheckCostFieldNumber = 17,
    kStatusFieldNumber = 6,
  };
  // optional string address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional string resource_tag = 4;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional string physical_room = 5;
  bool has_physical_room() const;
  private:
  bool _internal_has_physical_room() const;
  public:
  void clear_physical_room();
  const std::string& physical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_physical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_physical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_physical_room();
  void set_allocated_physical_room(std::string* physical_room);
  private:
  const std::string& _internal_physical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_physical_room(const std::string& value);
  std::string* _internal_mutable_physical_room();
  public:

  // optional string logical_room = 7;
  bool has_logical_room() const;
  private:
  bool _internal_has_logical_room() const;
  public:
  void clear_logical_room();
  const std::string& logical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_logical_room();
  void set_allocated_logical_room(std::string* logical_room);
  private:
  const std::string& _internal_logical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logical_room(const std::string& value);
  std::string* _internal_mutable_logical_room();
  public:

  // optional string version = 8;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string network_segment = 15;
  bool has_network_segment() const;
  private:
  bool _internal_has_network_segment() const;
  public:
  void clear_network_segment();
  const std::string& network_segment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network_segment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network_segment();
  PROTOBUF_MUST_USE_RESULT std::string* release_network_segment();
  void set_allocated_network_segment(std::string* network_segment);
  private:
  const std::string& _internal_network_segment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network_segment(const std::string& value);
  std::string* _internal_mutable_network_segment();
  public:

  // optional string container_id = 16;
  bool has_container_id() const;
  private:
  bool _internal_has_container_id() const;
  public:
  void clear_container_id();
  const std::string& container_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_container_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_container_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_container_id();
  void set_allocated_container_id(std::string* container_id);
  private:
  const std::string& _internal_container_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_container_id(const std::string& value);
  std::string* _internal_mutable_container_id();
  public:

  // optional string init_address = 18;
  bool has_init_address() const;
  private:
  bool _internal_has_init_address() const;
  public:
  void clear_init_address();
  const std::string& init_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_init_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_init_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_init_address();
  void set_allocated_init_address(std::string* init_address);
  private:
  const std::string& _internal_init_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_init_address(const std::string& value);
  std::string* _internal_mutable_init_address();
  public:

  // optional int64 capacity = 2;
  bool has_capacity() const;
  private:
  bool _internal_has_capacity() const;
  public:
  void clear_capacity();
  ::PROTOBUF_NAMESPACE_ID::int64 capacity() const;
  void set_capacity(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_capacity() const;
  void _internal_set_capacity(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 used_size = 3;
  bool has_used_size() const;
  private:
  bool _internal_has_used_size() const;
  public:
  void clear_used_size();
  ::PROTOBUF_NAMESPACE_ID::int64 used_size() const;
  void set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_used_size() const;
  void _internal_set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 dml_latency = 9;
  bool has_dml_latency() const;
  private:
  bool _internal_has_dml_latency() const;
  public:
  void clear_dml_latency();
  ::PROTOBUF_NAMESPACE_ID::int64 dml_latency() const;
  void set_dml_latency(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_dml_latency() const;
  void _internal_set_dml_latency(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 dml_qps = 10;
  bool has_dml_qps() const;
  private:
  bool _internal_has_dml_qps() const;
  public:
  void clear_dml_qps();
  ::PROTOBUF_NAMESPACE_ID::int64 dml_qps() const;
  void set_dml_qps(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_dml_qps() const;
  void _internal_set_dml_qps(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 raft_total_latency = 11;
  bool has_raft_total_latency() const;
  private:
  bool _internal_has_raft_total_latency() const;
  public:
  void clear_raft_total_latency();
  ::PROTOBUF_NAMESPACE_ID::int64 raft_total_latency() const;
  void set_raft_total_latency(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_raft_total_latency() const;
  void _internal_set_raft_total_latency(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 raft_total_qps = 12;
  bool has_raft_total_qps() const;
  private:
  bool _internal_has_raft_total_qps() const;
  public:
  void clear_raft_total_qps();
  ::PROTOBUF_NAMESPACE_ID::int64 raft_total_qps() const;
  void set_raft_total_qps(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_raft_total_qps() const;
  void _internal_set_raft_total_qps(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 select_latency = 13;
  bool has_select_latency() const;
  private:
  bool _internal_has_select_latency() const;
  public:
  void clear_select_latency();
  ::PROTOBUF_NAMESPACE_ID::int64 select_latency() const;
  void set_select_latency(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_select_latency() const;
  void _internal_set_select_latency(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 select_qps = 14;
  bool has_select_qps() const;
  private:
  bool _internal_has_select_qps() const;
  public:
  void clear_select_qps();
  ::PROTOBUF_NAMESPACE_ID::int64 select_qps() const;
  void set_select_qps(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_select_qps() const;
  void _internal_set_select_qps(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 rocks_hang_check_cost = 17;
  bool has_rocks_hang_check_cost() const;
  private:
  bool _internal_has_rocks_hang_check_cost() const;
  public:
  void clear_rocks_hang_check_cost();
  ::PROTOBUF_NAMESPACE_ID::int64 rocks_hang_check_cost() const;
  void set_rocks_hang_check_cost(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_rocks_hang_check_cost() const;
  void _internal_set_rocks_hang_check_cost(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.Status status = 6;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::baikaldb::pb::Status status() const;
  void set_status(::baikaldb::pb::Status value);
  private:
  ::baikaldb::pb::Status _internal_status() const;
  void _internal_set_status(::baikaldb::pb::Status value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.InstanceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr physical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_segment_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr container_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr init_address_;
  ::PROTOBUF_NAMESPACE_ID::int64 capacity_;
  ::PROTOBUF_NAMESPACE_ID::int64 used_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 dml_latency_;
  ::PROTOBUF_NAMESPACE_ID::int64 dml_qps_;
  ::PROTOBUF_NAMESPACE_ID::int64 raft_total_latency_;
  ::PROTOBUF_NAMESPACE_ID::int64 raft_total_qps_;
  ::PROTOBUF_NAMESPACE_ID::int64 select_latency_;
  ::PROTOBUF_NAMESPACE_ID::int64 select_qps_;
  ::PROTOBUF_NAMESPACE_ID::int64 rocks_hang_check_cost_;
  int status_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BaikalStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BaikalStatus) */ {
 public:
  inline BaikalStatus() : BaikalStatus(nullptr) {}
  ~BaikalStatus() override;
  explicit constexpr BaikalStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaikalStatus(const BaikalStatus& from);
  BaikalStatus(BaikalStatus&& from) noexcept
    : BaikalStatus() {
    *this = ::std::move(from);
  }

  inline BaikalStatus& operator=(const BaikalStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaikalStatus& operator=(BaikalStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaikalStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaikalStatus* internal_default_instance() {
    return reinterpret_cast<const BaikalStatus*>(
               &_BaikalStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(BaikalStatus& a, BaikalStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(BaikalStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaikalStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BaikalStatus* New() const final {
    return new BaikalStatus();
  }

  BaikalStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BaikalStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaikalStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BaikalStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaikalStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BaikalStatus";
  }
  protected:
  explicit BaikalStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kResourceTagFieldNumber = 2,
    kLastHeartbeatTimestampFieldNumber = 4,
    kStatusFieldNumber = 3,
  };
  // required string address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // required string resource_tag = 2;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional int64 last_heartbeat_timestamp = 4;
  bool has_last_heartbeat_timestamp() const;
  private:
  bool _internal_has_last_heartbeat_timestamp() const;
  public:
  void clear_last_heartbeat_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 last_heartbeat_timestamp() const;
  void set_last_heartbeat_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_last_heartbeat_timestamp() const;
  void _internal_set_last_heartbeat_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required .baikaldb.pb.Status status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::baikaldb::pb::Status status() const;
  void set_status(::baikaldb::pb::Status value);
  private:
  ::baikaldb::pb::Status _internal_status() const;
  void _internal_set_status(::baikaldb::pb::Status value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BaikalStatus)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::int64 last_heartbeat_timestamp_;
  int status_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class MovePhysicalRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.MovePhysicalRequest) */ {
 public:
  inline MovePhysicalRequest() : MovePhysicalRequest(nullptr) {}
  ~MovePhysicalRequest() override;
  explicit constexpr MovePhysicalRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MovePhysicalRequest(const MovePhysicalRequest& from);
  MovePhysicalRequest(MovePhysicalRequest&& from) noexcept
    : MovePhysicalRequest() {
    *this = ::std::move(from);
  }

  inline MovePhysicalRequest& operator=(const MovePhysicalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovePhysicalRequest& operator=(MovePhysicalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MovePhysicalRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MovePhysicalRequest* internal_default_instance() {
    return reinterpret_cast<const MovePhysicalRequest*>(
               &_MovePhysicalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(MovePhysicalRequest& a, MovePhysicalRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MovePhysicalRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovePhysicalRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MovePhysicalRequest* New() const final {
    return new MovePhysicalRequest();
  }

  MovePhysicalRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MovePhysicalRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MovePhysicalRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MovePhysicalRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MovePhysicalRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.MovePhysicalRequest";
  }
  protected:
  explicit MovePhysicalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhysicalRoomFieldNumber = 1,
    kOldLogicalRoomFieldNumber = 2,
    kNewLogicalRoomFieldNumber = 3,
  };
  // required string physical_room = 1;
  bool has_physical_room() const;
  private:
  bool _internal_has_physical_room() const;
  public:
  void clear_physical_room();
  const std::string& physical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_physical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_physical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_physical_room();
  void set_allocated_physical_room(std::string* physical_room);
  private:
  const std::string& _internal_physical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_physical_room(const std::string& value);
  std::string* _internal_mutable_physical_room();
  public:

  // required string old_logical_room = 2;
  bool has_old_logical_room() const;
  private:
  bool _internal_has_old_logical_room() const;
  public:
  void clear_old_logical_room();
  const std::string& old_logical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_logical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_logical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_old_logical_room();
  void set_allocated_old_logical_room(std::string* old_logical_room);
  private:
  const std::string& _internal_old_logical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_logical_room(const std::string& value);
  std::string* _internal_mutable_old_logical_room();
  public:

  // required string new_logical_room = 3;
  bool has_new_logical_room() const;
  private:
  bool _internal_has_new_logical_room() const;
  public:
  void clear_new_logical_room();
  const std::string& new_logical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_logical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_logical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_new_logical_room();
  void set_allocated_new_logical_room(std::string* new_logical_room);
  private:
  const std::string& _internal_new_logical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_logical_room(const std::string& value);
  std::string* _internal_mutable_new_logical_room();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.MovePhysicalRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr physical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_logical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_logical_room_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class AlterTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.AlterTableRequest) */ {
 public:
  inline AlterTableRequest() : AlterTableRequest(nullptr) {}
  ~AlterTableRequest() override;
  explicit constexpr AlterTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlterTableRequest(const AlterTableRequest& from);
  AlterTableRequest(AlterTableRequest&& from) noexcept
    : AlterTableRequest() {
    *this = ::std::move(from);
  }

  inline AlterTableRequest& operator=(const AlterTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlterTableRequest& operator=(AlterTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlterTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlterTableRequest* internal_default_instance() {
    return reinterpret_cast<const AlterTableRequest*>(
               &_AlterTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AlterTableRequest& a, AlterTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AlterTableRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlterTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AlterTableRequest* New() const final {
    return new AlterTableRequest();
  }

  AlterTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AlterTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlterTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AlterTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlterTableRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.AlterTableRequest";
  }
  protected:
  explicit AlterTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 7,
    kIndexsFieldNumber = 8,
    kTableNameFieldNumber = 1,
    kNamespaceFieldNumber = 2,
    kDatabaseFieldNumber = 3,
    kTableIdFieldNumber = 4,
    kNamespaceIdFieldNumber = 5,
    kDatabaseIdFieldNumber = 6,
  };
  // repeated .baikaldb.pb.FieldInfo fields = 7;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::baikaldb::pb::FieldInfo* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FieldInfo >*
      mutable_fields();
  private:
  const ::baikaldb::pb::FieldInfo& _internal_fields(int index) const;
  ::baikaldb::pb::FieldInfo* _internal_add_fields();
  public:
  const ::baikaldb::pb::FieldInfo& fields(int index) const;
  ::baikaldb::pb::FieldInfo* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FieldInfo >&
      fields() const;

  // repeated .baikaldb.pb.IndexInfo indexs = 8;
  int indexs_size() const;
  private:
  int _internal_indexs_size() const;
  public:
  void clear_indexs();
  ::baikaldb::pb::IndexInfo* mutable_indexs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::IndexInfo >*
      mutable_indexs();
  private:
  const ::baikaldb::pb::IndexInfo& _internal_indexs(int index) const;
  ::baikaldb::pb::IndexInfo* _internal_add_indexs();
  public:
  const ::baikaldb::pb::IndexInfo& indexs(int index) const;
  ::baikaldb::pb::IndexInfo* add_indexs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::IndexInfo >&
      indexs() const;

  // required string table_name = 1;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // required string namespace = 2;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_MUST_USE_RESULT std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // required string database = 3;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_MUST_USE_RESULT std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // optional int64 table_id = 4;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 namespace_id = 5;
  bool has_namespace_id() const;
  private:
  bool _internal_has_namespace_id() const;
  public:
  void clear_namespace_id();
  ::PROTOBUF_NAMESPACE_ID::int64 namespace_id() const;
  void set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_namespace_id() const;
  void _internal_set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 database_id = 6;
  bool has_database_id() const;
  private:
  bool _internal_has_database_id() const;
  public:
  void clear_database_id();
  ::PROTOBUF_NAMESPACE_ID::int64 database_id() const;
  void set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_database_id() const;
  void _internal_set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.AlterTableRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FieldInfo > fields_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::IndexInfo > indexs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 namespace_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 database_id_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RegionMergeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RegionMergeRequest) */ {
 public:
  inline RegionMergeRequest() : RegionMergeRequest(nullptr) {}
  ~RegionMergeRequest() override;
  explicit constexpr RegionMergeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionMergeRequest(const RegionMergeRequest& from);
  RegionMergeRequest(RegionMergeRequest&& from) noexcept
    : RegionMergeRequest() {
    *this = ::std::move(from);
  }

  inline RegionMergeRequest& operator=(const RegionMergeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionMergeRequest& operator=(RegionMergeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionMergeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionMergeRequest* internal_default_instance() {
    return reinterpret_cast<const RegionMergeRequest*>(
               &_RegionMergeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(RegionMergeRequest& a, RegionMergeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionMergeRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionMergeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionMergeRequest* New() const final {
    return new RegionMergeRequest();
  }

  RegionMergeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionMergeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionMergeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegionMergeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionMergeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RegionMergeRequest";
  }
  protected:
  explicit RegionMergeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcStartKeyFieldNumber = 2,
    kSrcEndKeyFieldNumber = 3,
    kSrcRegionIdFieldNumber = 1,
    kTableIdFieldNumber = 4,
    kPartitionIdFieldNumber = 5,
  };
  // required bytes src_start_key = 2;
  bool has_src_start_key() const;
  private:
  bool _internal_has_src_start_key() const;
  public:
  void clear_src_start_key();
  const std::string& src_start_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_start_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_start_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_src_start_key();
  void set_allocated_src_start_key(std::string* src_start_key);
  private:
  const std::string& _internal_src_start_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_start_key(const std::string& value);
  std::string* _internal_mutable_src_start_key();
  public:

  // required bytes src_end_key = 3;
  bool has_src_end_key() const;
  private:
  bool _internal_has_src_end_key() const;
  public:
  void clear_src_end_key();
  const std::string& src_end_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_end_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_end_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_src_end_key();
  void set_allocated_src_end_key(std::string* src_end_key);
  private:
  const std::string& _internal_src_end_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_end_key(const std::string& value);
  std::string* _internal_mutable_src_end_key();
  public:

  // required int64 src_region_id = 1;
  bool has_src_region_id() const;
  private:
  bool _internal_has_src_region_id() const;
  public:
  void clear_src_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 src_region_id() const;
  void set_src_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_src_region_id() const;
  void _internal_set_src_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 table_id = 4;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 partition_id = 5;
  bool has_partition_id() const;
  private:
  bool _internal_has_partition_id() const;
  public:
  void clear_partition_id();
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id() const;
  void set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_partition_id() const;
  void _internal_set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RegionMergeRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_start_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_end_key_;
  ::PROTOBUF_NAMESPACE_ID::int64 src_region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RegionMergeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RegionMergeResponse) */ {
 public:
  inline RegionMergeResponse() : RegionMergeResponse(nullptr) {}
  ~RegionMergeResponse() override;
  explicit constexpr RegionMergeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionMergeResponse(const RegionMergeResponse& from);
  RegionMergeResponse(RegionMergeResponse&& from) noexcept
    : RegionMergeResponse() {
    *this = ::std::move(from);
  }

  inline RegionMergeResponse& operator=(const RegionMergeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionMergeResponse& operator=(RegionMergeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionMergeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionMergeResponse* internal_default_instance() {
    return reinterpret_cast<const RegionMergeResponse*>(
               &_RegionMergeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(RegionMergeResponse& a, RegionMergeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionMergeResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionMergeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionMergeResponse* New() const final {
    return new RegionMergeResponse();
  }

  RegionMergeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionMergeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionMergeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegionMergeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionMergeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RegionMergeResponse";
  }
  protected:
  explicit RegionMergeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDstInstanceFieldNumber = 2,
    kDstStartKeyFieldNumber = 3,
    kDstEndKeyFieldNumber = 4,
    kDstRegionFieldNumber = 6,
    kDstRegionIdFieldNumber = 1,
    kVersionFieldNumber = 5,
  };
  // optional string dst_instance = 2;
  bool has_dst_instance() const;
  private:
  bool _internal_has_dst_instance() const;
  public:
  void clear_dst_instance();
  const std::string& dst_instance() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dst_instance(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dst_instance();
  PROTOBUF_MUST_USE_RESULT std::string* release_dst_instance();
  void set_allocated_dst_instance(std::string* dst_instance);
  private:
  const std::string& _internal_dst_instance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_instance(const std::string& value);
  std::string* _internal_mutable_dst_instance();
  public:

  // optional bytes dst_start_key = 3;
  bool has_dst_start_key() const;
  private:
  bool _internal_has_dst_start_key() const;
  public:
  void clear_dst_start_key();
  const std::string& dst_start_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dst_start_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dst_start_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_dst_start_key();
  void set_allocated_dst_start_key(std::string* dst_start_key);
  private:
  const std::string& _internal_dst_start_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_start_key(const std::string& value);
  std::string* _internal_mutable_dst_start_key();
  public:

  // optional bytes dst_end_key = 4;
  bool has_dst_end_key() const;
  private:
  bool _internal_has_dst_end_key() const;
  public:
  void clear_dst_end_key();
  const std::string& dst_end_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dst_end_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dst_end_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_dst_end_key();
  void set_allocated_dst_end_key(std::string* dst_end_key);
  private:
  const std::string& _internal_dst_end_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dst_end_key(const std::string& value);
  std::string* _internal_mutable_dst_end_key();
  public:

  // optional .baikaldb.pb.RegionInfo dst_region = 6;
  bool has_dst_region() const;
  private:
  bool _internal_has_dst_region() const;
  public:
  void clear_dst_region();
  const ::baikaldb::pb::RegionInfo& dst_region() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionInfo* release_dst_region();
  ::baikaldb::pb::RegionInfo* mutable_dst_region();
  void set_allocated_dst_region(::baikaldb::pb::RegionInfo* dst_region);
  private:
  const ::baikaldb::pb::RegionInfo& _internal_dst_region() const;
  ::baikaldb::pb::RegionInfo* _internal_mutable_dst_region();
  public:
  void unsafe_arena_set_allocated_dst_region(
      ::baikaldb::pb::RegionInfo* dst_region);
  ::baikaldb::pb::RegionInfo* unsafe_arena_release_dst_region();

  // optional int64 dst_region_id = 1;
  bool has_dst_region_id() const;
  private:
  bool _internal_has_dst_region_id() const;
  public:
  void clear_dst_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 dst_region_id() const;
  void set_dst_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_dst_region_id() const;
  void _internal_set_dst_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 version = 5;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RegionMergeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_instance_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_start_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dst_end_key_;
  ::baikaldb::pb::RegionInfo* dst_region_;
  ::PROTOBUF_NAMESPACE_ID::int64 dst_region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RegionSplitRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RegionSplitRequest) */ {
 public:
  inline RegionSplitRequest() : RegionSplitRequest(nullptr) {}
  ~RegionSplitRequest() override;
  explicit constexpr RegionSplitRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionSplitRequest(const RegionSplitRequest& from);
  RegionSplitRequest(RegionSplitRequest&& from) noexcept
    : RegionSplitRequest() {
    *this = ::std::move(from);
  }

  inline RegionSplitRequest& operator=(const RegionSplitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionSplitRequest& operator=(RegionSplitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionSplitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionSplitRequest* internal_default_instance() {
    return reinterpret_cast<const RegionSplitRequest*>(
               &_RegionSplitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(RegionSplitRequest& a, RegionSplitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionSplitRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionSplitRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionSplitRequest* New() const final {
    return new RegionSplitRequest();
  }

  RegionSplitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionSplitRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionSplitRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegionSplitRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionSplitRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RegionSplitRequest";
  }
  protected:
  explicit RegionSplitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSplitKeyFieldNumber = 2,
    kNewInstanceFieldNumber = 3,
    kResourceTagFieldNumber = 6,
    kRegionIdFieldNumber = 1,
    kTableIdFieldNumber = 5,
    kNewRegionNumFieldNumber = 7,
    kTailSplitFieldNumber = 4,
  };
  // required bytes split_key = 2;
  bool has_split_key() const;
  private:
  bool _internal_has_split_key() const;
  public:
  void clear_split_key();
  const std::string& split_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_split_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_split_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_split_key();
  void set_allocated_split_key(std::string* split_key);
  private:
  const std::string& _internal_split_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_split_key(const std::string& value);
  std::string* _internal_mutable_split_key();
  public:

  // optional string new_instance = 3;
  bool has_new_instance() const;
  private:
  bool _internal_has_new_instance() const;
  public:
  void clear_new_instance();
  const std::string& new_instance() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_instance(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_instance();
  PROTOBUF_MUST_USE_RESULT std::string* release_new_instance();
  void set_allocated_new_instance(std::string* new_instance);
  private:
  const std::string& _internal_new_instance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_instance(const std::string& value);
  std::string* _internal_mutable_new_instance();
  public:

  // optional string resource_tag = 6;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // required int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 table_id = 5;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 new_region_num = 7;
  bool has_new_region_num() const;
  private:
  bool _internal_has_new_region_num() const;
  public:
  void clear_new_region_num();
  ::PROTOBUF_NAMESPACE_ID::int64 new_region_num() const;
  void set_new_region_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_new_region_num() const;
  void _internal_set_new_region_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool tail_split = 4;
  bool has_tail_split() const;
  private:
  bool _internal_has_tail_split() const;
  public:
  void clear_tail_split();
  bool tail_split() const;
  void set_tail_split(bool value);
  private:
  bool _internal_tail_split() const;
  void _internal_set_tail_split(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RegionSplitRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr split_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_instance_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 new_region_num_;
  bool tail_split_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class MultiSplitRegion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.MultiSplitRegion) */ {
 public:
  inline MultiSplitRegion() : MultiSplitRegion(nullptr) {}
  ~MultiSplitRegion() override;
  explicit constexpr MultiSplitRegion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiSplitRegion(const MultiSplitRegion& from);
  MultiSplitRegion(MultiSplitRegion&& from) noexcept
    : MultiSplitRegion() {
    *this = ::std::move(from);
  }

  inline MultiSplitRegion& operator=(const MultiSplitRegion& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiSplitRegion& operator=(MultiSplitRegion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiSplitRegion& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiSplitRegion* internal_default_instance() {
    return reinterpret_cast<const MultiSplitRegion*>(
               &_MultiSplitRegion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(MultiSplitRegion& a, MultiSplitRegion& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiSplitRegion* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiSplitRegion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiSplitRegion* New() const final {
    return new MultiSplitRegion();
  }

  MultiSplitRegion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiSplitRegion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiSplitRegion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MultiSplitRegion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiSplitRegion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.MultiSplitRegion";
  }
  protected:
  explicit MultiSplitRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddPeerInstanceFieldNumber = 3,
    kNewInstanceFieldNumber = 2,
    kNewRegionIdFieldNumber = 1,
  };
  // repeated string add_peer_instance = 3;
  int add_peer_instance_size() const;
  private:
  int _internal_add_peer_instance_size() const;
  public:
  void clear_add_peer_instance();
  const std::string& add_peer_instance(int index) const;
  std::string* mutable_add_peer_instance(int index);
  void set_add_peer_instance(int index, const std::string& value);
  void set_add_peer_instance(int index, std::string&& value);
  void set_add_peer_instance(int index, const char* value);
  void set_add_peer_instance(int index, const char* value, size_t size);
  std::string* add_add_peer_instance();
  void add_add_peer_instance(const std::string& value);
  void add_add_peer_instance(std::string&& value);
  void add_add_peer_instance(const char* value);
  void add_add_peer_instance(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& add_peer_instance() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_add_peer_instance();
  private:
  const std::string& _internal_add_peer_instance(int index) const;
  std::string* _internal_add_add_peer_instance();
  public:

  // optional string new_instance = 2;
  bool has_new_instance() const;
  private:
  bool _internal_has_new_instance() const;
  public:
  void clear_new_instance();
  const std::string& new_instance() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_instance(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_instance();
  PROTOBUF_MUST_USE_RESULT std::string* release_new_instance();
  void set_allocated_new_instance(std::string* new_instance);
  private:
  const std::string& _internal_new_instance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_instance(const std::string& value);
  std::string* _internal_mutable_new_instance();
  public:

  // optional int64 new_region_id = 1;
  bool has_new_region_id() const;
  private:
  bool _internal_has_new_region_id() const;
  public:
  void clear_new_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 new_region_id() const;
  void set_new_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_new_region_id() const;
  void _internal_set_new_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.MultiSplitRegion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> add_peer_instance_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_instance_;
  ::PROTOBUF_NAMESPACE_ID::int64 new_region_id_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RegionSplitResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RegionSplitResponse) */ {
 public:
  inline RegionSplitResponse() : RegionSplitResponse(nullptr) {}
  ~RegionSplitResponse() override;
  explicit constexpr RegionSplitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionSplitResponse(const RegionSplitResponse& from);
  RegionSplitResponse(RegionSplitResponse&& from) noexcept
    : RegionSplitResponse() {
    *this = ::std::move(from);
  }

  inline RegionSplitResponse& operator=(const RegionSplitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionSplitResponse& operator=(RegionSplitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionSplitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionSplitResponse* internal_default_instance() {
    return reinterpret_cast<const RegionSplitResponse*>(
               &_RegionSplitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(RegionSplitResponse& a, RegionSplitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionSplitResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionSplitResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionSplitResponse* New() const final {
    return new RegionSplitResponse();
  }

  RegionSplitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionSplitResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionSplitResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegionSplitResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionSplitResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RegionSplitResponse";
  }
  protected:
  explicit RegionSplitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddPeerInstanceFieldNumber = 4,
    kMultiNewRegionsFieldNumber = 5,
    kNewInstanceFieldNumber = 3,
    kOldRegionIdFieldNumber = 1,
    kNewRegionIdFieldNumber = 2,
  };
  // repeated string add_peer_instance = 4;
  int add_peer_instance_size() const;
  private:
  int _internal_add_peer_instance_size() const;
  public:
  void clear_add_peer_instance();
  const std::string& add_peer_instance(int index) const;
  std::string* mutable_add_peer_instance(int index);
  void set_add_peer_instance(int index, const std::string& value);
  void set_add_peer_instance(int index, std::string&& value);
  void set_add_peer_instance(int index, const char* value);
  void set_add_peer_instance(int index, const char* value, size_t size);
  std::string* add_add_peer_instance();
  void add_add_peer_instance(const std::string& value);
  void add_add_peer_instance(std::string&& value);
  void add_add_peer_instance(const char* value);
  void add_add_peer_instance(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& add_peer_instance() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_add_peer_instance();
  private:
  const std::string& _internal_add_peer_instance(int index) const;
  std::string* _internal_add_add_peer_instance();
  public:

  // repeated .baikaldb.pb.MultiSplitRegion multi_new_regions = 5;
  int multi_new_regions_size() const;
  private:
  int _internal_multi_new_regions_size() const;
  public:
  void clear_multi_new_regions();
  ::baikaldb::pb::MultiSplitRegion* mutable_multi_new_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::MultiSplitRegion >*
      mutable_multi_new_regions();
  private:
  const ::baikaldb::pb::MultiSplitRegion& _internal_multi_new_regions(int index) const;
  ::baikaldb::pb::MultiSplitRegion* _internal_add_multi_new_regions();
  public:
  const ::baikaldb::pb::MultiSplitRegion& multi_new_regions(int index) const;
  ::baikaldb::pb::MultiSplitRegion* add_multi_new_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::MultiSplitRegion >&
      multi_new_regions() const;

  // optional string new_instance = 3;
  bool has_new_instance() const;
  private:
  bool _internal_has_new_instance() const;
  public:
  void clear_new_instance();
  const std::string& new_instance() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_instance(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_instance();
  PROTOBUF_MUST_USE_RESULT std::string* release_new_instance();
  void set_allocated_new_instance(std::string* new_instance);
  private:
  const std::string& _internal_new_instance() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_instance(const std::string& value);
  std::string* _internal_mutable_new_instance();
  public:

  // required int64 old_region_id = 1;
  bool has_old_region_id() const;
  private:
  bool _internal_has_old_region_id() const;
  public:
  void clear_old_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 old_region_id() const;
  void set_old_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_old_region_id() const;
  void _internal_set_old_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 new_region_id = 2;
  bool has_new_region_id() const;
  private:
  bool _internal_has_new_region_id() const;
  public:
  void clear_new_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 new_region_id() const;
  void set_new_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_new_region_id() const;
  void _internal_set_new_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RegionSplitResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> add_peer_instance_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::MultiSplitRegion > multi_new_regions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_instance_;
  ::PROTOBUF_NAMESPACE_ID::int64 old_region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 new_region_id_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class AutoIncrementRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.AutoIncrementRequest) */ {
 public:
  inline AutoIncrementRequest() : AutoIncrementRequest(nullptr) {}
  ~AutoIncrementRequest() override;
  explicit constexpr AutoIncrementRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutoIncrementRequest(const AutoIncrementRequest& from);
  AutoIncrementRequest(AutoIncrementRequest&& from) noexcept
    : AutoIncrementRequest() {
    *this = ::std::move(from);
  }

  inline AutoIncrementRequest& operator=(const AutoIncrementRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoIncrementRequest& operator=(AutoIncrementRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoIncrementRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoIncrementRequest* internal_default_instance() {
    return reinterpret_cast<const AutoIncrementRequest*>(
               &_AutoIncrementRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(AutoIncrementRequest& a, AutoIncrementRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoIncrementRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoIncrementRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AutoIncrementRequest* New() const final {
    return new AutoIncrementRequest();
  }

  AutoIncrementRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutoIncrementRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AutoIncrementRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AutoIncrementRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutoIncrementRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.AutoIncrementRequest";
  }
  protected:
  explicit AutoIncrementRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableIdFieldNumber = 1,
    kCountFieldNumber = 2,
    kStartIdFieldNumber = 3,
    kIncrementIdFieldNumber = 4,
    kForceFieldNumber = 5,
  };
  // required int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint64 count = 2;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 start_id = 3;
  bool has_start_id() const;
  private:
  bool _internal_has_start_id() const;
  public:
  void clear_start_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 start_id() const;
  void set_start_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_start_id() const;
  void _internal_set_start_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 increment_id = 4;
  bool has_increment_id() const;
  private:
  bool _internal_has_increment_id() const;
  public:
  void clear_increment_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 increment_id() const;
  void set_increment_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_increment_id() const;
  void _internal_set_increment_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool force = 5;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.AutoIncrementRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 count_;
  ::PROTOBUF_NAMESPACE_ID::uint64 start_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 increment_id_;
  bool force_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RestoreRegionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RestoreRegionRequest) */ {
 public:
  inline RestoreRegionRequest() : RestoreRegionRequest(nullptr) {}
  ~RestoreRegionRequest() override;
  explicit constexpr RestoreRegionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RestoreRegionRequest(const RestoreRegionRequest& from);
  RestoreRegionRequest(RestoreRegionRequest&& from) noexcept
    : RestoreRegionRequest() {
    *this = ::std::move(from);
  }

  inline RestoreRegionRequest& operator=(const RestoreRegionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestoreRegionRequest& operator=(RestoreRegionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestoreRegionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RestoreRegionRequest* internal_default_instance() {
    return reinterpret_cast<const RestoreRegionRequest*>(
               &_RestoreRegionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(RestoreRegionRequest& a, RestoreRegionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RestoreRegionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestoreRegionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RestoreRegionRequest* New() const final {
    return new RestoreRegionRequest();
  }

  RestoreRegionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RestoreRegionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RestoreRegionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RestoreRegionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestoreRegionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RestoreRegionRequest";
  }
  protected:
  explicit RestoreRegionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRestoreRegionIdFieldNumber = 1,
    kLowerRegionIdFieldNumber = 2,
    kUpperRegionIdFieldNumber = 3,
  };
  // optional int64 restore_region_id = 1;
  bool has_restore_region_id() const;
  private:
  bool _internal_has_restore_region_id() const;
  public:
  void clear_restore_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 restore_region_id() const;
  void set_restore_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_restore_region_id() const;
  void _internal_set_restore_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 lower_region_id = 2;
  bool has_lower_region_id() const;
  private:
  bool _internal_has_lower_region_id() const;
  public:
  void clear_lower_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 lower_region_id() const;
  void set_lower_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_lower_region_id() const;
  void _internal_set_lower_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 upper_region_id = 3;
  bool has_upper_region_id() const;
  private:
  bool _internal_has_upper_region_id() const;
  public:
  void clear_upper_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 upper_region_id() const;
  void set_upper_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_upper_region_id() const;
  void _internal_set_upper_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RestoreRegionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 restore_region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 lower_region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 upper_region_id_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class IndexDdlRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.IndexDdlRequest) */ {
 public:
  inline IndexDdlRequest() : IndexDdlRequest(nullptr) {}
  ~IndexDdlRequest() override;
  explicit constexpr IndexDdlRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexDdlRequest(const IndexDdlRequest& from);
  IndexDdlRequest(IndexDdlRequest&& from) noexcept
    : IndexDdlRequest() {
    *this = ::std::move(from);
  }

  inline IndexDdlRequest& operator=(const IndexDdlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexDdlRequest& operator=(IndexDdlRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexDdlRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexDdlRequest* internal_default_instance() {
    return reinterpret_cast<const IndexDdlRequest*>(
               &_IndexDdlRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(IndexDdlRequest& a, IndexDdlRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexDdlRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexDdlRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IndexDdlRequest* New() const final {
    return new IndexDdlRequest();
  }

  IndexDdlRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IndexDdlRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexDdlRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IndexDdlRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexDdlRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.IndexDdlRequest";
  }
  protected:
  explicit IndexDdlRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddKeysFieldNumber = 3,
    kAddValsFieldNumber = 4,
    kRegionDdlWorkFieldNumber = 5,
    kTableIdFieldNumber = 1,
    kRegionIdFieldNumber = 2,
  };
  // repeated string add_keys = 3;
  int add_keys_size() const;
  private:
  int _internal_add_keys_size() const;
  public:
  void clear_add_keys();
  const std::string& add_keys(int index) const;
  std::string* mutable_add_keys(int index);
  void set_add_keys(int index, const std::string& value);
  void set_add_keys(int index, std::string&& value);
  void set_add_keys(int index, const char* value);
  void set_add_keys(int index, const char* value, size_t size);
  std::string* add_add_keys();
  void add_add_keys(const std::string& value);
  void add_add_keys(std::string&& value);
  void add_add_keys(const char* value);
  void add_add_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& add_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_add_keys();
  private:
  const std::string& _internal_add_keys(int index) const;
  std::string* _internal_add_add_keys();
  public:

  // repeated string add_vals = 4;
  int add_vals_size() const;
  private:
  int _internal_add_vals_size() const;
  public:
  void clear_add_vals();
  const std::string& add_vals(int index) const;
  std::string* mutable_add_vals(int index);
  void set_add_vals(int index, const std::string& value);
  void set_add_vals(int index, std::string&& value);
  void set_add_vals(int index, const char* value);
  void set_add_vals(int index, const char* value, size_t size);
  std::string* add_add_vals();
  void add_add_vals(const std::string& value);
  void add_add_vals(std::string&& value);
  void add_add_vals(const char* value);
  void add_add_vals(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& add_vals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_add_vals();
  private:
  const std::string& _internal_add_vals(int index) const;
  std::string* _internal_add_add_vals();
  public:

  // optional .baikaldb.pb.RegionDdlWork region_ddl_work = 5;
  bool has_region_ddl_work() const;
  private:
  bool _internal_has_region_ddl_work() const;
  public:
  void clear_region_ddl_work();
  const ::baikaldb::pb::RegionDdlWork& region_ddl_work() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionDdlWork* release_region_ddl_work();
  ::baikaldb::pb::RegionDdlWork* mutable_region_ddl_work();
  void set_allocated_region_ddl_work(::baikaldb::pb::RegionDdlWork* region_ddl_work);
  private:
  const ::baikaldb::pb::RegionDdlWork& _internal_region_ddl_work() const;
  ::baikaldb::pb::RegionDdlWork* _internal_mutable_region_ddl_work();
  public:
  void unsafe_arena_set_allocated_region_ddl_work(
      ::baikaldb::pb::RegionDdlWork* region_ddl_work);
  ::baikaldb::pb::RegionDdlWork* unsafe_arena_release_region_ddl_work();

  // optional int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_id = 2;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.IndexDdlRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> add_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> add_vals_;
  ::baikaldb::pb::RegionDdlWork* region_ddl_work_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class ParamDesc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ParamDesc) */ {
 public:
  inline ParamDesc() : ParamDesc(nullptr) {}
  ~ParamDesc() override;
  explicit constexpr ParamDesc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParamDesc(const ParamDesc& from);
  ParamDesc(ParamDesc&& from) noexcept
    : ParamDesc() {
    *this = ::std::move(from);
  }

  inline ParamDesc& operator=(const ParamDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParamDesc& operator=(ParamDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParamDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParamDesc* internal_default_instance() {
    return reinterpret_cast<const ParamDesc*>(
               &_ParamDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ParamDesc& a, ParamDesc& b) {
    a.Swap(&b);
  }
  inline void Swap(ParamDesc* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParamDesc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ParamDesc* New() const final {
    return new ParamDesc();
  }

  ParamDesc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ParamDesc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParamDesc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ParamDesc& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParamDesc* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ParamDesc";
  }
  protected:
  explicit ParamDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kIsMetaParamFieldNumber = 3,
    kNeedDeleteFieldNumber = 4,
  };
  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional bool is_meta_param = 3;
  bool has_is_meta_param() const;
  private:
  bool _internal_has_is_meta_param() const;
  public:
  void clear_is_meta_param();
  bool is_meta_param() const;
  void set_is_meta_param(bool value);
  private:
  bool _internal_is_meta_param() const;
  void _internal_set_is_meta_param(bool value);
  public:

  // optional bool need_delete = 4;
  bool has_need_delete() const;
  private:
  bool _internal_has_need_delete() const;
  public:
  void clear_need_delete();
  bool need_delete() const;
  void set_need_delete(bool value);
  private:
  bool _internal_need_delete() const;
  void _internal_set_need_delete(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ParamDesc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  bool is_meta_param_;
  bool need_delete_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class InstanceParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.InstanceParam) */ {
 public:
  inline InstanceParam() : InstanceParam(nullptr) {}
  ~InstanceParam() override;
  explicit constexpr InstanceParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstanceParam(const InstanceParam& from);
  InstanceParam(InstanceParam&& from) noexcept
    : InstanceParam() {
    *this = ::std::move(from);
  }

  inline InstanceParam& operator=(const InstanceParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstanceParam& operator=(InstanceParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstanceParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstanceParam* internal_default_instance() {
    return reinterpret_cast<const InstanceParam*>(
               &_InstanceParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(InstanceParam& a, InstanceParam& b) {
    a.Swap(&b);
  }
  inline void Swap(InstanceParam* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstanceParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InstanceParam* New() const final {
    return new InstanceParam();
  }

  InstanceParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InstanceParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstanceParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InstanceParam& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstanceParam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.InstanceParam";
  }
  protected:
  explicit InstanceParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 2,
    kResourceTagOrAddressFieldNumber = 1,
  };
  // repeated .baikaldb.pb.ParamDesc params = 2;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  ::baikaldb::pb::ParamDesc* mutable_params(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ParamDesc >*
      mutable_params();
  private:
  const ::baikaldb::pb::ParamDesc& _internal_params(int index) const;
  ::baikaldb::pb::ParamDesc* _internal_add_params();
  public:
  const ::baikaldb::pb::ParamDesc& params(int index) const;
  ::baikaldb::pb::ParamDesc* add_params();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ParamDesc >&
      params() const;

  // optional string resource_tag_or_address = 1;
  bool has_resource_tag_or_address() const;
  private:
  bool _internal_has_resource_tag_or_address() const;
  public:
  void clear_resource_tag_or_address();
  const std::string& resource_tag_or_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag_or_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag_or_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag_or_address();
  void set_allocated_resource_tag_or_address(std::string* resource_tag_or_address);
  private:
  const std::string& _internal_resource_tag_or_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag_or_address(const std::string& value);
  std::string* _internal_mutable_resource_tag_or_address();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.InstanceParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ParamDesc > params_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_or_address_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class VirtualIndexInfluence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.VirtualIndexInfluence) */ {
 public:
  inline VirtualIndexInfluence() : VirtualIndexInfluence(nullptr) {}
  ~VirtualIndexInfluence() override;
  explicit constexpr VirtualIndexInfluence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualIndexInfluence(const VirtualIndexInfluence& from);
  VirtualIndexInfluence(VirtualIndexInfluence&& from) noexcept
    : VirtualIndexInfluence() {
    *this = ::std::move(from);
  }

  inline VirtualIndexInfluence& operator=(const VirtualIndexInfluence& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualIndexInfluence& operator=(VirtualIndexInfluence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualIndexInfluence& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualIndexInfluence* internal_default_instance() {
    return reinterpret_cast<const VirtualIndexInfluence*>(
               &_VirtualIndexInfluence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(VirtualIndexInfluence& a, VirtualIndexInfluence& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualIndexInfluence* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualIndexInfluence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualIndexInfluence* New() const final {
    return new VirtualIndexInfluence();
  }

  VirtualIndexInfluence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualIndexInfluence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualIndexInfluence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualIndexInfluence& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualIndexInfluence* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.VirtualIndexInfluence";
  }
  protected:
  explicit VirtualIndexInfluence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVirtualIndexNameFieldNumber = 2,
    kInfluencedSqlFieldNumber = 3,
    kVirtualIndexIdFieldNumber = 1,
  };
  // optional string virtual_index_name = 2;
  bool has_virtual_index_name() const;
  private:
  bool _internal_has_virtual_index_name() const;
  public:
  void clear_virtual_index_name();
  const std::string& virtual_index_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_virtual_index_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_virtual_index_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_virtual_index_name();
  void set_allocated_virtual_index_name(std::string* virtual_index_name);
  private:
  const std::string& _internal_virtual_index_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_virtual_index_name(const std::string& value);
  std::string* _internal_mutable_virtual_index_name();
  public:

  // optional string influenced_sql = 3;
  bool has_influenced_sql() const;
  private:
  bool _internal_has_influenced_sql() const;
  public:
  void clear_influenced_sql();
  const std::string& influenced_sql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_influenced_sql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_influenced_sql();
  PROTOBUF_MUST_USE_RESULT std::string* release_influenced_sql();
  void set_allocated_influenced_sql(std::string* influenced_sql);
  private:
  const std::string& _internal_influenced_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_influenced_sql(const std::string& value);
  std::string* _internal_mutable_influenced_sql();
  public:

  // optional int64 virtual_index_id = 1;
  bool has_virtual_index_id() const;
  private:
  bool _internal_has_virtual_index_id() const;
  public:
  void clear_virtual_index_id();
  ::PROTOBUF_NAMESPACE_ID::int64 virtual_index_id() const;
  void set_virtual_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_virtual_index_id() const;
  void _internal_set_virtual_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.VirtualIndexInfluence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr virtual_index_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr influenced_sql_;
  ::PROTOBUF_NAMESPACE_ID::int64 virtual_index_id_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class MetaManagerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.MetaManagerRequest) */ {
 public:
  inline MetaManagerRequest() : MetaManagerRequest(nullptr) {}
  ~MetaManagerRequest() override;
  explicit constexpr MetaManagerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetaManagerRequest(const MetaManagerRequest& from);
  MetaManagerRequest(MetaManagerRequest&& from) noexcept
    : MetaManagerRequest() {
    *this = ::std::move(from);
  }

  inline MetaManagerRequest& operator=(const MetaManagerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetaManagerRequest& operator=(MetaManagerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetaManagerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetaManagerRequest* internal_default_instance() {
    return reinterpret_cast<const MetaManagerRequest*>(
               &_MetaManagerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(MetaManagerRequest& a, MetaManagerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MetaManagerRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetaManagerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MetaManagerRequest* New() const final {
    return new MetaManagerRequest();
  }

  MetaManagerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MetaManagerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetaManagerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetaManagerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetaManagerRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.MetaManagerRequest";
  }
  protected:
  explicit MetaManagerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDropRegionIdsFieldNumber = 12,
    kResourceTagsFieldNumber = 16,
    kRegionInfosFieldNumber = 19,
    kInstanceParamsFieldNumber = 24,
    kTableInfoFieldNumber = 2,
    kNamespaceInfoFieldNumber = 3,
    kDatabaseInfoFieldNumber = 4,
    kUserPrivilegeFieldNumber = 5,
    kAlterTableFieldNumber = 6,
    kLogicalRoomsFieldNumber = 7,
    kPhysicalRoomsFieldNumber = 8,
    kInstanceFieldNumber = 9,
    kMovePhysicalRequestFieldNumber = 10,
    kRegionInfoFieldNumber = 11,
    kRegionSplitFieldNumber = 13,
    kAutoIncrementFieldNumber = 14,
    kRestoreRegionFieldNumber = 15,
    kRegionMergeFieldNumber = 17,
    kDdlworkInfoFieldNumber = 20,
    kStatisticsFieldNumber = 22,
    kBinlogInfoFieldNumber = 23,
    kIndexDdlRequestFieldNumber = 26,
    kOpTypeFieldNumber = 1,
    kNeedMergeFieldNumber = 18,
    kAddDeleteRegionFieldNumber = 21,
    kIsDynamicChangeFieldNumber = 28,
    kIsForceSettingFieldNumber = 29,
    kLearnerReplicaNumFieldNumber = 27,
    kRecoverOptFieldNumber = 25,
  };
  // repeated int64 drop_region_ids = 12;
  int drop_region_ids_size() const;
  private:
  int _internal_drop_region_ids_size() const;
  public:
  void clear_drop_region_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_drop_region_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_drop_region_ids() const;
  void _internal_add_drop_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_drop_region_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 drop_region_ids(int index) const;
  void set_drop_region_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_drop_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      drop_region_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_drop_region_ids();

  // repeated string resource_tags = 16;
  int resource_tags_size() const;
  private:
  int _internal_resource_tags_size() const;
  public:
  void clear_resource_tags();
  const std::string& resource_tags(int index) const;
  std::string* mutable_resource_tags(int index);
  void set_resource_tags(int index, const std::string& value);
  void set_resource_tags(int index, std::string&& value);
  void set_resource_tags(int index, const char* value);
  void set_resource_tags(int index, const char* value, size_t size);
  std::string* add_resource_tags();
  void add_resource_tags(const std::string& value);
  void add_resource_tags(std::string&& value);
  void add_resource_tags(const char* value);
  void add_resource_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& resource_tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_resource_tags();
  private:
  const std::string& _internal_resource_tags(int index) const;
  std::string* _internal_add_resource_tags();
  public:

  // repeated .baikaldb.pb.RegionInfo region_infos = 19;
  int region_infos_size() const;
  private:
  int _internal_region_infos_size() const;
  public:
  void clear_region_infos();
  ::baikaldb::pb::RegionInfo* mutable_region_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >*
      mutable_region_infos();
  private:
  const ::baikaldb::pb::RegionInfo& _internal_region_infos(int index) const;
  ::baikaldb::pb::RegionInfo* _internal_add_region_infos();
  public:
  const ::baikaldb::pb::RegionInfo& region_infos(int index) const;
  ::baikaldb::pb::RegionInfo* add_region_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >&
      region_infos() const;

  // repeated .baikaldb.pb.InstanceParam instance_params = 24;
  int instance_params_size() const;
  private:
  int _internal_instance_params_size() const;
  public:
  void clear_instance_params();
  ::baikaldb::pb::InstanceParam* mutable_instance_params(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam >*
      mutable_instance_params();
  private:
  const ::baikaldb::pb::InstanceParam& _internal_instance_params(int index) const;
  ::baikaldb::pb::InstanceParam* _internal_add_instance_params();
  public:
  const ::baikaldb::pb::InstanceParam& instance_params(int index) const;
  ::baikaldb::pb::InstanceParam* add_instance_params();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam >&
      instance_params() const;

  // optional .baikaldb.pb.SchemaInfo table_info = 2;
  bool has_table_info() const;
  private:
  bool _internal_has_table_info() const;
  public:
  void clear_table_info();
  const ::baikaldb::pb::SchemaInfo& table_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::SchemaInfo* release_table_info();
  ::baikaldb::pb::SchemaInfo* mutable_table_info();
  void set_allocated_table_info(::baikaldb::pb::SchemaInfo* table_info);
  private:
  const ::baikaldb::pb::SchemaInfo& _internal_table_info() const;
  ::baikaldb::pb::SchemaInfo* _internal_mutable_table_info();
  public:
  void unsafe_arena_set_allocated_table_info(
      ::baikaldb::pb::SchemaInfo* table_info);
  ::baikaldb::pb::SchemaInfo* unsafe_arena_release_table_info();

  // optional .baikaldb.pb.NameSpaceInfo namespace_info = 3;
  bool has_namespace_info() const;
  private:
  bool _internal_has_namespace_info() const;
  public:
  void clear_namespace_info();
  const ::baikaldb::pb::NameSpaceInfo& namespace_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::NameSpaceInfo* release_namespace_info();
  ::baikaldb::pb::NameSpaceInfo* mutable_namespace_info();
  void set_allocated_namespace_info(::baikaldb::pb::NameSpaceInfo* namespace_info);
  private:
  const ::baikaldb::pb::NameSpaceInfo& _internal_namespace_info() const;
  ::baikaldb::pb::NameSpaceInfo* _internal_mutable_namespace_info();
  public:
  void unsafe_arena_set_allocated_namespace_info(
      ::baikaldb::pb::NameSpaceInfo* namespace_info);
  ::baikaldb::pb::NameSpaceInfo* unsafe_arena_release_namespace_info();

  // optional .baikaldb.pb.DataBaseInfo database_info = 4;
  bool has_database_info() const;
  private:
  bool _internal_has_database_info() const;
  public:
  void clear_database_info();
  const ::baikaldb::pb::DataBaseInfo& database_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::DataBaseInfo* release_database_info();
  ::baikaldb::pb::DataBaseInfo* mutable_database_info();
  void set_allocated_database_info(::baikaldb::pb::DataBaseInfo* database_info);
  private:
  const ::baikaldb::pb::DataBaseInfo& _internal_database_info() const;
  ::baikaldb::pb::DataBaseInfo* _internal_mutable_database_info();
  public:
  void unsafe_arena_set_allocated_database_info(
      ::baikaldb::pb::DataBaseInfo* database_info);
  ::baikaldb::pb::DataBaseInfo* unsafe_arena_release_database_info();

  // optional .baikaldb.pb.UserPrivilege user_privilege = 5;
  bool has_user_privilege() const;
  private:
  bool _internal_has_user_privilege() const;
  public:
  void clear_user_privilege();
  const ::baikaldb::pb::UserPrivilege& user_privilege() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::UserPrivilege* release_user_privilege();
  ::baikaldb::pb::UserPrivilege* mutable_user_privilege();
  void set_allocated_user_privilege(::baikaldb::pb::UserPrivilege* user_privilege);
  private:
  const ::baikaldb::pb::UserPrivilege& _internal_user_privilege() const;
  ::baikaldb::pb::UserPrivilege* _internal_mutable_user_privilege();
  public:
  void unsafe_arena_set_allocated_user_privilege(
      ::baikaldb::pb::UserPrivilege* user_privilege);
  ::baikaldb::pb::UserPrivilege* unsafe_arena_release_user_privilege();

  // optional .baikaldb.pb.AlterTableRequest alter_table = 6;
  bool has_alter_table() const;
  private:
  bool _internal_has_alter_table() const;
  public:
  void clear_alter_table();
  const ::baikaldb::pb::AlterTableRequest& alter_table() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::AlterTableRequest* release_alter_table();
  ::baikaldb::pb::AlterTableRequest* mutable_alter_table();
  void set_allocated_alter_table(::baikaldb::pb::AlterTableRequest* alter_table);
  private:
  const ::baikaldb::pb::AlterTableRequest& _internal_alter_table() const;
  ::baikaldb::pb::AlterTableRequest* _internal_mutable_alter_table();
  public:
  void unsafe_arena_set_allocated_alter_table(
      ::baikaldb::pb::AlterTableRequest* alter_table);
  ::baikaldb::pb::AlterTableRequest* unsafe_arena_release_alter_table();

  // optional .baikaldb.pb.LogicalRoom logical_rooms = 7;
  bool has_logical_rooms() const;
  private:
  bool _internal_has_logical_rooms() const;
  public:
  void clear_logical_rooms();
  const ::baikaldb::pb::LogicalRoom& logical_rooms() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::LogicalRoom* release_logical_rooms();
  ::baikaldb::pb::LogicalRoom* mutable_logical_rooms();
  void set_allocated_logical_rooms(::baikaldb::pb::LogicalRoom* logical_rooms);
  private:
  const ::baikaldb::pb::LogicalRoom& _internal_logical_rooms() const;
  ::baikaldb::pb::LogicalRoom* _internal_mutable_logical_rooms();
  public:
  void unsafe_arena_set_allocated_logical_rooms(
      ::baikaldb::pb::LogicalRoom* logical_rooms);
  ::baikaldb::pb::LogicalRoom* unsafe_arena_release_logical_rooms();

  // optional .baikaldb.pb.PhysicalRoom physical_rooms = 8;
  bool has_physical_rooms() const;
  private:
  bool _internal_has_physical_rooms() const;
  public:
  void clear_physical_rooms();
  const ::baikaldb::pb::PhysicalRoom& physical_rooms() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::PhysicalRoom* release_physical_rooms();
  ::baikaldb::pb::PhysicalRoom* mutable_physical_rooms();
  void set_allocated_physical_rooms(::baikaldb::pb::PhysicalRoom* physical_rooms);
  private:
  const ::baikaldb::pb::PhysicalRoom& _internal_physical_rooms() const;
  ::baikaldb::pb::PhysicalRoom* _internal_mutable_physical_rooms();
  public:
  void unsafe_arena_set_allocated_physical_rooms(
      ::baikaldb::pb::PhysicalRoom* physical_rooms);
  ::baikaldb::pb::PhysicalRoom* unsafe_arena_release_physical_rooms();

  // optional .baikaldb.pb.InstanceInfo instance = 9;
  bool has_instance() const;
  private:
  bool _internal_has_instance() const;
  public:
  void clear_instance();
  const ::baikaldb::pb::InstanceInfo& instance() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::InstanceInfo* release_instance();
  ::baikaldb::pb::InstanceInfo* mutable_instance();
  void set_allocated_instance(::baikaldb::pb::InstanceInfo* instance);
  private:
  const ::baikaldb::pb::InstanceInfo& _internal_instance() const;
  ::baikaldb::pb::InstanceInfo* _internal_mutable_instance();
  public:
  void unsafe_arena_set_allocated_instance(
      ::baikaldb::pb::InstanceInfo* instance);
  ::baikaldb::pb::InstanceInfo* unsafe_arena_release_instance();

  // optional .baikaldb.pb.MovePhysicalRequest move_physical_request = 10;
  bool has_move_physical_request() const;
  private:
  bool _internal_has_move_physical_request() const;
  public:
  void clear_move_physical_request();
  const ::baikaldb::pb::MovePhysicalRequest& move_physical_request() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::MovePhysicalRequest* release_move_physical_request();
  ::baikaldb::pb::MovePhysicalRequest* mutable_move_physical_request();
  void set_allocated_move_physical_request(::baikaldb::pb::MovePhysicalRequest* move_physical_request);
  private:
  const ::baikaldb::pb::MovePhysicalRequest& _internal_move_physical_request() const;
  ::baikaldb::pb::MovePhysicalRequest* _internal_mutable_move_physical_request();
  public:
  void unsafe_arena_set_allocated_move_physical_request(
      ::baikaldb::pb::MovePhysicalRequest* move_physical_request);
  ::baikaldb::pb::MovePhysicalRequest* unsafe_arena_release_move_physical_request();

  // optional .baikaldb.pb.RegionInfo region_info = 11;
  bool has_region_info() const;
  private:
  bool _internal_has_region_info() const;
  public:
  void clear_region_info();
  const ::baikaldb::pb::RegionInfo& region_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionInfo* release_region_info();
  ::baikaldb::pb::RegionInfo* mutable_region_info();
  void set_allocated_region_info(::baikaldb::pb::RegionInfo* region_info);
  private:
  const ::baikaldb::pb::RegionInfo& _internal_region_info() const;
  ::baikaldb::pb::RegionInfo* _internal_mutable_region_info();
  public:
  void unsafe_arena_set_allocated_region_info(
      ::baikaldb::pb::RegionInfo* region_info);
  ::baikaldb::pb::RegionInfo* unsafe_arena_release_region_info();

  // optional .baikaldb.pb.RegionSplitRequest region_split = 13;
  bool has_region_split() const;
  private:
  bool _internal_has_region_split() const;
  public:
  void clear_region_split();
  const ::baikaldb::pb::RegionSplitRequest& region_split() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionSplitRequest* release_region_split();
  ::baikaldb::pb::RegionSplitRequest* mutable_region_split();
  void set_allocated_region_split(::baikaldb::pb::RegionSplitRequest* region_split);
  private:
  const ::baikaldb::pb::RegionSplitRequest& _internal_region_split() const;
  ::baikaldb::pb::RegionSplitRequest* _internal_mutable_region_split();
  public:
  void unsafe_arena_set_allocated_region_split(
      ::baikaldb::pb::RegionSplitRequest* region_split);
  ::baikaldb::pb::RegionSplitRequest* unsafe_arena_release_region_split();

  // optional .baikaldb.pb.AutoIncrementRequest auto_increment = 14;
  bool has_auto_increment() const;
  private:
  bool _internal_has_auto_increment() const;
  public:
  void clear_auto_increment();
  const ::baikaldb::pb::AutoIncrementRequest& auto_increment() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::AutoIncrementRequest* release_auto_increment();
  ::baikaldb::pb::AutoIncrementRequest* mutable_auto_increment();
  void set_allocated_auto_increment(::baikaldb::pb::AutoIncrementRequest* auto_increment);
  private:
  const ::baikaldb::pb::AutoIncrementRequest& _internal_auto_increment() const;
  ::baikaldb::pb::AutoIncrementRequest* _internal_mutable_auto_increment();
  public:
  void unsafe_arena_set_allocated_auto_increment(
      ::baikaldb::pb::AutoIncrementRequest* auto_increment);
  ::baikaldb::pb::AutoIncrementRequest* unsafe_arena_release_auto_increment();

  // optional .baikaldb.pb.RestoreRegionRequest restore_region = 15;
  bool has_restore_region() const;
  private:
  bool _internal_has_restore_region() const;
  public:
  void clear_restore_region();
  const ::baikaldb::pb::RestoreRegionRequest& restore_region() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RestoreRegionRequest* release_restore_region();
  ::baikaldb::pb::RestoreRegionRequest* mutable_restore_region();
  void set_allocated_restore_region(::baikaldb::pb::RestoreRegionRequest* restore_region);
  private:
  const ::baikaldb::pb::RestoreRegionRequest& _internal_restore_region() const;
  ::baikaldb::pb::RestoreRegionRequest* _internal_mutable_restore_region();
  public:
  void unsafe_arena_set_allocated_restore_region(
      ::baikaldb::pb::RestoreRegionRequest* restore_region);
  ::baikaldb::pb::RestoreRegionRequest* unsafe_arena_release_restore_region();

  // optional .baikaldb.pb.RegionMergeRequest region_merge = 17;
  bool has_region_merge() const;
  private:
  bool _internal_has_region_merge() const;
  public:
  void clear_region_merge();
  const ::baikaldb::pb::RegionMergeRequest& region_merge() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionMergeRequest* release_region_merge();
  ::baikaldb::pb::RegionMergeRequest* mutable_region_merge();
  void set_allocated_region_merge(::baikaldb::pb::RegionMergeRequest* region_merge);
  private:
  const ::baikaldb::pb::RegionMergeRequest& _internal_region_merge() const;
  ::baikaldb::pb::RegionMergeRequest* _internal_mutable_region_merge();
  public:
  void unsafe_arena_set_allocated_region_merge(
      ::baikaldb::pb::RegionMergeRequest* region_merge);
  ::baikaldb::pb::RegionMergeRequest* unsafe_arena_release_region_merge();

  // optional .baikaldb.pb.DdlWorkInfo ddlwork_info = 20;
  bool has_ddlwork_info() const;
  private:
  bool _internal_has_ddlwork_info() const;
  public:
  void clear_ddlwork_info();
  const ::baikaldb::pb::DdlWorkInfo& ddlwork_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::DdlWorkInfo* release_ddlwork_info();
  ::baikaldb::pb::DdlWorkInfo* mutable_ddlwork_info();
  void set_allocated_ddlwork_info(::baikaldb::pb::DdlWorkInfo* ddlwork_info);
  private:
  const ::baikaldb::pb::DdlWorkInfo& _internal_ddlwork_info() const;
  ::baikaldb::pb::DdlWorkInfo* _internal_mutable_ddlwork_info();
  public:
  void unsafe_arena_set_allocated_ddlwork_info(
      ::baikaldb::pb::DdlWorkInfo* ddlwork_info);
  ::baikaldb::pb::DdlWorkInfo* unsafe_arena_release_ddlwork_info();

  // optional .baikaldb.pb.Statistics statistics = 22;
  bool has_statistics() const;
  private:
  bool _internal_has_statistics() const;
  public:
  void clear_statistics();
  const ::baikaldb::pb::Statistics& statistics() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::Statistics* release_statistics();
  ::baikaldb::pb::Statistics* mutable_statistics();
  void set_allocated_statistics(::baikaldb::pb::Statistics* statistics);
  private:
  const ::baikaldb::pb::Statistics& _internal_statistics() const;
  ::baikaldb::pb::Statistics* _internal_mutable_statistics();
  public:
  void unsafe_arena_set_allocated_statistics(
      ::baikaldb::pb::Statistics* statistics);
  ::baikaldb::pb::Statistics* unsafe_arena_release_statistics();

  // optional .baikaldb.pb.SchemaInfo binlog_info = 23;
  bool has_binlog_info() const;
  private:
  bool _internal_has_binlog_info() const;
  public:
  void clear_binlog_info();
  const ::baikaldb::pb::SchemaInfo& binlog_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::SchemaInfo* release_binlog_info();
  ::baikaldb::pb::SchemaInfo* mutable_binlog_info();
  void set_allocated_binlog_info(::baikaldb::pb::SchemaInfo* binlog_info);
  private:
  const ::baikaldb::pb::SchemaInfo& _internal_binlog_info() const;
  ::baikaldb::pb::SchemaInfo* _internal_mutable_binlog_info();
  public:
  void unsafe_arena_set_allocated_binlog_info(
      ::baikaldb::pb::SchemaInfo* binlog_info);
  ::baikaldb::pb::SchemaInfo* unsafe_arena_release_binlog_info();

  // optional .baikaldb.pb.IndexDdlRequest index_ddl_request = 26;
  bool has_index_ddl_request() const;
  private:
  bool _internal_has_index_ddl_request() const;
  public:
  void clear_index_ddl_request();
  const ::baikaldb::pb::IndexDdlRequest& index_ddl_request() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::IndexDdlRequest* release_index_ddl_request();
  ::baikaldb::pb::IndexDdlRequest* mutable_index_ddl_request();
  void set_allocated_index_ddl_request(::baikaldb::pb::IndexDdlRequest* index_ddl_request);
  private:
  const ::baikaldb::pb::IndexDdlRequest& _internal_index_ddl_request() const;
  ::baikaldb::pb::IndexDdlRequest* _internal_mutable_index_ddl_request();
  public:
  void unsafe_arena_set_allocated_index_ddl_request(
      ::baikaldb::pb::IndexDdlRequest* index_ddl_request);
  ::baikaldb::pb::IndexDdlRequest* unsafe_arena_release_index_ddl_request();

  // required .baikaldb.pb.OpType op_type = 1;
  bool has_op_type() const;
  private:
  bool _internal_has_op_type() const;
  public:
  void clear_op_type();
  ::baikaldb::pb::OpType op_type() const;
  void set_op_type(::baikaldb::pb::OpType value);
  private:
  ::baikaldb::pb::OpType _internal_op_type() const;
  void _internal_set_op_type(::baikaldb::pb::OpType value);
  public:

  // optional bool need_merge = 18;
  bool has_need_merge() const;
  private:
  bool _internal_has_need_merge() const;
  public:
  void clear_need_merge();
  bool need_merge() const;
  void set_need_merge(bool value);
  private:
  bool _internal_need_merge() const;
  void _internal_set_need_merge(bool value);
  public:

  // optional bool add_delete_region = 21;
  bool has_add_delete_region() const;
  private:
  bool _internal_has_add_delete_region() const;
  public:
  void clear_add_delete_region();
  bool add_delete_region() const;
  void set_add_delete_region(bool value);
  private:
  bool _internal_add_delete_region() const;
  void _internal_set_add_delete_region(bool value);
  public:

  // optional bool is_dynamic_change = 28;
  bool has_is_dynamic_change() const;
  private:
  bool _internal_has_is_dynamic_change() const;
  public:
  void clear_is_dynamic_change();
  bool is_dynamic_change() const;
  void set_is_dynamic_change(bool value);
  private:
  bool _internal_is_dynamic_change() const;
  void _internal_set_is_dynamic_change(bool value);
  public:

  // optional bool is_force_setting = 29;
  bool has_is_force_setting() const;
  private:
  bool _internal_has_is_force_setting() const;
  public:
  void clear_is_force_setting();
  bool is_force_setting() const;
  void set_is_force_setting(bool value);
  private:
  bool _internal_is_force_setting() const;
  void _internal_set_is_force_setting(bool value);
  public:

  // optional int64 learner_replica_num = 27;
  bool has_learner_replica_num() const;
  private:
  bool _internal_has_learner_replica_num() const;
  public:
  void clear_learner_replica_num();
  ::PROTOBUF_NAMESPACE_ID::int64 learner_replica_num() const;
  void set_learner_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_learner_replica_num() const;
  void _internal_set_learner_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.RecoverOpt recover_opt = 25;
  bool has_recover_opt() const;
  private:
  bool _internal_has_recover_opt() const;
  public:
  void clear_recover_opt();
  ::baikaldb::pb::RecoverOpt recover_opt() const;
  void set_recover_opt(::baikaldb::pb::RecoverOpt value);
  private:
  ::baikaldb::pb::RecoverOpt _internal_recover_opt() const;
  void _internal_set_recover_opt(::baikaldb::pb::RecoverOpt value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.MetaManagerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > drop_region_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> resource_tags_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo > region_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam > instance_params_;
  ::baikaldb::pb::SchemaInfo* table_info_;
  ::baikaldb::pb::NameSpaceInfo* namespace_info_;
  ::baikaldb::pb::DataBaseInfo* database_info_;
  ::baikaldb::pb::UserPrivilege* user_privilege_;
  ::baikaldb::pb::AlterTableRequest* alter_table_;
  ::baikaldb::pb::LogicalRoom* logical_rooms_;
  ::baikaldb::pb::PhysicalRoom* physical_rooms_;
  ::baikaldb::pb::InstanceInfo* instance_;
  ::baikaldb::pb::MovePhysicalRequest* move_physical_request_;
  ::baikaldb::pb::RegionInfo* region_info_;
  ::baikaldb::pb::RegionSplitRequest* region_split_;
  ::baikaldb::pb::AutoIncrementRequest* auto_increment_;
  ::baikaldb::pb::RestoreRegionRequest* restore_region_;
  ::baikaldb::pb::RegionMergeRequest* region_merge_;
  ::baikaldb::pb::DdlWorkInfo* ddlwork_info_;
  ::baikaldb::pb::Statistics* statistics_;
  ::baikaldb::pb::SchemaInfo* binlog_info_;
  ::baikaldb::pb::IndexDdlRequest* index_ddl_request_;
  int op_type_;
  bool need_merge_;
  bool add_delete_region_;
  bool is_dynamic_change_;
  bool is_force_setting_;
  ::PROTOBUF_NAMESPACE_ID::int64 learner_replica_num_;
  int recover_opt_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class CreateTableResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.CreateTableResponse) */ {
 public:
  inline CreateTableResponse() : CreateTableResponse(nullptr) {}
  ~CreateTableResponse() override;
  explicit constexpr CreateTableResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTableResponse(const CreateTableResponse& from);
  CreateTableResponse(CreateTableResponse&& from) noexcept
    : CreateTableResponse() {
    *this = ::std::move(from);
  }

  inline CreateTableResponse& operator=(const CreateTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTableResponse& operator=(CreateTableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTableResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTableResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTableResponse*>(
               &_CreateTableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(CreateTableResponse& a, CreateTableResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTableResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTableResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateTableResponse* New() const final {
    return new CreateTableResponse();
  }

  CreateTableResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateTableResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTableResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateTableResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTableResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.CreateTableResponse";
  }
  protected:
  explicit CreateTableResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionInfosFieldNumber = 2,
    kSchemaInfoFieldNumber = 1,
  };
  // repeated .baikaldb.pb.RegionInfo region_infos = 2;
  int region_infos_size() const;
  private:
  int _internal_region_infos_size() const;
  public:
  void clear_region_infos();
  ::baikaldb::pb::RegionInfo* mutable_region_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >*
      mutable_region_infos();
  private:
  const ::baikaldb::pb::RegionInfo& _internal_region_infos(int index) const;
  ::baikaldb::pb::RegionInfo* _internal_add_region_infos();
  public:
  const ::baikaldb::pb::RegionInfo& region_infos(int index) const;
  ::baikaldb::pb::RegionInfo* add_region_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >&
      region_infos() const;

  // optional .baikaldb.pb.SchemaInfo schema_info = 1;
  bool has_schema_info() const;
  private:
  bool _internal_has_schema_info() const;
  public:
  void clear_schema_info();
  const ::baikaldb::pb::SchemaInfo& schema_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::SchemaInfo* release_schema_info();
  ::baikaldb::pb::SchemaInfo* mutable_schema_info();
  void set_allocated_schema_info(::baikaldb::pb::SchemaInfo* schema_info);
  private:
  const ::baikaldb::pb::SchemaInfo& _internal_schema_info() const;
  ::baikaldb::pb::SchemaInfo* _internal_mutable_schema_info();
  public:
  void unsafe_arena_set_allocated_schema_info(
      ::baikaldb::pb::SchemaInfo* schema_info);
  ::baikaldb::pb::SchemaInfo* unsafe_arena_release_schema_info();

  // @@protoc_insertion_point(class_scope:baikaldb.pb.CreateTableResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo > region_infos_;
  ::baikaldb::pb::SchemaInfo* schema_info_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class MetaManagerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.MetaManagerResponse) */ {
 public:
  inline MetaManagerResponse() : MetaManagerResponse(nullptr) {}
  ~MetaManagerResponse() override;
  explicit constexpr MetaManagerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetaManagerResponse(const MetaManagerResponse& from);
  MetaManagerResponse(MetaManagerResponse&& from) noexcept
    : MetaManagerResponse() {
    *this = ::std::move(from);
  }

  inline MetaManagerResponse& operator=(const MetaManagerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetaManagerResponse& operator=(MetaManagerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetaManagerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetaManagerResponse* internal_default_instance() {
    return reinterpret_cast<const MetaManagerResponse*>(
               &_MetaManagerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(MetaManagerResponse& a, MetaManagerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MetaManagerResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetaManagerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MetaManagerResponse* New() const final {
    return new MetaManagerResponse();
  }

  MetaManagerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MetaManagerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetaManagerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetaManagerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetaManagerResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.MetaManagerResponse";
  }
  protected:
  explicit MetaManagerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrmsgFieldNumber = 2,
    kLeaderFieldNumber = 3,
    kSplitResponseFieldNumber = 4,
    kMergeResponseFieldNumber = 8,
    kRecoverResponseFieldNumber = 9,
    kCreateTableResponseFieldNumber = 10,
    kErrcodeFieldNumber = 1,
    kOpTypeFieldNumber = 5,
    kStartIdFieldNumber = 6,
    kEndIdFieldNumber = 7,
  };
  // optional string errmsg = 2;
  bool has_errmsg() const;
  private:
  bool _internal_has_errmsg() const;
  public:
  void clear_errmsg();
  const std::string& errmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errmsg();
  PROTOBUF_MUST_USE_RESULT std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // optional string leader = 3;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // optional .baikaldb.pb.RegionSplitResponse split_response = 4;
  bool has_split_response() const;
  private:
  bool _internal_has_split_response() const;
  public:
  void clear_split_response();
  const ::baikaldb::pb::RegionSplitResponse& split_response() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionSplitResponse* release_split_response();
  ::baikaldb::pb::RegionSplitResponse* mutable_split_response();
  void set_allocated_split_response(::baikaldb::pb::RegionSplitResponse* split_response);
  private:
  const ::baikaldb::pb::RegionSplitResponse& _internal_split_response() const;
  ::baikaldb::pb::RegionSplitResponse* _internal_mutable_split_response();
  public:
  void unsafe_arena_set_allocated_split_response(
      ::baikaldb::pb::RegionSplitResponse* split_response);
  ::baikaldb::pb::RegionSplitResponse* unsafe_arena_release_split_response();

  // optional .baikaldb.pb.RegionMergeResponse merge_response = 8;
  bool has_merge_response() const;
  private:
  bool _internal_has_merge_response() const;
  public:
  void clear_merge_response();
  const ::baikaldb::pb::RegionMergeResponse& merge_response() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionMergeResponse* release_merge_response();
  ::baikaldb::pb::RegionMergeResponse* mutable_merge_response();
  void set_allocated_merge_response(::baikaldb::pb::RegionMergeResponse* merge_response);
  private:
  const ::baikaldb::pb::RegionMergeResponse& _internal_merge_response() const;
  ::baikaldb::pb::RegionMergeResponse* _internal_mutable_merge_response();
  public:
  void unsafe_arena_set_allocated_merge_response(
      ::baikaldb::pb::RegionMergeResponse* merge_response);
  ::baikaldb::pb::RegionMergeResponse* unsafe_arena_release_merge_response();

  // optional .baikaldb.pb.RegionRecoverResponse recover_response = 9;
  bool has_recover_response() const;
  private:
  bool _internal_has_recover_response() const;
  public:
  void clear_recover_response();
  const ::baikaldb::pb::RegionRecoverResponse& recover_response() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionRecoverResponse* release_recover_response();
  ::baikaldb::pb::RegionRecoverResponse* mutable_recover_response();
  void set_allocated_recover_response(::baikaldb::pb::RegionRecoverResponse* recover_response);
  private:
  const ::baikaldb::pb::RegionRecoverResponse& _internal_recover_response() const;
  ::baikaldb::pb::RegionRecoverResponse* _internal_mutable_recover_response();
  public:
  void unsafe_arena_set_allocated_recover_response(
      ::baikaldb::pb::RegionRecoverResponse* recover_response);
  ::baikaldb::pb::RegionRecoverResponse* unsafe_arena_release_recover_response();

  // optional .baikaldb.pb.CreateTableResponse create_table_response = 10;
  bool has_create_table_response() const;
  private:
  bool _internal_has_create_table_response() const;
  public:
  void clear_create_table_response();
  const ::baikaldb::pb::CreateTableResponse& create_table_response() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::CreateTableResponse* release_create_table_response();
  ::baikaldb::pb::CreateTableResponse* mutable_create_table_response();
  void set_allocated_create_table_response(::baikaldb::pb::CreateTableResponse* create_table_response);
  private:
  const ::baikaldb::pb::CreateTableResponse& _internal_create_table_response() const;
  ::baikaldb::pb::CreateTableResponse* _internal_mutable_create_table_response();
  public:
  void unsafe_arena_set_allocated_create_table_response(
      ::baikaldb::pb::CreateTableResponse* create_table_response);
  ::baikaldb::pb::CreateTableResponse* unsafe_arena_release_create_table_response();

  // required .baikaldb.pb.ErrCode errcode = 1;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::ErrCode errcode() const;
  void set_errcode(::baikaldb::pb::ErrCode value);
  private:
  ::baikaldb::pb::ErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::ErrCode value);
  public:

  // optional .baikaldb.pb.OpType op_type = 5;
  bool has_op_type() const;
  private:
  bool _internal_has_op_type() const;
  public:
  void clear_op_type();
  ::baikaldb::pb::OpType op_type() const;
  void set_op_type(::baikaldb::pb::OpType value);
  private:
  ::baikaldb::pb::OpType _internal_op_type() const;
  void _internal_set_op_type(::baikaldb::pb::OpType value);
  public:

  // optional uint64 start_id = 6;
  bool has_start_id() const;
  private:
  bool _internal_has_start_id() const;
  public:
  void clear_start_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 start_id() const;
  void set_start_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_start_id() const;
  void _internal_set_start_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 end_id = 7;
  bool has_end_id() const;
  private:
  bool _internal_has_end_id() const;
  public:
  void clear_end_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 end_id() const;
  void set_end_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_end_id() const;
  void _internal_set_end_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.MetaManagerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  ::baikaldb::pb::RegionSplitResponse* split_response_;
  ::baikaldb::pb::RegionMergeResponse* merge_response_;
  ::baikaldb::pb::RegionRecoverResponse* recover_response_;
  ::baikaldb::pb::CreateTableResponse* create_table_response_;
  int errcode_;
  int op_type_;
  ::PROTOBUF_NAMESPACE_ID::uint64 start_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 end_id_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RegionRecoverResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RegionRecoverResponse) */ {
 public:
  inline RegionRecoverResponse() : RegionRecoverResponse(nullptr) {}
  ~RegionRecoverResponse() override;
  explicit constexpr RegionRecoverResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionRecoverResponse(const RegionRecoverResponse& from);
  RegionRecoverResponse(RegionRecoverResponse&& from) noexcept
    : RegionRecoverResponse() {
    *this = ::std::move(from);
  }

  inline RegionRecoverResponse& operator=(const RegionRecoverResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionRecoverResponse& operator=(RegionRecoverResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionRecoverResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionRecoverResponse* internal_default_instance() {
    return reinterpret_cast<const RegionRecoverResponse*>(
               &_RegionRecoverResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(RegionRecoverResponse& a, RegionRecoverResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionRecoverResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionRecoverResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionRecoverResponse* New() const final {
    return new RegionRecoverResponse();
  }

  RegionRecoverResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionRecoverResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionRecoverResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegionRecoverResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionRecoverResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RegionRecoverResponse";
  }
  protected:
  explicit RegionRecoverResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetPeerRegionsFieldNumber = 1,
    kInitedRegionsFieldNumber = 2,
    kIllegalRegionsFieldNumber = 3,
  };
  // repeated .baikaldb.pb.PeerStateInfo set_peer_regions = 1;
  int set_peer_regions_size() const;
  private:
  int _internal_set_peer_regions_size() const;
  public:
  void clear_set_peer_regions();
  ::baikaldb::pb::PeerStateInfo* mutable_set_peer_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >*
      mutable_set_peer_regions();
  private:
  const ::baikaldb::pb::PeerStateInfo& _internal_set_peer_regions(int index) const;
  ::baikaldb::pb::PeerStateInfo* _internal_add_set_peer_regions();
  public:
  const ::baikaldb::pb::PeerStateInfo& set_peer_regions(int index) const;
  ::baikaldb::pb::PeerStateInfo* add_set_peer_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >&
      set_peer_regions() const;

  // repeated .baikaldb.pb.PeerStateInfo inited_regions = 2;
  int inited_regions_size() const;
  private:
  int _internal_inited_regions_size() const;
  public:
  void clear_inited_regions();
  ::baikaldb::pb::PeerStateInfo* mutable_inited_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >*
      mutable_inited_regions();
  private:
  const ::baikaldb::pb::PeerStateInfo& _internal_inited_regions(int index) const;
  ::baikaldb::pb::PeerStateInfo* _internal_add_inited_regions();
  public:
  const ::baikaldb::pb::PeerStateInfo& inited_regions(int index) const;
  ::baikaldb::pb::PeerStateInfo* add_inited_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >&
      inited_regions() const;

  // repeated .baikaldb.pb.PeerStateInfo illegal_regions = 3;
  int illegal_regions_size() const;
  private:
  int _internal_illegal_regions_size() const;
  public:
  void clear_illegal_regions();
  ::baikaldb::pb::PeerStateInfo* mutable_illegal_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >*
      mutable_illegal_regions();
  private:
  const ::baikaldb::pb::PeerStateInfo& _internal_illegal_regions(int index) const;
  ::baikaldb::pb::PeerStateInfo* _internal_add_illegal_regions();
  public:
  const ::baikaldb::pb::PeerStateInfo& illegal_regions(int index) const;
  ::baikaldb::pb::PeerStateInfo* add_illegal_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >&
      illegal_regions() const;

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RegionRecoverResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo > set_peer_regions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo > inited_regions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo > illegal_regions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class SchemaHeartBeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.SchemaHeartBeat) */ {
 public:
  inline SchemaHeartBeat() : SchemaHeartBeat(nullptr) {}
  ~SchemaHeartBeat() override;
  explicit constexpr SchemaHeartBeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchemaHeartBeat(const SchemaHeartBeat& from);
  SchemaHeartBeat(SchemaHeartBeat&& from) noexcept
    : SchemaHeartBeat() {
    *this = ::std::move(from);
  }

  inline SchemaHeartBeat& operator=(const SchemaHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaHeartBeat& operator=(SchemaHeartBeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaHeartBeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaHeartBeat* internal_default_instance() {
    return reinterpret_cast<const SchemaHeartBeat*>(
               &_SchemaHeartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(SchemaHeartBeat& a, SchemaHeartBeat& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaHeartBeat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaHeartBeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchemaHeartBeat* New() const final {
    return new SchemaHeartBeat();
  }

  SchemaHeartBeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchemaHeartBeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchemaHeartBeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SchemaHeartBeat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaHeartBeat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.SchemaHeartBeat";
  }
  protected:
  explicit SchemaHeartBeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableIdFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // required int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.SchemaHeartBeat)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BinlogPeerState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BinlogPeerState) */ {
 public:
  inline BinlogPeerState() : BinlogPeerState(nullptr) {}
  ~BinlogPeerState() override;
  explicit constexpr BinlogPeerState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinlogPeerState(const BinlogPeerState& from);
  BinlogPeerState(BinlogPeerState&& from) noexcept
    : BinlogPeerState() {
    *this = ::std::move(from);
  }

  inline BinlogPeerState& operator=(const BinlogPeerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinlogPeerState& operator=(BinlogPeerState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinlogPeerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinlogPeerState* internal_default_instance() {
    return reinterpret_cast<const BinlogPeerState*>(
               &_BinlogPeerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(BinlogPeerState& a, BinlogPeerState& b) {
    a.Swap(&b);
  }
  inline void Swap(BinlogPeerState* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinlogPeerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinlogPeerState* New() const final {
    return new BinlogPeerState();
  }

  BinlogPeerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinlogPeerState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinlogPeerState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BinlogPeerState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinlogPeerState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BinlogPeerState";
  }
  protected:
  explicit BinlogPeerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdFieldNumber = 1,
    kOldestTimestampToNowIntervalFieldNumber = 2,
  };
  // required int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint32 oldest_timestamp_to_now_interval = 2;
  bool has_oldest_timestamp_to_now_interval() const;
  private:
  bool _internal_has_oldest_timestamp_to_now_interval() const;
  public:
  void clear_oldest_timestamp_to_now_interval();
  ::PROTOBUF_NAMESPACE_ID::uint32 oldest_timestamp_to_now_interval() const;
  void set_oldest_timestamp_to_now_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_oldest_timestamp_to_now_interval() const;
  void _internal_set_oldest_timestamp_to_now_interval(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BinlogPeerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 oldest_timestamp_to_now_interval_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class PeerStateInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.PeerStateInfo) */ {
 public:
  inline PeerStateInfo() : PeerStateInfo(nullptr) {}
  ~PeerStateInfo() override;
  explicit constexpr PeerStateInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerStateInfo(const PeerStateInfo& from);
  PeerStateInfo(PeerStateInfo&& from) noexcept
    : PeerStateInfo() {
    *this = ::std::move(from);
  }

  inline PeerStateInfo& operator=(const PeerStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerStateInfo& operator=(PeerStateInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerStateInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerStateInfo* internal_default_instance() {
    return reinterpret_cast<const PeerStateInfo*>(
               &_PeerStateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(PeerStateInfo& a, PeerStateInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerStateInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerStateInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PeerStateInfo* New() const final {
    return new PeerStateInfo();
  }

  PeerStateInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PeerStateInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeerStateInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PeerStateInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerStateInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.PeerStateInfo";
  }
  protected:
  explicit PeerStateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerIdFieldNumber = 1,
    kTableIdFieldNumber = 3,
    kTimestampFieldNumber = 4,
    kPeerStatusFieldNumber = 2,
    kIsLearnerFieldNumber = 6,
    kRegionIdFieldNumber = 5,
  };
  // optional string peer_id = 1;
  bool has_peer_id() const;
  private:
  bool _internal_has_peer_id() const;
  public:
  void clear_peer_id();
  const std::string& peer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_peer_id();
  void set_allocated_peer_id(std::string* peer_id);
  private:
  const std::string& _internal_peer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer_id(const std::string& value);
  std::string* _internal_mutable_peer_id();
  public:

  // optional int64 table_id = 3;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 timestamp = 4;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.PeerStatus peer_status = 2;
  bool has_peer_status() const;
  private:
  bool _internal_has_peer_status() const;
  public:
  void clear_peer_status();
  ::baikaldb::pb::PeerStatus peer_status() const;
  void set_peer_status(::baikaldb::pb::PeerStatus value);
  private:
  ::baikaldb::pb::PeerStatus _internal_peer_status() const;
  void _internal_set_peer_status(::baikaldb::pb::PeerStatus value);
  public:

  // optional bool is_learner = 6;
  bool has_is_learner() const;
  private:
  bool _internal_has_is_learner() const;
  public:
  void clear_is_learner();
  bool is_learner() const;
  void set_is_learner(bool value);
  private:
  bool _internal_is_learner() const;
  void _internal_set_is_learner(bool value);
  public:

  // optional int64 region_id = 5;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.PeerStateInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  int peer_status_;
  bool is_learner_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RegionStateInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RegionStateInfo) */ {
 public:
  inline RegionStateInfo() : RegionStateInfo(nullptr) {}
  ~RegionStateInfo() override;
  explicit constexpr RegionStateInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionStateInfo(const RegionStateInfo& from);
  RegionStateInfo(RegionStateInfo&& from) noexcept
    : RegionStateInfo() {
    *this = ::std::move(from);
  }

  inline RegionStateInfo& operator=(const RegionStateInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionStateInfo& operator=(RegionStateInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionStateInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionStateInfo* internal_default_instance() {
    return reinterpret_cast<const RegionStateInfo*>(
               &_RegionStateInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(RegionStateInfo& a, RegionStateInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionStateInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionStateInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionStateInfo* New() const final {
    return new RegionStateInfo();
  }

  RegionStateInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionStateInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionStateInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegionStateInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionStateInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RegionStateInfo";
  }
  protected:
  explicit RegionStateInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerStatusInfosFieldNumber = 5,
    kTableNameFieldNumber = 4,
    kTableIdFieldNumber = 1,
    kRegionIdFieldNumber = 2,
    kIsHealthyFieldNumber = 3,
  };
  // repeated .baikaldb.pb.PeerStateInfo peer_status_infos = 5;
  int peer_status_infos_size() const;
  private:
  int _internal_peer_status_infos_size() const;
  public:
  void clear_peer_status_infos();
  ::baikaldb::pb::PeerStateInfo* mutable_peer_status_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >*
      mutable_peer_status_infos();
  private:
  const ::baikaldb::pb::PeerStateInfo& _internal_peer_status_infos(int index) const;
  ::baikaldb::pb::PeerStateInfo* _internal_add_peer_status_infos();
  public:
  const ::baikaldb::pb::PeerStateInfo& peer_status_infos(int index) const;
  ::baikaldb::pb::PeerStateInfo* add_peer_status_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >&
      peer_status_infos() const;

  // optional string table_name = 4;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_id = 2;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool is_healthy = 3;
  bool has_is_healthy() const;
  private:
  bool _internal_has_is_healthy() const;
  public:
  void clear_is_healthy();
  bool is_healthy() const;
  void set_is_healthy(bool value);
  private:
  bool _internal_is_healthy() const;
  void _internal_set_is_healthy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RegionStateInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo > peer_status_infos_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  bool is_healthy_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class LeaderHeartBeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.LeaderHeartBeat) */ {
 public:
  inline LeaderHeartBeat() : LeaderHeartBeat(nullptr) {}
  ~LeaderHeartBeat() override;
  explicit constexpr LeaderHeartBeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaderHeartBeat(const LeaderHeartBeat& from);
  LeaderHeartBeat(LeaderHeartBeat&& from) noexcept
    : LeaderHeartBeat() {
    *this = ::std::move(from);
  }

  inline LeaderHeartBeat& operator=(const LeaderHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaderHeartBeat& operator=(LeaderHeartBeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaderHeartBeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaderHeartBeat* internal_default_instance() {
    return reinterpret_cast<const LeaderHeartBeat*>(
               &_LeaderHeartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(LeaderHeartBeat& a, LeaderHeartBeat& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaderHeartBeat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaderHeartBeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LeaderHeartBeat* New() const final {
    return new LeaderHeartBeat();
  }

  LeaderHeartBeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LeaderHeartBeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaderHeartBeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LeaderHeartBeat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaderHeartBeat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.LeaderHeartBeat";
  }
  protected:
  explicit LeaderHeartBeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersStatusFieldNumber = 3,
    kRegionFieldNumber = 1,
    kSimpleFieldNumber = 4,
    kStatusFieldNumber = 2,
  };
  // repeated .baikaldb.pb.PeerStateInfo peers_status = 3;
  int peers_status_size() const;
  private:
  int _internal_peers_status_size() const;
  public:
  void clear_peers_status();
  ::baikaldb::pb::PeerStateInfo* mutable_peers_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >*
      mutable_peers_status();
  private:
  const ::baikaldb::pb::PeerStateInfo& _internal_peers_status(int index) const;
  ::baikaldb::pb::PeerStateInfo* _internal_add_peers_status();
  public:
  const ::baikaldb::pb::PeerStateInfo& peers_status(int index) const;
  ::baikaldb::pb::PeerStateInfo* add_peers_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >&
      peers_status() const;

  // required .baikaldb.pb.RegionInfo region = 1;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const ::baikaldb::pb::RegionInfo& region() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionInfo* release_region();
  ::baikaldb::pb::RegionInfo* mutable_region();
  void set_allocated_region(::baikaldb::pb::RegionInfo* region);
  private:
  const ::baikaldb::pb::RegionInfo& _internal_region() const;
  ::baikaldb::pb::RegionInfo* _internal_mutable_region();
  public:
  void unsafe_arena_set_allocated_region(
      ::baikaldb::pb::RegionInfo* region);
  ::baikaldb::pb::RegionInfo* unsafe_arena_release_region();

  // optional bool simple = 4;
  bool has_simple() const;
  private:
  bool _internal_has_simple() const;
  public:
  void clear_simple();
  bool simple() const;
  void set_simple(bool value);
  private:
  bool _internal_simple() const;
  void _internal_set_simple(bool value);
  public:

  // optional .baikaldb.pb.RegionStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::baikaldb::pb::RegionStatus status() const;
  void set_status(::baikaldb::pb::RegionStatus value);
  private:
  ::baikaldb::pb::RegionStatus _internal_status() const;
  void _internal_set_status(::baikaldb::pb::RegionStatus value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.LeaderHeartBeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo > peers_status_;
  ::baikaldb::pb::RegionInfo* region_;
  bool simple_;
  int status_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class LearnerHeartBeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.LearnerHeartBeat) */ {
 public:
  inline LearnerHeartBeat() : LearnerHeartBeat(nullptr) {}
  ~LearnerHeartBeat() override;
  explicit constexpr LearnerHeartBeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LearnerHeartBeat(const LearnerHeartBeat& from);
  LearnerHeartBeat(LearnerHeartBeat&& from) noexcept
    : LearnerHeartBeat() {
    *this = ::std::move(from);
  }

  inline LearnerHeartBeat& operator=(const LearnerHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline LearnerHeartBeat& operator=(LearnerHeartBeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LearnerHeartBeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const LearnerHeartBeat* internal_default_instance() {
    return reinterpret_cast<const LearnerHeartBeat*>(
               &_LearnerHeartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(LearnerHeartBeat& a, LearnerHeartBeat& b) {
    a.Swap(&b);
  }
  inline void Swap(LearnerHeartBeat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LearnerHeartBeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LearnerHeartBeat* New() const final {
    return new LearnerHeartBeat();
  }

  LearnerHeartBeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LearnerHeartBeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LearnerHeartBeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LearnerHeartBeat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LearnerHeartBeat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.LearnerHeartBeat";
  }
  protected:
  explicit LearnerHeartBeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kStateFieldNumber = 3,
    kStatusFieldNumber = 2,
  };
  // required .baikaldb.pb.RegionInfo region = 1;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const ::baikaldb::pb::RegionInfo& region() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionInfo* release_region();
  ::baikaldb::pb::RegionInfo* mutable_region();
  void set_allocated_region(::baikaldb::pb::RegionInfo* region);
  private:
  const ::baikaldb::pb::RegionInfo& _internal_region() const;
  ::baikaldb::pb::RegionInfo* _internal_mutable_region();
  public:
  void unsafe_arena_set_allocated_region(
      ::baikaldb::pb::RegionInfo* region);
  ::baikaldb::pb::RegionInfo* unsafe_arena_release_region();

  // optional .baikaldb.pb.PeerStatus state = 3;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::baikaldb::pb::PeerStatus state() const;
  void set_state(::baikaldb::pb::PeerStatus value);
  private:
  ::baikaldb::pb::PeerStatus _internal_state() const;
  void _internal_set_state(::baikaldb::pb::PeerStatus value);
  public:

  // optional .baikaldb.pb.RegionStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::baikaldb::pb::RegionStatus status() const;
  void set_status(::baikaldb::pb::RegionStatus value);
  private:
  ::baikaldb::pb::RegionStatus _internal_status() const;
  void _internal_set_status(::baikaldb::pb::RegionStatus value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.LearnerHeartBeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::RegionInfo* region_;
  int state_;
  int status_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class PeerHeartBeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.PeerHeartBeat) */ {
 public:
  inline PeerHeartBeat() : PeerHeartBeat(nullptr) {}
  ~PeerHeartBeat() override;
  explicit constexpr PeerHeartBeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerHeartBeat(const PeerHeartBeat& from);
  PeerHeartBeat(PeerHeartBeat&& from) noexcept
    : PeerHeartBeat() {
    *this = ::std::move(from);
  }

  inline PeerHeartBeat& operator=(const PeerHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerHeartBeat& operator=(PeerHeartBeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerHeartBeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerHeartBeat* internal_default_instance() {
    return reinterpret_cast<const PeerHeartBeat*>(
               &_PeerHeartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(PeerHeartBeat& a, PeerHeartBeat& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerHeartBeat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerHeartBeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PeerHeartBeat* New() const final {
    return new PeerHeartBeat();
  }

  PeerHeartBeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PeerHeartBeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeerHeartBeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PeerHeartBeat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerHeartBeat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.PeerHeartBeat";
  }
  protected:
  explicit PeerHeartBeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartKeyFieldNumber = 4,
    kEndKeyFieldNumber = 5,
    kRegionIdFieldNumber = 1,
    kTableIdFieldNumber = 2,
    kLogIndexFieldNumber = 3,
    kMainTableIdFieldNumber = 6,
    kPartitionIdFieldNumber = 9,
    kExistLeaderFieldNumber = 7,
    kIsLearnerFieldNumber = 8,
  };
  // optional bytes start_key = 4;
  bool has_start_key() const;
  private:
  bool _internal_has_start_key() const;
  public:
  void clear_start_key();
  const std::string& start_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_start_key();
  void set_allocated_start_key(std::string* start_key);
  private:
  const std::string& _internal_start_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_key(const std::string& value);
  std::string* _internal_mutable_start_key();
  public:

  // optional bytes end_key = 5;
  bool has_end_key() const;
  private:
  bool _internal_has_end_key() const;
  public:
  void clear_end_key();
  const std::string& end_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_end_key();
  void set_allocated_end_key(std::string* end_key);
  private:
  const std::string& _internal_end_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_key(const std::string& value);
  std::string* _internal_mutable_end_key();
  public:

  // required int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 table_id = 2;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 log_index = 3;
  bool has_log_index() const;
  private:
  bool _internal_has_log_index() const;
  public:
  void clear_log_index();
  ::PROTOBUF_NAMESPACE_ID::int64 log_index() const;
  void set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_log_index() const;
  void _internal_set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 main_table_id = 6;
  bool has_main_table_id() const;
  private:
  bool _internal_has_main_table_id() const;
  public:
  void clear_main_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 main_table_id() const;
  void set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_main_table_id() const;
  void _internal_set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 partition_id = 9;
  bool has_partition_id() const;
  private:
  bool _internal_has_partition_id() const;
  public:
  void clear_partition_id();
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id() const;
  void set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_partition_id() const;
  void _internal_set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool exist_leader = 7;
  bool has_exist_leader() const;
  private:
  bool _internal_has_exist_leader() const;
  public:
  void clear_exist_leader();
  bool exist_leader() const;
  void set_exist_leader(bool value);
  private:
  bool _internal_exist_leader() const;
  void _internal_set_exist_leader(bool value);
  public:

  // optional bool is_learner = 8;
  bool has_is_learner() const;
  private:
  bool _internal_has_is_learner() const;
  public:
  void clear_is_learner();
  bool is_learner() const;
  void set_is_learner(bool value);
  private:
  bool _internal_is_learner() const;
  void _internal_set_is_learner(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.PeerHeartBeat)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_key_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 log_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 main_table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id_;
  bool exist_leader_;
  bool is_learner_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class AddPeer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.AddPeer) */ {
 public:
  inline AddPeer() : AddPeer(nullptr) {}
  ~AddPeer() override;
  explicit constexpr AddPeer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddPeer(const AddPeer& from);
  AddPeer(AddPeer&& from) noexcept
    : AddPeer() {
    *this = ::std::move(from);
  }

  inline AddPeer& operator=(const AddPeer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddPeer& operator=(AddPeer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddPeer& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddPeer* internal_default_instance() {
    return reinterpret_cast<const AddPeer*>(
               &_AddPeer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(AddPeer& a, AddPeer& b) {
    a.Swap(&b);
  }
  inline void Swap(AddPeer* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddPeer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddPeer* New() const final {
    return new AddPeer();
  }

  AddPeer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddPeer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddPeer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddPeer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddPeer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.AddPeer";
  }
  protected:
  explicit AddPeer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldPeersFieldNumber = 2,
    kNewPeersFieldNumber = 3,
    kRegionIdFieldNumber = 1,
    kIsSplitFieldNumber = 4,
  };
  // repeated string old_peers = 2;
  int old_peers_size() const;
  private:
  int _internal_old_peers_size() const;
  public:
  void clear_old_peers();
  const std::string& old_peers(int index) const;
  std::string* mutable_old_peers(int index);
  void set_old_peers(int index, const std::string& value);
  void set_old_peers(int index, std::string&& value);
  void set_old_peers(int index, const char* value);
  void set_old_peers(int index, const char* value, size_t size);
  std::string* add_old_peers();
  void add_old_peers(const std::string& value);
  void add_old_peers(std::string&& value);
  void add_old_peers(const char* value);
  void add_old_peers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& old_peers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_old_peers();
  private:
  const std::string& _internal_old_peers(int index) const;
  std::string* _internal_add_old_peers();
  public:

  // repeated string new_peers = 3;
  int new_peers_size() const;
  private:
  int _internal_new_peers_size() const;
  public:
  void clear_new_peers();
  const std::string& new_peers(int index) const;
  std::string* mutable_new_peers(int index);
  void set_new_peers(int index, const std::string& value);
  void set_new_peers(int index, std::string&& value);
  void set_new_peers(int index, const char* value);
  void set_new_peers(int index, const char* value, size_t size);
  std::string* add_new_peers();
  void add_new_peers(const std::string& value);
  void add_new_peers(std::string&& value);
  void add_new_peers(const char* value);
  void add_new_peers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& new_peers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_new_peers();
  private:
  const std::string& _internal_new_peers(int index) const;
  std::string* _internal_add_new_peers();
  public:

  // required int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool is_split = 4;
  bool has_is_split() const;
  private:
  bool _internal_has_is_split() const;
  public:
  void clear_is_split();
  bool is_split() const;
  void set_is_split(bool value);
  private:
  bool _internal_is_split() const;
  void _internal_set_is_split(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.AddPeer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> old_peers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> new_peers_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  bool is_split_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class TransLeaderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TransLeaderRequest) */ {
 public:
  inline TransLeaderRequest() : TransLeaderRequest(nullptr) {}
  ~TransLeaderRequest() override;
  explicit constexpr TransLeaderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransLeaderRequest(const TransLeaderRequest& from);
  TransLeaderRequest(TransLeaderRequest&& from) noexcept
    : TransLeaderRequest() {
    *this = ::std::move(from);
  }

  inline TransLeaderRequest& operator=(const TransLeaderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransLeaderRequest& operator=(TransLeaderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransLeaderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransLeaderRequest* internal_default_instance() {
    return reinterpret_cast<const TransLeaderRequest*>(
               &_TransLeaderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(TransLeaderRequest& a, TransLeaderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TransLeaderRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransLeaderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransLeaderRequest* New() const final {
    return new TransLeaderRequest();
  }

  TransLeaderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransLeaderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransLeaderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransLeaderRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransLeaderRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TransLeaderRequest";
  }
  protected:
  explicit TransLeaderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldLeaderFieldNumber = 2,
    kNewLeaderFieldNumber = 3,
    kRegionIdFieldNumber = 1,
    kTableIdFieldNumber = 4,
  };
  // required string old_leader = 2;
  bool has_old_leader() const;
  private:
  bool _internal_has_old_leader() const;
  public:
  void clear_old_leader();
  const std::string& old_leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_old_leader();
  void set_allocated_old_leader(std::string* old_leader);
  private:
  const std::string& _internal_old_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_leader(const std::string& value);
  std::string* _internal_mutable_old_leader();
  public:

  // required string new_leader = 3;
  bool has_new_leader() const;
  private:
  bool _internal_has_new_leader() const;
  public:
  void clear_new_leader();
  const std::string& new_leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_new_leader();
  void set_allocated_new_leader(std::string* new_leader);
  private:
  const std::string& _internal_new_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_leader(const std::string& value);
  std::string* _internal_mutable_new_leader();
  public:

  // required int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 table_id = 4;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TransLeaderRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_leader_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_leader_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class StoreHeartBeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.StoreHeartBeatRequest) */ {
 public:
  inline StoreHeartBeatRequest() : StoreHeartBeatRequest(nullptr) {}
  ~StoreHeartBeatRequest() override;
  explicit constexpr StoreHeartBeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreHeartBeatRequest(const StoreHeartBeatRequest& from);
  StoreHeartBeatRequest(StoreHeartBeatRequest&& from) noexcept
    : StoreHeartBeatRequest() {
    *this = ::std::move(from);
  }

  inline StoreHeartBeatRequest& operator=(const StoreHeartBeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreHeartBeatRequest& operator=(StoreHeartBeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreHeartBeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreHeartBeatRequest* internal_default_instance() {
    return reinterpret_cast<const StoreHeartBeatRequest*>(
               &_StoreHeartBeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(StoreHeartBeatRequest& a, StoreHeartBeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreHeartBeatRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreHeartBeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StoreHeartBeatRequest* New() const final {
    return new StoreHeartBeatRequest();
  }

  StoreHeartBeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StoreHeartBeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreHeartBeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreHeartBeatRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreHeartBeatRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.StoreHeartBeatRequest";
  }
  protected:
  explicit StoreHeartBeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaInfosFieldNumber = 2,
    kLeaderRegionsFieldNumber = 3,
    kPeerInfosFieldNumber = 4,
    kDdlworkInfosFieldNumber = 7,
    kLearnerRegionsFieldNumber = 8,
    kBinlogTsInfosFieldNumber = 9,
    kInstanceInfoFieldNumber = 1,
    kNeedLeaderBalanceFieldNumber = 5,
    kNeedPeerBalanceFieldNumber = 6,
  };
  // repeated .baikaldb.pb.SchemaHeartBeat schema_infos = 2;
  int schema_infos_size() const;
  private:
  int _internal_schema_infos_size() const;
  public:
  void clear_schema_infos();
  ::baikaldb::pb::SchemaHeartBeat* mutable_schema_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaHeartBeat >*
      mutable_schema_infos();
  private:
  const ::baikaldb::pb::SchemaHeartBeat& _internal_schema_infos(int index) const;
  ::baikaldb::pb::SchemaHeartBeat* _internal_add_schema_infos();
  public:
  const ::baikaldb::pb::SchemaHeartBeat& schema_infos(int index) const;
  ::baikaldb::pb::SchemaHeartBeat* add_schema_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaHeartBeat >&
      schema_infos() const;

  // repeated .baikaldb.pb.LeaderHeartBeat leader_regions = 3;
  int leader_regions_size() const;
  private:
  int _internal_leader_regions_size() const;
  public:
  void clear_leader_regions();
  ::baikaldb::pb::LeaderHeartBeat* mutable_leader_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::LeaderHeartBeat >*
      mutable_leader_regions();
  private:
  const ::baikaldb::pb::LeaderHeartBeat& _internal_leader_regions(int index) const;
  ::baikaldb::pb::LeaderHeartBeat* _internal_add_leader_regions();
  public:
  const ::baikaldb::pb::LeaderHeartBeat& leader_regions(int index) const;
  ::baikaldb::pb::LeaderHeartBeat* add_leader_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::LeaderHeartBeat >&
      leader_regions() const;

  // repeated .baikaldb.pb.PeerHeartBeat peer_infos = 4;
  int peer_infos_size() const;
  private:
  int _internal_peer_infos_size() const;
  public:
  void clear_peer_infos();
  ::baikaldb::pb::PeerHeartBeat* mutable_peer_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerHeartBeat >*
      mutable_peer_infos();
  private:
  const ::baikaldb::pb::PeerHeartBeat& _internal_peer_infos(int index) const;
  ::baikaldb::pb::PeerHeartBeat* _internal_add_peer_infos();
  public:
  const ::baikaldb::pb::PeerHeartBeat& peer_infos(int index) const;
  ::baikaldb::pb::PeerHeartBeat* add_peer_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerHeartBeat >&
      peer_infos() const;

  // repeated .baikaldb.pb.DdlWorkInfoHeartBeat ddlwork_infos = 7;
  int ddlwork_infos_size() const;
  private:
  int _internal_ddlwork_infos_size() const;
  public:
  void clear_ddlwork_infos();
  ::baikaldb::pb::DdlWorkInfoHeartBeat* mutable_ddlwork_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfoHeartBeat >*
      mutable_ddlwork_infos();
  private:
  const ::baikaldb::pb::DdlWorkInfoHeartBeat& _internal_ddlwork_infos(int index) const;
  ::baikaldb::pb::DdlWorkInfoHeartBeat* _internal_add_ddlwork_infos();
  public:
  const ::baikaldb::pb::DdlWorkInfoHeartBeat& ddlwork_infos(int index) const;
  ::baikaldb::pb::DdlWorkInfoHeartBeat* add_ddlwork_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfoHeartBeat >&
      ddlwork_infos() const;

  // repeated .baikaldb.pb.LearnerHeartBeat learner_regions = 8;
  int learner_regions_size() const;
  private:
  int _internal_learner_regions_size() const;
  public:
  void clear_learner_regions();
  ::baikaldb::pb::LearnerHeartBeat* mutable_learner_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::LearnerHeartBeat >*
      mutable_learner_regions();
  private:
  const ::baikaldb::pb::LearnerHeartBeat& _internal_learner_regions(int index) const;
  ::baikaldb::pb::LearnerHeartBeat* _internal_add_learner_regions();
  public:
  const ::baikaldb::pb::LearnerHeartBeat& learner_regions(int index) const;
  ::baikaldb::pb::LearnerHeartBeat* add_learner_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::LearnerHeartBeat >&
      learner_regions() const;

  // repeated .baikaldb.pb.BinlogPeerState binlog_ts_infos = 9;
  int binlog_ts_infos_size() const;
  private:
  int _internal_binlog_ts_infos_size() const;
  public:
  void clear_binlog_ts_infos();
  ::baikaldb::pb::BinlogPeerState* mutable_binlog_ts_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogPeerState >*
      mutable_binlog_ts_infos();
  private:
  const ::baikaldb::pb::BinlogPeerState& _internal_binlog_ts_infos(int index) const;
  ::baikaldb::pb::BinlogPeerState* _internal_add_binlog_ts_infos();
  public:
  const ::baikaldb::pb::BinlogPeerState& binlog_ts_infos(int index) const;
  ::baikaldb::pb::BinlogPeerState* add_binlog_ts_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogPeerState >&
      binlog_ts_infos() const;

  // required .baikaldb.pb.InstanceInfo instance_info = 1;
  bool has_instance_info() const;
  private:
  bool _internal_has_instance_info() const;
  public:
  void clear_instance_info();
  const ::baikaldb::pb::InstanceInfo& instance_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::InstanceInfo* release_instance_info();
  ::baikaldb::pb::InstanceInfo* mutable_instance_info();
  void set_allocated_instance_info(::baikaldb::pb::InstanceInfo* instance_info);
  private:
  const ::baikaldb::pb::InstanceInfo& _internal_instance_info() const;
  ::baikaldb::pb::InstanceInfo* _internal_mutable_instance_info();
  public:
  void unsafe_arena_set_allocated_instance_info(
      ::baikaldb::pb::InstanceInfo* instance_info);
  ::baikaldb::pb::InstanceInfo* unsafe_arena_release_instance_info();

  // optional bool need_leader_balance = 5;
  bool has_need_leader_balance() const;
  private:
  bool _internal_has_need_leader_balance() const;
  public:
  void clear_need_leader_balance();
  bool need_leader_balance() const;
  void set_need_leader_balance(bool value);
  private:
  bool _internal_need_leader_balance() const;
  void _internal_set_need_leader_balance(bool value);
  public:

  // optional bool need_peer_balance = 6;
  bool has_need_peer_balance() const;
  private:
  bool _internal_has_need_peer_balance() const;
  public:
  void clear_need_peer_balance();
  bool need_peer_balance() const;
  void set_need_peer_balance(bool value);
  private:
  bool _internal_need_peer_balance() const;
  void _internal_set_need_peer_balance(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.StoreHeartBeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaHeartBeat > schema_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::LeaderHeartBeat > leader_regions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerHeartBeat > peer_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfoHeartBeat > ddlwork_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::LearnerHeartBeat > learner_regions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogPeerState > binlog_ts_infos_;
  ::baikaldb::pb::InstanceInfo* instance_info_;
  bool need_leader_balance_;
  bool need_peer_balance_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class StoreHeartBeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.StoreHeartBeatResponse) */ {
 public:
  inline StoreHeartBeatResponse() : StoreHeartBeatResponse(nullptr) {}
  ~StoreHeartBeatResponse() override;
  explicit constexpr StoreHeartBeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreHeartBeatResponse(const StoreHeartBeatResponse& from);
  StoreHeartBeatResponse(StoreHeartBeatResponse&& from) noexcept
    : StoreHeartBeatResponse() {
    *this = ::std::move(from);
  }

  inline StoreHeartBeatResponse& operator=(const StoreHeartBeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreHeartBeatResponse& operator=(StoreHeartBeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreHeartBeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreHeartBeatResponse* internal_default_instance() {
    return reinterpret_cast<const StoreHeartBeatResponse*>(
               &_StoreHeartBeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(StoreHeartBeatResponse& a, StoreHeartBeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreHeartBeatResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreHeartBeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StoreHeartBeatResponse* New() const final {
    return new StoreHeartBeatResponse();
  }

  StoreHeartBeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StoreHeartBeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreHeartBeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreHeartBeatResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreHeartBeatResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.StoreHeartBeatResponse";
  }
  protected:
  explicit StoreHeartBeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaChangeInfoFieldNumber = 3,
    kDeleteRegionIdsFieldNumber = 4,
    kAddPeersFieldNumber = 5,
    kTransLeaderFieldNumber = 7,
    kTransLeaderTableIdFieldNumber = 8,
    kTransLeaderCountFieldNumber = 9,
    kDdlworkInfosFieldNumber = 10,
    kInstanceParamsFieldNumber = 11,
    kErrmsgFieldNumber = 2,
    kLeaderFieldNumber = 6,
    kErrcodeFieldNumber = 1,
    kNeedReportFieldNumber = 12,
  };
  // repeated .baikaldb.pb.SchemaInfo schema_change_info = 3;
  int schema_change_info_size() const;
  private:
  int _internal_schema_change_info_size() const;
  public:
  void clear_schema_change_info();
  ::baikaldb::pb::SchemaInfo* mutable_schema_change_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaInfo >*
      mutable_schema_change_info();
  private:
  const ::baikaldb::pb::SchemaInfo& _internal_schema_change_info(int index) const;
  ::baikaldb::pb::SchemaInfo* _internal_add_schema_change_info();
  public:
  const ::baikaldb::pb::SchemaInfo& schema_change_info(int index) const;
  ::baikaldb::pb::SchemaInfo* add_schema_change_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaInfo >&
      schema_change_info() const;

  // repeated int64 delete_region_ids = 4;
  int delete_region_ids_size() const;
  private:
  int _internal_delete_region_ids_size() const;
  public:
  void clear_delete_region_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_delete_region_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_delete_region_ids() const;
  void _internal_add_delete_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_delete_region_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 delete_region_ids(int index) const;
  void set_delete_region_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_delete_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      delete_region_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_delete_region_ids();

  // repeated .baikaldb.pb.AddPeer add_peers = 5;
  int add_peers_size() const;
  private:
  int _internal_add_peers_size() const;
  public:
  void clear_add_peers();
  ::baikaldb::pb::AddPeer* mutable_add_peers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::AddPeer >*
      mutable_add_peers();
  private:
  const ::baikaldb::pb::AddPeer& _internal_add_peers(int index) const;
  ::baikaldb::pb::AddPeer* _internal_add_add_peers();
  public:
  const ::baikaldb::pb::AddPeer& add_peers(int index) const;
  ::baikaldb::pb::AddPeer* add_add_peers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::AddPeer >&
      add_peers() const;

  // repeated .baikaldb.pb.TransLeaderRequest trans_leader = 7;
  int trans_leader_size() const;
  private:
  int _internal_trans_leader_size() const;
  public:
  void clear_trans_leader();
  ::baikaldb::pb::TransLeaderRequest* mutable_trans_leader(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TransLeaderRequest >*
      mutable_trans_leader();
  private:
  const ::baikaldb::pb::TransLeaderRequest& _internal_trans_leader(int index) const;
  ::baikaldb::pb::TransLeaderRequest* _internal_add_trans_leader();
  public:
  const ::baikaldb::pb::TransLeaderRequest& trans_leader(int index) const;
  ::baikaldb::pb::TransLeaderRequest* add_trans_leader();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TransLeaderRequest >&
      trans_leader() const;

  // repeated int64 trans_leader_table_id = 8;
  int trans_leader_table_id_size() const;
  private:
  int _internal_trans_leader_table_id_size() const;
  public:
  void clear_trans_leader_table_id();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_trans_leader_table_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_trans_leader_table_id() const;
  void _internal_add_trans_leader_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_trans_leader_table_id();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 trans_leader_table_id(int index) const;
  void set_trans_leader_table_id(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_trans_leader_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      trans_leader_table_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_trans_leader_table_id();

  // repeated int64 trans_leader_count = 9;
  int trans_leader_count_size() const;
  private:
  int _internal_trans_leader_count_size() const;
  public:
  void clear_trans_leader_count();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_trans_leader_count(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_trans_leader_count() const;
  void _internal_add_trans_leader_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_trans_leader_count();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 trans_leader_count(int index) const;
  void set_trans_leader_count(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_trans_leader_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      trans_leader_count() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_trans_leader_count();

  // repeated .baikaldb.pb.DdlWorkInfo ddlwork_infos = 10;
  int ddlwork_infos_size() const;
  private:
  int _internal_ddlwork_infos_size() const;
  public:
  void clear_ddlwork_infos();
  ::baikaldb::pb::DdlWorkInfo* mutable_ddlwork_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >*
      mutable_ddlwork_infos();
  private:
  const ::baikaldb::pb::DdlWorkInfo& _internal_ddlwork_infos(int index) const;
  ::baikaldb::pb::DdlWorkInfo* _internal_add_ddlwork_infos();
  public:
  const ::baikaldb::pb::DdlWorkInfo& ddlwork_infos(int index) const;
  ::baikaldb::pb::DdlWorkInfo* add_ddlwork_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >&
      ddlwork_infos() const;

  // repeated .baikaldb.pb.InstanceParam instance_params = 11;
  int instance_params_size() const;
  private:
  int _internal_instance_params_size() const;
  public:
  void clear_instance_params();
  ::baikaldb::pb::InstanceParam* mutable_instance_params(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam >*
      mutable_instance_params();
  private:
  const ::baikaldb::pb::InstanceParam& _internal_instance_params(int index) const;
  ::baikaldb::pb::InstanceParam* _internal_add_instance_params();
  public:
  const ::baikaldb::pb::InstanceParam& instance_params(int index) const;
  ::baikaldb::pb::InstanceParam* add_instance_params();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam >&
      instance_params() const;

  // optional string errmsg = 2;
  bool has_errmsg() const;
  private:
  bool _internal_has_errmsg() const;
  public:
  void clear_errmsg();
  const std::string& errmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errmsg();
  PROTOBUF_MUST_USE_RESULT std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // optional string leader = 6;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // required .baikaldb.pb.ErrCode errcode = 1;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::ErrCode errcode() const;
  void set_errcode(::baikaldb::pb::ErrCode value);
  private:
  ::baikaldb::pb::ErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::ErrCode value);
  public:

  // optional bool need_report = 12;
  bool has_need_report() const;
  private:
  bool _internal_has_need_report() const;
  public:
  void clear_need_report();
  bool need_report() const;
  void set_need_report(bool value);
  private:
  bool _internal_need_report() const;
  void _internal_set_need_report(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.StoreHeartBeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaInfo > schema_change_info_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > delete_region_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::AddPeer > add_peers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TransLeaderRequest > trans_leader_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > trans_leader_table_id_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > trans_leader_count_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo > ddlwork_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam > instance_params_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  int errcode_;
  bool need_report_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RegionHeartBeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RegionHeartBeat) */ {
 public:
  inline RegionHeartBeat() : RegionHeartBeat(nullptr) {}
  ~RegionHeartBeat() override;
  explicit constexpr RegionHeartBeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionHeartBeat(const RegionHeartBeat& from);
  RegionHeartBeat(RegionHeartBeat&& from) noexcept
    : RegionHeartBeat() {
    *this = ::std::move(from);
  }

  inline RegionHeartBeat& operator=(const RegionHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionHeartBeat& operator=(RegionHeartBeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionHeartBeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionHeartBeat* internal_default_instance() {
    return reinterpret_cast<const RegionHeartBeat*>(
               &_RegionHeartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(RegionHeartBeat& a, RegionHeartBeat& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionHeartBeat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionHeartBeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionHeartBeat* New() const final {
    return new RegionHeartBeat();
  }

  RegionHeartBeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionHeartBeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionHeartBeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegionHeartBeat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionHeartBeat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RegionHeartBeat";
  }
  protected:
  explicit RegionHeartBeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaderFieldNumber = 4,
    kRegionIdFieldNumber = 1,
    kVersionFieldNumber = 2,
    kConfVersionFieldNumber = 3,
    kNumTableLinesFieldNumber = 6,
    kUsedSizeFieldNumber = 7,
    kNeedUpdateFieldNumber = 5,
  };
  // optional string leader = 4;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // required int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 conf_version = 3;
  bool has_conf_version() const;
  private:
  bool _internal_has_conf_version() const;
  public:
  void clear_conf_version();
  ::PROTOBUF_NAMESPACE_ID::int64 conf_version() const;
  void set_conf_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_conf_version() const;
  void _internal_set_conf_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 num_table_lines = 6;
  bool has_num_table_lines() const;
  private:
  bool _internal_has_num_table_lines() const;
  public:
  void clear_num_table_lines();
  ::PROTOBUF_NAMESPACE_ID::int64 num_table_lines() const;
  void set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_num_table_lines() const;
  void _internal_set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 used_size = 7;
  bool has_used_size() const;
  private:
  bool _internal_has_used_size() const;
  public:
  void clear_used_size();
  ::PROTOBUF_NAMESPACE_ID::int64 used_size() const;
  void set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_used_size() const;
  void _internal_set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool need_update = 5;
  bool has_need_update() const;
  private:
  bool _internal_has_need_update() const;
  public:
  void clear_need_update();
  bool need_update() const;
  void set_need_update(bool value);
  private:
  bool _internal_need_update() const;
  void _internal_set_need_update(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RegionHeartBeat)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  ::PROTOBUF_NAMESPACE_ID::int64 conf_version_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_table_lines_;
  ::PROTOBUF_NAMESPACE_ID::int64 used_size_;
  bool need_update_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BaikalSchemaHeartBeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BaikalSchemaHeartBeat) */ {
 public:
  inline BaikalSchemaHeartBeat() : BaikalSchemaHeartBeat(nullptr) {}
  ~BaikalSchemaHeartBeat() override;
  explicit constexpr BaikalSchemaHeartBeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaikalSchemaHeartBeat(const BaikalSchemaHeartBeat& from);
  BaikalSchemaHeartBeat(BaikalSchemaHeartBeat&& from) noexcept
    : BaikalSchemaHeartBeat() {
    *this = ::std::move(from);
  }

  inline BaikalSchemaHeartBeat& operator=(const BaikalSchemaHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaikalSchemaHeartBeat& operator=(BaikalSchemaHeartBeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaikalSchemaHeartBeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaikalSchemaHeartBeat* internal_default_instance() {
    return reinterpret_cast<const BaikalSchemaHeartBeat*>(
               &_BaikalSchemaHeartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(BaikalSchemaHeartBeat& a, BaikalSchemaHeartBeat& b) {
    a.Swap(&b);
  }
  inline void Swap(BaikalSchemaHeartBeat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaikalSchemaHeartBeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BaikalSchemaHeartBeat* New() const final {
    return new BaikalSchemaHeartBeat();
  }

  BaikalSchemaHeartBeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BaikalSchemaHeartBeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaikalSchemaHeartBeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BaikalSchemaHeartBeat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaikalSchemaHeartBeat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BaikalSchemaHeartBeat";
  }
  protected:
  explicit BaikalSchemaHeartBeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableIdFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // required int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BaikalSchemaHeartBeat)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BaikalHeartBeatTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BaikalHeartBeatTable) */ {
 public:
  inline BaikalHeartBeatTable() : BaikalHeartBeatTable(nullptr) {}
  ~BaikalHeartBeatTable() override;
  explicit constexpr BaikalHeartBeatTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaikalHeartBeatTable(const BaikalHeartBeatTable& from);
  BaikalHeartBeatTable(BaikalHeartBeatTable&& from) noexcept
    : BaikalHeartBeatTable() {
    *this = ::std::move(from);
  }

  inline BaikalHeartBeatTable& operator=(const BaikalHeartBeatTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaikalHeartBeatTable& operator=(BaikalHeartBeatTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaikalHeartBeatTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaikalHeartBeatTable* internal_default_instance() {
    return reinterpret_cast<const BaikalHeartBeatTable*>(
               &_BaikalHeartBeatTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(BaikalHeartBeatTable& a, BaikalHeartBeatTable& b) {
    a.Swap(&b);
  }
  inline void Swap(BaikalHeartBeatTable* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaikalHeartBeatTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BaikalHeartBeatTable* New() const final {
    return new BaikalHeartBeatTable();
  }

  BaikalHeartBeatTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BaikalHeartBeatTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaikalHeartBeatTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BaikalHeartBeatTable& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaikalHeartBeatTable* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BaikalHeartBeatTable";
  }
  protected:
  explicit BaikalHeartBeatTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionIdsFieldNumber = 6,
    kNamespaceNameFieldNumber = 1,
    kDatabaseFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kTableIdFieldNumber = 4,
    kIsNewFieldNumber = 5,
  };
  // repeated int64 partition_ids = 6;
  int partition_ids_size() const;
  private:
  int _internal_partition_ids_size() const;
  public:
  void clear_partition_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_partition_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_partition_ids() const;
  void _internal_add_partition_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_partition_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 partition_ids(int index) const;
  void set_partition_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_partition_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      partition_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_partition_ids();

  // required string namespace_name = 1;
  bool has_namespace_name() const;
  private:
  bool _internal_has_namespace_name() const;
  public:
  void clear_namespace_name();
  const std::string& namespace_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_namespace_name();
  void set_allocated_namespace_name(std::string* namespace_name);
  private:
  const std::string& _internal_namespace_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_name(const std::string& value);
  std::string* _internal_mutable_namespace_name();
  public:

  // required string database = 2;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_MUST_USE_RESULT std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // required string table_name = 3;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional int64 table_id = 4;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool is_new = 5;
  bool has_is_new() const;
  private:
  bool _internal_has_is_new() const;
  public:
  void clear_is_new();
  bool is_new() const;
  void set_is_new(bool value);
  private:
  bool _internal_is_new() const;
  void _internal_set_is_new(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BaikalHeartBeatTable)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > partition_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  bool is_new_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BaikalHeartBeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BaikalHeartBeatRequest) */ {
 public:
  inline BaikalHeartBeatRequest() : BaikalHeartBeatRequest(nullptr) {}
  ~BaikalHeartBeatRequest() override;
  explicit constexpr BaikalHeartBeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaikalHeartBeatRequest(const BaikalHeartBeatRequest& from);
  BaikalHeartBeatRequest(BaikalHeartBeatRequest&& from) noexcept
    : BaikalHeartBeatRequest() {
    *this = ::std::move(from);
  }

  inline BaikalHeartBeatRequest& operator=(const BaikalHeartBeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaikalHeartBeatRequest& operator=(BaikalHeartBeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaikalHeartBeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaikalHeartBeatRequest* internal_default_instance() {
    return reinterpret_cast<const BaikalHeartBeatRequest*>(
               &_BaikalHeartBeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(BaikalHeartBeatRequest& a, BaikalHeartBeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BaikalHeartBeatRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaikalHeartBeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BaikalHeartBeatRequest* New() const final {
    return new BaikalHeartBeatRequest();
  }

  BaikalHeartBeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BaikalHeartBeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaikalHeartBeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BaikalHeartBeatRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaikalHeartBeatRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BaikalHeartBeatRequest";
  }
  protected:
  explicit BaikalHeartBeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaInfosFieldNumber = 1,
    kRegionDdlWorksFieldNumber = 4,
    kDdlWorksFieldNumber = 5,
    kInfoAffectFieldNumber = 8,
    kHeartbeatTablesFieldNumber = 11,
    kPhysicalRoomFieldNumber = 7,
    kBaikalStatusFieldNumber = 13,
    kLastUpdatedIndexFieldNumber = 2,
    kCanDoDdlworkFieldNumber = 6,
    kNeedHeartbeatTableFieldNumber = 9,
    kNeedBinlogHeartbeatFieldNumber = 10,
    kNeedGlobalIndexHeartbeatFieldNumber = 12,
  };
  // repeated .baikaldb.pb.BaikalSchemaHeartBeat schema_infos = 1;
  int schema_infos_size() const;
  private:
  int _internal_schema_infos_size() const;
  public:
  void clear_schema_infos();
  ::baikaldb::pb::BaikalSchemaHeartBeat* mutable_schema_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalSchemaHeartBeat >*
      mutable_schema_infos();
  private:
  const ::baikaldb::pb::BaikalSchemaHeartBeat& _internal_schema_infos(int index) const;
  ::baikaldb::pb::BaikalSchemaHeartBeat* _internal_add_schema_infos();
  public:
  const ::baikaldb::pb::BaikalSchemaHeartBeat& schema_infos(int index) const;
  ::baikaldb::pb::BaikalSchemaHeartBeat* add_schema_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalSchemaHeartBeat >&
      schema_infos() const;

  // repeated .baikaldb.pb.RegionDdlWork region_ddl_works = 4;
  int region_ddl_works_size() const;
  private:
  int _internal_region_ddl_works_size() const;
  public:
  void clear_region_ddl_works();
  ::baikaldb::pb::RegionDdlWork* mutable_region_ddl_works(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionDdlWork >*
      mutable_region_ddl_works();
  private:
  const ::baikaldb::pb::RegionDdlWork& _internal_region_ddl_works(int index) const;
  ::baikaldb::pb::RegionDdlWork* _internal_add_region_ddl_works();
  public:
  const ::baikaldb::pb::RegionDdlWork& region_ddl_works(int index) const;
  ::baikaldb::pb::RegionDdlWork* add_region_ddl_works();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionDdlWork >&
      region_ddl_works() const;

  // repeated .baikaldb.pb.DdlWorkInfo ddl_works = 5;
  int ddl_works_size() const;
  private:
  int _internal_ddl_works_size() const;
  public:
  void clear_ddl_works();
  ::baikaldb::pb::DdlWorkInfo* mutable_ddl_works(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >*
      mutable_ddl_works();
  private:
  const ::baikaldb::pb::DdlWorkInfo& _internal_ddl_works(int index) const;
  ::baikaldb::pb::DdlWorkInfo* _internal_add_ddl_works();
  public:
  const ::baikaldb::pb::DdlWorkInfo& ddl_works(int index) const;
  ::baikaldb::pb::DdlWorkInfo* add_ddl_works();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >&
      ddl_works() const;

  // repeated .baikaldb.pb.VirtualIndexInfluence info_affect = 8;
  int info_affect_size() const;
  private:
  int _internal_info_affect_size() const;
  public:
  void clear_info_affect();
  ::baikaldb::pb::VirtualIndexInfluence* mutable_info_affect(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::VirtualIndexInfluence >*
      mutable_info_affect();
  private:
  const ::baikaldb::pb::VirtualIndexInfluence& _internal_info_affect(int index) const;
  ::baikaldb::pb::VirtualIndexInfluence* _internal_add_info_affect();
  public:
  const ::baikaldb::pb::VirtualIndexInfluence& info_affect(int index) const;
  ::baikaldb::pb::VirtualIndexInfluence* add_info_affect();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::VirtualIndexInfluence >&
      info_affect() const;

  // repeated .baikaldb.pb.BaikalHeartBeatTable heartbeat_tables = 11;
  int heartbeat_tables_size() const;
  private:
  int _internal_heartbeat_tables_size() const;
  public:
  void clear_heartbeat_tables();
  ::baikaldb::pb::BaikalHeartBeatTable* mutable_heartbeat_tables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalHeartBeatTable >*
      mutable_heartbeat_tables();
  private:
  const ::baikaldb::pb::BaikalHeartBeatTable& _internal_heartbeat_tables(int index) const;
  ::baikaldb::pb::BaikalHeartBeatTable* _internal_add_heartbeat_tables();
  public:
  const ::baikaldb::pb::BaikalHeartBeatTable& heartbeat_tables(int index) const;
  ::baikaldb::pb::BaikalHeartBeatTable* add_heartbeat_tables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalHeartBeatTable >&
      heartbeat_tables() const;

  // optional string physical_room = 7;
  bool has_physical_room() const;
  private:
  bool _internal_has_physical_room() const;
  public:
  void clear_physical_room();
  const std::string& physical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_physical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_physical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_physical_room();
  void set_allocated_physical_room(std::string* physical_room);
  private:
  const std::string& _internal_physical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_physical_room(const std::string& value);
  std::string* _internal_mutable_physical_room();
  public:

  // optional .baikaldb.pb.BaikalStatus baikal_status = 13;
  bool has_baikal_status() const;
  private:
  bool _internal_has_baikal_status() const;
  public:
  void clear_baikal_status();
  const ::baikaldb::pb::BaikalStatus& baikal_status() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::BaikalStatus* release_baikal_status();
  ::baikaldb::pb::BaikalStatus* mutable_baikal_status();
  void set_allocated_baikal_status(::baikaldb::pb::BaikalStatus* baikal_status);
  private:
  const ::baikaldb::pb::BaikalStatus& _internal_baikal_status() const;
  ::baikaldb::pb::BaikalStatus* _internal_mutable_baikal_status();
  public:
  void unsafe_arena_set_allocated_baikal_status(
      ::baikaldb::pb::BaikalStatus* baikal_status);
  ::baikaldb::pb::BaikalStatus* unsafe_arena_release_baikal_status();

  // optional int64 last_updated_index = 2;
  bool has_last_updated_index() const;
  private:
  bool _internal_has_last_updated_index() const;
  public:
  void clear_last_updated_index();
  ::PROTOBUF_NAMESPACE_ID::int64 last_updated_index() const;
  void set_last_updated_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_last_updated_index() const;
  void _internal_set_last_updated_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool can_do_ddlwork = 6;
  bool has_can_do_ddlwork() const;
  private:
  bool _internal_has_can_do_ddlwork() const;
  public:
  void clear_can_do_ddlwork();
  bool can_do_ddlwork() const;
  void set_can_do_ddlwork(bool value);
  private:
  bool _internal_can_do_ddlwork() const;
  void _internal_set_can_do_ddlwork(bool value);
  public:

  // optional bool need_heartbeat_table = 9;
  bool has_need_heartbeat_table() const;
  private:
  bool _internal_has_need_heartbeat_table() const;
  public:
  void clear_need_heartbeat_table();
  bool need_heartbeat_table() const;
  void set_need_heartbeat_table(bool value);
  private:
  bool _internal_need_heartbeat_table() const;
  void _internal_set_need_heartbeat_table(bool value);
  public:

  // optional bool need_binlog_heartbeat = 10;
  bool has_need_binlog_heartbeat() const;
  private:
  bool _internal_has_need_binlog_heartbeat() const;
  public:
  void clear_need_binlog_heartbeat();
  bool need_binlog_heartbeat() const;
  void set_need_binlog_heartbeat(bool value);
  private:
  bool _internal_need_binlog_heartbeat() const;
  void _internal_set_need_binlog_heartbeat(bool value);
  public:

  // optional bool need_global_index_heartbeat = 12;
  bool has_need_global_index_heartbeat() const;
  private:
  bool _internal_has_need_global_index_heartbeat() const;
  public:
  void clear_need_global_index_heartbeat();
  bool need_global_index_heartbeat() const;
  void set_need_global_index_heartbeat(bool value);
  private:
  bool _internal_need_global_index_heartbeat() const;
  void _internal_set_need_global_index_heartbeat(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BaikalHeartBeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalSchemaHeartBeat > schema_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionDdlWork > region_ddl_works_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo > ddl_works_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::VirtualIndexInfluence > info_affect_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalHeartBeatTable > heartbeat_tables_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr physical_room_;
  ::baikaldb::pb::BaikalStatus* baikal_status_;
  ::PROTOBUF_NAMESPACE_ID::int64 last_updated_index_;
  bool can_do_ddlwork_;
  bool need_heartbeat_table_;
  bool need_binlog_heartbeat_;
  bool need_global_index_heartbeat_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BaikalOtherHeartBeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BaikalOtherHeartBeat) */ {
 public:
  inline BaikalOtherHeartBeat() : BaikalOtherHeartBeat(nullptr) {}
  ~BaikalOtherHeartBeat() override;
  explicit constexpr BaikalOtherHeartBeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaikalOtherHeartBeat(const BaikalOtherHeartBeat& from);
  BaikalOtherHeartBeat(BaikalOtherHeartBeat&& from) noexcept
    : BaikalOtherHeartBeat() {
    *this = ::std::move(from);
  }

  inline BaikalOtherHeartBeat& operator=(const BaikalOtherHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaikalOtherHeartBeat& operator=(BaikalOtherHeartBeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaikalOtherHeartBeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaikalOtherHeartBeat* internal_default_instance() {
    return reinterpret_cast<const BaikalOtherHeartBeat*>(
               &_BaikalOtherHeartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(BaikalOtherHeartBeat& a, BaikalOtherHeartBeat& b) {
    a.Swap(&b);
  }
  inline void Swap(BaikalOtherHeartBeat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaikalOtherHeartBeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BaikalOtherHeartBeat* New() const final {
    return new BaikalOtherHeartBeat();
  }

  BaikalOtherHeartBeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BaikalOtherHeartBeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaikalOtherHeartBeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BaikalOtherHeartBeat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaikalOtherHeartBeat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BaikalOtherHeartBeat";
  }
  protected:
  explicit BaikalOtherHeartBeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableIdFieldNumber = 1,
    kStatisVersionFieldNumber = 2,
  };
  // required int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 statis_version = 2;
  bool has_statis_version() const;
  private:
  bool _internal_has_statis_version() const;
  public:
  void clear_statis_version();
  ::PROTOBUF_NAMESPACE_ID::int64 statis_version() const;
  void set_statis_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_statis_version() const;
  void _internal_set_statis_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BaikalOtherHeartBeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 statis_version_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BaikalOtherHeartBeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BaikalOtherHeartBeatRequest) */ {
 public:
  inline BaikalOtherHeartBeatRequest() : BaikalOtherHeartBeatRequest(nullptr) {}
  ~BaikalOtherHeartBeatRequest() override;
  explicit constexpr BaikalOtherHeartBeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaikalOtherHeartBeatRequest(const BaikalOtherHeartBeatRequest& from);
  BaikalOtherHeartBeatRequest(BaikalOtherHeartBeatRequest&& from) noexcept
    : BaikalOtherHeartBeatRequest() {
    *this = ::std::move(from);
  }

  inline BaikalOtherHeartBeatRequest& operator=(const BaikalOtherHeartBeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaikalOtherHeartBeatRequest& operator=(BaikalOtherHeartBeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaikalOtherHeartBeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaikalOtherHeartBeatRequest* internal_default_instance() {
    return reinterpret_cast<const BaikalOtherHeartBeatRequest*>(
               &_BaikalOtherHeartBeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(BaikalOtherHeartBeatRequest& a, BaikalOtherHeartBeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BaikalOtherHeartBeatRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaikalOtherHeartBeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BaikalOtherHeartBeatRequest* New() const final {
    return new BaikalOtherHeartBeatRequest();
  }

  BaikalOtherHeartBeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BaikalOtherHeartBeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaikalOtherHeartBeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BaikalOtherHeartBeatRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaikalOtherHeartBeatRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BaikalOtherHeartBeatRequest";
  }
  protected:
  explicit BaikalOtherHeartBeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaInfosFieldNumber = 1,
    kBaikaldbResourceTagFieldNumber = 2,
  };
  // repeated .baikaldb.pb.BaikalOtherHeartBeat schema_infos = 1;
  int schema_infos_size() const;
  private:
  int _internal_schema_infos_size() const;
  public:
  void clear_schema_infos();
  ::baikaldb::pb::BaikalOtherHeartBeat* mutable_schema_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalOtherHeartBeat >*
      mutable_schema_infos();
  private:
  const ::baikaldb::pb::BaikalOtherHeartBeat& _internal_schema_infos(int index) const;
  ::baikaldb::pb::BaikalOtherHeartBeat* _internal_add_schema_infos();
  public:
  const ::baikaldb::pb::BaikalOtherHeartBeat& schema_infos(int index) const;
  ::baikaldb::pb::BaikalOtherHeartBeat* add_schema_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalOtherHeartBeat >&
      schema_infos() const;

  // optional string baikaldb_resource_tag = 2;
  bool has_baikaldb_resource_tag() const;
  private:
  bool _internal_has_baikaldb_resource_tag() const;
  public:
  void clear_baikaldb_resource_tag();
  const std::string& baikaldb_resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_baikaldb_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_baikaldb_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_baikaldb_resource_tag();
  void set_allocated_baikaldb_resource_tag(std::string* baikaldb_resource_tag);
  private:
  const std::string& _internal_baikaldb_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_baikaldb_resource_tag(const std::string& value);
  std::string* _internal_mutable_baikaldb_resource_tag();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BaikalOtherHeartBeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalOtherHeartBeat > schema_infos_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr baikaldb_resource_tag_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BaikalOtherHeartBeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BaikalOtherHeartBeatResponse) */ {
 public:
  inline BaikalOtherHeartBeatResponse() : BaikalOtherHeartBeatResponse(nullptr) {}
  ~BaikalOtherHeartBeatResponse() override;
  explicit constexpr BaikalOtherHeartBeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaikalOtherHeartBeatResponse(const BaikalOtherHeartBeatResponse& from);
  BaikalOtherHeartBeatResponse(BaikalOtherHeartBeatResponse&& from) noexcept
    : BaikalOtherHeartBeatResponse() {
    *this = ::std::move(from);
  }

  inline BaikalOtherHeartBeatResponse& operator=(const BaikalOtherHeartBeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaikalOtherHeartBeatResponse& operator=(BaikalOtherHeartBeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaikalOtherHeartBeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaikalOtherHeartBeatResponse* internal_default_instance() {
    return reinterpret_cast<const BaikalOtherHeartBeatResponse*>(
               &_BaikalOtherHeartBeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(BaikalOtherHeartBeatResponse& a, BaikalOtherHeartBeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BaikalOtherHeartBeatResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaikalOtherHeartBeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BaikalOtherHeartBeatResponse* New() const final {
    return new BaikalOtherHeartBeatResponse();
  }

  BaikalOtherHeartBeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BaikalOtherHeartBeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaikalOtherHeartBeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BaikalOtherHeartBeatResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaikalOtherHeartBeatResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BaikalOtherHeartBeatResponse";
  }
  protected:
  explicit BaikalOtherHeartBeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatisticsFieldNumber = 4,
    kInstanceParamFieldNumber = 5,
    kErrmsgFieldNumber = 2,
    kLeaderFieldNumber = 3,
    kErrcodeFieldNumber = 1,
  };
  // repeated .baikaldb.pb.Statistics statistics = 4;
  int statistics_size() const;
  private:
  int _internal_statistics_size() const;
  public:
  void clear_statistics();
  ::baikaldb::pb::Statistics* mutable_statistics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Statistics >*
      mutable_statistics();
  private:
  const ::baikaldb::pb::Statistics& _internal_statistics(int index) const;
  ::baikaldb::pb::Statistics* _internal_add_statistics();
  public:
  const ::baikaldb::pb::Statistics& statistics(int index) const;
  ::baikaldb::pb::Statistics* add_statistics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Statistics >&
      statistics() const;

  // repeated .baikaldb.pb.InstanceParam instance_param = 5;
  int instance_param_size() const;
  private:
  int _internal_instance_param_size() const;
  public:
  void clear_instance_param();
  ::baikaldb::pb::InstanceParam* mutable_instance_param(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam >*
      mutable_instance_param();
  private:
  const ::baikaldb::pb::InstanceParam& _internal_instance_param(int index) const;
  ::baikaldb::pb::InstanceParam* _internal_add_instance_param();
  public:
  const ::baikaldb::pb::InstanceParam& instance_param(int index) const;
  ::baikaldb::pb::InstanceParam* add_instance_param();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam >&
      instance_param() const;

  // optional string errmsg = 2;
  bool has_errmsg() const;
  private:
  bool _internal_has_errmsg() const;
  public:
  void clear_errmsg();
  const std::string& errmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errmsg();
  PROTOBUF_MUST_USE_RESULT std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // optional string leader = 3;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // required .baikaldb.pb.ErrCode errcode = 1;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::ErrCode errcode() const;
  void set_errcode(::baikaldb::pb::ErrCode value);
  private:
  ::baikaldb::pb::ErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::ErrCode value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BaikalOtherHeartBeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Statistics > statistics_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam > instance_param_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  int errcode_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class IdcInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.IdcInfo) */ {
 public:
  inline IdcInfo() : IdcInfo(nullptr) {}
  ~IdcInfo() override;
  explicit constexpr IdcInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IdcInfo(const IdcInfo& from);
  IdcInfo(IdcInfo&& from) noexcept
    : IdcInfo() {
    *this = ::std::move(from);
  }

  inline IdcInfo& operator=(const IdcInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline IdcInfo& operator=(IdcInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IdcInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const IdcInfo* internal_default_instance() {
    return reinterpret_cast<const IdcInfo*>(
               &_IdcInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(IdcInfo& a, IdcInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(IdcInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IdcInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IdcInfo* New() const final {
    return new IdcInfo();
  }

  IdcInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IdcInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IdcInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IdcInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IdcInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.IdcInfo";
  }
  protected:
  explicit IdcInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicalPhysicalMapFieldNumber = 1,
    kInstanceInfosFieldNumber = 2,
  };
  // repeated .baikaldb.pb.PhysicalRoom logical_physical_map = 1;
  int logical_physical_map_size() const;
  private:
  int _internal_logical_physical_map_size() const;
  public:
  void clear_logical_physical_map();
  ::baikaldb::pb::PhysicalRoom* mutable_logical_physical_map(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PhysicalRoom >*
      mutable_logical_physical_map();
  private:
  const ::baikaldb::pb::PhysicalRoom& _internal_logical_physical_map(int index) const;
  ::baikaldb::pb::PhysicalRoom* _internal_add_logical_physical_map();
  public:
  const ::baikaldb::pb::PhysicalRoom& logical_physical_map(int index) const;
  ::baikaldb::pb::PhysicalRoom* add_logical_physical_map();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PhysicalRoom >&
      logical_physical_map() const;

  // repeated .baikaldb.pb.InstanceInfo instance_infos = 2;
  int instance_infos_size() const;
  private:
  int _internal_instance_infos_size() const;
  public:
  void clear_instance_infos();
  ::baikaldb::pb::InstanceInfo* mutable_instance_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceInfo >*
      mutable_instance_infos();
  private:
  const ::baikaldb::pb::InstanceInfo& _internal_instance_infos(int index) const;
  ::baikaldb::pb::InstanceInfo* _internal_add_instance_infos();
  public:
  const ::baikaldb::pb::InstanceInfo& instance_infos(int index) const;
  ::baikaldb::pb::InstanceInfo* add_instance_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceInfo >&
      instance_infos() const;

  // @@protoc_insertion_point(class_scope:baikaldb.pb.IdcInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PhysicalRoom > logical_physical_map_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceInfo > instance_infos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BaikalHeartBeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BaikalHeartBeatResponse) */ {
 public:
  inline BaikalHeartBeatResponse() : BaikalHeartBeatResponse(nullptr) {}
  ~BaikalHeartBeatResponse() override;
  explicit constexpr BaikalHeartBeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaikalHeartBeatResponse(const BaikalHeartBeatResponse& from);
  BaikalHeartBeatResponse(BaikalHeartBeatResponse&& from) noexcept
    : BaikalHeartBeatResponse() {
    *this = ::std::move(from);
  }

  inline BaikalHeartBeatResponse& operator=(const BaikalHeartBeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaikalHeartBeatResponse& operator=(BaikalHeartBeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaikalHeartBeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaikalHeartBeatResponse* internal_default_instance() {
    return reinterpret_cast<const BaikalHeartBeatResponse*>(
               &_BaikalHeartBeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(BaikalHeartBeatResponse& a, BaikalHeartBeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BaikalHeartBeatResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaikalHeartBeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BaikalHeartBeatResponse* New() const final {
    return new BaikalHeartBeatResponse();
  }

  BaikalHeartBeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BaikalHeartBeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaikalHeartBeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BaikalHeartBeatResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaikalHeartBeatResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BaikalHeartBeatResponse";
  }
  protected:
  explicit BaikalHeartBeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaChangeInfoFieldNumber = 4,
    kRegionChangeInfoFieldNumber = 5,
    kPrivilegeChangeInfoFieldNumber = 6,
    kDbInfoFieldNumber = 8,
    kStatisticsFieldNumber = 10,
    kRegionDdlWorksFieldNumber = 11,
    kDdlWorksFieldNumber = 12,
    kNsInfoFieldNumber = 13,
    kBaikalStatusFieldNumber = 14,
    kErrmsgFieldNumber = 2,
    kLeaderFieldNumber = 3,
    kIdcInfoFieldNumber = 7,
    kLastUpdatedIndexFieldNumber = 9,
    kErrcodeFieldNumber = 1,
  };
  // repeated .baikaldb.pb.SchemaInfo schema_change_info = 4;
  int schema_change_info_size() const;
  private:
  int _internal_schema_change_info_size() const;
  public:
  void clear_schema_change_info();
  ::baikaldb::pb::SchemaInfo* mutable_schema_change_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaInfo >*
      mutable_schema_change_info();
  private:
  const ::baikaldb::pb::SchemaInfo& _internal_schema_change_info(int index) const;
  ::baikaldb::pb::SchemaInfo* _internal_add_schema_change_info();
  public:
  const ::baikaldb::pb::SchemaInfo& schema_change_info(int index) const;
  ::baikaldb::pb::SchemaInfo* add_schema_change_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaInfo >&
      schema_change_info() const;

  // repeated .baikaldb.pb.RegionInfo region_change_info = 5;
  int region_change_info_size() const;
  private:
  int _internal_region_change_info_size() const;
  public:
  void clear_region_change_info();
  ::baikaldb::pb::RegionInfo* mutable_region_change_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >*
      mutable_region_change_info();
  private:
  const ::baikaldb::pb::RegionInfo& _internal_region_change_info(int index) const;
  ::baikaldb::pb::RegionInfo* _internal_add_region_change_info();
  public:
  const ::baikaldb::pb::RegionInfo& region_change_info(int index) const;
  ::baikaldb::pb::RegionInfo* add_region_change_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >&
      region_change_info() const;

  // repeated .baikaldb.pb.UserPrivilege privilege_change_info = 6;
  int privilege_change_info_size() const;
  private:
  int _internal_privilege_change_info_size() const;
  public:
  void clear_privilege_change_info();
  ::baikaldb::pb::UserPrivilege* mutable_privilege_change_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::UserPrivilege >*
      mutable_privilege_change_info();
  private:
  const ::baikaldb::pb::UserPrivilege& _internal_privilege_change_info(int index) const;
  ::baikaldb::pb::UserPrivilege* _internal_add_privilege_change_info();
  public:
  const ::baikaldb::pb::UserPrivilege& privilege_change_info(int index) const;
  ::baikaldb::pb::UserPrivilege* add_privilege_change_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::UserPrivilege >&
      privilege_change_info() const;

  // repeated .baikaldb.pb.DataBaseInfo db_info = 8;
  int db_info_size() const;
  private:
  int _internal_db_info_size() const;
  public:
  void clear_db_info();
  ::baikaldb::pb::DataBaseInfo* mutable_db_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DataBaseInfo >*
      mutable_db_info();
  private:
  const ::baikaldb::pb::DataBaseInfo& _internal_db_info(int index) const;
  ::baikaldb::pb::DataBaseInfo* _internal_add_db_info();
  public:
  const ::baikaldb::pb::DataBaseInfo& db_info(int index) const;
  ::baikaldb::pb::DataBaseInfo* add_db_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DataBaseInfo >&
      db_info() const;

  // repeated .baikaldb.pb.Statistics statistics = 10;
  int statistics_size() const;
  private:
  int _internal_statistics_size() const;
  public:
  void clear_statistics();
  ::baikaldb::pb::Statistics* mutable_statistics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Statistics >*
      mutable_statistics();
  private:
  const ::baikaldb::pb::Statistics& _internal_statistics(int index) const;
  ::baikaldb::pb::Statistics* _internal_add_statistics();
  public:
  const ::baikaldb::pb::Statistics& statistics(int index) const;
  ::baikaldb::pb::Statistics* add_statistics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Statistics >&
      statistics() const;

  // repeated .baikaldb.pb.RegionDdlWork region_ddl_works = 11;
  int region_ddl_works_size() const;
  private:
  int _internal_region_ddl_works_size() const;
  public:
  void clear_region_ddl_works();
  ::baikaldb::pb::RegionDdlWork* mutable_region_ddl_works(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionDdlWork >*
      mutable_region_ddl_works();
  private:
  const ::baikaldb::pb::RegionDdlWork& _internal_region_ddl_works(int index) const;
  ::baikaldb::pb::RegionDdlWork* _internal_add_region_ddl_works();
  public:
  const ::baikaldb::pb::RegionDdlWork& region_ddl_works(int index) const;
  ::baikaldb::pb::RegionDdlWork* add_region_ddl_works();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionDdlWork >&
      region_ddl_works() const;

  // repeated .baikaldb.pb.DdlWorkInfo ddl_works = 12;
  int ddl_works_size() const;
  private:
  int _internal_ddl_works_size() const;
  public:
  void clear_ddl_works();
  ::baikaldb::pb::DdlWorkInfo* mutable_ddl_works(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >*
      mutable_ddl_works();
  private:
  const ::baikaldb::pb::DdlWorkInfo& _internal_ddl_works(int index) const;
  ::baikaldb::pb::DdlWorkInfo* _internal_add_ddl_works();
  public:
  const ::baikaldb::pb::DdlWorkInfo& ddl_works(int index) const;
  ::baikaldb::pb::DdlWorkInfo* add_ddl_works();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >&
      ddl_works() const;

  // repeated .baikaldb.pb.NameSpaceInfo ns_info = 13;
  int ns_info_size() const;
  private:
  int _internal_ns_info_size() const;
  public:
  void clear_ns_info();
  ::baikaldb::pb::NameSpaceInfo* mutable_ns_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::NameSpaceInfo >*
      mutable_ns_info();
  private:
  const ::baikaldb::pb::NameSpaceInfo& _internal_ns_info(int index) const;
  ::baikaldb::pb::NameSpaceInfo* _internal_add_ns_info();
  public:
  const ::baikaldb::pb::NameSpaceInfo& ns_info(int index) const;
  ::baikaldb::pb::NameSpaceInfo* add_ns_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::NameSpaceInfo >&
      ns_info() const;

  // repeated .baikaldb.pb.BaikalStatus baikal_status = 14;
  int baikal_status_size() const;
  private:
  int _internal_baikal_status_size() const;
  public:
  void clear_baikal_status();
  ::baikaldb::pb::BaikalStatus* mutable_baikal_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalStatus >*
      mutable_baikal_status();
  private:
  const ::baikaldb::pb::BaikalStatus& _internal_baikal_status(int index) const;
  ::baikaldb::pb::BaikalStatus* _internal_add_baikal_status();
  public:
  const ::baikaldb::pb::BaikalStatus& baikal_status(int index) const;
  ::baikaldb::pb::BaikalStatus* add_baikal_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalStatus >&
      baikal_status() const;

  // optional string errmsg = 2;
  bool has_errmsg() const;
  private:
  bool _internal_has_errmsg() const;
  public:
  void clear_errmsg();
  const std::string& errmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errmsg();
  PROTOBUF_MUST_USE_RESULT std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // optional string leader = 3;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // optional .baikaldb.pb.IdcInfo idc_info = 7;
  bool has_idc_info() const;
  private:
  bool _internal_has_idc_info() const;
  public:
  void clear_idc_info();
  const ::baikaldb::pb::IdcInfo& idc_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::IdcInfo* release_idc_info();
  ::baikaldb::pb::IdcInfo* mutable_idc_info();
  void set_allocated_idc_info(::baikaldb::pb::IdcInfo* idc_info);
  private:
  const ::baikaldb::pb::IdcInfo& _internal_idc_info() const;
  ::baikaldb::pb::IdcInfo* _internal_mutable_idc_info();
  public:
  void unsafe_arena_set_allocated_idc_info(
      ::baikaldb::pb::IdcInfo* idc_info);
  ::baikaldb::pb::IdcInfo* unsafe_arena_release_idc_info();

  // optional int64 last_updated_index = 9;
  bool has_last_updated_index() const;
  private:
  bool _internal_has_last_updated_index() const;
  public:
  void clear_last_updated_index();
  ::PROTOBUF_NAMESPACE_ID::int64 last_updated_index() const;
  void set_last_updated_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_last_updated_index() const;
  void _internal_set_last_updated_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required .baikaldb.pb.ErrCode errcode = 1;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::ErrCode errcode() const;
  void set_errcode(::baikaldb::pb::ErrCode value);
  private:
  ::baikaldb::pb::ErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::ErrCode value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BaikalHeartBeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaInfo > schema_change_info_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo > region_change_info_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::UserPrivilege > privilege_change_info_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DataBaseInfo > db_info_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Statistics > statistics_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionDdlWork > region_ddl_works_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo > ddl_works_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::NameSpaceInfo > ns_info_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalStatus > baikal_status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  ::baikaldb::pb::IdcInfo* idc_info_;
  ::PROTOBUF_NAMESPACE_ID::int64 last_updated_index_;
  int errcode_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class PhysicalInstance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.PhysicalInstance) */ {
 public:
  inline PhysicalInstance() : PhysicalInstance(nullptr) {}
  ~PhysicalInstance() override;
  explicit constexpr PhysicalInstance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhysicalInstance(const PhysicalInstance& from);
  PhysicalInstance(PhysicalInstance&& from) noexcept
    : PhysicalInstance() {
    *this = ::std::move(from);
  }

  inline PhysicalInstance& operator=(const PhysicalInstance& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhysicalInstance& operator=(PhysicalInstance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhysicalInstance& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhysicalInstance* internal_default_instance() {
    return reinterpret_cast<const PhysicalInstance*>(
               &_PhysicalInstance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(PhysicalInstance& a, PhysicalInstance& b) {
    a.Swap(&b);
  }
  inline void Swap(PhysicalInstance* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhysicalInstance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PhysicalInstance* New() const final {
    return new PhysicalInstance();
  }

  PhysicalInstance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PhysicalInstance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhysicalInstance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PhysicalInstance& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicalInstance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.PhysicalInstance";
  }
  protected:
  explicit PhysicalInstance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstancesFieldNumber = 3,
    kPhysicalRoomFieldNumber = 1,
    kLogicalRoomFieldNumber = 2,
  };
  // repeated string instances = 3;
  int instances_size() const;
  private:
  int _internal_instances_size() const;
  public:
  void clear_instances();
  const std::string& instances(int index) const;
  std::string* mutable_instances(int index);
  void set_instances(int index, const std::string& value);
  void set_instances(int index, std::string&& value);
  void set_instances(int index, const char* value);
  void set_instances(int index, const char* value, size_t size);
  std::string* add_instances();
  void add_instances(const std::string& value);
  void add_instances(std::string&& value);
  void add_instances(const char* value);
  void add_instances(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& instances() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_instances();
  private:
  const std::string& _internal_instances(int index) const;
  std::string* _internal_add_instances();
  public:

  // required string physical_room = 1;
  bool has_physical_room() const;
  private:
  bool _internal_has_physical_room() const;
  public:
  void clear_physical_room();
  const std::string& physical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_physical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_physical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_physical_room();
  void set_allocated_physical_room(std::string* physical_room);
  private:
  const std::string& _internal_physical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_physical_room(const std::string& value);
  std::string* _internal_mutable_physical_room();
  public:

  // required string logical_room = 2;
  bool has_logical_room() const;
  private:
  bool _internal_has_logical_room() const;
  public:
  void clear_logical_room();
  const std::string& logical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_logical_room();
  void set_allocated_logical_room(std::string* logical_room);
  private:
  const std::string& _internal_logical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logical_room(const std::string& value);
  std::string* _internal_mutable_logical_room();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.PhysicalInstance)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> instances_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr physical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logical_room_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class QueryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.QueryRequest) */ {
 public:
  inline QueryRequest() : QueryRequest(nullptr) {}
  ~QueryRequest() override;
  explicit constexpr QueryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryRequest(const QueryRequest& from);
  QueryRequest(QueryRequest&& from) noexcept
    : QueryRequest() {
    *this = ::std::move(from);
  }

  inline QueryRequest& operator=(const QueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryRequest& operator=(QueryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryRequest* internal_default_instance() {
    return reinterpret_cast<const QueryRequest*>(
               &_QueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(QueryRequest& a, QueryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryRequest* New() const final {
    return new QueryRequest();
  }

  QueryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.QueryRequest";
  }
  protected:
  explicit QueryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionIdsFieldNumber = 9,
    kLogicalRoomFieldNumber = 2,
    kPhysicalRoomFieldNumber = 3,
    kInstanceAddressFieldNumber = 4,
    kUserNameFieldNumber = 5,
    kNamespaceNameFieldNumber = 6,
    kDatabaseFieldNumber = 7,
    kTableNameFieldNumber = 8,
    kOldLeaderFieldNumber = 10,
    kNewLeaderFieldNumber = 11,
    kOldPeersFieldNumber = 12,
    kNewPeersFieldNumber = 13,
    kResourceTagFieldNumber = 14,
    kStrRegionIdFieldNumber = 15,
    kTableIdFieldNumber = 16,
    kOpTypeFieldNumber = 1,
  };
  // repeated int64 region_ids = 9;
  int region_ids_size() const;
  private:
  int _internal_region_ids_size() const;
  public:
  void clear_region_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_region_ids() const;
  void _internal_add_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_region_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 region_ids(int index) const;
  void set_region_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      region_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_region_ids();

  // optional string logical_room = 2;
  bool has_logical_room() const;
  private:
  bool _internal_has_logical_room() const;
  public:
  void clear_logical_room();
  const std::string& logical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_logical_room();
  void set_allocated_logical_room(std::string* logical_room);
  private:
  const std::string& _internal_logical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logical_room(const std::string& value);
  std::string* _internal_mutable_logical_room();
  public:

  // optional string physical_room = 3;
  bool has_physical_room() const;
  private:
  bool _internal_has_physical_room() const;
  public:
  void clear_physical_room();
  const std::string& physical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_physical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_physical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_physical_room();
  void set_allocated_physical_room(std::string* physical_room);
  private:
  const std::string& _internal_physical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_physical_room(const std::string& value);
  std::string* _internal_mutable_physical_room();
  public:

  // optional string instance_address = 4;
  bool has_instance_address() const;
  private:
  bool _internal_has_instance_address() const;
  public:
  void clear_instance_address();
  const std::string& instance_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instance_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instance_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_instance_address();
  void set_allocated_instance_address(std::string* instance_address);
  private:
  const std::string& _internal_instance_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_address(const std::string& value);
  std::string* _internal_mutable_instance_address();
  public:

  // optional string user_name = 5;
  bool has_user_name() const;
  private:
  bool _internal_has_user_name() const;
  public:
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // optional string namespace_name = 6;
  bool has_namespace_name() const;
  private:
  bool _internal_has_namespace_name() const;
  public:
  void clear_namespace_name();
  const std::string& namespace_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_namespace_name();
  void set_allocated_namespace_name(std::string* namespace_name);
  private:
  const std::string& _internal_namespace_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_name(const std::string& value);
  std::string* _internal_mutable_namespace_name();
  public:

  // optional string database = 7;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_MUST_USE_RESULT std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // optional string table_name = 8;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional string old_leader = 10;
  bool has_old_leader() const;
  private:
  bool _internal_has_old_leader() const;
  public:
  void clear_old_leader();
  const std::string& old_leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_old_leader();
  void set_allocated_old_leader(std::string* old_leader);
  private:
  const std::string& _internal_old_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_leader(const std::string& value);
  std::string* _internal_mutable_old_leader();
  public:

  // optional string new_leader = 11;
  bool has_new_leader() const;
  private:
  bool _internal_has_new_leader() const;
  public:
  void clear_new_leader();
  const std::string& new_leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_new_leader();
  void set_allocated_new_leader(std::string* new_leader);
  private:
  const std::string& _internal_new_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_leader(const std::string& value);
  std::string* _internal_mutable_new_leader();
  public:

  // optional string old_peers = 12;
  bool has_old_peers() const;
  private:
  bool _internal_has_old_peers() const;
  public:
  void clear_old_peers();
  const std::string& old_peers() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_peers(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_peers();
  PROTOBUF_MUST_USE_RESULT std::string* release_old_peers();
  void set_allocated_old_peers(std::string* old_peers);
  private:
  const std::string& _internal_old_peers() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_peers(const std::string& value);
  std::string* _internal_mutable_old_peers();
  public:

  // optional string new_peers = 13;
  bool has_new_peers() const;
  private:
  bool _internal_has_new_peers() const;
  public:
  void clear_new_peers();
  const std::string& new_peers() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_peers(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_peers();
  PROTOBUF_MUST_USE_RESULT std::string* release_new_peers();
  void set_allocated_new_peers(std::string* new_peers);
  private:
  const std::string& _internal_new_peers() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_peers(const std::string& value);
  std::string* _internal_mutable_new_peers();
  public:

  // optional string resource_tag = 14;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional string str_region_id = 15;
  bool has_str_region_id() const;
  private:
  bool _internal_has_str_region_id() const;
  public:
  void clear_str_region_id();
  const std::string& str_region_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str_region_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str_region_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_str_region_id();
  void set_allocated_str_region_id(std::string* str_region_id);
  private:
  const std::string& _internal_str_region_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str_region_id(const std::string& value);
  std::string* _internal_mutable_str_region_id();
  public:

  // optional int64 table_id = 16;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required .baikaldb.pb.QueryOpType op_type = 1;
  bool has_op_type() const;
  private:
  bool _internal_has_op_type() const;
  public:
  void clear_op_type();
  ::baikaldb::pb::QueryOpType op_type() const;
  void set_op_type(::baikaldb::pb::QueryOpType value);
  private:
  ::baikaldb::pb::QueryOpType _internal_op_type() const;
  void _internal_set_op_type(::baikaldb::pb::QueryOpType value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.QueryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > region_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr physical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_leader_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_leader_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_peers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_peers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  int op_type_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class ResourceTagInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ResourceTagInfo) */ {
 public:
  inline ResourceTagInfo() : ResourceTagInfo(nullptr) {}
  ~ResourceTagInfo() override;
  explicit constexpr ResourceTagInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceTagInfo(const ResourceTagInfo& from);
  ResourceTagInfo(ResourceTagInfo&& from) noexcept
    : ResourceTagInfo() {
    *this = ::std::move(from);
  }

  inline ResourceTagInfo& operator=(const ResourceTagInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceTagInfo& operator=(ResourceTagInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceTagInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceTagInfo* internal_default_instance() {
    return reinterpret_cast<const ResourceTagInfo*>(
               &_ResourceTagInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(ResourceTagInfo& a, ResourceTagInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceTagInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceTagInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourceTagInfo* New() const final {
    return new ResourceTagInfo();
  }

  ResourceTagInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourceTagInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceTagInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResourceTagInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceTagInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ResourceTagInfo";
  }
  protected:
  explicit ResourceTagInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceTagFieldNumber = 1,
    kPeerLoadBalanceFieldNumber = 2,
    kMigrateFieldNumber = 3,
    kNetworkSegmentBalanceFieldNumber = 4,
  };
  // required string resource_tag = 1;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional bool peer_load_balance = 2;
  bool has_peer_load_balance() const;
  private:
  bool _internal_has_peer_load_balance() const;
  public:
  void clear_peer_load_balance();
  bool peer_load_balance() const;
  void set_peer_load_balance(bool value);
  private:
  bool _internal_peer_load_balance() const;
  void _internal_set_peer_load_balance(bool value);
  public:

  // optional bool migrate = 3;
  bool has_migrate() const;
  private:
  bool _internal_has_migrate() const;
  public:
  void clear_migrate();
  bool migrate() const;
  void set_migrate(bool value);
  private:
  bool _internal_migrate() const;
  void _internal_set_migrate(bool value);
  public:

  // optional bool network_segment_balance = 4;
  bool has_network_segment_balance() const;
  private:
  bool _internal_has_network_segment_balance() const;
  public:
  void clear_network_segment_balance();
  bool network_segment_balance() const;
  void set_network_segment_balance(bool value);
  private:
  bool _internal_network_segment_balance() const;
  void _internal_set_network_segment_balance(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ResourceTagInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  bool peer_load_balance_;
  bool migrate_;
  bool network_segment_balance_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class VirtualInfoAndSqls final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.VirtualInfoAndSqls) */ {
 public:
  inline VirtualInfoAndSqls() : VirtualInfoAndSqls(nullptr) {}
  ~VirtualInfoAndSqls() override;
  explicit constexpr VirtualInfoAndSqls(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VirtualInfoAndSqls(const VirtualInfoAndSqls& from);
  VirtualInfoAndSqls(VirtualInfoAndSqls&& from) noexcept
    : VirtualInfoAndSqls() {
    *this = ::std::move(from);
  }

  inline VirtualInfoAndSqls& operator=(const VirtualInfoAndSqls& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualInfoAndSqls& operator=(VirtualInfoAndSqls&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VirtualInfoAndSqls& default_instance() {
    return *internal_default_instance();
  }
  static inline const VirtualInfoAndSqls* internal_default_instance() {
    return reinterpret_cast<const VirtualInfoAndSqls*>(
               &_VirtualInfoAndSqls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(VirtualInfoAndSqls& a, VirtualInfoAndSqls& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualInfoAndSqls* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualInfoAndSqls* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualInfoAndSqls* New() const final {
    return new VirtualInfoAndSqls();
  }

  VirtualInfoAndSqls* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualInfoAndSqls>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VirtualInfoAndSqls& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VirtualInfoAndSqls& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualInfoAndSqls* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.VirtualInfoAndSqls";
  }
  protected:
  explicit VirtualInfoAndSqls(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVirtualIndexInfoFieldNumber = 1,
    kAffectedSignFieldNumber = 2,
    kAffectedSqlsFieldNumber = 3,
  };
  // optional string virtual_index_info = 1;
  bool has_virtual_index_info() const;
  private:
  bool _internal_has_virtual_index_info() const;
  public:
  void clear_virtual_index_info();
  const std::string& virtual_index_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_virtual_index_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_virtual_index_info();
  PROTOBUF_MUST_USE_RESULT std::string* release_virtual_index_info();
  void set_allocated_virtual_index_info(std::string* virtual_index_info);
  private:
  const std::string& _internal_virtual_index_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_virtual_index_info(const std::string& value);
  std::string* _internal_mutable_virtual_index_info();
  public:

  // optional string affected_sign = 2;
  bool has_affected_sign() const;
  private:
  bool _internal_has_affected_sign() const;
  public:
  void clear_affected_sign();
  const std::string& affected_sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_affected_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_affected_sign();
  PROTOBUF_MUST_USE_RESULT std::string* release_affected_sign();
  void set_allocated_affected_sign(std::string* affected_sign);
  private:
  const std::string& _internal_affected_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_affected_sign(const std::string& value);
  std::string* _internal_mutable_affected_sign();
  public:

  // optional string affected_sqls = 3;
  bool has_affected_sqls() const;
  private:
  bool _internal_has_affected_sqls() const;
  public:
  void clear_affected_sqls();
  const std::string& affected_sqls() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_affected_sqls(ArgT0&& arg0, ArgT... args);
  std::string* mutable_affected_sqls();
  PROTOBUF_MUST_USE_RESULT std::string* release_affected_sqls();
  void set_allocated_affected_sqls(std::string* affected_sqls);
  private:
  const std::string& _internal_affected_sqls() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_affected_sqls(const std::string& value);
  std::string* _internal_mutable_affected_sqls();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.VirtualInfoAndSqls)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr virtual_index_info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr affected_sign_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr affected_sqls_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class BinlogRegionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BinlogRegionInfo) */ {
 public:
  inline BinlogRegionInfo() : BinlogRegionInfo(nullptr) {}
  ~BinlogRegionInfo() override;
  explicit constexpr BinlogRegionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinlogRegionInfo(const BinlogRegionInfo& from);
  BinlogRegionInfo(BinlogRegionInfo&& from) noexcept
    : BinlogRegionInfo() {
    *this = ::std::move(from);
  }

  inline BinlogRegionInfo& operator=(const BinlogRegionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinlogRegionInfo& operator=(BinlogRegionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinlogRegionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinlogRegionInfo* internal_default_instance() {
    return reinterpret_cast<const BinlogRegionInfo*>(
               &_BinlogRegionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(BinlogRegionInfo& a, BinlogRegionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(BinlogRegionInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinlogRegionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinlogRegionInfo* New() const final {
    return new BinlogRegionInfo();
  }

  BinlogRegionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinlogRegionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinlogRegionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BinlogRegionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinlogRegionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BinlogRegionInfo";
  }
  protected:
  explicit BinlogRegionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerIdFieldNumber = 2,
    kOldestTsToNowFieldNumber = 3,
    kRegionIdFieldNumber = 1,
  };
  // repeated string peer_id = 2;
  int peer_id_size() const;
  private:
  int _internal_peer_id_size() const;
  public:
  void clear_peer_id();
  const std::string& peer_id(int index) const;
  std::string* mutable_peer_id(int index);
  void set_peer_id(int index, const std::string& value);
  void set_peer_id(int index, std::string&& value);
  void set_peer_id(int index, const char* value);
  void set_peer_id(int index, const char* value, size_t size);
  std::string* add_peer_id();
  void add_peer_id(const std::string& value);
  void add_peer_id(std::string&& value);
  void add_peer_id(const char* value);
  void add_peer_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& peer_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_peer_id();
  private:
  const std::string& _internal_peer_id(int index) const;
  std::string* _internal_add_peer_id();
  public:

  // repeated uint32 oldest_ts_to_now = 3;
  int oldest_ts_to_now_size() const;
  private:
  int _internal_oldest_ts_to_now_size() const;
  public:
  void clear_oldest_ts_to_now();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_oldest_ts_to_now(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_oldest_ts_to_now() const;
  void _internal_add_oldest_ts_to_now(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_oldest_ts_to_now();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 oldest_ts_to_now(int index) const;
  void set_oldest_ts_to_now(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_oldest_ts_to_now(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      oldest_ts_to_now() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_oldest_ts_to_now();

  // required int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BinlogRegionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> peer_id_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > oldest_ts_to_now_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class QueryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.QueryResponse) */ {
 public:
  inline QueryResponse() : QueryResponse(nullptr) {}
  ~QueryResponse() override;
  explicit constexpr QueryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryResponse(const QueryResponse& from);
  QueryResponse(QueryResponse&& from) noexcept
    : QueryResponse() {
    *this = ::std::move(from);
  }

  inline QueryResponse& operator=(const QueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryResponse& operator=(QueryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryResponse* internal_default_instance() {
    return reinterpret_cast<const QueryResponse*>(
               &_QueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(QueryResponse& a, QueryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryResponse* New() const final {
    return new QueryResponse();
  }

  QueryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.QueryResponse";
  }
  protected:
  explicit QueryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhysicalRoomsFieldNumber = 4,
    kPhysicalInstancesFieldNumber = 5,
    kInstanceInfosFieldNumber = 6,
    kUserPrivilegeFieldNumber = 7,
    kNamespaceInfosFieldNumber = 8,
    kDatabaseInfosFieldNumber = 9,
    kSchemaInfosFieldNumber = 10,
    kRegionInfosFieldNumber = 11,
    kFlattenInstancesFieldNumber = 12,
    kFlattenPrivilegesFieldNumber = 13,
    kFlattenRegionsFieldNumber = 14,
    kFlattenTablesFieldNumber = 15,
    kFlattenSchemaInfosFieldNumber = 16,
    kPeerIdsFieldNumber = 17,
    kRegionIdsFieldNumber = 18,
    kDdlworkInfosFieldNumber = 19,
    kQueryDdlInfosFieldNumber = 20,
    kRegionStatusInfosFieldNumber = 21,
    kInstanceParamsFieldNumber = 22,
    kRegionDdlInfosFieldNumber = 23,
    kResourceTagInfosFieldNumber = 24,
    kVirtualIndexInfluenceInfoFieldNumber = 25,
    kBinlogRegionStateFieldNumber = 26,
    kErrmsgFieldNumber = 2,
    kLeaderFieldNumber = 3,
    kErrcodeFieldNumber = 1,
  };
  // repeated .baikaldb.pb.PhysicalRoom physical_rooms = 4;
  int physical_rooms_size() const;
  private:
  int _internal_physical_rooms_size() const;
  public:
  void clear_physical_rooms();
  ::baikaldb::pb::PhysicalRoom* mutable_physical_rooms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PhysicalRoom >*
      mutable_physical_rooms();
  private:
  const ::baikaldb::pb::PhysicalRoom& _internal_physical_rooms(int index) const;
  ::baikaldb::pb::PhysicalRoom* _internal_add_physical_rooms();
  public:
  const ::baikaldb::pb::PhysicalRoom& physical_rooms(int index) const;
  ::baikaldb::pb::PhysicalRoom* add_physical_rooms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PhysicalRoom >&
      physical_rooms() const;

  // repeated .baikaldb.pb.PhysicalInstance physical_instances = 5;
  int physical_instances_size() const;
  private:
  int _internal_physical_instances_size() const;
  public:
  void clear_physical_instances();
  ::baikaldb::pb::PhysicalInstance* mutable_physical_instances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PhysicalInstance >*
      mutable_physical_instances();
  private:
  const ::baikaldb::pb::PhysicalInstance& _internal_physical_instances(int index) const;
  ::baikaldb::pb::PhysicalInstance* _internal_add_physical_instances();
  public:
  const ::baikaldb::pb::PhysicalInstance& physical_instances(int index) const;
  ::baikaldb::pb::PhysicalInstance* add_physical_instances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PhysicalInstance >&
      physical_instances() const;

  // repeated .baikaldb.pb.InstanceInfo instance_infos = 6;
  int instance_infos_size() const;
  private:
  int _internal_instance_infos_size() const;
  public:
  void clear_instance_infos();
  ::baikaldb::pb::InstanceInfo* mutable_instance_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceInfo >*
      mutable_instance_infos();
  private:
  const ::baikaldb::pb::InstanceInfo& _internal_instance_infos(int index) const;
  ::baikaldb::pb::InstanceInfo* _internal_add_instance_infos();
  public:
  const ::baikaldb::pb::InstanceInfo& instance_infos(int index) const;
  ::baikaldb::pb::InstanceInfo* add_instance_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceInfo >&
      instance_infos() const;

  // repeated .baikaldb.pb.UserPrivilege user_privilege = 7;
  int user_privilege_size() const;
  private:
  int _internal_user_privilege_size() const;
  public:
  void clear_user_privilege();
  ::baikaldb::pb::UserPrivilege* mutable_user_privilege(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::UserPrivilege >*
      mutable_user_privilege();
  private:
  const ::baikaldb::pb::UserPrivilege& _internal_user_privilege(int index) const;
  ::baikaldb::pb::UserPrivilege* _internal_add_user_privilege();
  public:
  const ::baikaldb::pb::UserPrivilege& user_privilege(int index) const;
  ::baikaldb::pb::UserPrivilege* add_user_privilege();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::UserPrivilege >&
      user_privilege() const;

  // repeated .baikaldb.pb.NameSpaceInfo namespace_infos = 8;
  int namespace_infos_size() const;
  private:
  int _internal_namespace_infos_size() const;
  public:
  void clear_namespace_infos();
  ::baikaldb::pb::NameSpaceInfo* mutable_namespace_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::NameSpaceInfo >*
      mutable_namespace_infos();
  private:
  const ::baikaldb::pb::NameSpaceInfo& _internal_namespace_infos(int index) const;
  ::baikaldb::pb::NameSpaceInfo* _internal_add_namespace_infos();
  public:
  const ::baikaldb::pb::NameSpaceInfo& namespace_infos(int index) const;
  ::baikaldb::pb::NameSpaceInfo* add_namespace_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::NameSpaceInfo >&
      namespace_infos() const;

  // repeated .baikaldb.pb.DataBaseInfo database_infos = 9;
  int database_infos_size() const;
  private:
  int _internal_database_infos_size() const;
  public:
  void clear_database_infos();
  ::baikaldb::pb::DataBaseInfo* mutable_database_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DataBaseInfo >*
      mutable_database_infos();
  private:
  const ::baikaldb::pb::DataBaseInfo& _internal_database_infos(int index) const;
  ::baikaldb::pb::DataBaseInfo* _internal_add_database_infos();
  public:
  const ::baikaldb::pb::DataBaseInfo& database_infos(int index) const;
  ::baikaldb::pb::DataBaseInfo* add_database_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DataBaseInfo >&
      database_infos() const;

  // repeated .baikaldb.pb.SchemaInfo schema_infos = 10;
  int schema_infos_size() const;
  private:
  int _internal_schema_infos_size() const;
  public:
  void clear_schema_infos();
  ::baikaldb::pb::SchemaInfo* mutable_schema_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaInfo >*
      mutable_schema_infos();
  private:
  const ::baikaldb::pb::SchemaInfo& _internal_schema_infos(int index) const;
  ::baikaldb::pb::SchemaInfo* _internal_add_schema_infos();
  public:
  const ::baikaldb::pb::SchemaInfo& schema_infos(int index) const;
  ::baikaldb::pb::SchemaInfo* add_schema_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaInfo >&
      schema_infos() const;

  // repeated .baikaldb.pb.RegionInfo region_infos = 11;
  int region_infos_size() const;
  private:
  int _internal_region_infos_size() const;
  public:
  void clear_region_infos();
  ::baikaldb::pb::RegionInfo* mutable_region_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >*
      mutable_region_infos();
  private:
  const ::baikaldb::pb::RegionInfo& _internal_region_infos(int index) const;
  ::baikaldb::pb::RegionInfo* _internal_add_region_infos();
  public:
  const ::baikaldb::pb::RegionInfo& region_infos(int index) const;
  ::baikaldb::pb::RegionInfo* add_region_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >&
      region_infos() const;

  // repeated .baikaldb.pb.QueryInstance flatten_instances = 12;
  int flatten_instances_size() const;
  private:
  int _internal_flatten_instances_size() const;
  public:
  void clear_flatten_instances();
  ::baikaldb::pb::QueryInstance* mutable_flatten_instances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryInstance >*
      mutable_flatten_instances();
  private:
  const ::baikaldb::pb::QueryInstance& _internal_flatten_instances(int index) const;
  ::baikaldb::pb::QueryInstance* _internal_add_flatten_instances();
  public:
  const ::baikaldb::pb::QueryInstance& flatten_instances(int index) const;
  ::baikaldb::pb::QueryInstance* add_flatten_instances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryInstance >&
      flatten_instances() const;

  // repeated .baikaldb.pb.QueryUserPrivilege flatten_privileges = 13;
  int flatten_privileges_size() const;
  private:
  int _internal_flatten_privileges_size() const;
  public:
  void clear_flatten_privileges();
  ::baikaldb::pb::QueryUserPrivilege* mutable_flatten_privileges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryUserPrivilege >*
      mutable_flatten_privileges();
  private:
  const ::baikaldb::pb::QueryUserPrivilege& _internal_flatten_privileges(int index) const;
  ::baikaldb::pb::QueryUserPrivilege* _internal_add_flatten_privileges();
  public:
  const ::baikaldb::pb::QueryUserPrivilege& flatten_privileges(int index) const;
  ::baikaldb::pb::QueryUserPrivilege* add_flatten_privileges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryUserPrivilege >&
      flatten_privileges() const;

  // repeated .baikaldb.pb.QueryRegion flatten_regions = 14;
  int flatten_regions_size() const;
  private:
  int _internal_flatten_regions_size() const;
  public:
  void clear_flatten_regions();
  ::baikaldb::pb::QueryRegion* mutable_flatten_regions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryRegion >*
      mutable_flatten_regions();
  private:
  const ::baikaldb::pb::QueryRegion& _internal_flatten_regions(int index) const;
  ::baikaldb::pb::QueryRegion* _internal_add_flatten_regions();
  public:
  const ::baikaldb::pb::QueryRegion& flatten_regions(int index) const;
  ::baikaldb::pb::QueryRegion* add_flatten_regions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryRegion >&
      flatten_regions() const;

  // repeated .baikaldb.pb.QueryTable flatten_tables = 15;
  int flatten_tables_size() const;
  private:
  int _internal_flatten_tables_size() const;
  public:
  void clear_flatten_tables();
  ::baikaldb::pb::QueryTable* mutable_flatten_tables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryTable >*
      mutable_flatten_tables();
  private:
  const ::baikaldb::pb::QueryTable& _internal_flatten_tables(int index) const;
  ::baikaldb::pb::QueryTable* _internal_add_flatten_tables();
  public:
  const ::baikaldb::pb::QueryTable& flatten_tables(int index) const;
  ::baikaldb::pb::QueryTable* add_flatten_tables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryTable >&
      flatten_tables() const;

  // repeated .baikaldb.pb.QuerySchema flatten_schema_infos = 16;
  int flatten_schema_infos_size() const;
  private:
  int _internal_flatten_schema_infos_size() const;
  public:
  void clear_flatten_schema_infos();
  ::baikaldb::pb::QuerySchema* mutable_flatten_schema_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QuerySchema >*
      mutable_flatten_schema_infos();
  private:
  const ::baikaldb::pb::QuerySchema& _internal_flatten_schema_infos(int index) const;
  ::baikaldb::pb::QuerySchema* _internal_add_flatten_schema_infos();
  public:
  const ::baikaldb::pb::QuerySchema& flatten_schema_infos(int index) const;
  ::baikaldb::pb::QuerySchema* add_flatten_schema_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QuerySchema >&
      flatten_schema_infos() const;

  // repeated int64 peer_ids = 17;
  int peer_ids_size() const;
  private:
  int _internal_peer_ids_size() const;
  public:
  void clear_peer_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_peer_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_peer_ids() const;
  void _internal_add_peer_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_peer_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 peer_ids(int index) const;
  void set_peer_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_peer_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      peer_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_peer_ids();

  // repeated int64 region_ids = 18;
  int region_ids_size() const;
  private:
  int _internal_region_ids_size() const;
  public:
  void clear_region_ids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_region_ids() const;
  void _internal_add_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_region_ids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 region_ids(int index) const;
  void set_region_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      region_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_region_ids();

  // repeated .baikaldb.pb.DdlWorkInfo ddlwork_infos = 19;
  int ddlwork_infos_size() const;
  private:
  int _internal_ddlwork_infos_size() const;
  public:
  void clear_ddlwork_infos();
  ::baikaldb::pb::DdlWorkInfo* mutable_ddlwork_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >*
      mutable_ddlwork_infos();
  private:
  const ::baikaldb::pb::DdlWorkInfo& _internal_ddlwork_infos(int index) const;
  ::baikaldb::pb::DdlWorkInfo* _internal_add_ddlwork_infos();
  public:
  const ::baikaldb::pb::DdlWorkInfo& ddlwork_infos(int index) const;
  ::baikaldb::pb::DdlWorkInfo* add_ddlwork_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >&
      ddlwork_infos() const;

  // repeated .baikaldb.pb.QueryDdlInfo query_ddl_infos = 20;
  int query_ddl_infos_size() const;
  private:
  int _internal_query_ddl_infos_size() const;
  public:
  void clear_query_ddl_infos();
  ::baikaldb::pb::QueryDdlInfo* mutable_query_ddl_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryDdlInfo >*
      mutable_query_ddl_infos();
  private:
  const ::baikaldb::pb::QueryDdlInfo& _internal_query_ddl_infos(int index) const;
  ::baikaldb::pb::QueryDdlInfo* _internal_add_query_ddl_infos();
  public:
  const ::baikaldb::pb::QueryDdlInfo& query_ddl_infos(int index) const;
  ::baikaldb::pb::QueryDdlInfo* add_query_ddl_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryDdlInfo >&
      query_ddl_infos() const;

  // repeated .baikaldb.pb.RegionStateInfo region_status_infos = 21;
  int region_status_infos_size() const;
  private:
  int _internal_region_status_infos_size() const;
  public:
  void clear_region_status_infos();
  ::baikaldb::pb::RegionStateInfo* mutable_region_status_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionStateInfo >*
      mutable_region_status_infos();
  private:
  const ::baikaldb::pb::RegionStateInfo& _internal_region_status_infos(int index) const;
  ::baikaldb::pb::RegionStateInfo* _internal_add_region_status_infos();
  public:
  const ::baikaldb::pb::RegionStateInfo& region_status_infos(int index) const;
  ::baikaldb::pb::RegionStateInfo* add_region_status_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionStateInfo >&
      region_status_infos() const;

  // repeated .baikaldb.pb.InstanceParam instance_params = 22;
  int instance_params_size() const;
  private:
  int _internal_instance_params_size() const;
  public:
  void clear_instance_params();
  ::baikaldb::pb::InstanceParam* mutable_instance_params(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam >*
      mutable_instance_params();
  private:
  const ::baikaldb::pb::InstanceParam& _internal_instance_params(int index) const;
  ::baikaldb::pb::InstanceParam* _internal_add_instance_params();
  public:
  const ::baikaldb::pb::InstanceParam& instance_params(int index) const;
  ::baikaldb::pb::InstanceParam* add_instance_params();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam >&
      instance_params() const;

  // repeated .baikaldb.pb.RegionDdlWork region_ddl_infos = 23;
  int region_ddl_infos_size() const;
  private:
  int _internal_region_ddl_infos_size() const;
  public:
  void clear_region_ddl_infos();
  ::baikaldb::pb::RegionDdlWork* mutable_region_ddl_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionDdlWork >*
      mutable_region_ddl_infos();
  private:
  const ::baikaldb::pb::RegionDdlWork& _internal_region_ddl_infos(int index) const;
  ::baikaldb::pb::RegionDdlWork* _internal_add_region_ddl_infos();
  public:
  const ::baikaldb::pb::RegionDdlWork& region_ddl_infos(int index) const;
  ::baikaldb::pb::RegionDdlWork* add_region_ddl_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionDdlWork >&
      region_ddl_infos() const;

  // repeated .baikaldb.pb.ResourceTagInfo resource_tag_infos = 24;
  int resource_tag_infos_size() const;
  private:
  int _internal_resource_tag_infos_size() const;
  public:
  void clear_resource_tag_infos();
  ::baikaldb::pb::ResourceTagInfo* mutable_resource_tag_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ResourceTagInfo >*
      mutable_resource_tag_infos();
  private:
  const ::baikaldb::pb::ResourceTagInfo& _internal_resource_tag_infos(int index) const;
  ::baikaldb::pb::ResourceTagInfo* _internal_add_resource_tag_infos();
  public:
  const ::baikaldb::pb::ResourceTagInfo& resource_tag_infos(int index) const;
  ::baikaldb::pb::ResourceTagInfo* add_resource_tag_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ResourceTagInfo >&
      resource_tag_infos() const;

  // repeated .baikaldb.pb.VirtualInfoAndSqls virtual_index_influence_info = 25;
  int virtual_index_influence_info_size() const;
  private:
  int _internal_virtual_index_influence_info_size() const;
  public:
  void clear_virtual_index_influence_info();
  ::baikaldb::pb::VirtualInfoAndSqls* mutable_virtual_index_influence_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::VirtualInfoAndSqls >*
      mutable_virtual_index_influence_info();
  private:
  const ::baikaldb::pb::VirtualInfoAndSqls& _internal_virtual_index_influence_info(int index) const;
  ::baikaldb::pb::VirtualInfoAndSqls* _internal_add_virtual_index_influence_info();
  public:
  const ::baikaldb::pb::VirtualInfoAndSqls& virtual_index_influence_info(int index) const;
  ::baikaldb::pb::VirtualInfoAndSqls* add_virtual_index_influence_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::VirtualInfoAndSqls >&
      virtual_index_influence_info() const;

  // repeated .baikaldb.pb.BinlogRegionInfo binlog_region_state = 26;
  int binlog_region_state_size() const;
  private:
  int _internal_binlog_region_state_size() const;
  public:
  void clear_binlog_region_state();
  ::baikaldb::pb::BinlogRegionInfo* mutable_binlog_region_state(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogRegionInfo >*
      mutable_binlog_region_state();
  private:
  const ::baikaldb::pb::BinlogRegionInfo& _internal_binlog_region_state(int index) const;
  ::baikaldb::pb::BinlogRegionInfo* _internal_add_binlog_region_state();
  public:
  const ::baikaldb::pb::BinlogRegionInfo& binlog_region_state(int index) const;
  ::baikaldb::pb::BinlogRegionInfo* add_binlog_region_state();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogRegionInfo >&
      binlog_region_state() const;

  // optional string errmsg = 2;
  bool has_errmsg() const;
  private:
  bool _internal_has_errmsg() const;
  public:
  void clear_errmsg();
  const std::string& errmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errmsg();
  PROTOBUF_MUST_USE_RESULT std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // optional string leader = 3;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // required .baikaldb.pb.ErrCode errcode = 1;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::ErrCode errcode() const;
  void set_errcode(::baikaldb::pb::ErrCode value);
  private:
  ::baikaldb::pb::ErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::ErrCode value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.QueryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PhysicalRoom > physical_rooms_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PhysicalInstance > physical_instances_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceInfo > instance_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::UserPrivilege > user_privilege_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::NameSpaceInfo > namespace_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DataBaseInfo > database_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaInfo > schema_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo > region_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryInstance > flatten_instances_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryUserPrivilege > flatten_privileges_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryRegion > flatten_regions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryTable > flatten_tables_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QuerySchema > flatten_schema_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > peer_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > region_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo > ddlwork_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryDdlInfo > query_ddl_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionStateInfo > region_status_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam > instance_params_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionDdlWork > region_ddl_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ResourceTagInfo > resource_tag_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::VirtualInfoAndSqls > virtual_index_influence_info_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogRegionInfo > binlog_region_state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  int errcode_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class DdlPeerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.DdlPeerInfo) */ {
 public:
  inline DdlPeerInfo() : DdlPeerInfo(nullptr) {}
  ~DdlPeerInfo() override;
  explicit constexpr DdlPeerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DdlPeerInfo(const DdlPeerInfo& from);
  DdlPeerInfo(DdlPeerInfo&& from) noexcept
    : DdlPeerInfo() {
    *this = ::std::move(from);
  }

  inline DdlPeerInfo& operator=(const DdlPeerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DdlPeerInfo& operator=(DdlPeerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DdlPeerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DdlPeerInfo* internal_default_instance() {
    return reinterpret_cast<const DdlPeerInfo*>(
               &_DdlPeerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(DdlPeerInfo& a, DdlPeerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DdlPeerInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DdlPeerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DdlPeerInfo* New() const final {
    return new DdlPeerInfo();
  }

  DdlPeerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DdlPeerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DdlPeerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DdlPeerInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DdlPeerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.DdlPeerInfo";
  }
  protected:
  explicit DdlPeerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // optional string peer = 1;
  bool has_peer() const;
  private:
  bool _internal_has_peer() const;
  public:
  void clear_peer();
  const std::string& peer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer();
  PROTOBUF_MUST_USE_RESULT std::string* release_peer();
  void set_allocated_peer(std::string* peer);
  private:
  const std::string& _internal_peer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer(const std::string& value);
  std::string* _internal_mutable_peer();
  public:

  // optional .baikaldb.pb.IndexState state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::baikaldb::pb::IndexState state() const;
  void set_state(::baikaldb::pb::IndexState value);
  private:
  ::baikaldb::pb::IndexState _internal_state() const;
  void _internal_set_state(::baikaldb::pb::IndexState value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.DdlPeerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_;
  int state_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class DdlRegionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.DdlRegionInfo) */ {
 public:
  inline DdlRegionInfo() : DdlRegionInfo(nullptr) {}
  ~DdlRegionInfo() override;
  explicit constexpr DdlRegionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DdlRegionInfo(const DdlRegionInfo& from);
  DdlRegionInfo(DdlRegionInfo&& from) noexcept
    : DdlRegionInfo() {
    *this = ::std::move(from);
  }

  inline DdlRegionInfo& operator=(const DdlRegionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DdlRegionInfo& operator=(DdlRegionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DdlRegionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DdlRegionInfo* internal_default_instance() {
    return reinterpret_cast<const DdlRegionInfo*>(
               &_DdlRegionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(DdlRegionInfo& a, DdlRegionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DdlRegionInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DdlRegionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DdlRegionInfo* New() const final {
    return new DdlRegionInfo();
  }

  DdlRegionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DdlRegionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DdlRegionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DdlRegionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DdlRegionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.DdlRegionInfo";
  }
  protected:
  explicit DdlRegionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDdlPeerInfosFieldNumber = 3,
    kRegionIdFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // repeated .baikaldb.pb.DdlPeerInfo ddl_peer_infos = 3;
  int ddl_peer_infos_size() const;
  private:
  int _internal_ddl_peer_infos_size() const;
  public:
  void clear_ddl_peer_infos();
  ::baikaldb::pb::DdlPeerInfo* mutable_ddl_peer_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlPeerInfo >*
      mutable_ddl_peer_infos();
  private:
  const ::baikaldb::pb::DdlPeerInfo& _internal_ddl_peer_infos(int index) const;
  ::baikaldb::pb::DdlPeerInfo* _internal_add_ddl_peer_infos();
  public:
  const ::baikaldb::pb::DdlPeerInfo& ddl_peer_infos(int index) const;
  ::baikaldb::pb::DdlPeerInfo* add_ddl_peer_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlPeerInfo >&
      ddl_peer_infos() const;

  // optional int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.IndexState state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::baikaldb::pb::IndexState state() const;
  void set_state(::baikaldb::pb::IndexState value);
  private:
  ::baikaldb::pb::IndexState _internal_state() const;
  void _internal_set_state(::baikaldb::pb::IndexState value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.DdlRegionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlPeerInfo > ddl_peer_infos_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  int state_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class QueryDdlInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.QueryDdlInfo) */ {
 public:
  inline QueryDdlInfo() : QueryDdlInfo(nullptr) {}
  ~QueryDdlInfo() override;
  explicit constexpr QueryDdlInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryDdlInfo(const QueryDdlInfo& from);
  QueryDdlInfo(QueryDdlInfo&& from) noexcept
    : QueryDdlInfo() {
    *this = ::std::move(from);
  }

  inline QueryDdlInfo& operator=(const QueryDdlInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryDdlInfo& operator=(QueryDdlInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryDdlInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryDdlInfo* internal_default_instance() {
    return reinterpret_cast<const QueryDdlInfo*>(
               &_QueryDdlInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(QueryDdlInfo& a, QueryDdlInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryDdlInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryDdlInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryDdlInfo* New() const final {
    return new QueryDdlInfo();
  }

  QueryDdlInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryDdlInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryDdlInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryDdlInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryDdlInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.QueryDdlInfo";
  }
  protected:
  explicit QueryDdlInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDdlRegionInfosFieldNumber = 2,
    kTableIdFieldNumber = 1,
  };
  // repeated .baikaldb.pb.DdlRegionInfo ddl_region_infos = 2;
  int ddl_region_infos_size() const;
  private:
  int _internal_ddl_region_infos_size() const;
  public:
  void clear_ddl_region_infos();
  ::baikaldb::pb::DdlRegionInfo* mutable_ddl_region_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlRegionInfo >*
      mutable_ddl_region_infos();
  private:
  const ::baikaldb::pb::DdlRegionInfo& _internal_ddl_region_infos(int index) const;
  ::baikaldb::pb::DdlRegionInfo* _internal_add_ddl_region_infos();
  public:
  const ::baikaldb::pb::DdlRegionInfo& ddl_region_infos(int index) const;
  ::baikaldb::pb::DdlRegionInfo* add_ddl_region_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlRegionInfo >&
      ddl_region_infos() const;

  // optional int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.QueryDdlInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlRegionInfo > ddl_region_infos_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class QueryUserPrivilege final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.QueryUserPrivilege) */ {
 public:
  inline QueryUserPrivilege() : QueryUserPrivilege(nullptr) {}
  ~QueryUserPrivilege() override;
  explicit constexpr QueryUserPrivilege(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryUserPrivilege(const QueryUserPrivilege& from);
  QueryUserPrivilege(QueryUserPrivilege&& from) noexcept
    : QueryUserPrivilege() {
    *this = ::std::move(from);
  }

  inline QueryUserPrivilege& operator=(const QueryUserPrivilege& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryUserPrivilege& operator=(QueryUserPrivilege&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryUserPrivilege& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryUserPrivilege* internal_default_instance() {
    return reinterpret_cast<const QueryUserPrivilege*>(
               &_QueryUserPrivilege_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(QueryUserPrivilege& a, QueryUserPrivilege& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryUserPrivilege* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryUserPrivilege* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryUserPrivilege* New() const final {
    return new QueryUserPrivilege();
  }

  QueryUserPrivilege* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryUserPrivilege>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryUserPrivilege& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryUserPrivilege& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryUserPrivilege* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.QueryUserPrivilege";
  }
  protected:
  explicit QueryUserPrivilege(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kNamespaceNameFieldNumber = 2,
    kPrivilegeFieldNumber = 3,
    kPasswordFieldNumber = 5,
    kTableRwFieldNumber = 4,
  };
  // required string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_MUST_USE_RESULT std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // required string namespace_name = 2;
  bool has_namespace_name() const;
  private:
  bool _internal_has_namespace_name() const;
  public:
  void clear_namespace_name();
  const std::string& namespace_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_namespace_name();
  void set_allocated_namespace_name(std::string* namespace_name);
  private:
  const std::string& _internal_namespace_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_name(const std::string& value);
  std::string* _internal_mutable_namespace_name();
  public:

  // required string privilege = 3;
  bool has_privilege() const;
  private:
  bool _internal_has_privilege() const;
  public:
  void clear_privilege();
  const std::string& privilege() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_privilege(ArgT0&& arg0, ArgT... args);
  std::string* mutable_privilege();
  PROTOBUF_MUST_USE_RESULT std::string* release_privilege();
  void set_allocated_privilege(std::string* privilege);
  private:
  const std::string& _internal_privilege() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_privilege(const std::string& value);
  std::string* _internal_mutable_privilege();
  public:

  // optional string password = 5;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_MUST_USE_RESULT std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // required .baikaldb.pb.RW table_rw = 4;
  bool has_table_rw() const;
  private:
  bool _internal_has_table_rw() const;
  public:
  void clear_table_rw();
  ::baikaldb::pb::RW table_rw() const;
  void set_table_rw(::baikaldb::pb::RW value);
  private:
  ::baikaldb::pb::RW _internal_table_rw() const;
  void _internal_set_table_rw(::baikaldb::pb::RW value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.QueryUserPrivilege)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr privilege_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  int table_rw_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class QueryInstance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.QueryInstance) */ {
 public:
  inline QueryInstance() : QueryInstance(nullptr) {}
  ~QueryInstance() override;
  explicit constexpr QueryInstance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryInstance(const QueryInstance& from);
  QueryInstance(QueryInstance&& from) noexcept
    : QueryInstance() {
    *this = ::std::move(from);
  }

  inline QueryInstance& operator=(const QueryInstance& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryInstance& operator=(QueryInstance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryInstance& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryInstance* internal_default_instance() {
    return reinterpret_cast<const QueryInstance*>(
               &_QueryInstance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(QueryInstance& a, QueryInstance& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryInstance* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryInstance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryInstance* New() const final {
    return new QueryInstance();
  }

  QueryInstance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryInstance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryInstance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryInstance& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryInstance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.QueryInstance";
  }
  protected:
  explicit QueryInstance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kResourceTagFieldNumber = 4,
    kPhysicalRoomFieldNumber = 6,
    kLogicalRoomFieldNumber = 7,
    kPeerIdsFieldNumber = 9,
    kRegionLeaderIdsFieldNumber = 11,
    kRegionIdsFieldNumber = 13,
    kVersionFieldNumber = 14,
    kCapacityFieldNumber = 2,
    kUsedSizeFieldNumber = 3,
    kPeerCountFieldNumber = 8,
    kRegionLeaderCountFieldNumber = 10,
    kRegionCountFieldNumber = 12,
    kStatusFieldNumber = 5,
  };
  // required string address = 1;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional string resource_tag = 4;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional string physical_room = 6;
  bool has_physical_room() const;
  private:
  bool _internal_has_physical_room() const;
  public:
  void clear_physical_room();
  const std::string& physical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_physical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_physical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_physical_room();
  void set_allocated_physical_room(std::string* physical_room);
  private:
  const std::string& _internal_physical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_physical_room(const std::string& value);
  std::string* _internal_mutable_physical_room();
  public:

  // optional string logical_room = 7;
  bool has_logical_room() const;
  private:
  bool _internal_has_logical_room() const;
  public:
  void clear_logical_room();
  const std::string& logical_room() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logical_room(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logical_room();
  PROTOBUF_MUST_USE_RESULT std::string* release_logical_room();
  void set_allocated_logical_room(std::string* logical_room);
  private:
  const std::string& _internal_logical_room() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logical_room(const std::string& value);
  std::string* _internal_mutable_logical_room();
  public:

  // optional string peer_ids = 9;
  bool has_peer_ids() const;
  private:
  bool _internal_has_peer_ids() const;
  public:
  void clear_peer_ids();
  const std::string& peer_ids() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer_ids(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer_ids();
  PROTOBUF_MUST_USE_RESULT std::string* release_peer_ids();
  void set_allocated_peer_ids(std::string* peer_ids);
  private:
  const std::string& _internal_peer_ids() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer_ids(const std::string& value);
  std::string* _internal_mutable_peer_ids();
  public:

  // optional string region_leader_ids = 11;
  bool has_region_leader_ids() const;
  private:
  bool _internal_has_region_leader_ids() const;
  public:
  void clear_region_leader_ids();
  const std::string& region_leader_ids() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region_leader_ids(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region_leader_ids();
  PROTOBUF_MUST_USE_RESULT std::string* release_region_leader_ids();
  void set_allocated_region_leader_ids(std::string* region_leader_ids);
  private:
  const std::string& _internal_region_leader_ids() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region_leader_ids(const std::string& value);
  std::string* _internal_mutable_region_leader_ids();
  public:

  // optional string region_ids = 13;
  bool has_region_ids() const;
  private:
  bool _internal_has_region_ids() const;
  public:
  void clear_region_ids();
  const std::string& region_ids() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region_ids(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region_ids();
  PROTOBUF_MUST_USE_RESULT std::string* release_region_ids();
  void set_allocated_region_ids(std::string* region_ids);
  private:
  const std::string& _internal_region_ids() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region_ids(const std::string& value);
  std::string* _internal_mutable_region_ids();
  public:

  // optional string version = 14;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_MUST_USE_RESULT std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional int64 capacity = 2;
  bool has_capacity() const;
  private:
  bool _internal_has_capacity() const;
  public:
  void clear_capacity();
  ::PROTOBUF_NAMESPACE_ID::int64 capacity() const;
  void set_capacity(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_capacity() const;
  void _internal_set_capacity(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 used_size = 3;
  bool has_used_size() const;
  private:
  bool _internal_has_used_size() const;
  public:
  void clear_used_size();
  ::PROTOBUF_NAMESPACE_ID::int64 used_size() const;
  void set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_used_size() const;
  void _internal_set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 peer_count = 8;
  bool has_peer_count() const;
  private:
  bool _internal_has_peer_count() const;
  public:
  void clear_peer_count();
  ::PROTOBUF_NAMESPACE_ID::int64 peer_count() const;
  void set_peer_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_peer_count() const;
  void _internal_set_peer_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_leader_count = 10;
  bool has_region_leader_count() const;
  private:
  bool _internal_has_region_leader_count() const;
  public:
  void clear_region_leader_count();
  ::PROTOBUF_NAMESPACE_ID::int64 region_leader_count() const;
  void set_region_leader_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_leader_count() const;
  void _internal_set_region_leader_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_count = 12;
  bool has_region_count() const;
  private:
  bool _internal_has_region_count() const;
  public:
  void clear_region_count();
  ::PROTOBUF_NAMESPACE_ID::int64 region_count() const;
  void set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_count() const;
  void _internal_set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.Status status = 5;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::baikaldb::pb::Status status() const;
  void set_status(::baikaldb::pb::Status value);
  private:
  ::baikaldb::pb::Status _internal_status() const;
  void _internal_set_status(::baikaldb::pb::Status value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.QueryInstance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr physical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logical_room_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_leader_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::int64 capacity_;
  ::PROTOBUF_NAMESPACE_ID::int64 used_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 peer_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_leader_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_count_;
  int status_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class QueryRegion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.QueryRegion) */ {
 public:
  inline QueryRegion() : QueryRegion(nullptr) {}
  ~QueryRegion() override;
  explicit constexpr QueryRegion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryRegion(const QueryRegion& from);
  QueryRegion(QueryRegion&& from) noexcept
    : QueryRegion() {
    *this = ::std::move(from);
  }

  inline QueryRegion& operator=(const QueryRegion& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryRegion& operator=(QueryRegion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryRegion& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryRegion* internal_default_instance() {
    return reinterpret_cast<const QueryRegion*>(
               &_QueryRegion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(QueryRegion& a, QueryRegion& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryRegion* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryRegion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryRegion* New() const final {
    return new QueryRegion();
  }

  QueryRegion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryRegion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryRegion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryRegion& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryRegion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.QueryRegion";
  }
  protected:
  explicit QueryRegion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNameFieldNumber = 2,
    kStartKeyFieldNumber = 7,
    kEndKeyFieldNumber = 8,
    kPeersFieldNumber = 9,
    kLeaderFieldNumber = 10,
    kPrimaryKeyFieldNumber = 16,
    kResourceTagFieldNumber = 17,
    kCreateTimeFieldNumber = 19,
    kRawStartKeyFieldNumber = 22,
    kRegionIdFieldNumber = 1,
    kPartitionIdFieldNumber = 3,
    kReplicaNumFieldNumber = 4,
    kVersionFieldNumber = 5,
    kConfVersionFieldNumber = 6,
    kUsedSizeFieldNumber = 12,
    kLogIndexFieldNumber = 13,
    kParentFieldNumber = 18,
    kTableIdFieldNumber = 20,
    kNumTableLinesFieldNumber = 21,
    kMainTableIdFieldNumber = 23,
    kDeletedFieldNumber = 14,
    kCanAddPeerFieldNumber = 15,
    kStatusFieldNumber = 11,
  };
  // optional string table_name = 2;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional bytes start_key = 7;
  bool has_start_key() const;
  private:
  bool _internal_has_start_key() const;
  public:
  void clear_start_key();
  const std::string& start_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_start_key();
  void set_allocated_start_key(std::string* start_key);
  private:
  const std::string& _internal_start_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_key(const std::string& value);
  std::string* _internal_mutable_start_key();
  public:

  // optional bytes end_key = 8;
  bool has_end_key() const;
  private:
  bool _internal_has_end_key() const;
  public:
  void clear_end_key();
  const std::string& end_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_end_key();
  void set_allocated_end_key(std::string* end_key);
  private:
  const std::string& _internal_end_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_key(const std::string& value);
  std::string* _internal_mutable_end_key();
  public:

  // optional string peers = 9;
  bool has_peers() const;
  private:
  bool _internal_has_peers() const;
  public:
  void clear_peers();
  const std::string& peers() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peers(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peers();
  PROTOBUF_MUST_USE_RESULT std::string* release_peers();
  void set_allocated_peers(std::string* peers);
  private:
  const std::string& _internal_peers() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peers(const std::string& value);
  std::string* _internal_mutable_peers();
  public:

  // optional string leader = 10;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // optional string primary_key = 16;
  bool has_primary_key() const;
  private:
  bool _internal_has_primary_key() const;
  public:
  void clear_primary_key();
  const std::string& primary_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_primary_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_primary_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_primary_key();
  void set_allocated_primary_key(std::string* primary_key);
  private:
  const std::string& _internal_primary_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_key(const std::string& value);
  std::string* _internal_mutable_primary_key();
  public:

  // optional string resource_tag = 17;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional string create_time = 19;
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  const std::string& create_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_time();
  PROTOBUF_MUST_USE_RESULT std::string* release_create_time();
  void set_allocated_create_time(std::string* create_time);
  private:
  const std::string& _internal_create_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_time(const std::string& value);
  std::string* _internal_mutable_create_time();
  public:

  // optional string raw_start_key = 22;
  bool has_raw_start_key() const;
  private:
  bool _internal_has_raw_start_key() const;
  public:
  void clear_raw_start_key();
  const std::string& raw_start_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_raw_start_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_raw_start_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_raw_start_key();
  void set_allocated_raw_start_key(std::string* raw_start_key);
  private:
  const std::string& _internal_raw_start_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_start_key(const std::string& value);
  std::string* _internal_mutable_raw_start_key();
  public:

  // required int64 region_id = 1;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 partition_id = 3;
  bool has_partition_id() const;
  private:
  bool _internal_has_partition_id() const;
  public:
  void clear_partition_id();
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id() const;
  void set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_partition_id() const;
  void _internal_set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 replica_num = 4;
  bool has_replica_num() const;
  private:
  bool _internal_has_replica_num() const;
  public:
  void clear_replica_num();
  ::PROTOBUF_NAMESPACE_ID::int64 replica_num() const;
  void set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_replica_num() const;
  void _internal_set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 version = 5;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 conf_version = 6;
  bool has_conf_version() const;
  private:
  bool _internal_has_conf_version() const;
  public:
  void clear_conf_version();
  ::PROTOBUF_NAMESPACE_ID::int64 conf_version() const;
  void set_conf_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_conf_version() const;
  void _internal_set_conf_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 used_size = 12;
  bool has_used_size() const;
  private:
  bool _internal_has_used_size() const;
  public:
  void clear_used_size();
  ::PROTOBUF_NAMESPACE_ID::int64 used_size() const;
  void set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_used_size() const;
  void _internal_set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 log_index = 13;
  bool has_log_index() const;
  private:
  bool _internal_has_log_index() const;
  public:
  void clear_log_index();
  ::PROTOBUF_NAMESPACE_ID::int64 log_index() const;
  void set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_log_index() const;
  void _internal_set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 parent = 18;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  ::PROTOBUF_NAMESPACE_ID::int64 parent() const;
  void set_parent(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_parent() const;
  void _internal_set_parent(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 table_id = 20;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 num_table_lines = 21;
  bool has_num_table_lines() const;
  private:
  bool _internal_has_num_table_lines() const;
  public:
  void clear_num_table_lines();
  ::PROTOBUF_NAMESPACE_ID::int64 num_table_lines() const;
  void set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_num_table_lines() const;
  void _internal_set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 main_table_id = 23;
  bool has_main_table_id() const;
  private:
  bool _internal_has_main_table_id() const;
  public:
  void clear_main_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 main_table_id() const;
  void set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_main_table_id() const;
  void _internal_set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool deleted = 14;
  bool has_deleted() const;
  private:
  bool _internal_has_deleted() const;
  public:
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // optional bool can_add_peer = 15;
  bool has_can_add_peer() const;
  private:
  bool _internal_has_can_add_peer() const;
  public:
  void clear_can_add_peer();
  bool can_add_peer() const;
  void set_can_add_peer(bool value);
  private:
  bool _internal_can_add_peer() const;
  void _internal_set_can_add_peer(bool value);
  public:

  // optional .baikaldb.pb.RegionStatus status = 11;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::baikaldb::pb::RegionStatus status() const;
  void set_status(::baikaldb::pb::RegionStatus value);
  private:
  ::baikaldb::pb::RegionStatus _internal_status() const;
  void _internal_set_status(::baikaldb::pb::RegionStatus value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.QueryRegion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr primary_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_start_key_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 partition_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 replica_num_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  ::PROTOBUF_NAMESPACE_ID::int64 conf_version_;
  ::PROTOBUF_NAMESPACE_ID::int64 used_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 log_index_;
  ::PROTOBUF_NAMESPACE_ID::int64 parent_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_table_lines_;
  ::PROTOBUF_NAMESPACE_ID::int64 main_table_id_;
  bool deleted_;
  bool can_add_peer_;
  int status_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class QueryTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.QueryTable) */ {
 public:
  inline QueryTable() : QueryTable(nullptr) {}
  ~QueryTable() override;
  explicit constexpr QueryTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryTable(const QueryTable& from);
  QueryTable(QueryTable&& from) noexcept
    : QueryTable() {
    *this = ::std::move(from);
  }

  inline QueryTable& operator=(const QueryTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryTable& operator=(QueryTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryTable* internal_default_instance() {
    return reinterpret_cast<const QueryTable*>(
               &_QueryTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(QueryTable& a, QueryTable& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryTable* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QueryTable* New() const final {
    return new QueryTable();
  }

  QueryTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QueryTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryTable& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryTable* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.QueryTable";
  }
  protected:
  explicit QueryTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceNameFieldNumber = 1,
    kDatabaseFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kUpperTableNameFieldNumber = 4,
    kResourceTagFieldNumber = 7,
    kSplitKeysFieldNumber = 12,
    kCreateTimeFieldNumber = 16,
    kBinlogFieldNumber = 23,
    kRegionSizeFieldNumber = 5,
    kReplicaNumFieldNumber = 6,
    kMaxFieldIdFieldNumber = 8,
    kVersionFieldNumber = 10,
    kByteSizePerRecordFieldNumber = 14,
    kTableIdFieldNumber = 15,
    kRegionCountFieldNumber = 17,
    kRowCountFieldNumber = 18,
    kMainTableIdFieldNumber = 19,
    kRegionSplitLinesFieldNumber = 20,
    kPartitionNumFieldNumber = 21,
    kFastImporterTsFieldNumber = 22,
    kDeletedFieldNumber = 13,
    kStatusFieldNumber = 11,
  };
  // required string namespace_name = 1;
  bool has_namespace_name() const;
  private:
  bool _internal_has_namespace_name() const;
  public:
  void clear_namespace_name();
  const std::string& namespace_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_namespace_name();
  void set_allocated_namespace_name(std::string* namespace_name);
  private:
  const std::string& _internal_namespace_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_name(const std::string& value);
  std::string* _internal_mutable_namespace_name();
  public:

  // required string database = 2;
  bool has_database() const;
  private:
  bool _internal_has_database() const;
  public:
  void clear_database();
  const std::string& database() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_database(ArgT0&& arg0, ArgT... args);
  std::string* mutable_database();
  PROTOBUF_MUST_USE_RESULT std::string* release_database();
  void set_allocated_database(std::string* database);
  private:
  const std::string& _internal_database() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_database(const std::string& value);
  std::string* _internal_mutable_database();
  public:

  // required string table_name = 3;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional string upper_table_name = 4;
  bool has_upper_table_name() const;
  private:
  bool _internal_has_upper_table_name() const;
  public:
  void clear_upper_table_name();
  const std::string& upper_table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_upper_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_upper_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_upper_table_name();
  void set_allocated_upper_table_name(std::string* upper_table_name);
  private:
  const std::string& _internal_upper_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_upper_table_name(const std::string& value);
  std::string* _internal_mutable_upper_table_name();
  public:

  // required string resource_tag = 7;
  bool has_resource_tag() const;
  private:
  bool _internal_has_resource_tag() const;
  public:
  void clear_resource_tag();
  const std::string& resource_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resource_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resource_tag();
  PROTOBUF_MUST_USE_RESULT std::string* release_resource_tag();
  void set_allocated_resource_tag(std::string* resource_tag);
  private:
  const std::string& _internal_resource_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_tag(const std::string& value);
  std::string* _internal_mutable_resource_tag();
  public:

  // optional string split_keys = 12;
  bool has_split_keys() const;
  private:
  bool _internal_has_split_keys() const;
  public:
  void clear_split_keys();
  const std::string& split_keys() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_split_keys(ArgT0&& arg0, ArgT... args);
  std::string* mutable_split_keys();
  PROTOBUF_MUST_USE_RESULT std::string* release_split_keys();
  void set_allocated_split_keys(std::string* split_keys);
  private:
  const std::string& _internal_split_keys() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_split_keys(const std::string& value);
  std::string* _internal_mutable_split_keys();
  public:

  // optional string create_time = 16;
  bool has_create_time() const;
  private:
  bool _internal_has_create_time() const;
  public:
  void clear_create_time();
  const std::string& create_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_time();
  PROTOBUF_MUST_USE_RESULT std::string* release_create_time();
  void set_allocated_create_time(std::string* create_time);
  private:
  const std::string& _internal_create_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_time(const std::string& value);
  std::string* _internal_mutable_create_time();
  public:

  // optional string binlog = 23;
  bool has_binlog() const;
  private:
  bool _internal_has_binlog() const;
  public:
  void clear_binlog();
  const std::string& binlog() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_binlog(ArgT0&& arg0, ArgT... args);
  std::string* mutable_binlog();
  PROTOBUF_MUST_USE_RESULT std::string* release_binlog();
  void set_allocated_binlog(std::string* binlog);
  private:
  const std::string& _internal_binlog() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_binlog(const std::string& value);
  std::string* _internal_mutable_binlog();
  public:

  // required int64 region_size = 5;
  bool has_region_size() const;
  private:
  bool _internal_has_region_size() const;
  public:
  void clear_region_size();
  ::PROTOBUF_NAMESPACE_ID::int64 region_size() const;
  void set_region_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_size() const;
  void _internal_set_region_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 replica_num = 6;
  bool has_replica_num() const;
  private:
  bool _internal_has_replica_num() const;
  public:
  void clear_replica_num();
  ::PROTOBUF_NAMESPACE_ID::int64 replica_num() const;
  void set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_replica_num() const;
  void _internal_set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 max_field_id = 8;
  bool has_max_field_id() const;
  private:
  bool _internal_has_max_field_id() const;
  public:
  void clear_max_field_id();
  ::PROTOBUF_NAMESPACE_ID::int64 max_field_id() const;
  void set_max_field_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_max_field_id() const;
  void _internal_set_max_field_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 version = 10;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 byte_size_per_record = 14;
  bool has_byte_size_per_record() const;
  private:
  bool _internal_has_byte_size_per_record() const;
  public:
  void clear_byte_size_per_record();
  ::PROTOBUF_NAMESPACE_ID::int64 byte_size_per_record() const;
  void set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_byte_size_per_record() const;
  void _internal_set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 table_id = 15;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_count = 17;
  bool has_region_count() const;
  private:
  bool _internal_has_region_count() const;
  public:
  void clear_region_count();
  ::PROTOBUF_NAMESPACE_ID::int64 region_count() const;
  void set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_count() const;
  void _internal_set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 row_count = 18;
  bool has_row_count() const;
  private:
  bool _internal_has_row_count() const;
  public:
  void clear_row_count();
  ::PROTOBUF_NAMESPACE_ID::int64 row_count() const;
  void set_row_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_row_count() const;
  void _internal_set_row_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 main_table_id = 19;
  bool has_main_table_id() const;
  private:
  bool _internal_has_main_table_id() const;
  public:
  void clear_main_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 main_table_id() const;
  void set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_main_table_id() const;
  void _internal_set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_split_lines = 20;
  bool has_region_split_lines() const;
  private:
  bool _internal_has_region_split_lines() const;
  public:
  void clear_region_split_lines();
  ::PROTOBUF_NAMESPACE_ID::int64 region_split_lines() const;
  void set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_split_lines() const;
  void _internal_set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 partition_num = 21;
  bool has_partition_num() const;
  private:
  bool _internal_has_partition_num() const;
  public:
  void clear_partition_num();
  ::PROTOBUF_NAMESPACE_ID::int64 partition_num() const;
  void set_partition_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_partition_num() const;
  void _internal_set_partition_num(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 fast_importer_ts = 22;
  bool has_fast_importer_ts() const;
  private:
  bool _internal_has_fast_importer_ts() const;
  public:
  void clear_fast_importer_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 fast_importer_ts() const;
  void set_fast_importer_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_fast_importer_ts() const;
  void _internal_set_fast_importer_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required bool deleted = 13;
  bool has_deleted() const;
  private:
  bool _internal_has_deleted() const;
  public:
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // required .baikaldb.pb.Status status = 11;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::baikaldb::pb::Status status() const;
  void set_status(::baikaldb::pb::Status value);
  private:
  ::baikaldb::pb::Status _internal_status() const;
  void _internal_set_status(::baikaldb::pb::Status value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.QueryTable)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr database_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr upper_table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr split_keys_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr binlog_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 replica_num_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_field_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  ::PROTOBUF_NAMESPACE_ID::int64 byte_size_per_record_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 row_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 main_table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_split_lines_;
  ::PROTOBUF_NAMESPACE_ID::int64 partition_num_;
  ::PROTOBUF_NAMESPACE_ID::int64 fast_importer_ts_;
  bool deleted_;
  int status_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class QuerySchema final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.QuerySchema) */ {
 public:
  inline QuerySchema() : QuerySchema(nullptr) {}
  ~QuerySchema() override;
  explicit constexpr QuerySchema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuerySchema(const QuerySchema& from);
  QuerySchema(QuerySchema&& from) noexcept
    : QuerySchema() {
    *this = ::std::move(from);
  }

  inline QuerySchema& operator=(const QuerySchema& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuerySchema& operator=(QuerySchema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuerySchema& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuerySchema* internal_default_instance() {
    return reinterpret_cast<const QuerySchema*>(
               &_QuerySchema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(QuerySchema& a, QuerySchema& b) {
    a.Swap(&b);
  }
  inline void Swap(QuerySchema* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuerySchema* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QuerySchema* New() const final {
    return new QuerySchema();
  }

  QuerySchema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QuerySchema>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuerySchema& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QuerySchema& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuerySchema* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.QuerySchema";
  }
  protected:
  explicit QuerySchema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldOrIndexFieldNumber = 1,
    kColumnNameFieldNumber = 2,
    kColumnTypeFieldNumber = 4,
    kExtraFieldNumber = 6,
    kDefaultValueFieldNumber = 8,
    kCommentFieldNumber = 9,
    kColumnIdFieldNumber = 3,
    kCanNullFieldNumber = 5,
    kDeletedFieldNumber = 7,
  };
  // required string field_or_index = 1;
  bool has_field_or_index() const;
  private:
  bool _internal_has_field_or_index() const;
  public:
  void clear_field_or_index();
  const std::string& field_or_index() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field_or_index(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field_or_index();
  PROTOBUF_MUST_USE_RESULT std::string* release_field_or_index();
  void set_allocated_field_or_index(std::string* field_or_index);
  private:
  const std::string& _internal_field_or_index() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field_or_index(const std::string& value);
  std::string* _internal_mutable_field_or_index();
  public:

  // required string column_name = 2;
  bool has_column_name() const;
  private:
  bool _internal_has_column_name() const;
  public:
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // required string column_type = 4;
  bool has_column_type() const;
  private:
  bool _internal_has_column_type() const;
  public:
  void clear_column_type();
  const std::string& column_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_column_type();
  void set_allocated_column_type(std::string* column_type);
  private:
  const std::string& _internal_column_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_type(const std::string& value);
  std::string* _internal_mutable_column_type();
  public:

  // optional string extra = 6;
  bool has_extra() const;
  private:
  bool _internal_has_extra() const;
  public:
  void clear_extra();
  const std::string& extra() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra();
  PROTOBUF_MUST_USE_RESULT std::string* release_extra();
  void set_allocated_extra(std::string* extra);
  private:
  const std::string& _internal_extra() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra(const std::string& value);
  std::string* _internal_mutable_extra();
  public:

  // optional string default_value = 8;
  bool has_default_value() const;
  private:
  bool _internal_has_default_value() const;
  public:
  void clear_default_value();
  const std::string& default_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_default_value();
  void set_allocated_default_value(std::string* default_value);
  private:
  const std::string& _internal_default_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_value(const std::string& value);
  std::string* _internal_mutable_default_value();
  public:

  // optional string comment = 9;
  bool has_comment() const;
  private:
  bool _internal_has_comment() const;
  public:
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_MUST_USE_RESULT std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // required int64 column_id = 3;
  bool has_column_id() const;
  private:
  bool _internal_has_column_id() const;
  public:
  void clear_column_id();
  ::PROTOBUF_NAMESPACE_ID::int64 column_id() const;
  void set_column_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_column_id() const;
  void _internal_set_column_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool can_null = 5;
  bool has_can_null() const;
  private:
  bool _internal_has_can_null() const;
  public:
  void clear_can_null();
  bool can_null() const;
  void set_can_null(bool value);
  private:
  bool _internal_can_null() const;
  void _internal_set_can_null(bool value);
  public:

  // optional bool deleted = 7;
  bool has_deleted() const;
  private:
  bool _internal_has_deleted() const;
  public:
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.QuerySchema)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_or_index_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
  ::PROTOBUF_NAMESPACE_ID::int64 column_id_;
  bool can_null_;
  bool deleted_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class MigrateInstance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.MigrateInstance) */ {
 public:
  inline MigrateInstance() : MigrateInstance(nullptr) {}
  ~MigrateInstance() override;
  explicit constexpr MigrateInstance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MigrateInstance(const MigrateInstance& from);
  MigrateInstance(MigrateInstance&& from) noexcept
    : MigrateInstance() {
    *this = ::std::move(from);
  }

  inline MigrateInstance& operator=(const MigrateInstance& from) {
    CopyFrom(from);
    return *this;
  }
  inline MigrateInstance& operator=(MigrateInstance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MigrateInstance& default_instance() {
    return *internal_default_instance();
  }
  static inline const MigrateInstance* internal_default_instance() {
    return reinterpret_cast<const MigrateInstance*>(
               &_MigrateInstance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(MigrateInstance& a, MigrateInstance& b) {
    a.Swap(&b);
  }
  inline void Swap(MigrateInstance* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MigrateInstance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MigrateInstance* New() const final {
    return new MigrateInstance();
  }

  MigrateInstance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MigrateInstance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MigrateInstance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MigrateInstance& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MigrateInstance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.MigrateInstance";
  }
  protected:
  explicit MigrateInstance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kEventFieldNumber = 2,
    kPreHostFieldNumber = 3,
    kPrePortFieldNumber = 4,
    kPostHostFieldNumber = 5,
    kPostPortFieldNumber = 6,
    kStatusFieldNumber = 7,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string event = 2;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const std::string& event() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event();
  PROTOBUF_MUST_USE_RESULT std::string* release_event();
  void set_allocated_event(std::string* event);
  private:
  const std::string& _internal_event() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event(const std::string& value);
  std::string* _internal_mutable_event();
  public:

  // optional string pre_host = 3;
  bool has_pre_host() const;
  private:
  bool _internal_has_pre_host() const;
  public:
  void clear_pre_host();
  const std::string& pre_host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pre_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pre_host();
  PROTOBUF_MUST_USE_RESULT std::string* release_pre_host();
  void set_allocated_pre_host(std::string* pre_host);
  private:
  const std::string& _internal_pre_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pre_host(const std::string& value);
  std::string* _internal_mutable_pre_host();
  public:

  // optional string pre_port = 4;
  bool has_pre_port() const;
  private:
  bool _internal_has_pre_port() const;
  public:
  void clear_pre_port();
  const std::string& pre_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pre_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pre_port();
  PROTOBUF_MUST_USE_RESULT std::string* release_pre_port();
  void set_allocated_pre_port(std::string* pre_port);
  private:
  const std::string& _internal_pre_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pre_port(const std::string& value);
  std::string* _internal_mutable_pre_port();
  public:

  // optional string post_host = 5;
  bool has_post_host() const;
  private:
  bool _internal_has_post_host() const;
  public:
  void clear_post_host();
  const std::string& post_host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_post_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_post_host();
  PROTOBUF_MUST_USE_RESULT std::string* release_post_host();
  void set_allocated_post_host(std::string* post_host);
  private:
  const std::string& _internal_post_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_post_host(const std::string& value);
  std::string* _internal_mutable_post_host();
  public:

  // optional string post_port = 6;
  bool has_post_port() const;
  private:
  bool _internal_has_post_port() const;
  public:
  void clear_post_port();
  const std::string& post_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_post_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_post_port();
  PROTOBUF_MUST_USE_RESULT std::string* release_post_port();
  void set_allocated_post_port(std::string* post_port);
  private:
  const std::string& _internal_post_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_post_port(const std::string& value);
  std::string* _internal_mutable_post_port();
  public:

  // optional string status = 7;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_MUST_USE_RESULT std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.MigrateInstance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pre_host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pre_port_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr post_host_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr post_port_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class TargetsList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TargetsList) */ {
 public:
  inline TargetsList() : TargetsList(nullptr) {}
  ~TargetsList() override;
  explicit constexpr TargetsList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetsList(const TargetsList& from);
  TargetsList(TargetsList&& from) noexcept
    : TargetsList() {
    *this = ::std::move(from);
  }

  inline TargetsList& operator=(const TargetsList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetsList& operator=(TargetsList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetsList& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetsList* internal_default_instance() {
    return reinterpret_cast<const TargetsList*>(
               &_TargetsList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(TargetsList& a, TargetsList& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetsList* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetsList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TargetsList* New() const final {
    return new TargetsList();
  }

  TargetsList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TargetsList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TargetsList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TargetsList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetsList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TargetsList";
  }
  protected:
  explicit TargetsList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstancesFieldNumber = 1,
  };
  // repeated .baikaldb.pb.MigrateInstance instances = 1;
  int instances_size() const;
  private:
  int _internal_instances_size() const;
  public:
  void clear_instances();
  ::baikaldb::pb::MigrateInstance* mutable_instances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::MigrateInstance >*
      mutable_instances();
  private:
  const ::baikaldb::pb::MigrateInstance& _internal_instances(int index) const;
  ::baikaldb::pb::MigrateInstance* _internal_add_instances();
  public:
  const ::baikaldb::pb::MigrateInstance& instances(int index) const;
  ::baikaldb::pb::MigrateInstance* add_instances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::MigrateInstance >&
      instances() const;

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TargetsList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::MigrateInstance > instances_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class MigrateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.MigrateRequest) */ {
 public:
  inline MigrateRequest() : MigrateRequest(nullptr) {}
  ~MigrateRequest() override;
  explicit constexpr MigrateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MigrateRequest(const MigrateRequest& from);
  MigrateRequest(MigrateRequest&& from) noexcept
    : MigrateRequest() {
    *this = ::std::move(from);
  }

  inline MigrateRequest& operator=(const MigrateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MigrateRequest& operator=(MigrateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MigrateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MigrateRequest* internal_default_instance() {
    return reinterpret_cast<const MigrateRequest*>(
               &_MigrateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(MigrateRequest& a, MigrateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MigrateRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MigrateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MigrateRequest* New() const final {
    return new MigrateRequest();
  }

  MigrateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MigrateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MigrateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MigrateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MigrateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.MigrateRequest";
  }
  protected:
  explicit MigrateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperaActionFieldNumber = 1,
    kTargetsListFieldNumber = 2,
  };
  // optional string opera_action = 1;
  bool has_opera_action() const;
  private:
  bool _internal_has_opera_action() const;
  public:
  void clear_opera_action();
  const std::string& opera_action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_opera_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_opera_action();
  PROTOBUF_MUST_USE_RESULT std::string* release_opera_action();
  void set_allocated_opera_action(std::string* opera_action);
  private:
  const std::string& _internal_opera_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_opera_action(const std::string& value);
  std::string* _internal_mutable_opera_action();
  public:

  // optional .baikaldb.pb.TargetsList targets_list = 2;
  bool has_targets_list() const;
  private:
  bool _internal_has_targets_list() const;
  public:
  void clear_targets_list();
  const ::baikaldb::pb::TargetsList& targets_list() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::TargetsList* release_targets_list();
  ::baikaldb::pb::TargetsList* mutable_targets_list();
  void set_allocated_targets_list(::baikaldb::pb::TargetsList* targets_list);
  private:
  const ::baikaldb::pb::TargetsList& _internal_targets_list() const;
  ::baikaldb::pb::TargetsList* _internal_mutable_targets_list();
  public:
  void unsafe_arena_set_allocated_targets_list(
      ::baikaldb::pb::TargetsList* targets_list);
  ::baikaldb::pb::TargetsList* unsafe_arena_release_targets_list();

  // @@protoc_insertion_point(class_scope:baikaldb.pb.MigrateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr opera_action_;
  ::baikaldb::pb::TargetsList* targets_list_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class MigrateData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.MigrateData) */ {
 public:
  inline MigrateData() : MigrateData(nullptr) {}
  ~MigrateData() override;
  explicit constexpr MigrateData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MigrateData(const MigrateData& from);
  MigrateData(MigrateData&& from) noexcept
    : MigrateData() {
    *this = ::std::move(from);
  }

  inline MigrateData& operator=(const MigrateData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MigrateData& operator=(MigrateData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MigrateData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MigrateData* internal_default_instance() {
    return reinterpret_cast<const MigrateData*>(
               &_MigrateData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(MigrateData& a, MigrateData& b) {
    a.Swap(&b);
  }
  inline void Swap(MigrateData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MigrateData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MigrateData* New() const final {
    return new MigrateData();
  }

  MigrateData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MigrateData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MigrateData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MigrateData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MigrateData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.MigrateData";
  }
  protected:
  explicit MigrateData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetsListFieldNumber = 1,
  };
  // optional .baikaldb.pb.TargetsList targets_list = 1;
  bool has_targets_list() const;
  private:
  bool _internal_has_targets_list() const;
  public:
  void clear_targets_list();
  const ::baikaldb::pb::TargetsList& targets_list() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::TargetsList* release_targets_list();
  ::baikaldb::pb::TargetsList* mutable_targets_list();
  void set_allocated_targets_list(::baikaldb::pb::TargetsList* targets_list);
  private:
  const ::baikaldb::pb::TargetsList& _internal_targets_list() const;
  ::baikaldb::pb::TargetsList* _internal_mutable_targets_list();
  public:
  void unsafe_arena_set_allocated_targets_list(
      ::baikaldb::pb::TargetsList* targets_list);
  ::baikaldb::pb::TargetsList* unsafe_arena_release_targets_list();

  // @@protoc_insertion_point(class_scope:baikaldb.pb.MigrateData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::TargetsList* targets_list_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class MigrateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.MigrateResponse) */ {
 public:
  inline MigrateResponse() : MigrateResponse(nullptr) {}
  ~MigrateResponse() override;
  explicit constexpr MigrateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MigrateResponse(const MigrateResponse& from);
  MigrateResponse(MigrateResponse&& from) noexcept
    : MigrateResponse() {
    *this = ::std::move(from);
  }

  inline MigrateResponse& operator=(const MigrateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MigrateResponse& operator=(MigrateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MigrateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MigrateResponse* internal_default_instance() {
    return reinterpret_cast<const MigrateResponse*>(
               &_MigrateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(MigrateResponse& a, MigrateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MigrateResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MigrateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MigrateResponse* New() const final {
    return new MigrateResponse();
  }

  MigrateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MigrateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MigrateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MigrateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MigrateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.MigrateResponse";
  }
  protected:
  explicit MigrateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // optional .baikaldb.pb.MigrateData data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::baikaldb::pb::MigrateData& data() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::MigrateData* release_data();
  ::baikaldb::pb::MigrateData* mutable_data();
  void set_allocated_data(::baikaldb::pb::MigrateData* data);
  private:
  const ::baikaldb::pb::MigrateData& _internal_data() const;
  ::baikaldb::pb::MigrateData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::baikaldb::pb::MigrateData* data);
  ::baikaldb::pb::MigrateData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:baikaldb.pb.MigrateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::MigrateData* data_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class TableInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TableInfo) */ {
 public:
  inline TableInfo() : TableInfo(nullptr) {}
  ~TableInfo() override;
  explicit constexpr TableInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableInfo(const TableInfo& from);
  TableInfo(TableInfo&& from) noexcept
    : TableInfo() {
    *this = ::std::move(from);
  }

  inline TableInfo& operator=(const TableInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableInfo& operator=(TableInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableInfo* internal_default_instance() {
    return reinterpret_cast<const TableInfo*>(
               &_TableInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(TableInfo& a, TableInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TableInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TableInfo* New() const final {
    return new TableInfo();
  }

  TableInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TableInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TableInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TableInfo";
  }
  protected:
  explicit TableInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemaInfoFieldNumber = 1,
    kRowCountFieldNumber = 2,
    kRegionCountFieldNumber = 3,
    kTableIdFieldNumber = 4,
    kMainTableIdFieldNumber = 6,
    kDeletedFieldNumber = 5,
  };
  // optional .baikaldb.pb.SchemaInfo schema_info = 1;
  bool has_schema_info() const;
  private:
  bool _internal_has_schema_info() const;
  public:
  void clear_schema_info();
  const ::baikaldb::pb::SchemaInfo& schema_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::SchemaInfo* release_schema_info();
  ::baikaldb::pb::SchemaInfo* mutable_schema_info();
  void set_allocated_schema_info(::baikaldb::pb::SchemaInfo* schema_info);
  private:
  const ::baikaldb::pb::SchemaInfo& _internal_schema_info() const;
  ::baikaldb::pb::SchemaInfo* _internal_mutable_schema_info();
  public:
  void unsafe_arena_set_allocated_schema_info(
      ::baikaldb::pb::SchemaInfo* schema_info);
  ::baikaldb::pb::SchemaInfo* unsafe_arena_release_schema_info();

  // optional int64 row_count = 2;
  bool has_row_count() const;
  private:
  bool _internal_has_row_count() const;
  public:
  void clear_row_count();
  ::PROTOBUF_NAMESPACE_ID::int64 row_count() const;
  void set_row_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_row_count() const;
  void _internal_set_row_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_count = 3;
  bool has_region_count() const;
  private:
  bool _internal_has_region_count() const;
  public:
  void clear_region_count();
  ::PROTOBUF_NAMESPACE_ID::int64 region_count() const;
  void set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_count() const;
  void _internal_set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 table_id = 4;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 main_table_id = 6;
  bool has_main_table_id() const;
  private:
  bool _internal_has_main_table_id() const;
  public:
  void clear_main_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 main_table_id() const;
  void set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_main_table_id() const;
  void _internal_set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool deleted = 5;
  bool has_deleted() const;
  private:
  bool _internal_has_deleted() const;
  public:
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TableInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::SchemaInfo* schema_info_;
  ::PROTOBUF_NAMESPACE_ID::int64 row_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_count_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 main_table_id_;
  bool deleted_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RegionChangeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RegionChangeInfo) */ {
 public:
  inline RegionChangeInfo() : RegionChangeInfo(nullptr) {}
  ~RegionChangeInfo() override;
  explicit constexpr RegionChangeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionChangeInfo(const RegionChangeInfo& from);
  RegionChangeInfo(RegionChangeInfo&& from) noexcept
    : RegionChangeInfo() {
    *this = ::std::move(from);
  }

  inline RegionChangeInfo& operator=(const RegionChangeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionChangeInfo& operator=(RegionChangeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionChangeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionChangeInfo* internal_default_instance() {
    return reinterpret_cast<const RegionChangeInfo*>(
               &_RegionChangeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(RegionChangeInfo& a, RegionChangeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionChangeInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionChangeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionChangeInfo* New() const final {
    return new RegionChangeInfo();
  }

  RegionChangeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionChangeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionChangeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegionChangeInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionChangeInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RegionChangeInfo";
  }
  protected:
  explicit RegionChangeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionInfoFieldNumber = 1,
    kRegionIdFieldNumber = 2,
    kUsedSizeFieldNumber = 3,
    kNumTableLinesFieldNumber = 4,
  };
  // optional .baikaldb.pb.RegionInfo region_info = 1;
  bool has_region_info() const;
  private:
  bool _internal_has_region_info() const;
  public:
  void clear_region_info();
  const ::baikaldb::pb::RegionInfo& region_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::RegionInfo* release_region_info();
  ::baikaldb::pb::RegionInfo* mutable_region_info();
  void set_allocated_region_info(::baikaldb::pb::RegionInfo* region_info);
  private:
  const ::baikaldb::pb::RegionInfo& _internal_region_info() const;
  ::baikaldb::pb::RegionInfo* _internal_mutable_region_info();
  public:
  void unsafe_arena_set_allocated_region_info(
      ::baikaldb::pb::RegionInfo* region_info);
  ::baikaldb::pb::RegionInfo* unsafe_arena_release_region_info();

  // optional int64 region_id = 2;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 used_size = 3;
  bool has_used_size() const;
  private:
  bool _internal_has_used_size() const;
  public:
  void clear_used_size();
  ::PROTOBUF_NAMESPACE_ID::int64 used_size() const;
  void set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_used_size() const;
  void _internal_set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 num_table_lines = 4;
  bool has_num_table_lines() const;
  private:
  bool _internal_has_num_table_lines() const;
  public:
  void clear_num_table_lines();
  ::PROTOBUF_NAMESPACE_ID::int64 num_table_lines() const;
  void set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_num_table_lines() const;
  void _internal_set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RegionChangeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::RegionInfo* region_info_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 used_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_table_lines_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class DdlWorkInfoHeartBeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.DdlWorkInfoHeartBeat) */ {
 public:
  inline DdlWorkInfoHeartBeat() : DdlWorkInfoHeartBeat(nullptr) {}
  ~DdlWorkInfoHeartBeat() override;
  explicit constexpr DdlWorkInfoHeartBeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DdlWorkInfoHeartBeat(const DdlWorkInfoHeartBeat& from);
  DdlWorkInfoHeartBeat(DdlWorkInfoHeartBeat&& from) noexcept
    : DdlWorkInfoHeartBeat() {
    *this = ::std::move(from);
  }

  inline DdlWorkInfoHeartBeat& operator=(const DdlWorkInfoHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline DdlWorkInfoHeartBeat& operator=(DdlWorkInfoHeartBeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DdlWorkInfoHeartBeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const DdlWorkInfoHeartBeat* internal_default_instance() {
    return reinterpret_cast<const DdlWorkInfoHeartBeat*>(
               &_DdlWorkInfoHeartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(DdlWorkInfoHeartBeat& a, DdlWorkInfoHeartBeat& b) {
    a.Swap(&b);
  }
  inline void Swap(DdlWorkInfoHeartBeat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DdlWorkInfoHeartBeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DdlWorkInfoHeartBeat* New() const final {
    return new DdlWorkInfoHeartBeat();
  }

  DdlWorkInfoHeartBeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DdlWorkInfoHeartBeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DdlWorkInfoHeartBeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DdlWorkInfoHeartBeat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DdlWorkInfoHeartBeat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.DdlWorkInfoHeartBeat";
  }
  protected:
  explicit DdlWorkInfoHeartBeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableIdFieldNumber = 1,
    kOpTypeFieldNumber = 2,
    kRollbackFieldNumber = 5,
    kRegionIdFieldNumber = 4,
    kBeginTimestampFieldNumber = 6,
    kErrcodeFieldNumber = 7,
    kJobStateFieldNumber = 3,
  };
  // optional int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.OpType op_type = 2;
  bool has_op_type() const;
  private:
  bool _internal_has_op_type() const;
  public:
  void clear_op_type();
  ::baikaldb::pb::OpType op_type() const;
  void set_op_type(::baikaldb::pb::OpType value);
  private:
  ::baikaldb::pb::OpType _internal_op_type() const;
  void _internal_set_op_type(::baikaldb::pb::OpType value);
  public:

  // optional bool rollback = 5 [default = false];
  bool has_rollback() const;
  private:
  bool _internal_has_rollback() const;
  public:
  void clear_rollback();
  bool rollback() const;
  void set_rollback(bool value);
  private:
  bool _internal_rollback() const;
  void _internal_set_rollback(bool value);
  public:

  // optional int64 region_id = 4;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint32 begin_timestamp = 6;
  bool has_begin_timestamp() const;
  private:
  bool _internal_has_begin_timestamp() const;
  public:
  void clear_begin_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint32 begin_timestamp() const;
  void set_begin_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_begin_timestamp() const;
  void _internal_set_begin_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .baikaldb.pb.ErrCode errcode = 7;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::ErrCode errcode() const;
  void set_errcode(::baikaldb::pb::ErrCode value);
  private:
  ::baikaldb::pb::ErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::ErrCode value);
  public:

  // optional .baikaldb.pb.IndexState job_state = 3;
  bool has_job_state() const;
  private:
  bool _internal_has_job_state() const;
  public:
  void clear_job_state();
  ::baikaldb::pb::IndexState job_state() const;
  void set_job_state(::baikaldb::pb::IndexState value);
  private:
  ::baikaldb::pb::IndexState _internal_job_state() const;
  void _internal_set_job_state(::baikaldb::pb::IndexState value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.DdlWorkInfoHeartBeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  int op_type_;
  bool rollback_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 begin_timestamp_;
  int errcode_;
  int job_state_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class DdlWorkInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.DdlWorkInfo) */ {
 public:
  inline DdlWorkInfo() : DdlWorkInfo(nullptr) {}
  ~DdlWorkInfo() override;
  explicit constexpr DdlWorkInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DdlWorkInfo(const DdlWorkInfo& from);
  DdlWorkInfo(DdlWorkInfo&& from) noexcept
    : DdlWorkInfo() {
    *this = ::std::move(from);
  }

  inline DdlWorkInfo& operator=(const DdlWorkInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DdlWorkInfo& operator=(DdlWorkInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DdlWorkInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DdlWorkInfo* internal_default_instance() {
    return reinterpret_cast<const DdlWorkInfo*>(
               &_DdlWorkInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(DdlWorkInfo& a, DdlWorkInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DdlWorkInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DdlWorkInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DdlWorkInfo* New() const final {
    return new DdlWorkInfo();
  }

  DdlWorkInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DdlWorkInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DdlWorkInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DdlWorkInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DdlWorkInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.DdlWorkInfo";
  }
  protected:
  explicit DdlWorkInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptSqlFieldNumber = 16,
    kColumnDdlInfoFieldNumber = 15,
    kTableIdFieldNumber = 1,
    kIndexIdFieldNumber = 4,
    kBeginTimestampFieldNumber = 5,
    kOpTypeFieldNumber = 2,
    kErrcodeFieldNumber = 8,
    kEndTimestampFieldNumber = 6,
    kRollbackFieldNumber = 7,
    kDeletedFieldNumber = 9,
    kSuspendFieldNumber = 11,
    kGlobalFieldNumber = 13,
    kDropIndexFieldNumber = 14,
    kIsRollupFieldNumber = 17,
    kUpdateTimestampFieldNumber = 12,
    kJobStateFieldNumber = 3,
    kStatusFieldNumber = 10,
  };
  // optional string opt_sql = 16;
  bool has_opt_sql() const;
  private:
  bool _internal_has_opt_sql() const;
  public:
  void clear_opt_sql();
  const std::string& opt_sql() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_opt_sql(ArgT0&& arg0, ArgT... args);
  std::string* mutable_opt_sql();
  PROTOBUF_MUST_USE_RESULT std::string* release_opt_sql();
  void set_allocated_opt_sql(std::string* opt_sql);
  private:
  const std::string& _internal_opt_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_opt_sql(const std::string& value);
  std::string* _internal_mutable_opt_sql();
  public:

  // optional .baikaldb.pb.ColumnDdlInfo column_ddl_info = 15;
  bool has_column_ddl_info() const;
  private:
  bool _internal_has_column_ddl_info() const;
  public:
  void clear_column_ddl_info();
  const ::baikaldb::pb::ColumnDdlInfo& column_ddl_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::ColumnDdlInfo* release_column_ddl_info();
  ::baikaldb::pb::ColumnDdlInfo* mutable_column_ddl_info();
  void set_allocated_column_ddl_info(::baikaldb::pb::ColumnDdlInfo* column_ddl_info);
  private:
  const ::baikaldb::pb::ColumnDdlInfo& _internal_column_ddl_info() const;
  ::baikaldb::pb::ColumnDdlInfo* _internal_mutable_column_ddl_info();
  public:
  void unsafe_arena_set_allocated_column_ddl_info(
      ::baikaldb::pb::ColumnDdlInfo* column_ddl_info);
  ::baikaldb::pb::ColumnDdlInfo* unsafe_arena_release_column_ddl_info();

  // optional int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 index_id = 4;
  bool has_index_id() const;
  private:
  bool _internal_has_index_id() const;
  public:
  void clear_index_id();
  ::PROTOBUF_NAMESPACE_ID::int64 index_id() const;
  void set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_index_id() const;
  void _internal_set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 begin_timestamp = 5;
  bool has_begin_timestamp() const;
  private:
  bool _internal_has_begin_timestamp() const;
  public:
  void clear_begin_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 begin_timestamp() const;
  void set_begin_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_begin_timestamp() const;
  void _internal_set_begin_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.OpType op_type = 2;
  bool has_op_type() const;
  private:
  bool _internal_has_op_type() const;
  public:
  void clear_op_type();
  ::baikaldb::pb::OpType op_type() const;
  void set_op_type(::baikaldb::pb::OpType value);
  private:
  ::baikaldb::pb::OpType _internal_op_type() const;
  void _internal_set_op_type(::baikaldb::pb::OpType value);
  public:

  // optional .baikaldb.pb.ErrCode errcode = 8;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::ErrCode errcode() const;
  void set_errcode(::baikaldb::pb::ErrCode value);
  private:
  ::baikaldb::pb::ErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::ErrCode value);
  public:

  // optional int64 end_timestamp = 6;
  bool has_end_timestamp() const;
  private:
  bool _internal_has_end_timestamp() const;
  public:
  void clear_end_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 end_timestamp() const;
  void set_end_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_end_timestamp() const;
  void _internal_set_end_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool rollback = 7 [default = false];
  bool has_rollback() const;
  private:
  bool _internal_has_rollback() const;
  public:
  void clear_rollback();
  bool rollback() const;
  void set_rollback(bool value);
  private:
  bool _internal_rollback() const;
  void _internal_set_rollback(bool value);
  public:

  // optional bool deleted = 9 [default = false];
  bool has_deleted() const;
  private:
  bool _internal_has_deleted() const;
  public:
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // optional bool suspend = 11;
  bool has_suspend() const;
  private:
  bool _internal_has_suspend() const;
  public:
  void clear_suspend();
  bool suspend() const;
  void set_suspend(bool value);
  private:
  bool _internal_suspend() const;
  void _internal_set_suspend(bool value);
  public:

  // optional bool global = 13;
  bool has_global() const;
  private:
  bool _internal_has_global() const;
  public:
  void clear_global();
  bool global() const;
  void set_global(bool value);
  private:
  bool _internal_global() const;
  void _internal_set_global(bool value);
  public:

  // optional bool drop_index = 14;
  bool has_drop_index() const;
  private:
  bool _internal_has_drop_index() const;
  public:
  void clear_drop_index();
  bool drop_index() const;
  void set_drop_index(bool value);
  private:
  bool _internal_drop_index() const;
  void _internal_set_drop_index(bool value);
  public:

  // optional bool is_rollup = 17;
  bool has_is_rollup() const;
  private:
  bool _internal_has_is_rollup() const;
  public:
  void clear_is_rollup();
  bool is_rollup() const;
  void set_is_rollup(bool value);
  private:
  bool _internal_is_rollup() const;
  void _internal_set_is_rollup(bool value);
  public:

  // optional int64 update_timestamp = 12;
  bool has_update_timestamp() const;
  private:
  bool _internal_has_update_timestamp() const;
  public:
  void clear_update_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 update_timestamp() const;
  void set_update_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_update_timestamp() const;
  void _internal_set_update_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.IndexState job_state = 3;
  bool has_job_state() const;
  private:
  bool _internal_has_job_state() const;
  public:
  void clear_job_state();
  ::baikaldb::pb::IndexState job_state() const;
  void set_job_state(::baikaldb::pb::IndexState value);
  private:
  ::baikaldb::pb::IndexState _internal_job_state() const;
  void _internal_set_job_state(::baikaldb::pb::IndexState value);
  public:

  // optional .baikaldb.pb.DdlWorkStatus status = 10;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::baikaldb::pb::DdlWorkStatus status() const;
  void set_status(::baikaldb::pb::DdlWorkStatus value);
  private:
  ::baikaldb::pb::DdlWorkStatus _internal_status() const;
  void _internal_set_status(::baikaldb::pb::DdlWorkStatus value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.DdlWorkInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr opt_sql_;
  ::baikaldb::pb::ColumnDdlInfo* column_ddl_info_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 index_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 begin_timestamp_;
  int op_type_;
  int errcode_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_timestamp_;
  bool rollback_;
  bool deleted_;
  bool suspend_;
  bool global_;
  bool drop_index_;
  bool is_rollup_;
  ::PROTOBUF_NAMESPACE_ID::int64 update_timestamp_;
  int job_state_;
  int status_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class RegionDdlWork final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.RegionDdlWork) */ {
 public:
  inline RegionDdlWork() : RegionDdlWork(nullptr) {}
  ~RegionDdlWork() override;
  explicit constexpr RegionDdlWork(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegionDdlWork(const RegionDdlWork& from);
  RegionDdlWork(RegionDdlWork&& from) noexcept
    : RegionDdlWork() {
    *this = ::std::move(from);
  }

  inline RegionDdlWork& operator=(const RegionDdlWork& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionDdlWork& operator=(RegionDdlWork&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegionDdlWork& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegionDdlWork* internal_default_instance() {
    return reinterpret_cast<const RegionDdlWork*>(
               &_RegionDdlWork_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(RegionDdlWork& a, RegionDdlWork& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionDdlWork* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionDdlWork* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionDdlWork* New() const final {
    return new RegionDdlWork();
  }

  RegionDdlWork* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionDdlWork>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegionDdlWork& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegionDdlWork& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionDdlWork* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.RegionDdlWork";
  }
  protected:
  explicit RegionDdlWork(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartKeyFieldNumber = 3,
    kEndKeyFieldNumber = 4,
    kAddressFieldNumber = 8,
    kColumnDdlInfoFieldNumber = 13,
    kTableIdFieldNumber = 1,
    kRegionIdFieldNumber = 2,
    kIndexIdFieldNumber = 7,
    kOpTypeFieldNumber = 6,
    kRetryTimeFieldNumber = 9,
    kUpdateTimestampFieldNumber = 10,
    kPartitionFieldNumber = 11,
    kIsGlobalFieldNumber = 12,
    kStatusFieldNumber = 5,
  };
  // optional bytes start_key = 3;
  bool has_start_key() const;
  private:
  bool _internal_has_start_key() const;
  public:
  void clear_start_key();
  const std::string& start_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_start_key();
  void set_allocated_start_key(std::string* start_key);
  private:
  const std::string& _internal_start_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_key(const std::string& value);
  std::string* _internal_mutable_start_key();
  public:

  // optional bytes end_key = 4;
  bool has_end_key() const;
  private:
  bool _internal_has_end_key() const;
  public:
  void clear_end_key();
  const std::string& end_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_end_key();
  void set_allocated_end_key(std::string* end_key);
  private:
  const std::string& _internal_end_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_key(const std::string& value);
  std::string* _internal_mutable_end_key();
  public:

  // optional string address = 8;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional .baikaldb.pb.ColumnDdlInfo column_ddl_info = 13;
  bool has_column_ddl_info() const;
  private:
  bool _internal_has_column_ddl_info() const;
  public:
  void clear_column_ddl_info();
  const ::baikaldb::pb::ColumnDdlInfo& column_ddl_info() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::ColumnDdlInfo* release_column_ddl_info();
  ::baikaldb::pb::ColumnDdlInfo* mutable_column_ddl_info();
  void set_allocated_column_ddl_info(::baikaldb::pb::ColumnDdlInfo* column_ddl_info);
  private:
  const ::baikaldb::pb::ColumnDdlInfo& _internal_column_ddl_info() const;
  ::baikaldb::pb::ColumnDdlInfo* _internal_mutable_column_ddl_info();
  public:
  void unsafe_arena_set_allocated_column_ddl_info(
      ::baikaldb::pb::ColumnDdlInfo* column_ddl_info);
  ::baikaldb::pb::ColumnDdlInfo* unsafe_arena_release_column_ddl_info();

  // optional int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 region_id = 2;
  bool has_region_id() const;
  private:
  bool _internal_has_region_id() const;
  public:
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::int64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_region_id() const;
  void _internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 index_id = 7;
  bool has_index_id() const;
  private:
  bool _internal_has_index_id() const;
  public:
  void clear_index_id();
  ::PROTOBUF_NAMESPACE_ID::int64 index_id() const;
  void set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_index_id() const;
  void _internal_set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .baikaldb.pb.OpType op_type = 6;
  bool has_op_type() const;
  private:
  bool _internal_has_op_type() const;
  public:
  void clear_op_type();
  ::baikaldb::pb::OpType op_type() const;
  void set_op_type(::baikaldb::pb::OpType value);
  private:
  ::baikaldb::pb::OpType _internal_op_type() const;
  void _internal_set_op_type(::baikaldb::pb::OpType value);
  public:

  // optional uint32 retry_time = 9;
  bool has_retry_time() const;
  private:
  bool _internal_has_retry_time() const;
  public:
  void clear_retry_time();
  ::PROTOBUF_NAMESPACE_ID::uint32 retry_time() const;
  void set_retry_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_retry_time() const;
  void _internal_set_retry_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional int64 update_timestamp = 10;
  bool has_update_timestamp() const;
  private:
  bool _internal_has_update_timestamp() const;
  public:
  void clear_update_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 update_timestamp() const;
  void set_update_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_update_timestamp() const;
  void _internal_set_update_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 partition = 11;
  bool has_partition() const;
  private:
  bool _internal_has_partition() const;
  public:
  void clear_partition();
  ::PROTOBUF_NAMESPACE_ID::int64 partition() const;
  void set_partition(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_partition() const;
  void _internal_set_partition(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool is_global = 12;
  bool has_is_global() const;
  private:
  bool _internal_has_is_global() const;
  public:
  void clear_is_global();
  bool is_global() const;
  void set_is_global(bool value);
  private:
  bool _internal_is_global() const;
  void _internal_set_is_global(bool value);
  public:

  // optional .baikaldb.pb.DdlWorkStatus status = 5;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::baikaldb::pb::DdlWorkStatus status() const;
  void set_status(::baikaldb::pb::DdlWorkStatus value);
  private:
  ::baikaldb::pb::DdlWorkStatus _internal_status() const;
  void _internal_set_status(::baikaldb::pb::DdlWorkStatus value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.RegionDdlWork)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::baikaldb::pb::ColumnDdlInfo* column_ddl_info_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 region_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 index_id_;
  int op_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 retry_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 update_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int64 partition_;
  bool is_global_;
  int status_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class TableHeartBeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TableHeartBeat) */ {
 public:
  inline TableHeartBeat() : TableHeartBeat(nullptr) {}
  ~TableHeartBeat() override;
  explicit constexpr TableHeartBeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableHeartBeat(const TableHeartBeat& from);
  TableHeartBeat(TableHeartBeat&& from) noexcept
    : TableHeartBeat() {
    *this = ::std::move(from);
  }

  inline TableHeartBeat& operator=(const TableHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableHeartBeat& operator=(TableHeartBeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableHeartBeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableHeartBeat* internal_default_instance() {
    return reinterpret_cast<const TableHeartBeat*>(
               &_TableHeartBeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(TableHeartBeat& a, TableHeartBeat& b) {
    a.Swap(&b);
  }
  inline void Swap(TableHeartBeat* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableHeartBeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TableHeartBeat* New() const final {
    return new TableHeartBeat();
  }

  TableHeartBeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TableHeartBeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableHeartBeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TableHeartBeat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableHeartBeat* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TableHeartBeat";
  }
  protected:
  explicit TableHeartBeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableIdFieldNumber = 1,
    kVersionFieldNumber = 2,
    kNeedUpdateFieldNumber = 3,
  };
  // optional int64 table_id = 1;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  ::PROTOBUF_NAMESPACE_ID::int64 table_id() const;
  void set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_table_id() const;
  void _internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool need_update = 3;
  bool has_need_update() const;
  private:
  bool _internal_has_need_update() const;
  public:
  void clear_need_update();
  bool need_update() const;
  void set_need_update(bool value);
  private:
  bool _internal_need_update() const;
  void _internal_set_need_update(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TableHeartBeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 table_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  bool need_update_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class ConsoleHeartBeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ConsoleHeartBeatRequest) */ {
 public:
  inline ConsoleHeartBeatRequest() : ConsoleHeartBeatRequest(nullptr) {}
  ~ConsoleHeartBeatRequest() override;
  explicit constexpr ConsoleHeartBeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConsoleHeartBeatRequest(const ConsoleHeartBeatRequest& from);
  ConsoleHeartBeatRequest(ConsoleHeartBeatRequest&& from) noexcept
    : ConsoleHeartBeatRequest() {
    *this = ::std::move(from);
  }

  inline ConsoleHeartBeatRequest& operator=(const ConsoleHeartBeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsoleHeartBeatRequest& operator=(ConsoleHeartBeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsoleHeartBeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConsoleHeartBeatRequest* internal_default_instance() {
    return reinterpret_cast<const ConsoleHeartBeatRequest*>(
               &_ConsoleHeartBeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(ConsoleHeartBeatRequest& a, ConsoleHeartBeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConsoleHeartBeatRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsoleHeartBeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConsoleHeartBeatRequest* New() const final {
    return new ConsoleHeartBeatRequest();
  }

  ConsoleHeartBeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConsoleHeartBeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConsoleHeartBeatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConsoleHeartBeatRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsoleHeartBeatRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ConsoleHeartBeatRequest";
  }
  protected:
  explicit ConsoleHeartBeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableVersionsFieldNumber = 1,
    kRegionVersionsFieldNumber = 2,
  };
  // repeated .baikaldb.pb.TableHeartBeat table_versions = 1;
  int table_versions_size() const;
  private:
  int _internal_table_versions_size() const;
  public:
  void clear_table_versions();
  ::baikaldb::pb::TableHeartBeat* mutable_table_versions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TableHeartBeat >*
      mutable_table_versions();
  private:
  const ::baikaldb::pb::TableHeartBeat& _internal_table_versions(int index) const;
  ::baikaldb::pb::TableHeartBeat* _internal_add_table_versions();
  public:
  const ::baikaldb::pb::TableHeartBeat& table_versions(int index) const;
  ::baikaldb::pb::TableHeartBeat* add_table_versions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TableHeartBeat >&
      table_versions() const;

  // repeated .baikaldb.pb.RegionHeartBeat region_versions = 2;
  int region_versions_size() const;
  private:
  int _internal_region_versions_size() const;
  public:
  void clear_region_versions();
  ::baikaldb::pb::RegionHeartBeat* mutable_region_versions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionHeartBeat >*
      mutable_region_versions();
  private:
  const ::baikaldb::pb::RegionHeartBeat& _internal_region_versions(int index) const;
  ::baikaldb::pb::RegionHeartBeat* _internal_add_region_versions();
  public:
  const ::baikaldb::pb::RegionHeartBeat& region_versions(int index) const;
  ::baikaldb::pb::RegionHeartBeat* add_region_versions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionHeartBeat >&
      region_versions() const;

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ConsoleHeartBeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TableHeartBeat > table_versions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionHeartBeat > region_versions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class ConsoleHeartBeatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ConsoleHeartBeatResponse) */ {
 public:
  inline ConsoleHeartBeatResponse() : ConsoleHeartBeatResponse(nullptr) {}
  ~ConsoleHeartBeatResponse() override;
  explicit constexpr ConsoleHeartBeatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConsoleHeartBeatResponse(const ConsoleHeartBeatResponse& from);
  ConsoleHeartBeatResponse(ConsoleHeartBeatResponse&& from) noexcept
    : ConsoleHeartBeatResponse() {
    *this = ::std::move(from);
  }

  inline ConsoleHeartBeatResponse& operator=(const ConsoleHeartBeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConsoleHeartBeatResponse& operator=(ConsoleHeartBeatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConsoleHeartBeatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConsoleHeartBeatResponse* internal_default_instance() {
    return reinterpret_cast<const ConsoleHeartBeatResponse*>(
               &_ConsoleHeartBeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(ConsoleHeartBeatResponse& a, ConsoleHeartBeatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConsoleHeartBeatResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConsoleHeartBeatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConsoleHeartBeatResponse* New() const final {
    return new ConsoleHeartBeatResponse();
  }

  ConsoleHeartBeatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConsoleHeartBeatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConsoleHeartBeatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConsoleHeartBeatResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConsoleHeartBeatResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ConsoleHeartBeatResponse";
  }
  protected:
  explicit ConsoleHeartBeatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlattenInstancesFieldNumber = 4,
    kFlattenPrivilegesFieldNumber = 5,
    kRegionChangeInfosFieldNumber = 6,
    kTableChangeInfosFieldNumber = 7,
    kErrmsgFieldNumber = 2,
    kLeaderFieldNumber = 3,
    kErrcodeFieldNumber = 1,
  };
  // repeated .baikaldb.pb.QueryInstance flatten_instances = 4;
  int flatten_instances_size() const;
  private:
  int _internal_flatten_instances_size() const;
  public:
  void clear_flatten_instances();
  ::baikaldb::pb::QueryInstance* mutable_flatten_instances(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryInstance >*
      mutable_flatten_instances();
  private:
  const ::baikaldb::pb::QueryInstance& _internal_flatten_instances(int index) const;
  ::baikaldb::pb::QueryInstance* _internal_add_flatten_instances();
  public:
  const ::baikaldb::pb::QueryInstance& flatten_instances(int index) const;
  ::baikaldb::pb::QueryInstance* add_flatten_instances();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryInstance >&
      flatten_instances() const;

  // repeated .baikaldb.pb.QueryUserPrivilege flatten_privileges = 5;
  int flatten_privileges_size() const;
  private:
  int _internal_flatten_privileges_size() const;
  public:
  void clear_flatten_privileges();
  ::baikaldb::pb::QueryUserPrivilege* mutable_flatten_privileges(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryUserPrivilege >*
      mutable_flatten_privileges();
  private:
  const ::baikaldb::pb::QueryUserPrivilege& _internal_flatten_privileges(int index) const;
  ::baikaldb::pb::QueryUserPrivilege* _internal_add_flatten_privileges();
  public:
  const ::baikaldb::pb::QueryUserPrivilege& flatten_privileges(int index) const;
  ::baikaldb::pb::QueryUserPrivilege* add_flatten_privileges();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryUserPrivilege >&
      flatten_privileges() const;

  // repeated .baikaldb.pb.RegionChangeInfo region_change_infos = 6;
  int region_change_infos_size() const;
  private:
  int _internal_region_change_infos_size() const;
  public:
  void clear_region_change_infos();
  ::baikaldb::pb::RegionChangeInfo* mutable_region_change_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionChangeInfo >*
      mutable_region_change_infos();
  private:
  const ::baikaldb::pb::RegionChangeInfo& _internal_region_change_infos(int index) const;
  ::baikaldb::pb::RegionChangeInfo* _internal_add_region_change_infos();
  public:
  const ::baikaldb::pb::RegionChangeInfo& region_change_infos(int index) const;
  ::baikaldb::pb::RegionChangeInfo* add_region_change_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionChangeInfo >&
      region_change_infos() const;

  // repeated .baikaldb.pb.TableInfo table_change_infos = 7;
  int table_change_infos_size() const;
  private:
  int _internal_table_change_infos_size() const;
  public:
  void clear_table_change_infos();
  ::baikaldb::pb::TableInfo* mutable_table_change_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TableInfo >*
      mutable_table_change_infos();
  private:
  const ::baikaldb::pb::TableInfo& _internal_table_change_infos(int index) const;
  ::baikaldb::pb::TableInfo* _internal_add_table_change_infos();
  public:
  const ::baikaldb::pb::TableInfo& table_change_infos(int index) const;
  ::baikaldb::pb::TableInfo* add_table_change_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TableInfo >&
      table_change_infos() const;

  // optional string errmsg = 2;
  bool has_errmsg() const;
  private:
  bool _internal_has_errmsg() const;
  public:
  void clear_errmsg();
  const std::string& errmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errmsg();
  PROTOBUF_MUST_USE_RESULT std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // optional string leader = 3;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // required .baikaldb.pb.ErrCode errcode = 1;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::ErrCode errcode() const;
  void set_errcode(::baikaldb::pb::ErrCode value);
  private:
  ::baikaldb::pb::ErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::ErrCode value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ConsoleHeartBeatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryInstance > flatten_instances_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryUserPrivilege > flatten_privileges_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionChangeInfo > region_change_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TableInfo > table_change_infos_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  int errcode_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class TsoTimestamp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TsoTimestamp) */ {
 public:
  inline TsoTimestamp() : TsoTimestamp(nullptr) {}
  ~TsoTimestamp() override;
  explicit constexpr TsoTimestamp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TsoTimestamp(const TsoTimestamp& from);
  TsoTimestamp(TsoTimestamp&& from) noexcept
    : TsoTimestamp() {
    *this = ::std::move(from);
  }

  inline TsoTimestamp& operator=(const TsoTimestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TsoTimestamp& operator=(TsoTimestamp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TsoTimestamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TsoTimestamp* internal_default_instance() {
    return reinterpret_cast<const TsoTimestamp*>(
               &_TsoTimestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(TsoTimestamp& a, TsoTimestamp& b) {
    a.Swap(&b);
  }
  inline void Swap(TsoTimestamp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TsoTimestamp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TsoTimestamp* New() const final {
    return new TsoTimestamp();
  }

  TsoTimestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TsoTimestamp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TsoTimestamp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TsoTimestamp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TsoTimestamp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TsoTimestamp";
  }
  protected:
  explicit TsoTimestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhysicalFieldNumber = 1,
    kLogicalFieldNumber = 2,
  };
  // optional int64 physical = 1;
  bool has_physical() const;
  private:
  bool _internal_has_physical() const;
  public:
  void clear_physical();
  ::PROTOBUF_NAMESPACE_ID::int64 physical() const;
  void set_physical(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_physical() const;
  void _internal_set_physical(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 logical = 2;
  bool has_logical() const;
  private:
  bool _internal_has_logical() const;
  public:
  void clear_logical();
  ::PROTOBUF_NAMESPACE_ID::int64 logical() const;
  void set_logical(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_logical() const;
  void _internal_set_logical(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TsoTimestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 physical_;
  ::PROTOBUF_NAMESPACE_ID::int64 logical_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class TsoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TsoRequest) */ {
 public:
  inline TsoRequest() : TsoRequest(nullptr) {}
  ~TsoRequest() override;
  explicit constexpr TsoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TsoRequest(const TsoRequest& from);
  TsoRequest(TsoRequest&& from) noexcept
    : TsoRequest() {
    *this = ::std::move(from);
  }

  inline TsoRequest& operator=(const TsoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TsoRequest& operator=(TsoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TsoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TsoRequest* internal_default_instance() {
    return reinterpret_cast<const TsoRequest*>(
               &_TsoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(TsoRequest& a, TsoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TsoRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TsoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TsoRequest* New() const final {
    return new TsoRequest();
  }

  TsoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TsoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TsoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TsoRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TsoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TsoRequest";
  }
  protected:
  explicit TsoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentTimestampFieldNumber = 3,
    kCountFieldNumber = 2,
    kOpTypeFieldNumber = 1,
    kForceFieldNumber = 5,
    kSavePhysicalFieldNumber = 4,
  };
  // optional .baikaldb.pb.TsoTimestamp current_timestamp = 3;
  bool has_current_timestamp() const;
  private:
  bool _internal_has_current_timestamp() const;
  public:
  void clear_current_timestamp();
  const ::baikaldb::pb::TsoTimestamp& current_timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::TsoTimestamp* release_current_timestamp();
  ::baikaldb::pb::TsoTimestamp* mutable_current_timestamp();
  void set_allocated_current_timestamp(::baikaldb::pb::TsoTimestamp* current_timestamp);
  private:
  const ::baikaldb::pb::TsoTimestamp& _internal_current_timestamp() const;
  ::baikaldb::pb::TsoTimestamp* _internal_mutable_current_timestamp();
  public:
  void unsafe_arena_set_allocated_current_timestamp(
      ::baikaldb::pb::TsoTimestamp* current_timestamp);
  ::baikaldb::pb::TsoTimestamp* unsafe_arena_release_current_timestamp();

  // optional int64 count = 2;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int64 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required .baikaldb.pb.OpType op_type = 1;
  bool has_op_type() const;
  private:
  bool _internal_has_op_type() const;
  public:
  void clear_op_type();
  ::baikaldb::pb::OpType op_type() const;
  void set_op_type(::baikaldb::pb::OpType value);
  private:
  ::baikaldb::pb::OpType _internal_op_type() const;
  void _internal_set_op_type(::baikaldb::pb::OpType value);
  public:

  // optional bool force = 5;
  bool has_force() const;
  private:
  bool _internal_has_force() const;
  public:
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // optional int64 save_physical = 4;
  bool has_save_physical() const;
  private:
  bool _internal_has_save_physical() const;
  public:
  void clear_save_physical();
  ::PROTOBUF_NAMESPACE_ID::int64 save_physical() const;
  void set_save_physical(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_save_physical() const;
  void _internal_set_save_physical(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TsoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::TsoTimestamp* current_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int64 count_;
  int op_type_;
  bool force_;
  ::PROTOBUF_NAMESPACE_ID::int64 save_physical_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// -------------------------------------------------------------------

class TsoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TsoResponse) */ {
 public:
  inline TsoResponse() : TsoResponse(nullptr) {}
  ~TsoResponse() override;
  explicit constexpr TsoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TsoResponse(const TsoResponse& from);
  TsoResponse(TsoResponse&& from) noexcept
    : TsoResponse() {
    *this = ::std::move(from);
  }

  inline TsoResponse& operator=(const TsoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TsoResponse& operator=(TsoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TsoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TsoResponse* internal_default_instance() {
    return reinterpret_cast<const TsoResponse*>(
               &_TsoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(TsoResponse& a, TsoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TsoResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TsoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TsoResponse* New() const final {
    return new TsoResponse();
  }

  TsoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TsoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TsoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TsoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TsoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TsoResponse";
  }
  protected:
  explicit TsoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrmsgFieldNumber = 5,
    kLeaderFieldNumber = 8,
    kStartTimestampFieldNumber = 3,
    kOpTypeFieldNumber = 1,
    kErrcodeFieldNumber = 2,
    kCountFieldNumber = 4,
    kSavePhysicalFieldNumber = 6,
    kSystemTimeFieldNumber = 7,
  };
  // optional string errmsg = 5;
  bool has_errmsg() const;
  private:
  bool _internal_has_errmsg() const;
  public:
  void clear_errmsg();
  const std::string& errmsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errmsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errmsg();
  PROTOBUF_MUST_USE_RESULT std::string* release_errmsg();
  void set_allocated_errmsg(std::string* errmsg);
  private:
  const std::string& _internal_errmsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errmsg(const std::string& value);
  std::string* _internal_mutable_errmsg();
  public:

  // optional string leader = 8;
  bool has_leader() const;
  private:
  bool _internal_has_leader() const;
  public:
  void clear_leader();
  const std::string& leader() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leader(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leader();
  PROTOBUF_MUST_USE_RESULT std::string* release_leader();
  void set_allocated_leader(std::string* leader);
  private:
  const std::string& _internal_leader() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leader(const std::string& value);
  std::string* _internal_mutable_leader();
  public:

  // optional .baikaldb.pb.TsoTimestamp start_timestamp = 3;
  bool has_start_timestamp() const;
  private:
  bool _internal_has_start_timestamp() const;
  public:
  void clear_start_timestamp();
  const ::baikaldb::pb::TsoTimestamp& start_timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::TsoTimestamp* release_start_timestamp();
  ::baikaldb::pb::TsoTimestamp* mutable_start_timestamp();
  void set_allocated_start_timestamp(::baikaldb::pb::TsoTimestamp* start_timestamp);
  private:
  const ::baikaldb::pb::TsoTimestamp& _internal_start_timestamp() const;
  ::baikaldb::pb::TsoTimestamp* _internal_mutable_start_timestamp();
  public:
  void unsafe_arena_set_allocated_start_timestamp(
      ::baikaldb::pb::TsoTimestamp* start_timestamp);
  ::baikaldb::pb::TsoTimestamp* unsafe_arena_release_start_timestamp();

  // required .baikaldb.pb.OpType op_type = 1;
  bool has_op_type() const;
  private:
  bool _internal_has_op_type() const;
  public:
  void clear_op_type();
  ::baikaldb::pb::OpType op_type() const;
  void set_op_type(::baikaldb::pb::OpType value);
  private:
  ::baikaldb::pb::OpType _internal_op_type() const;
  void _internal_set_op_type(::baikaldb::pb::OpType value);
  public:

  // optional .baikaldb.pb.ErrCode errcode = 2;
  bool has_errcode() const;
  private:
  bool _internal_has_errcode() const;
  public:
  void clear_errcode();
  ::baikaldb::pb::ErrCode errcode() const;
  void set_errcode(::baikaldb::pb::ErrCode value);
  private:
  ::baikaldb::pb::ErrCode _internal_errcode() const;
  void _internal_set_errcode(::baikaldb::pb::ErrCode value);
  public:

  // optional int64 count = 4;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int64 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 save_physical = 6;
  bool has_save_physical() const;
  private:
  bool _internal_has_save_physical() const;
  public:
  void clear_save_physical();
  ::PROTOBUF_NAMESPACE_ID::int64 save_physical() const;
  void set_save_physical(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_save_physical() const;
  void _internal_set_save_physical(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 system_time = 7;
  bool has_system_time() const;
  private:
  bool _internal_has_system_time() const;
  public:
  void clear_system_time();
  ::PROTOBUF_NAMESPACE_ID::int64 system_time() const;
  void set_system_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_system_time() const;
  void _internal_set_system_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TsoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errmsg_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leader_;
  ::baikaldb::pb::TsoTimestamp* start_timestamp_;
  int op_type_;
  int errcode_;
  ::PROTOBUF_NAMESPACE_ID::int64 count_;
  ::PROTOBUF_NAMESPACE_ID::int64 save_physical_;
  ::PROTOBUF_NAMESPACE_ID::int64 system_time_;
  friend struct ::TableStruct_meta_2einterface_2eproto;
};
// ===================================================================

class MetaService_Stub;

class MetaService : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline MetaService() {};
 public:
  virtual ~MetaService();

  typedef MetaService_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void raft_control(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RaftControlRequest* request,
                       ::baikaldb::pb::RaftControlResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void meta_manager(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::MetaManagerRequest* request,
                       ::baikaldb::pb::MetaManagerResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void store_heartbeat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::StoreHeartBeatRequest* request,
                       ::baikaldb::pb::StoreHeartBeatResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void baikal_heartbeat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::BaikalHeartBeatRequest* request,
                       ::baikaldb::pb::BaikalHeartBeatResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void query(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::QueryRequest* request,
                       ::baikaldb::pb::QueryResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void migrate(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::MigrateRequest* request,
                       ::baikaldb::pb::MigrateResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void console_heartbeat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::ConsoleHeartBeatRequest* request,
                       ::baikaldb::pb::ConsoleHeartBeatResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void tso_service(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::TsoRequest* request,
                       ::baikaldb::pb::TsoResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void baikal_other_heartbeat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::BaikalOtherHeartBeatRequest* request,
                       ::baikaldb::pb::BaikalOtherHeartBeatResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MetaService);
};

class MetaService_Stub : public MetaService {
 public:
  MetaService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  MetaService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~MetaService_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements MetaService ------------------------------------------

  void raft_control(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::RaftControlRequest* request,
                       ::baikaldb::pb::RaftControlResponse* response,
                       ::google::protobuf::Closure* done);
  void meta_manager(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::MetaManagerRequest* request,
                       ::baikaldb::pb::MetaManagerResponse* response,
                       ::google::protobuf::Closure* done);
  void store_heartbeat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::StoreHeartBeatRequest* request,
                       ::baikaldb::pb::StoreHeartBeatResponse* response,
                       ::google::protobuf::Closure* done);
  void baikal_heartbeat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::BaikalHeartBeatRequest* request,
                       ::baikaldb::pb::BaikalHeartBeatResponse* response,
                       ::google::protobuf::Closure* done);
  void query(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::QueryRequest* request,
                       ::baikaldb::pb::QueryResponse* response,
                       ::google::protobuf::Closure* done);
  void migrate(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::MigrateRequest* request,
                       ::baikaldb::pb::MigrateResponse* response,
                       ::google::protobuf::Closure* done);
  void console_heartbeat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::ConsoleHeartBeatRequest* request,
                       ::baikaldb::pb::ConsoleHeartBeatResponse* response,
                       ::google::protobuf::Closure* done);
  void tso_service(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::TsoRequest* request,
                       ::baikaldb::pb::TsoResponse* response,
                       ::google::protobuf::Closure* done);
  void baikal_other_heartbeat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::baikaldb::pb::BaikalOtherHeartBeatRequest* request,
                       ::baikaldb::pb::BaikalOtherHeartBeatResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MetaService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NameSpaceInfo

// required string namespace_name = 1;
inline bool NameSpaceInfo::_internal_has_namespace_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NameSpaceInfo::has_namespace_name() const {
  return _internal_has_namespace_name();
}
inline void NameSpaceInfo::clear_namespace_name() {
  namespace_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NameSpaceInfo::namespace_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.NameSpaceInfo.namespace_name)
  return _internal_namespace_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NameSpaceInfo::set_namespace_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.NameSpaceInfo.namespace_name)
}
inline std::string* NameSpaceInfo::mutable_namespace_name() {
  std::string* _s = _internal_mutable_namespace_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.NameSpaceInfo.namespace_name)
  return _s;
}
inline const std::string& NameSpaceInfo::_internal_namespace_name() const {
  return namespace_name_.Get();
}
inline void NameSpaceInfo::_internal_set_namespace_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NameSpaceInfo::_internal_mutable_namespace_name() {
  _has_bits_[0] |= 0x00000001u;
  return namespace_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NameSpaceInfo::release_namespace_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.NameSpaceInfo.namespace_name)
  if (!_internal_has_namespace_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return namespace_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NameSpaceInfo::set_allocated_namespace_name(std::string* namespace_name) {
  if (namespace_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  namespace_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.NameSpaceInfo.namespace_name)
}

// optional int64 namespace_id = 2;
inline bool NameSpaceInfo::_internal_has_namespace_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NameSpaceInfo::has_namespace_id() const {
  return _internal_has_namespace_id();
}
inline void NameSpaceInfo::clear_namespace_id() {
  namespace_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NameSpaceInfo::_internal_namespace_id() const {
  return namespace_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NameSpaceInfo::namespace_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.NameSpaceInfo.namespace_id)
  return _internal_namespace_id();
}
inline void NameSpaceInfo::_internal_set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  namespace_id_ = value;
}
inline void NameSpaceInfo::set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_namespace_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.NameSpaceInfo.namespace_id)
}

// optional int64 quota = 3;
inline bool NameSpaceInfo::_internal_has_quota() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NameSpaceInfo::has_quota() const {
  return _internal_has_quota();
}
inline void NameSpaceInfo::clear_quota() {
  quota_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NameSpaceInfo::_internal_quota() const {
  return quota_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NameSpaceInfo::quota() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.NameSpaceInfo.quota)
  return _internal_quota();
}
inline void NameSpaceInfo::_internal_set_quota(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  quota_ = value;
}
inline void NameSpaceInfo::set_quota(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_quota(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.NameSpaceInfo.quota)
}

// optional int64 version = 4;
inline bool NameSpaceInfo::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool NameSpaceInfo::has_version() const {
  return _internal_has_version();
}
inline void NameSpaceInfo::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NameSpaceInfo::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NameSpaceInfo::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.NameSpaceInfo.version)
  return _internal_version();
}
inline void NameSpaceInfo::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  version_ = value;
}
inline void NameSpaceInfo::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.NameSpaceInfo.version)
}

// optional bool deleted = 5;
inline bool NameSpaceInfo::_internal_has_deleted() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool NameSpaceInfo::has_deleted() const {
  return _internal_has_deleted();
}
inline void NameSpaceInfo::clear_deleted() {
  deleted_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool NameSpaceInfo::_internal_deleted() const {
  return deleted_;
}
inline bool NameSpaceInfo::deleted() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.NameSpaceInfo.deleted)
  return _internal_deleted();
}
inline void NameSpaceInfo::_internal_set_deleted(bool value) {
  _has_bits_[0] |= 0x00000080u;
  deleted_ = value;
}
inline void NameSpaceInfo::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.NameSpaceInfo.deleted)
}

// optional string resource_tag = 6;
inline bool NameSpaceInfo::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NameSpaceInfo::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void NameSpaceInfo::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NameSpaceInfo::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.NameSpaceInfo.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NameSpaceInfo::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.NameSpaceInfo.resource_tag)
}
inline std::string* NameSpaceInfo::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.NameSpaceInfo.resource_tag)
  return _s;
}
inline const std::string& NameSpaceInfo::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void NameSpaceInfo::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NameSpaceInfo::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000002u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NameSpaceInfo::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.NameSpaceInfo.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NameSpaceInfo::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.NameSpaceInfo.resource_tag)
}

// optional .baikaldb.pb.Engine engine = 7;
inline bool NameSpaceInfo::_internal_has_engine() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool NameSpaceInfo::has_engine() const {
  return _internal_has_engine();
}
inline void NameSpaceInfo::clear_engine() {
  engine_ = 1;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::baikaldb::pb::Engine NameSpaceInfo::_internal_engine() const {
  return static_cast< ::baikaldb::pb::Engine >(engine_);
}
inline ::baikaldb::pb::Engine NameSpaceInfo::engine() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.NameSpaceInfo.engine)
  return _internal_engine();
}
inline void NameSpaceInfo::_internal_set_engine(::baikaldb::pb::Engine value) {
  assert(::baikaldb::pb::Engine_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  engine_ = value;
}
inline void NameSpaceInfo::set_engine(::baikaldb::pb::Engine value) {
  _internal_set_engine(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.NameSpaceInfo.engine)
}

// optional .baikaldb.pb.Charset charset = 8;
inline bool NameSpaceInfo::_internal_has_charset() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool NameSpaceInfo::has_charset() const {
  return _internal_has_charset();
}
inline void NameSpaceInfo::clear_charset() {
  charset_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::baikaldb::pb::Charset NameSpaceInfo::_internal_charset() const {
  return static_cast< ::baikaldb::pb::Charset >(charset_);
}
inline ::baikaldb::pb::Charset NameSpaceInfo::charset() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.NameSpaceInfo.charset)
  return _internal_charset();
}
inline void NameSpaceInfo::_internal_set_charset(::baikaldb::pb::Charset value) {
  assert(::baikaldb::pb::Charset_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  charset_ = value;
}
inline void NameSpaceInfo::set_charset(::baikaldb::pb::Charset value) {
  _internal_set_charset(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.NameSpaceInfo.charset)
}

// optional int64 byte_size_per_record = 9;
inline bool NameSpaceInfo::_internal_has_byte_size_per_record() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool NameSpaceInfo::has_byte_size_per_record() const {
  return _internal_has_byte_size_per_record();
}
inline void NameSpaceInfo::clear_byte_size_per_record() {
  byte_size_per_record_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NameSpaceInfo::_internal_byte_size_per_record() const {
  return byte_size_per_record_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NameSpaceInfo::byte_size_per_record() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.NameSpaceInfo.byte_size_per_record)
  return _internal_byte_size_per_record();
}
inline void NameSpaceInfo::_internal_set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  byte_size_per_record_ = value;
}
inline void NameSpaceInfo::set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_byte_size_per_record(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.NameSpaceInfo.byte_size_per_record)
}

// optional int64 replica_num = 10;
inline bool NameSpaceInfo::_internal_has_replica_num() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool NameSpaceInfo::has_replica_num() const {
  return _internal_has_replica_num();
}
inline void NameSpaceInfo::clear_replica_num() {
  replica_num_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NameSpaceInfo::_internal_replica_num() const {
  return replica_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NameSpaceInfo::replica_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.NameSpaceInfo.replica_num)
  return _internal_replica_num();
}
inline void NameSpaceInfo::_internal_set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  replica_num_ = value;
}
inline void NameSpaceInfo::set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_replica_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.NameSpaceInfo.replica_num)
}

// optional int64 region_split_lines = 11;
inline bool NameSpaceInfo::_internal_has_region_split_lines() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool NameSpaceInfo::has_region_split_lines() const {
  return _internal_has_region_split_lines();
}
inline void NameSpaceInfo::clear_region_split_lines() {
  region_split_lines_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NameSpaceInfo::_internal_region_split_lines() const {
  return region_split_lines_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NameSpaceInfo::region_split_lines() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.NameSpaceInfo.region_split_lines)
  return _internal_region_split_lines();
}
inline void NameSpaceInfo::_internal_set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  region_split_lines_ = value;
}
inline void NameSpaceInfo::set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_split_lines(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.NameSpaceInfo.region_split_lines)
}

// optional bool if_exist = 13;
inline bool NameSpaceInfo::_internal_has_if_exist() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool NameSpaceInfo::has_if_exist() const {
  return _internal_has_if_exist();
}
inline void NameSpaceInfo::clear_if_exist() {
  if_exist_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool NameSpaceInfo::_internal_if_exist() const {
  return if_exist_;
}
inline bool NameSpaceInfo::if_exist() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.NameSpaceInfo.if_exist)
  return _internal_if_exist();
}
inline void NameSpaceInfo::_internal_set_if_exist(bool value) {
  _has_bits_[0] |= 0x00000100u;
  if_exist_ = value;
}
inline void NameSpaceInfo::set_if_exist(bool value) {
  _internal_set_if_exist(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.NameSpaceInfo.if_exist)
}

// repeated .baikaldb.pb.ReplicaDist dists = 14;
inline int NameSpaceInfo::_internal_dists_size() const {
  return dists_.size();
}
inline int NameSpaceInfo::dists_size() const {
  return _internal_dists_size();
}
inline void NameSpaceInfo::clear_dists() {
  dists_.Clear();
}
inline ::baikaldb::pb::ReplicaDist* NameSpaceInfo::mutable_dists(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.NameSpaceInfo.dists)
  return dists_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ReplicaDist >*
NameSpaceInfo::mutable_dists() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.NameSpaceInfo.dists)
  return &dists_;
}
inline const ::baikaldb::pb::ReplicaDist& NameSpaceInfo::_internal_dists(int index) const {
  return dists_.Get(index);
}
inline const ::baikaldb::pb::ReplicaDist& NameSpaceInfo::dists(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.NameSpaceInfo.dists)
  return _internal_dists(index);
}
inline ::baikaldb::pb::ReplicaDist* NameSpaceInfo::_internal_add_dists() {
  return dists_.Add();
}
inline ::baikaldb::pb::ReplicaDist* NameSpaceInfo::add_dists() {
  ::baikaldb::pb::ReplicaDist* _add = _internal_add_dists();
  // @@protoc_insertion_point(field_add:baikaldb.pb.NameSpaceInfo.dists)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ReplicaDist >&
NameSpaceInfo::dists() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.NameSpaceInfo.dists)
  return dists_;
}

// optional string main_logical_room = 15;
inline bool NameSpaceInfo::_internal_has_main_logical_room() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NameSpaceInfo::has_main_logical_room() const {
  return _internal_has_main_logical_room();
}
inline void NameSpaceInfo::clear_main_logical_room() {
  main_logical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NameSpaceInfo::main_logical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.NameSpaceInfo.main_logical_room)
  return _internal_main_logical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NameSpaceInfo::set_main_logical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 main_logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.NameSpaceInfo.main_logical_room)
}
inline std::string* NameSpaceInfo::mutable_main_logical_room() {
  std::string* _s = _internal_mutable_main_logical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.NameSpaceInfo.main_logical_room)
  return _s;
}
inline const std::string& NameSpaceInfo::_internal_main_logical_room() const {
  return main_logical_room_.Get();
}
inline void NameSpaceInfo::_internal_set_main_logical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  main_logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NameSpaceInfo::_internal_mutable_main_logical_room() {
  _has_bits_[0] |= 0x00000004u;
  return main_logical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NameSpaceInfo::release_main_logical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.NameSpaceInfo.main_logical_room)
  if (!_internal_has_main_logical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return main_logical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NameSpaceInfo::set_allocated_main_logical_room(std::string* main_logical_room) {
  if (main_logical_room != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  main_logical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), main_logical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.NameSpaceInfo.main_logical_room)
}

// repeated string learner_resource_tags = 16;
inline int NameSpaceInfo::_internal_learner_resource_tags_size() const {
  return learner_resource_tags_.size();
}
inline int NameSpaceInfo::learner_resource_tags_size() const {
  return _internal_learner_resource_tags_size();
}
inline void NameSpaceInfo::clear_learner_resource_tags() {
  learner_resource_tags_.Clear();
}
inline std::string* NameSpaceInfo::add_learner_resource_tags() {
  std::string* _s = _internal_add_learner_resource_tags();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.NameSpaceInfo.learner_resource_tags)
  return _s;
}
inline const std::string& NameSpaceInfo::_internal_learner_resource_tags(int index) const {
  return learner_resource_tags_.Get(index);
}
inline const std::string& NameSpaceInfo::learner_resource_tags(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.NameSpaceInfo.learner_resource_tags)
  return _internal_learner_resource_tags(index);
}
inline std::string* NameSpaceInfo::mutable_learner_resource_tags(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.NameSpaceInfo.learner_resource_tags)
  return learner_resource_tags_.Mutable(index);
}
inline void NameSpaceInfo::set_learner_resource_tags(int index, const std::string& value) {
  learner_resource_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.NameSpaceInfo.learner_resource_tags)
}
inline void NameSpaceInfo::set_learner_resource_tags(int index, std::string&& value) {
  learner_resource_tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.NameSpaceInfo.learner_resource_tags)
}
inline void NameSpaceInfo::set_learner_resource_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  learner_resource_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.NameSpaceInfo.learner_resource_tags)
}
inline void NameSpaceInfo::set_learner_resource_tags(int index, const char* value, size_t size) {
  learner_resource_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.NameSpaceInfo.learner_resource_tags)
}
inline std::string* NameSpaceInfo::_internal_add_learner_resource_tags() {
  return learner_resource_tags_.Add();
}
inline void NameSpaceInfo::add_learner_resource_tags(const std::string& value) {
  learner_resource_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.NameSpaceInfo.learner_resource_tags)
}
inline void NameSpaceInfo::add_learner_resource_tags(std::string&& value) {
  learner_resource_tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.NameSpaceInfo.learner_resource_tags)
}
inline void NameSpaceInfo::add_learner_resource_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  learner_resource_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.NameSpaceInfo.learner_resource_tags)
}
inline void NameSpaceInfo::add_learner_resource_tags(const char* value, size_t size) {
  learner_resource_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.NameSpaceInfo.learner_resource_tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NameSpaceInfo::learner_resource_tags() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.NameSpaceInfo.learner_resource_tags)
  return learner_resource_tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NameSpaceInfo::mutable_learner_resource_tags() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.NameSpaceInfo.learner_resource_tags)
  return &learner_resource_tags_;
}

// repeated .baikaldb.pb.BinlogInfo binlog_infos = 17;
inline int NameSpaceInfo::_internal_binlog_infos_size() const {
  return binlog_infos_.size();
}
inline int NameSpaceInfo::binlog_infos_size() const {
  return _internal_binlog_infos_size();
}
inline void NameSpaceInfo::clear_binlog_infos() {
  binlog_infos_.Clear();
}
inline ::baikaldb::pb::BinlogInfo* NameSpaceInfo::mutable_binlog_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.NameSpaceInfo.binlog_infos)
  return binlog_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogInfo >*
NameSpaceInfo::mutable_binlog_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.NameSpaceInfo.binlog_infos)
  return &binlog_infos_;
}
inline const ::baikaldb::pb::BinlogInfo& NameSpaceInfo::_internal_binlog_infos(int index) const {
  return binlog_infos_.Get(index);
}
inline const ::baikaldb::pb::BinlogInfo& NameSpaceInfo::binlog_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.NameSpaceInfo.binlog_infos)
  return _internal_binlog_infos(index);
}
inline ::baikaldb::pb::BinlogInfo* NameSpaceInfo::_internal_add_binlog_infos() {
  return binlog_infos_.Add();
}
inline ::baikaldb::pb::BinlogInfo* NameSpaceInfo::add_binlog_infos() {
  ::baikaldb::pb::BinlogInfo* _add = _internal_add_binlog_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.NameSpaceInfo.binlog_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogInfo >&
NameSpaceInfo::binlog_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.NameSpaceInfo.binlog_infos)
  return binlog_infos_;
}

// -------------------------------------------------------------------

// DataBaseInfo

// required string database = 1;
inline bool DataBaseInfo::_internal_has_database() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataBaseInfo::has_database() const {
  return _internal_has_database();
}
inline void DataBaseInfo::clear_database() {
  database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataBaseInfo::database() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataBaseInfo::set_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.database)
}
inline std::string* DataBaseInfo::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DataBaseInfo.database)
  return _s;
}
inline const std::string& DataBaseInfo::_internal_database() const {
  return database_.Get();
}
inline void DataBaseInfo::_internal_set_database(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataBaseInfo::_internal_mutable_database() {
  _has_bits_[0] |= 0x00000001u;
  return database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataBaseInfo::release_database() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DataBaseInfo.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataBaseInfo::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DataBaseInfo.database)
}

// optional int64 database_id = 2;
inline bool DataBaseInfo::_internal_has_database_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DataBaseInfo::has_database_id() const {
  return _internal_has_database_id();
}
inline void DataBaseInfo::clear_database_id() {
  database_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataBaseInfo::_internal_database_id() const {
  return database_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataBaseInfo::database_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.database_id)
  return _internal_database_id();
}
inline void DataBaseInfo::_internal_set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  database_id_ = value;
}
inline void DataBaseInfo::set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_database_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.database_id)
}

// required string namespace_name = 3;
inline bool DataBaseInfo::_internal_has_namespace_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataBaseInfo::has_namespace_name() const {
  return _internal_has_namespace_name();
}
inline void DataBaseInfo::clear_namespace_name() {
  namespace_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataBaseInfo::namespace_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.namespace_name)
  return _internal_namespace_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataBaseInfo::set_namespace_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.namespace_name)
}
inline std::string* DataBaseInfo::mutable_namespace_name() {
  std::string* _s = _internal_mutable_namespace_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DataBaseInfo.namespace_name)
  return _s;
}
inline const std::string& DataBaseInfo::_internal_namespace_name() const {
  return namespace_name_.Get();
}
inline void DataBaseInfo::_internal_set_namespace_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataBaseInfo::_internal_mutable_namespace_name() {
  _has_bits_[0] |= 0x00000002u;
  return namespace_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataBaseInfo::release_namespace_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DataBaseInfo.namespace_name)
  if (!_internal_has_namespace_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return namespace_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataBaseInfo::set_allocated_namespace_name(std::string* namespace_name) {
  if (namespace_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  namespace_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DataBaseInfo.namespace_name)
}

// optional int64 namespace_id = 4;
inline bool DataBaseInfo::_internal_has_namespace_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DataBaseInfo::has_namespace_id() const {
  return _internal_has_namespace_id();
}
inline void DataBaseInfo::clear_namespace_id() {
  namespace_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataBaseInfo::_internal_namespace_id() const {
  return namespace_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataBaseInfo::namespace_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.namespace_id)
  return _internal_namespace_id();
}
inline void DataBaseInfo::_internal_set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  namespace_id_ = value;
}
inline void DataBaseInfo::set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_namespace_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.namespace_id)
}

// optional int64 quota = 5;
inline bool DataBaseInfo::_internal_has_quota() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DataBaseInfo::has_quota() const {
  return _internal_has_quota();
}
inline void DataBaseInfo::clear_quota() {
  quota_ = int64_t{0};
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataBaseInfo::_internal_quota() const {
  return quota_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataBaseInfo::quota() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.quota)
  return _internal_quota();
}
inline void DataBaseInfo::_internal_set_quota(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  quota_ = value;
}
inline void DataBaseInfo::set_quota(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_quota(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.quota)
}

// optional int64 version = 6;
inline bool DataBaseInfo::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DataBaseInfo::has_version() const {
  return _internal_has_version();
}
inline void DataBaseInfo::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataBaseInfo::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataBaseInfo::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.version)
  return _internal_version();
}
inline void DataBaseInfo::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  version_ = value;
}
inline void DataBaseInfo::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.version)
}

// optional bool deleted = 7;
inline bool DataBaseInfo::_internal_has_deleted() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool DataBaseInfo::has_deleted() const {
  return _internal_has_deleted();
}
inline void DataBaseInfo::clear_deleted() {
  deleted_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool DataBaseInfo::_internal_deleted() const {
  return deleted_;
}
inline bool DataBaseInfo::deleted() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.deleted)
  return _internal_deleted();
}
inline void DataBaseInfo::_internal_set_deleted(bool value) {
  _has_bits_[0] |= 0x00000200u;
  deleted_ = value;
}
inline void DataBaseInfo::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.deleted)
}

// optional string resource_tag = 8;
inline bool DataBaseInfo::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DataBaseInfo::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void DataBaseInfo::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DataBaseInfo::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataBaseInfo::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.resource_tag)
}
inline std::string* DataBaseInfo::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DataBaseInfo.resource_tag)
  return _s;
}
inline const std::string& DataBaseInfo::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void DataBaseInfo::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataBaseInfo::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000004u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataBaseInfo::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DataBaseInfo.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataBaseInfo::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DataBaseInfo.resource_tag)
}

// optional .baikaldb.pb.Engine engine = 9;
inline bool DataBaseInfo::_internal_has_engine() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool DataBaseInfo::has_engine() const {
  return _internal_has_engine();
}
inline void DataBaseInfo::clear_engine() {
  engine_ = 1;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::baikaldb::pb::Engine DataBaseInfo::_internal_engine() const {
  return static_cast< ::baikaldb::pb::Engine >(engine_);
}
inline ::baikaldb::pb::Engine DataBaseInfo::engine() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.engine)
  return _internal_engine();
}
inline void DataBaseInfo::_internal_set_engine(::baikaldb::pb::Engine value) {
  assert(::baikaldb::pb::Engine_IsValid(value));
  _has_bits_[0] |= 0x00004000u;
  engine_ = value;
}
inline void DataBaseInfo::set_engine(::baikaldb::pb::Engine value) {
  _internal_set_engine(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.engine)
}

// optional .baikaldb.pb.Charset charset = 10;
inline bool DataBaseInfo::_internal_has_charset() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool DataBaseInfo::has_charset() const {
  return _internal_has_charset();
}
inline void DataBaseInfo::clear_charset() {
  charset_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::baikaldb::pb::Charset DataBaseInfo::_internal_charset() const {
  return static_cast< ::baikaldb::pb::Charset >(charset_);
}
inline ::baikaldb::pb::Charset DataBaseInfo::charset() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.charset)
  return _internal_charset();
}
inline void DataBaseInfo::_internal_set_charset(::baikaldb::pb::Charset value) {
  assert(::baikaldb::pb::Charset_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  charset_ = value;
}
inline void DataBaseInfo::set_charset(::baikaldb::pb::Charset value) {
  _internal_set_charset(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.charset)
}

// optional int64 byte_size_per_record = 11;
inline bool DataBaseInfo::_internal_has_byte_size_per_record() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool DataBaseInfo::has_byte_size_per_record() const {
  return _internal_has_byte_size_per_record();
}
inline void DataBaseInfo::clear_byte_size_per_record() {
  byte_size_per_record_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataBaseInfo::_internal_byte_size_per_record() const {
  return byte_size_per_record_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataBaseInfo::byte_size_per_record() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.byte_size_per_record)
  return _internal_byte_size_per_record();
}
inline void DataBaseInfo::_internal_set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  byte_size_per_record_ = value;
}
inline void DataBaseInfo::set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_byte_size_per_record(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.byte_size_per_record)
}

// optional int64 replica_num = 12;
inline bool DataBaseInfo::_internal_has_replica_num() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool DataBaseInfo::has_replica_num() const {
  return _internal_has_replica_num();
}
inline void DataBaseInfo::clear_replica_num() {
  replica_num_ = int64_t{0};
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataBaseInfo::_internal_replica_num() const {
  return replica_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataBaseInfo::replica_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.replica_num)
  return _internal_replica_num();
}
inline void DataBaseInfo::_internal_set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00001000u;
  replica_num_ = value;
}
inline void DataBaseInfo::set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_replica_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.replica_num)
}

// optional int64 region_split_lines = 13;
inline bool DataBaseInfo::_internal_has_region_split_lines() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool DataBaseInfo::has_region_split_lines() const {
  return _internal_has_region_split_lines();
}
inline void DataBaseInfo::clear_region_split_lines() {
  region_split_lines_ = int64_t{0};
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataBaseInfo::_internal_region_split_lines() const {
  return region_split_lines_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DataBaseInfo::region_split_lines() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.region_split_lines)
  return _internal_region_split_lines();
}
inline void DataBaseInfo::_internal_set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00002000u;
  region_split_lines_ = value;
}
inline void DataBaseInfo::set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_split_lines(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.region_split_lines)
}

// repeated .baikaldb.pb.ReplicaDist dists = 14;
inline int DataBaseInfo::_internal_dists_size() const {
  return dists_.size();
}
inline int DataBaseInfo::dists_size() const {
  return _internal_dists_size();
}
inline void DataBaseInfo::clear_dists() {
  dists_.Clear();
}
inline ::baikaldb::pb::ReplicaDist* DataBaseInfo::mutable_dists(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DataBaseInfo.dists)
  return dists_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ReplicaDist >*
DataBaseInfo::mutable_dists() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.DataBaseInfo.dists)
  return &dists_;
}
inline const ::baikaldb::pb::ReplicaDist& DataBaseInfo::_internal_dists(int index) const {
  return dists_.Get(index);
}
inline const ::baikaldb::pb::ReplicaDist& DataBaseInfo::dists(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.dists)
  return _internal_dists(index);
}
inline ::baikaldb::pb::ReplicaDist* DataBaseInfo::_internal_add_dists() {
  return dists_.Add();
}
inline ::baikaldb::pb::ReplicaDist* DataBaseInfo::add_dists() {
  ::baikaldb::pb::ReplicaDist* _add = _internal_add_dists();
  // @@protoc_insertion_point(field_add:baikaldb.pb.DataBaseInfo.dists)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ReplicaDist >&
DataBaseInfo::dists() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.DataBaseInfo.dists)
  return dists_;
}

// optional string main_logical_room = 15;
inline bool DataBaseInfo::_internal_has_main_logical_room() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DataBaseInfo::has_main_logical_room() const {
  return _internal_has_main_logical_room();
}
inline void DataBaseInfo::clear_main_logical_room() {
  main_logical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DataBaseInfo::main_logical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.main_logical_room)
  return _internal_main_logical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataBaseInfo::set_main_logical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 main_logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.main_logical_room)
}
inline std::string* DataBaseInfo::mutable_main_logical_room() {
  std::string* _s = _internal_mutable_main_logical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DataBaseInfo.main_logical_room)
  return _s;
}
inline const std::string& DataBaseInfo::_internal_main_logical_room() const {
  return main_logical_room_.Get();
}
inline void DataBaseInfo::_internal_set_main_logical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  main_logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataBaseInfo::_internal_mutable_main_logical_room() {
  _has_bits_[0] |= 0x00000008u;
  return main_logical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataBaseInfo::release_main_logical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DataBaseInfo.main_logical_room)
  if (!_internal_has_main_logical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return main_logical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataBaseInfo::set_allocated_main_logical_room(std::string* main_logical_room) {
  if (main_logical_room != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  main_logical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), main_logical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DataBaseInfo.main_logical_room)
}

// repeated string learner_resource_tags = 16;
inline int DataBaseInfo::_internal_learner_resource_tags_size() const {
  return learner_resource_tags_.size();
}
inline int DataBaseInfo::learner_resource_tags_size() const {
  return _internal_learner_resource_tags_size();
}
inline void DataBaseInfo::clear_learner_resource_tags() {
  learner_resource_tags_.Clear();
}
inline std::string* DataBaseInfo::add_learner_resource_tags() {
  std::string* _s = _internal_add_learner_resource_tags();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.DataBaseInfo.learner_resource_tags)
  return _s;
}
inline const std::string& DataBaseInfo::_internal_learner_resource_tags(int index) const {
  return learner_resource_tags_.Get(index);
}
inline const std::string& DataBaseInfo::learner_resource_tags(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.learner_resource_tags)
  return _internal_learner_resource_tags(index);
}
inline std::string* DataBaseInfo::mutable_learner_resource_tags(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DataBaseInfo.learner_resource_tags)
  return learner_resource_tags_.Mutable(index);
}
inline void DataBaseInfo::set_learner_resource_tags(int index, const std::string& value) {
  learner_resource_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.learner_resource_tags)
}
inline void DataBaseInfo::set_learner_resource_tags(int index, std::string&& value) {
  learner_resource_tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.learner_resource_tags)
}
inline void DataBaseInfo::set_learner_resource_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  learner_resource_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.DataBaseInfo.learner_resource_tags)
}
inline void DataBaseInfo::set_learner_resource_tags(int index, const char* value, size_t size) {
  learner_resource_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.DataBaseInfo.learner_resource_tags)
}
inline std::string* DataBaseInfo::_internal_add_learner_resource_tags() {
  return learner_resource_tags_.Add();
}
inline void DataBaseInfo::add_learner_resource_tags(const std::string& value) {
  learner_resource_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.DataBaseInfo.learner_resource_tags)
}
inline void DataBaseInfo::add_learner_resource_tags(std::string&& value) {
  learner_resource_tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.DataBaseInfo.learner_resource_tags)
}
inline void DataBaseInfo::add_learner_resource_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  learner_resource_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.DataBaseInfo.learner_resource_tags)
}
inline void DataBaseInfo::add_learner_resource_tags(const char* value, size_t size) {
  learner_resource_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.DataBaseInfo.learner_resource_tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DataBaseInfo::learner_resource_tags() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.DataBaseInfo.learner_resource_tags)
  return learner_resource_tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DataBaseInfo::mutable_learner_resource_tags() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.DataBaseInfo.learner_resource_tags)
  return &learner_resource_tags_;
}

// repeated .baikaldb.pb.BinlogInfo binlog_infos = 17;
inline int DataBaseInfo::_internal_binlog_infos_size() const {
  return binlog_infos_.size();
}
inline int DataBaseInfo::binlog_infos_size() const {
  return _internal_binlog_infos_size();
}
inline void DataBaseInfo::clear_binlog_infos() {
  binlog_infos_.Clear();
}
inline ::baikaldb::pb::BinlogInfo* DataBaseInfo::mutable_binlog_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DataBaseInfo.binlog_infos)
  return binlog_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogInfo >*
DataBaseInfo::mutable_binlog_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.DataBaseInfo.binlog_infos)
  return &binlog_infos_;
}
inline const ::baikaldb::pb::BinlogInfo& DataBaseInfo::_internal_binlog_infos(int index) const {
  return binlog_infos_.Get(index);
}
inline const ::baikaldb::pb::BinlogInfo& DataBaseInfo::binlog_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.binlog_infos)
  return _internal_binlog_infos(index);
}
inline ::baikaldb::pb::BinlogInfo* DataBaseInfo::_internal_add_binlog_infos() {
  return binlog_infos_.Add();
}
inline ::baikaldb::pb::BinlogInfo* DataBaseInfo::add_binlog_infos() {
  ::baikaldb::pb::BinlogInfo* _add = _internal_add_binlog_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.DataBaseInfo.binlog_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogInfo >&
DataBaseInfo::binlog_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.DataBaseInfo.binlog_infos)
  return binlog_infos_;
}

// optional string partition_info_str = 18;
inline bool DataBaseInfo::_internal_has_partition_info_str() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DataBaseInfo::has_partition_info_str() const {
  return _internal_has_partition_info_str();
}
inline void DataBaseInfo::clear_partition_info_str() {
  partition_info_str_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DataBaseInfo::partition_info_str() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DataBaseInfo.partition_info_str)
  return _internal_partition_info_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataBaseInfo::set_partition_info_str(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 partition_info_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DataBaseInfo.partition_info_str)
}
inline std::string* DataBaseInfo::mutable_partition_info_str() {
  std::string* _s = _internal_mutable_partition_info_str();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DataBaseInfo.partition_info_str)
  return _s;
}
inline const std::string& DataBaseInfo::_internal_partition_info_str() const {
  return partition_info_str_.Get();
}
inline void DataBaseInfo::_internal_set_partition_info_str(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  partition_info_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataBaseInfo::_internal_mutable_partition_info_str() {
  _has_bits_[0] |= 0x00000010u;
  return partition_info_str_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataBaseInfo::release_partition_info_str() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DataBaseInfo.partition_info_str)
  if (!_internal_has_partition_info_str()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return partition_info_str_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataBaseInfo::set_allocated_partition_info_str(std::string* partition_info_str) {
  if (partition_info_str != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  partition_info_str_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partition_info_str,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DataBaseInfo.partition_info_str)
}

// -------------------------------------------------------------------

// ReplicaDist

// optional string logical_room = 1;
inline bool ReplicaDist::_internal_has_logical_room() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReplicaDist::has_logical_room() const {
  return _internal_has_logical_room();
}
inline void ReplicaDist::clear_logical_room() {
  logical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReplicaDist::logical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ReplicaDist.logical_room)
  return _internal_logical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReplicaDist::set_logical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ReplicaDist.logical_room)
}
inline std::string* ReplicaDist::mutable_logical_room() {
  std::string* _s = _internal_mutable_logical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ReplicaDist.logical_room)
  return _s;
}
inline const std::string& ReplicaDist::_internal_logical_room() const {
  return logical_room_.Get();
}
inline void ReplicaDist::_internal_set_logical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReplicaDist::_internal_mutable_logical_room() {
  _has_bits_[0] |= 0x00000001u;
  return logical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReplicaDist::release_logical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ReplicaDist.logical_room)
  if (!_internal_has_logical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return logical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReplicaDist::set_allocated_logical_room(std::string* logical_room) {
  if (logical_room != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  logical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ReplicaDist.logical_room)
}

// required int64 count = 2;
inline bool ReplicaDist::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ReplicaDist::has_count() const {
  return _internal_has_count();
}
inline void ReplicaDist::clear_count() {
  count_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReplicaDist::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReplicaDist::count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ReplicaDist.count)
  return _internal_count();
}
inline void ReplicaDist::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  count_ = value;
}
inline void ReplicaDist::set_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ReplicaDist.count)
}

// optional string resource_tag = 3;
inline bool ReplicaDist::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReplicaDist::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void ReplicaDist::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ReplicaDist::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ReplicaDist.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReplicaDist::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ReplicaDist.resource_tag)
}
inline std::string* ReplicaDist::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ReplicaDist.resource_tag)
  return _s;
}
inline const std::string& ReplicaDist::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void ReplicaDist::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReplicaDist::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000002u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReplicaDist::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ReplicaDist.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReplicaDist::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ReplicaDist.resource_tag)
}

// optional string physical_room = 4;
inline bool ReplicaDist::_internal_has_physical_room() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ReplicaDist::has_physical_room() const {
  return _internal_has_physical_room();
}
inline void ReplicaDist::clear_physical_room() {
  physical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ReplicaDist::physical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ReplicaDist.physical_room)
  return _internal_physical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReplicaDist::set_physical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ReplicaDist.physical_room)
}
inline std::string* ReplicaDist::mutable_physical_room() {
  std::string* _s = _internal_mutable_physical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ReplicaDist.physical_room)
  return _s;
}
inline const std::string& ReplicaDist::_internal_physical_room() const {
  return physical_room_.Get();
}
inline void ReplicaDist::_internal_set_physical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReplicaDist::_internal_mutable_physical_room() {
  _has_bits_[0] |= 0x00000004u;
  return physical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReplicaDist::release_physical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ReplicaDist.physical_room)
  if (!_internal_has_physical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return physical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReplicaDist::set_allocated_physical_room(std::string* physical_room) {
  if (physical_room != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  physical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), physical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ReplicaDist.physical_room)
}

// -------------------------------------------------------------------

// SplitKey

// optional bytes index_name = 1;
inline bool SplitKey::_internal_has_index_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SplitKey::has_index_name() const {
  return _internal_has_index_name();
}
inline void SplitKey::clear_index_name() {
  index_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SplitKey::index_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SplitKey.index_name)
  return _internal_index_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SplitKey::set_index_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 index_name_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SplitKey.index_name)
}
inline std::string* SplitKey::mutable_index_name() {
  std::string* _s = _internal_mutable_index_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SplitKey.index_name)
  return _s;
}
inline const std::string& SplitKey::_internal_index_name() const {
  return index_name_.Get();
}
inline void SplitKey::_internal_set_index_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SplitKey::_internal_mutable_index_name() {
  _has_bits_[0] |= 0x00000001u;
  return index_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SplitKey::release_index_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SplitKey.index_name)
  if (!_internal_has_index_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return index_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SplitKey::set_allocated_index_name(std::string* index_name) {
  if (index_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  index_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SplitKey.index_name)
}

// repeated bytes split_keys = 2;
inline int SplitKey::_internal_split_keys_size() const {
  return split_keys_.size();
}
inline int SplitKey::split_keys_size() const {
  return _internal_split_keys_size();
}
inline void SplitKey::clear_split_keys() {
  split_keys_.Clear();
}
inline std::string* SplitKey::add_split_keys() {
  std::string* _s = _internal_add_split_keys();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.SplitKey.split_keys)
  return _s;
}
inline const std::string& SplitKey::_internal_split_keys(int index) const {
  return split_keys_.Get(index);
}
inline const std::string& SplitKey::split_keys(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SplitKey.split_keys)
  return _internal_split_keys(index);
}
inline std::string* SplitKey::mutable_split_keys(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SplitKey.split_keys)
  return split_keys_.Mutable(index);
}
inline void SplitKey::set_split_keys(int index, const std::string& value) {
  split_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SplitKey.split_keys)
}
inline void SplitKey::set_split_keys(int index, std::string&& value) {
  split_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.SplitKey.split_keys)
}
inline void SplitKey::set_split_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  split_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.SplitKey.split_keys)
}
inline void SplitKey::set_split_keys(int index, const void* value, size_t size) {
  split_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.SplitKey.split_keys)
}
inline std::string* SplitKey::_internal_add_split_keys() {
  return split_keys_.Add();
}
inline void SplitKey::add_split_keys(const std::string& value) {
  split_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.SplitKey.split_keys)
}
inline void SplitKey::add_split_keys(std::string&& value) {
  split_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.SplitKey.split_keys)
}
inline void SplitKey::add_split_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  split_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.SplitKey.split_keys)
}
inline void SplitKey::add_split_keys(const void* value, size_t size) {
  split_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.SplitKey.split_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SplitKey::split_keys() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SplitKey.split_keys)
  return split_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SplitKey::mutable_split_keys() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SplitKey.split_keys)
  return &split_keys_;
}

// -------------------------------------------------------------------

// BinlogInfo

// repeated int64 target_table_ids = 1;
inline int BinlogInfo::_internal_target_table_ids_size() const {
  return target_table_ids_.size();
}
inline int BinlogInfo::target_table_ids_size() const {
  return _internal_target_table_ids_size();
}
inline void BinlogInfo::clear_target_table_ids() {
  target_table_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogInfo::_internal_target_table_ids(int index) const {
  return target_table_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogInfo::target_table_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogInfo.target_table_ids)
  return _internal_target_table_ids(index);
}
inline void BinlogInfo::set_target_table_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  target_table_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogInfo.target_table_ids)
}
inline void BinlogInfo::_internal_add_target_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  target_table_ids_.Add(value);
}
inline void BinlogInfo::add_target_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_target_table_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.BinlogInfo.target_table_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
BinlogInfo::_internal_target_table_ids() const {
  return target_table_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
BinlogInfo::target_table_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BinlogInfo.target_table_ids)
  return _internal_target_table_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
BinlogInfo::_internal_mutable_target_table_ids() {
  return &target_table_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
BinlogInfo::mutable_target_table_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BinlogInfo.target_table_ids)
  return _internal_mutable_target_table_ids();
}

// optional int64 binlog_table_id = 2;
inline bool BinlogInfo::_internal_has_binlog_table_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BinlogInfo::has_binlog_table_id() const {
  return _internal_has_binlog_table_id();
}
inline void BinlogInfo::clear_binlog_table_id() {
  binlog_table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogInfo::_internal_binlog_table_id() const {
  return binlog_table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogInfo::binlog_table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogInfo.binlog_table_id)
  return _internal_binlog_table_id();
}
inline void BinlogInfo::_internal_set_binlog_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  binlog_table_id_ = value;
}
inline void BinlogInfo::set_binlog_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_binlog_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogInfo.binlog_table_id)
}

// optional .baikaldb.pb.FieldInfo link_field = 3;
inline bool BinlogInfo::_internal_has_link_field() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || link_field_ != nullptr);
  return value;
}
inline bool BinlogInfo::has_link_field() const {
  return _internal_has_link_field();
}
inline void BinlogInfo::clear_link_field() {
  if (link_field_ != nullptr) link_field_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::baikaldb::pb::FieldInfo& BinlogInfo::_internal_link_field() const {
  const ::baikaldb::pb::FieldInfo* p = link_field_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::FieldInfo&>(
      ::baikaldb::pb::_FieldInfo_default_instance_);
}
inline const ::baikaldb::pb::FieldInfo& BinlogInfo::link_field() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogInfo.link_field)
  return _internal_link_field();
}
inline void BinlogInfo::unsafe_arena_set_allocated_link_field(
    ::baikaldb::pb::FieldInfo* link_field) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(link_field_);
  }
  link_field_ = link_field;
  if (link_field) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.BinlogInfo.link_field)
}
inline ::baikaldb::pb::FieldInfo* BinlogInfo::release_link_field() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::FieldInfo* temp = link_field_;
  link_field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::FieldInfo* BinlogInfo::unsafe_arena_release_link_field() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BinlogInfo.link_field)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::FieldInfo* temp = link_field_;
  link_field_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::FieldInfo* BinlogInfo::_internal_mutable_link_field() {
  _has_bits_[0] |= 0x00000004u;
  if (link_field_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::FieldInfo>(GetArenaForAllocation());
    link_field_ = p;
  }
  return link_field_;
}
inline ::baikaldb::pb::FieldInfo* BinlogInfo::mutable_link_field() {
  ::baikaldb::pb::FieldInfo* _msg = _internal_mutable_link_field();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BinlogInfo.link_field)
  return _msg;
}
inline void BinlogInfo::set_allocated_link_field(::baikaldb::pb::FieldInfo* link_field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete link_field_;
  }
  if (link_field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::FieldInfo>::GetOwningArena(link_field);
    if (message_arena != submessage_arena) {
      link_field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link_field, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  link_field_ = link_field;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BinlogInfo.link_field)
}

// optional bool partition_is_same_hint = 4;
inline bool BinlogInfo::_internal_has_partition_is_same_hint() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BinlogInfo::has_partition_is_same_hint() const {
  return _internal_has_partition_is_same_hint();
}
inline void BinlogInfo::clear_partition_is_same_hint() {
  partition_is_same_hint_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool BinlogInfo::_internal_partition_is_same_hint() const {
  return partition_is_same_hint_;
}
inline bool BinlogInfo::partition_is_same_hint() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogInfo.partition_is_same_hint)
  return _internal_partition_is_same_hint();
}
inline void BinlogInfo::_internal_set_partition_is_same_hint(bool value) {
  _has_bits_[0] |= 0x00000010u;
  partition_is_same_hint_ = value;
}
inline void BinlogInfo::set_partition_is_same_hint(bool value) {
  _internal_set_partition_is_same_hint(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogInfo.partition_is_same_hint)
}

// optional string database = 5;
inline bool BinlogInfo::_internal_has_database() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BinlogInfo::has_database() const {
  return _internal_has_database();
}
inline void BinlogInfo::clear_database() {
  database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BinlogInfo::database() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogInfo.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinlogInfo::set_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogInfo.database)
}
inline std::string* BinlogInfo::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BinlogInfo.database)
  return _s;
}
inline const std::string& BinlogInfo::_internal_database() const {
  return database_.Get();
}
inline void BinlogInfo::_internal_set_database(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BinlogInfo::_internal_mutable_database() {
  _has_bits_[0] |= 0x00000001u;
  return database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BinlogInfo::release_database() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BinlogInfo.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BinlogInfo::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BinlogInfo.database)
}

// optional string table_name = 6;
inline bool BinlogInfo::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BinlogInfo::has_table_name() const {
  return _internal_has_table_name();
}
inline void BinlogInfo::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BinlogInfo::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogInfo.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BinlogInfo::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogInfo.table_name)
}
inline std::string* BinlogInfo::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BinlogInfo.table_name)
  return _s;
}
inline const std::string& BinlogInfo::_internal_table_name() const {
  return table_name_.Get();
}
inline void BinlogInfo::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BinlogInfo::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000002u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BinlogInfo::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BinlogInfo.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BinlogInfo::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BinlogInfo.table_name)
}

// -------------------------------------------------------------------

// PartitionRange

// optional .baikaldb.pb.Expr left_value = 1;
inline bool PartitionRange::_internal_has_left_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || left_value_ != nullptr);
  return value;
}
inline bool PartitionRange::has_left_value() const {
  return _internal_has_left_value();
}
inline const ::baikaldb::pb::Expr& PartitionRange::_internal_left_value() const {
  const ::baikaldb::pb::Expr* p = left_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::Expr&>(
      ::baikaldb::pb::_Expr_default_instance_);
}
inline const ::baikaldb::pb::Expr& PartitionRange::left_value() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionRange.left_value)
  return _internal_left_value();
}
inline void PartitionRange::unsafe_arena_set_allocated_left_value(
    ::baikaldb::pb::Expr* left_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_value_);
  }
  left_value_ = left_value;
  if (left_value) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.PartitionRange.left_value)
}
inline ::baikaldb::pb::Expr* PartitionRange::release_left_value() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::Expr* temp = left_value_;
  left_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::Expr* PartitionRange::unsafe_arena_release_left_value() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PartitionRange.left_value)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::Expr* temp = left_value_;
  left_value_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::Expr* PartitionRange::_internal_mutable_left_value() {
  _has_bits_[0] |= 0x00000001u;
  if (left_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::Expr>(GetArenaForAllocation());
    left_value_ = p;
  }
  return left_value_;
}
inline ::baikaldb::pb::Expr* PartitionRange::mutable_left_value() {
  ::baikaldb::pb::Expr* _msg = _internal_mutable_left_value();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PartitionRange.left_value)
  return _msg;
}
inline void PartitionRange::set_allocated_left_value(::baikaldb::pb::Expr* left_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_value_);
  }
  if (left_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_value));
    if (message_arena != submessage_arena) {
      left_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  left_value_ = left_value;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PartitionRange.left_value)
}

// optional .baikaldb.pb.Expr right_value = 2;
inline bool PartitionRange::_internal_has_right_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || right_value_ != nullptr);
  return value;
}
inline bool PartitionRange::has_right_value() const {
  return _internal_has_right_value();
}
inline const ::baikaldb::pb::Expr& PartitionRange::_internal_right_value() const {
  const ::baikaldb::pb::Expr* p = right_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::Expr&>(
      ::baikaldb::pb::_Expr_default_instance_);
}
inline const ::baikaldb::pb::Expr& PartitionRange::right_value() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionRange.right_value)
  return _internal_right_value();
}
inline void PartitionRange::unsafe_arena_set_allocated_right_value(
    ::baikaldb::pb::Expr* right_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_value_);
  }
  right_value_ = right_value;
  if (right_value) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.PartitionRange.right_value)
}
inline ::baikaldb::pb::Expr* PartitionRange::release_right_value() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::Expr* temp = right_value_;
  right_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::Expr* PartitionRange::unsafe_arena_release_right_value() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PartitionRange.right_value)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::Expr* temp = right_value_;
  right_value_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::Expr* PartitionRange::_internal_mutable_right_value() {
  _has_bits_[0] |= 0x00000002u;
  if (right_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::Expr>(GetArenaForAllocation());
    right_value_ = p;
  }
  return right_value_;
}
inline ::baikaldb::pb::Expr* PartitionRange::mutable_right_value() {
  ::baikaldb::pb::Expr* _msg = _internal_mutable_right_value();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PartitionRange.right_value)
  return _msg;
}
inline void PartitionRange::set_allocated_right_value(::baikaldb::pb::Expr* right_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_value_);
  }
  if (right_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_value));
    if (message_arena != submessage_arena) {
      right_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  right_value_ = right_value;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PartitionRange.right_value)
}

// -------------------------------------------------------------------

// RangePartitionInfo

// optional int64 partition_id = 1;
inline bool RangePartitionInfo::_internal_has_partition_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RangePartitionInfo::has_partition_id() const {
  return _internal_has_partition_id();
}
inline void RangePartitionInfo::clear_partition_id() {
  partition_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RangePartitionInfo::_internal_partition_id() const {
  return partition_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RangePartitionInfo::partition_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RangePartitionInfo.partition_id)
  return _internal_partition_id();
}
inline void RangePartitionInfo::_internal_set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  partition_id_ = value;
}
inline void RangePartitionInfo::set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_partition_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RangePartitionInfo.partition_id)
}

// optional string partition_name = 2;
inline bool RangePartitionInfo::_internal_has_partition_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RangePartitionInfo::has_partition_name() const {
  return _internal_has_partition_name();
}
inline void RangePartitionInfo::clear_partition_name() {
  partition_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RangePartitionInfo::partition_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RangePartitionInfo.partition_name)
  return _internal_partition_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangePartitionInfo::set_partition_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 partition_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RangePartitionInfo.partition_name)
}
inline std::string* RangePartitionInfo::mutable_partition_name() {
  std::string* _s = _internal_mutable_partition_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RangePartitionInfo.partition_name)
  return _s;
}
inline const std::string& RangePartitionInfo::_internal_partition_name() const {
  return partition_name_.Get();
}
inline void RangePartitionInfo::_internal_set_partition_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  partition_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RangePartitionInfo::_internal_mutable_partition_name() {
  _has_bits_[0] |= 0x00000001u;
  return partition_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RangePartitionInfo::release_partition_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RangePartitionInfo.partition_name)
  if (!_internal_has_partition_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return partition_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RangePartitionInfo::set_allocated_partition_name(std::string* partition_name) {
  if (partition_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  partition_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partition_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RangePartitionInfo.partition_name)
}

// optional .baikaldb.pb.Expr less_value = 3;
inline bool RangePartitionInfo::_internal_has_less_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || less_value_ != nullptr);
  return value;
}
inline bool RangePartitionInfo::has_less_value() const {
  return _internal_has_less_value();
}
inline const ::baikaldb::pb::Expr& RangePartitionInfo::_internal_less_value() const {
  const ::baikaldb::pb::Expr* p = less_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::Expr&>(
      ::baikaldb::pb::_Expr_default_instance_);
}
inline const ::baikaldb::pb::Expr& RangePartitionInfo::less_value() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RangePartitionInfo.less_value)
  return _internal_less_value();
}
inline void RangePartitionInfo::unsafe_arena_set_allocated_less_value(
    ::baikaldb::pb::Expr* less_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(less_value_);
  }
  less_value_ = less_value;
  if (less_value) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.RangePartitionInfo.less_value)
}
inline ::baikaldb::pb::Expr* RangePartitionInfo::release_less_value() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::Expr* temp = less_value_;
  less_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::Expr* RangePartitionInfo::unsafe_arena_release_less_value() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RangePartitionInfo.less_value)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::Expr* temp = less_value_;
  less_value_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::Expr* RangePartitionInfo::_internal_mutable_less_value() {
  _has_bits_[0] |= 0x00000004u;
  if (less_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::Expr>(GetArenaForAllocation());
    less_value_ = p;
  }
  return less_value_;
}
inline ::baikaldb::pb::Expr* RangePartitionInfo::mutable_less_value() {
  ::baikaldb::pb::Expr* _msg = _internal_mutable_less_value();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RangePartitionInfo.less_value)
  return _msg;
}
inline void RangePartitionInfo::set_allocated_less_value(::baikaldb::pb::Expr* less_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(less_value_);
  }
  if (less_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(less_value));
    if (message_arena != submessage_arena) {
      less_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, less_value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  less_value_ = less_value;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RangePartitionInfo.less_value)
}

// optional .baikaldb.pb.PartitionRange range = 4;
inline bool RangePartitionInfo::_internal_has_range() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || range_ != nullptr);
  return value;
}
inline bool RangePartitionInfo::has_range() const {
  return _internal_has_range();
}
inline void RangePartitionInfo::clear_range() {
  if (range_ != nullptr) range_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::baikaldb::pb::PartitionRange& RangePartitionInfo::_internal_range() const {
  const ::baikaldb::pb::PartitionRange* p = range_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::PartitionRange&>(
      ::baikaldb::pb::_PartitionRange_default_instance_);
}
inline const ::baikaldb::pb::PartitionRange& RangePartitionInfo::range() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RangePartitionInfo.range)
  return _internal_range();
}
inline void RangePartitionInfo::unsafe_arena_set_allocated_range(
    ::baikaldb::pb::PartitionRange* range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(range_);
  }
  range_ = range;
  if (range) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.RangePartitionInfo.range)
}
inline ::baikaldb::pb::PartitionRange* RangePartitionInfo::release_range() {
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::PartitionRange* temp = range_;
  range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::PartitionRange* RangePartitionInfo::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RangePartitionInfo.range)
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::PartitionRange* temp = range_;
  range_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::PartitionRange* RangePartitionInfo::_internal_mutable_range() {
  _has_bits_[0] |= 0x00000008u;
  if (range_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::PartitionRange>(GetArenaForAllocation());
    range_ = p;
  }
  return range_;
}
inline ::baikaldb::pb::PartitionRange* RangePartitionInfo::mutable_range() {
  ::baikaldb::pb::PartitionRange* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RangePartitionInfo.range)
  return _msg;
}
inline void RangePartitionInfo::set_allocated_range(::baikaldb::pb::PartitionRange* range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete range_;
  }
  if (range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::PartitionRange>::GetOwningArena(range);
    if (message_arena != submessage_arena) {
      range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  range_ = range;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RangePartitionInfo.range)
}

// optional string resource_tag = 5;
inline bool RangePartitionInfo::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RangePartitionInfo::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void RangePartitionInfo::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RangePartitionInfo::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RangePartitionInfo.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangePartitionInfo::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RangePartitionInfo.resource_tag)
}
inline std::string* RangePartitionInfo::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RangePartitionInfo.resource_tag)
  return _s;
}
inline const std::string& RangePartitionInfo::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void RangePartitionInfo::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RangePartitionInfo::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000002u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RangePartitionInfo::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RangePartitionInfo.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RangePartitionInfo::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RangePartitionInfo.resource_tag)
}

// optional bool is_cold = 6;
inline bool RangePartitionInfo::_internal_has_is_cold() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RangePartitionInfo::has_is_cold() const {
  return _internal_has_is_cold();
}
inline void RangePartitionInfo::clear_is_cold() {
  is_cold_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool RangePartitionInfo::_internal_is_cold() const {
  return is_cold_;
}
inline bool RangePartitionInfo::is_cold() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RangePartitionInfo.is_cold)
  return _internal_is_cold();
}
inline void RangePartitionInfo::_internal_set_is_cold(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_cold_ = value;
}
inline void RangePartitionInfo::set_is_cold(bool value) {
  _internal_set_is_cold(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RangePartitionInfo.is_cold)
}

// repeated .baikaldb.pb.SplitKey split_keys = 7;
inline int RangePartitionInfo::_internal_split_keys_size() const {
  return split_keys_.size();
}
inline int RangePartitionInfo::split_keys_size() const {
  return _internal_split_keys_size();
}
inline void RangePartitionInfo::clear_split_keys() {
  split_keys_.Clear();
}
inline ::baikaldb::pb::SplitKey* RangePartitionInfo::mutable_split_keys(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RangePartitionInfo.split_keys)
  return split_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SplitKey >*
RangePartitionInfo::mutable_split_keys() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RangePartitionInfo.split_keys)
  return &split_keys_;
}
inline const ::baikaldb::pb::SplitKey& RangePartitionInfo::_internal_split_keys(int index) const {
  return split_keys_.Get(index);
}
inline const ::baikaldb::pb::SplitKey& RangePartitionInfo::split_keys(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RangePartitionInfo.split_keys)
  return _internal_split_keys(index);
}
inline ::baikaldb::pb::SplitKey* RangePartitionInfo::_internal_add_split_keys() {
  return split_keys_.Add();
}
inline ::baikaldb::pb::SplitKey* RangePartitionInfo::add_split_keys() {
  ::baikaldb::pb::SplitKey* _add = _internal_add_split_keys();
  // @@protoc_insertion_point(field_add:baikaldb.pb.RangePartitionInfo.split_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SplitKey >&
RangePartitionInfo::split_keys() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RangePartitionInfo.split_keys)
  return split_keys_;
}

// optional .baikaldb.pb.RangePartitionType type = 8;
inline bool RangePartitionInfo::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool RangePartitionInfo::has_type() const {
  return _internal_has_type();
}
inline void RangePartitionInfo::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::baikaldb::pb::RangePartitionType RangePartitionInfo::_internal_type() const {
  return static_cast< ::baikaldb::pb::RangePartitionType >(type_);
}
inline ::baikaldb::pb::RangePartitionType RangePartitionInfo::type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RangePartitionInfo.type)
  return _internal_type();
}
inline void RangePartitionInfo::_internal_set_type(::baikaldb::pb::RangePartitionType value) {
  assert(::baikaldb::pb::RangePartitionType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  type_ = value;
}
inline void RangePartitionInfo::set_type(::baikaldb::pb::RangePartitionType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RangePartitionInfo.type)
}

// optional bool is_pre_split = 9;
inline bool RangePartitionInfo::_internal_has_is_pre_split() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RangePartitionInfo::has_is_pre_split() const {
  return _internal_has_is_pre_split();
}
inline void RangePartitionInfo::clear_is_pre_split() {
  is_pre_split_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool RangePartitionInfo::_internal_is_pre_split() const {
  return is_pre_split_;
}
inline bool RangePartitionInfo::is_pre_split() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RangePartitionInfo.is_pre_split)
  return _internal_is_pre_split();
}
inline void RangePartitionInfo::_internal_set_is_pre_split(bool value) {
  _has_bits_[0] |= 0x00000040u;
  is_pre_split_ = value;
}
inline void RangePartitionInfo::set_is_pre_split(bool value) {
  _internal_set_is_pre_split(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RangePartitionInfo.is_pre_split)
}

// -------------------------------------------------------------------

// DynamicPartitionAttr

// optional bool enable = 1;
inline bool DynamicPartitionAttr::_internal_has_enable() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DynamicPartitionAttr::has_enable() const {
  return _internal_has_enable();
}
inline void DynamicPartitionAttr::clear_enable() {
  enable_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool DynamicPartitionAttr::_internal_enable() const {
  return enable_;
}
inline bool DynamicPartitionAttr::enable() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DynamicPartitionAttr.enable)
  return _internal_enable();
}
inline void DynamicPartitionAttr::_internal_set_enable(bool value) {
  _has_bits_[0] |= 0x00000008u;
  enable_ = value;
}
inline void DynamicPartitionAttr::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DynamicPartitionAttr.enable)
}

// optional string time_unit = 2;
inline bool DynamicPartitionAttr::_internal_has_time_unit() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DynamicPartitionAttr::has_time_unit() const {
  return _internal_has_time_unit();
}
inline void DynamicPartitionAttr::clear_time_unit() {
  time_unit_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DynamicPartitionAttr::time_unit() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DynamicPartitionAttr.time_unit)
  return _internal_time_unit();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DynamicPartitionAttr::set_time_unit(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 time_unit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DynamicPartitionAttr.time_unit)
}
inline std::string* DynamicPartitionAttr::mutable_time_unit() {
  std::string* _s = _internal_mutable_time_unit();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DynamicPartitionAttr.time_unit)
  return _s;
}
inline const std::string& DynamicPartitionAttr::_internal_time_unit() const {
  return time_unit_.Get();
}
inline void DynamicPartitionAttr::_internal_set_time_unit(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  time_unit_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DynamicPartitionAttr::_internal_mutable_time_unit() {
  _has_bits_[0] |= 0x00000001u;
  return time_unit_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DynamicPartitionAttr::release_time_unit() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DynamicPartitionAttr.time_unit)
  if (!_internal_has_time_unit()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return time_unit_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DynamicPartitionAttr::set_allocated_time_unit(std::string* time_unit) {
  if (time_unit != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  time_unit_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), time_unit,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DynamicPartitionAttr.time_unit)
}

// optional int32 start = 3;
inline bool DynamicPartitionAttr::_internal_has_start() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DynamicPartitionAttr::has_start() const {
  return _internal_has_start();
}
inline void DynamicPartitionAttr::clear_start() {
  start_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DynamicPartitionAttr::_internal_start() const {
  return start_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DynamicPartitionAttr::start() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DynamicPartitionAttr.start)
  return _internal_start();
}
inline void DynamicPartitionAttr::_internal_set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  start_ = value;
}
inline void DynamicPartitionAttr::set_start(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DynamicPartitionAttr.start)
}

// optional int32 cold = 4;
inline bool DynamicPartitionAttr::_internal_has_cold() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DynamicPartitionAttr::has_cold() const {
  return _internal_has_cold();
}
inline void DynamicPartitionAttr::clear_cold() {
  cold_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DynamicPartitionAttr::_internal_cold() const {
  return cold_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DynamicPartitionAttr::cold() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DynamicPartitionAttr.cold)
  return _internal_cold();
}
inline void DynamicPartitionAttr::_internal_set_cold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  cold_ = value;
}
inline void DynamicPartitionAttr::set_cold(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cold(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DynamicPartitionAttr.cold)
}

// optional int32 end = 5;
inline bool DynamicPartitionAttr::_internal_has_end() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DynamicPartitionAttr::has_end() const {
  return _internal_has_end();
}
inline void DynamicPartitionAttr::clear_end() {
  end_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DynamicPartitionAttr::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DynamicPartitionAttr::end() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DynamicPartitionAttr.end)
  return _internal_end();
}
inline void DynamicPartitionAttr::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  end_ = value;
}
inline void DynamicPartitionAttr::set_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DynamicPartitionAttr.end)
}

// optional string prefix = 6;
inline bool DynamicPartitionAttr::_internal_has_prefix() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DynamicPartitionAttr::has_prefix() const {
  return _internal_has_prefix();
}
inline void DynamicPartitionAttr::clear_prefix() {
  prefix_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DynamicPartitionAttr::prefix() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DynamicPartitionAttr.prefix)
  return _internal_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DynamicPartitionAttr::set_prefix(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DynamicPartitionAttr.prefix)
}
inline std::string* DynamicPartitionAttr::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DynamicPartitionAttr.prefix)
  return _s;
}
inline const std::string& DynamicPartitionAttr::_internal_prefix() const {
  return prefix_.Get();
}
inline void DynamicPartitionAttr::_internal_set_prefix(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DynamicPartitionAttr::_internal_mutable_prefix() {
  _has_bits_[0] |= 0x00000002u;
  return prefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DynamicPartitionAttr::release_prefix() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DynamicPartitionAttr.prefix)
  if (!_internal_has_prefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return prefix_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DynamicPartitionAttr::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prefix,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DynamicPartitionAttr.prefix)
}

// optional int32 start_day_of_month = 7;
inline bool DynamicPartitionAttr::_internal_has_start_day_of_month() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DynamicPartitionAttr::has_start_day_of_month() const {
  return _internal_has_start_day_of_month();
}
inline void DynamicPartitionAttr::clear_start_day_of_month() {
  start_day_of_month_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DynamicPartitionAttr::_internal_start_day_of_month() const {
  return start_day_of_month_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DynamicPartitionAttr::start_day_of_month() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DynamicPartitionAttr.start_day_of_month)
  return _internal_start_day_of_month();
}
inline void DynamicPartitionAttr::_internal_set_start_day_of_month(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  start_day_of_month_ = value;
}
inline void DynamicPartitionAttr::set_start_day_of_month(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start_day_of_month(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DynamicPartitionAttr.start_day_of_month)
}

// optional string isolation = 8;
inline bool DynamicPartitionAttr::_internal_has_isolation() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DynamicPartitionAttr::has_isolation() const {
  return _internal_has_isolation();
}
inline void DynamicPartitionAttr::clear_isolation() {
  isolation_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DynamicPartitionAttr::isolation() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DynamicPartitionAttr.isolation)
  return _internal_isolation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DynamicPartitionAttr::set_isolation(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 isolation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DynamicPartitionAttr.isolation)
}
inline std::string* DynamicPartitionAttr::mutable_isolation() {
  std::string* _s = _internal_mutable_isolation();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DynamicPartitionAttr.isolation)
  return _s;
}
inline const std::string& DynamicPartitionAttr::_internal_isolation() const {
  return isolation_.Get();
}
inline void DynamicPartitionAttr::_internal_set_isolation(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  isolation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DynamicPartitionAttr::_internal_mutable_isolation() {
  _has_bits_[0] |= 0x00000004u;
  return isolation_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DynamicPartitionAttr::release_isolation() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DynamicPartitionAttr.isolation)
  if (!_internal_has_isolation()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return isolation_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DynamicPartitionAttr::set_allocated_isolation(std::string* isolation) {
  if (isolation != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  isolation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), isolation,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DynamicPartitionAttr.isolation)
}

// -------------------------------------------------------------------

// PartitionInfo

// required .baikaldb.pb.PartitionType type = 1;
inline bool PartitionInfo::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PartitionInfo::has_type() const {
  return _internal_has_type();
}
inline void PartitionInfo::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::baikaldb::pb::PartitionType PartitionInfo::_internal_type() const {
  return static_cast< ::baikaldb::pb::PartitionType >(type_);
}
inline ::baikaldb::pb::PartitionType PartitionInfo::type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionInfo.type)
  return _internal_type();
}
inline void PartitionInfo::_internal_set_type(::baikaldb::pb::PartitionType value) {
  assert(::baikaldb::pb::PartitionType_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  type_ = value;
}
inline void PartitionInfo::set_type(::baikaldb::pb::PartitionType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionInfo.type)
}

// optional .baikaldb.pb.FieldInfo field_info = 2;
inline bool PartitionInfo::_internal_has_field_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || field_info_ != nullptr);
  return value;
}
inline bool PartitionInfo::has_field_info() const {
  return _internal_has_field_info();
}
inline void PartitionInfo::clear_field_info() {
  if (field_info_ != nullptr) field_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::baikaldb::pb::FieldInfo& PartitionInfo::_internal_field_info() const {
  const ::baikaldb::pb::FieldInfo* p = field_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::FieldInfo&>(
      ::baikaldb::pb::_FieldInfo_default_instance_);
}
inline const ::baikaldb::pb::FieldInfo& PartitionInfo::field_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionInfo.field_info)
  return _internal_field_info();
}
inline void PartitionInfo::unsafe_arena_set_allocated_field_info(
    ::baikaldb::pb::FieldInfo* field_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(field_info_);
  }
  field_info_ = field_info;
  if (field_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.PartitionInfo.field_info)
}
inline ::baikaldb::pb::FieldInfo* PartitionInfo::release_field_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::FieldInfo* temp = field_info_;
  field_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::FieldInfo* PartitionInfo::unsafe_arena_release_field_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PartitionInfo.field_info)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::FieldInfo* temp = field_info_;
  field_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::FieldInfo* PartitionInfo::_internal_mutable_field_info() {
  _has_bits_[0] |= 0x00000002u;
  if (field_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::FieldInfo>(GetArenaForAllocation());
    field_info_ = p;
  }
  return field_info_;
}
inline ::baikaldb::pb::FieldInfo* PartitionInfo::mutable_field_info() {
  ::baikaldb::pb::FieldInfo* _msg = _internal_mutable_field_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PartitionInfo.field_info)
  return _msg;
}
inline void PartitionInfo::set_allocated_field_info(::baikaldb::pb::FieldInfo* field_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete field_info_;
  }
  if (field_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::FieldInfo>::GetOwningArena(field_info);
    if (message_arena != submessage_arena) {
      field_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  field_info_ = field_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PartitionInfo.field_info)
}

// optional int32 partition_field = 3;
inline bool PartitionInfo::_internal_has_partition_field() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PartitionInfo::has_partition_field() const {
  return _internal_has_partition_field();
}
inline void PartitionInfo::clear_partition_field() {
  partition_field_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitionInfo::_internal_partition_field() const {
  return partition_field_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitionInfo::partition_field() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionInfo.partition_field)
  return _internal_partition_field();
}
inline void PartitionInfo::_internal_set_partition_field(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  partition_field_ = value;
}
inline void PartitionInfo::set_partition_field(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_partition_field(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionInfo.partition_field)
}

// optional .baikaldb.pb.Expr range_partition_field = 4;
inline bool PartitionInfo::_internal_has_range_partition_field() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || range_partition_field_ != nullptr);
  return value;
}
inline bool PartitionInfo::has_range_partition_field() const {
  return _internal_has_range_partition_field();
}
inline const ::baikaldb::pb::Expr& PartitionInfo::_internal_range_partition_field() const {
  const ::baikaldb::pb::Expr* p = range_partition_field_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::Expr&>(
      ::baikaldb::pb::_Expr_default_instance_);
}
inline const ::baikaldb::pb::Expr& PartitionInfo::range_partition_field() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionInfo.range_partition_field)
  return _internal_range_partition_field();
}
inline void PartitionInfo::unsafe_arena_set_allocated_range_partition_field(
    ::baikaldb::pb::Expr* range_partition_field) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(range_partition_field_);
  }
  range_partition_field_ = range_partition_field;
  if (range_partition_field) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.PartitionInfo.range_partition_field)
}
inline ::baikaldb::pb::Expr* PartitionInfo::release_range_partition_field() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::Expr* temp = range_partition_field_;
  range_partition_field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::Expr* PartitionInfo::unsafe_arena_release_range_partition_field() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PartitionInfo.range_partition_field)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::Expr* temp = range_partition_field_;
  range_partition_field_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::Expr* PartitionInfo::_internal_mutable_range_partition_field() {
  _has_bits_[0] |= 0x00000004u;
  if (range_partition_field_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::Expr>(GetArenaForAllocation());
    range_partition_field_ = p;
  }
  return range_partition_field_;
}
inline ::baikaldb::pb::Expr* PartitionInfo::mutable_range_partition_field() {
  ::baikaldb::pb::Expr* _msg = _internal_mutable_range_partition_field();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PartitionInfo.range_partition_field)
  return _msg;
}
inline void PartitionInfo::set_allocated_range_partition_field(::baikaldb::pb::Expr* range_partition_field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(range_partition_field_);
  }
  if (range_partition_field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(range_partition_field));
    if (message_arena != submessage_arena) {
      range_partition_field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range_partition_field, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  range_partition_field_ = range_partition_field;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PartitionInfo.range_partition_field)
}

// repeated .baikaldb.pb.Expr range_partition_values = 5;
inline int PartitionInfo::_internal_range_partition_values_size() const {
  return range_partition_values_.size();
}
inline int PartitionInfo::range_partition_values_size() const {
  return _internal_range_partition_values_size();
}
inline ::baikaldb::pb::Expr* PartitionInfo::mutable_range_partition_values(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PartitionInfo.range_partition_values)
  return range_partition_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >*
PartitionInfo::mutable_range_partition_values() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PartitionInfo.range_partition_values)
  return &range_partition_values_;
}
inline const ::baikaldb::pb::Expr& PartitionInfo::_internal_range_partition_values(int index) const {
  return range_partition_values_.Get(index);
}
inline const ::baikaldb::pb::Expr& PartitionInfo::range_partition_values(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionInfo.range_partition_values)
  return _internal_range_partition_values(index);
}
inline ::baikaldb::pb::Expr* PartitionInfo::_internal_add_range_partition_values() {
  return range_partition_values_.Add();
}
inline ::baikaldb::pb::Expr* PartitionInfo::add_range_partition_values() {
  ::baikaldb::pb::Expr* _add = _internal_add_range_partition_values();
  // @@protoc_insertion_point(field_add:baikaldb.pb.PartitionInfo.range_partition_values)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Expr >&
PartitionInfo::range_partition_values() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PartitionInfo.range_partition_values)
  return range_partition_values_;
}

// repeated string partition_names = 6;
inline int PartitionInfo::_internal_partition_names_size() const {
  return partition_names_.size();
}
inline int PartitionInfo::partition_names_size() const {
  return _internal_partition_names_size();
}
inline void PartitionInfo::clear_partition_names() {
  partition_names_.Clear();
}
inline std::string* PartitionInfo::add_partition_names() {
  std::string* _s = _internal_add_partition_names();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.PartitionInfo.partition_names)
  return _s;
}
inline const std::string& PartitionInfo::_internal_partition_names(int index) const {
  return partition_names_.Get(index);
}
inline const std::string& PartitionInfo::partition_names(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionInfo.partition_names)
  return _internal_partition_names(index);
}
inline std::string* PartitionInfo::mutable_partition_names(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PartitionInfo.partition_names)
  return partition_names_.Mutable(index);
}
inline void PartitionInfo::set_partition_names(int index, const std::string& value) {
  partition_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionInfo.partition_names)
}
inline void PartitionInfo::set_partition_names(int index, std::string&& value) {
  partition_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionInfo.partition_names)
}
inline void PartitionInfo::set_partition_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  partition_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.PartitionInfo.partition_names)
}
inline void PartitionInfo::set_partition_names(int index, const char* value, size_t size) {
  partition_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.PartitionInfo.partition_names)
}
inline std::string* PartitionInfo::_internal_add_partition_names() {
  return partition_names_.Add();
}
inline void PartitionInfo::add_partition_names(const std::string& value) {
  partition_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.PartitionInfo.partition_names)
}
inline void PartitionInfo::add_partition_names(std::string&& value) {
  partition_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.PartitionInfo.partition_names)
}
inline void PartitionInfo::add_partition_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  partition_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.PartitionInfo.partition_names)
}
inline void PartitionInfo::add_partition_names(const char* value, size_t size) {
  partition_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.PartitionInfo.partition_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PartitionInfo::partition_names() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PartitionInfo.partition_names)
  return partition_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PartitionInfo::mutable_partition_names() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PartitionInfo.partition_names)
  return &partition_names_;
}

// optional .baikaldb.pb.Expr hash_expr_value = 7;
inline bool PartitionInfo::_internal_has_hash_expr_value() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || hash_expr_value_ != nullptr);
  return value;
}
inline bool PartitionInfo::has_hash_expr_value() const {
  return _internal_has_hash_expr_value();
}
inline const ::baikaldb::pb::Expr& PartitionInfo::_internal_hash_expr_value() const {
  const ::baikaldb::pb::Expr* p = hash_expr_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::Expr&>(
      ::baikaldb::pb::_Expr_default_instance_);
}
inline const ::baikaldb::pb::Expr& PartitionInfo::hash_expr_value() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionInfo.hash_expr_value)
  return _internal_hash_expr_value();
}
inline void PartitionInfo::unsafe_arena_set_allocated_hash_expr_value(
    ::baikaldb::pb::Expr* hash_expr_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hash_expr_value_);
  }
  hash_expr_value_ = hash_expr_value;
  if (hash_expr_value) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.PartitionInfo.hash_expr_value)
}
inline ::baikaldb::pb::Expr* PartitionInfo::release_hash_expr_value() {
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::Expr* temp = hash_expr_value_;
  hash_expr_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::Expr* PartitionInfo::unsafe_arena_release_hash_expr_value() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PartitionInfo.hash_expr_value)
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::Expr* temp = hash_expr_value_;
  hash_expr_value_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::Expr* PartitionInfo::_internal_mutable_hash_expr_value() {
  _has_bits_[0] |= 0x00000008u;
  if (hash_expr_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::Expr>(GetArenaForAllocation());
    hash_expr_value_ = p;
  }
  return hash_expr_value_;
}
inline ::baikaldb::pb::Expr* PartitionInfo::mutable_hash_expr_value() {
  ::baikaldb::pb::Expr* _msg = _internal_mutable_hash_expr_value();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PartitionInfo.hash_expr_value)
  return _msg;
}
inline void PartitionInfo::set_allocated_hash_expr_value(::baikaldb::pb::Expr* hash_expr_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hash_expr_value_);
  }
  if (hash_expr_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hash_expr_value));
    if (message_arena != submessage_arena) {
      hash_expr_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hash_expr_value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  hash_expr_value_ = hash_expr_value;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PartitionInfo.hash_expr_value)
}

// optional string expr_string = 8;
inline bool PartitionInfo::_internal_has_expr_string() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PartitionInfo::has_expr_string() const {
  return _internal_has_expr_string();
}
inline void PartitionInfo::clear_expr_string() {
  expr_string_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PartitionInfo::expr_string() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionInfo.expr_string)
  return _internal_expr_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PartitionInfo::set_expr_string(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 expr_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionInfo.expr_string)
}
inline std::string* PartitionInfo::mutable_expr_string() {
  std::string* _s = _internal_mutable_expr_string();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PartitionInfo.expr_string)
  return _s;
}
inline const std::string& PartitionInfo::_internal_expr_string() const {
  return expr_string_.Get();
}
inline void PartitionInfo::_internal_set_expr_string(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  expr_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PartitionInfo::_internal_mutable_expr_string() {
  _has_bits_[0] |= 0x00000001u;
  return expr_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PartitionInfo::release_expr_string() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PartitionInfo.expr_string)
  if (!_internal_has_expr_string()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return expr_string_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PartitionInfo::set_allocated_expr_string(std::string* expr_string) {
  if (expr_string != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  expr_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), expr_string,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PartitionInfo.expr_string)
}

// repeated .baikaldb.pb.RangePartitionInfo range_partition_infos = 9;
inline int PartitionInfo::_internal_range_partition_infos_size() const {
  return range_partition_infos_.size();
}
inline int PartitionInfo::range_partition_infos_size() const {
  return _internal_range_partition_infos_size();
}
inline void PartitionInfo::clear_range_partition_infos() {
  range_partition_infos_.Clear();
}
inline ::baikaldb::pb::RangePartitionInfo* PartitionInfo::mutable_range_partition_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PartitionInfo.range_partition_infos)
  return range_partition_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RangePartitionInfo >*
PartitionInfo::mutable_range_partition_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PartitionInfo.range_partition_infos)
  return &range_partition_infos_;
}
inline const ::baikaldb::pb::RangePartitionInfo& PartitionInfo::_internal_range_partition_infos(int index) const {
  return range_partition_infos_.Get(index);
}
inline const ::baikaldb::pb::RangePartitionInfo& PartitionInfo::range_partition_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionInfo.range_partition_infos)
  return _internal_range_partition_infos(index);
}
inline ::baikaldb::pb::RangePartitionInfo* PartitionInfo::_internal_add_range_partition_infos() {
  return range_partition_infos_.Add();
}
inline ::baikaldb::pb::RangePartitionInfo* PartitionInfo::add_range_partition_infos() {
  ::baikaldb::pb::RangePartitionInfo* _add = _internal_add_range_partition_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.PartitionInfo.range_partition_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RangePartitionInfo >&
PartitionInfo::range_partition_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PartitionInfo.range_partition_infos)
  return range_partition_infos_;
}

// optional .baikaldb.pb.DynamicPartitionAttr dynamic_partition_attr = 10;
inline bool PartitionInfo::_internal_has_dynamic_partition_attr() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || dynamic_partition_attr_ != nullptr);
  return value;
}
inline bool PartitionInfo::has_dynamic_partition_attr() const {
  return _internal_has_dynamic_partition_attr();
}
inline void PartitionInfo::clear_dynamic_partition_attr() {
  if (dynamic_partition_attr_ != nullptr) dynamic_partition_attr_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::baikaldb::pb::DynamicPartitionAttr& PartitionInfo::_internal_dynamic_partition_attr() const {
  const ::baikaldb::pb::DynamicPartitionAttr* p = dynamic_partition_attr_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::DynamicPartitionAttr&>(
      ::baikaldb::pb::_DynamicPartitionAttr_default_instance_);
}
inline const ::baikaldb::pb::DynamicPartitionAttr& PartitionInfo::dynamic_partition_attr() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionInfo.dynamic_partition_attr)
  return _internal_dynamic_partition_attr();
}
inline void PartitionInfo::unsafe_arena_set_allocated_dynamic_partition_attr(
    ::baikaldb::pb::DynamicPartitionAttr* dynamic_partition_attr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dynamic_partition_attr_);
  }
  dynamic_partition_attr_ = dynamic_partition_attr;
  if (dynamic_partition_attr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.PartitionInfo.dynamic_partition_attr)
}
inline ::baikaldb::pb::DynamicPartitionAttr* PartitionInfo::release_dynamic_partition_attr() {
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::DynamicPartitionAttr* temp = dynamic_partition_attr_;
  dynamic_partition_attr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::DynamicPartitionAttr* PartitionInfo::unsafe_arena_release_dynamic_partition_attr() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PartitionInfo.dynamic_partition_attr)
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::DynamicPartitionAttr* temp = dynamic_partition_attr_;
  dynamic_partition_attr_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::DynamicPartitionAttr* PartitionInfo::_internal_mutable_dynamic_partition_attr() {
  _has_bits_[0] |= 0x00000010u;
  if (dynamic_partition_attr_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::DynamicPartitionAttr>(GetArenaForAllocation());
    dynamic_partition_attr_ = p;
  }
  return dynamic_partition_attr_;
}
inline ::baikaldb::pb::DynamicPartitionAttr* PartitionInfo::mutable_dynamic_partition_attr() {
  ::baikaldb::pb::DynamicPartitionAttr* _msg = _internal_mutable_dynamic_partition_attr();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PartitionInfo.dynamic_partition_attr)
  return _msg;
}
inline void PartitionInfo::set_allocated_dynamic_partition_attr(::baikaldb::pb::DynamicPartitionAttr* dynamic_partition_attr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dynamic_partition_attr_;
  }
  if (dynamic_partition_attr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::DynamicPartitionAttr>::GetOwningArena(dynamic_partition_attr);
    if (message_arena != submessage_arena) {
      dynamic_partition_attr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamic_partition_attr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  dynamic_partition_attr_ = dynamic_partition_attr;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PartitionInfo.dynamic_partition_attr)
}

// optional int64 max_range_partition_id = 11;
inline bool PartitionInfo::_internal_has_max_range_partition_id() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PartitionInfo::has_max_range_partition_id() const {
  return _internal_has_max_range_partition_id();
}
inline void PartitionInfo::clear_max_range_partition_id() {
  max_range_partition_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PartitionInfo::_internal_max_range_partition_id() const {
  return max_range_partition_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PartitionInfo::max_range_partition_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionInfo.max_range_partition_id)
  return _internal_max_range_partition_id();
}
inline void PartitionInfo::_internal_set_max_range_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  max_range_partition_id_ = value;
}
inline void PartitionInfo::set_max_range_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_max_range_partition_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionInfo.max_range_partition_id)
}

// repeated .baikaldb.pb.RangePartitionType gen_range_partition_types = 12;
inline int PartitionInfo::_internal_gen_range_partition_types_size() const {
  return gen_range_partition_types_.size();
}
inline int PartitionInfo::gen_range_partition_types_size() const {
  return _internal_gen_range_partition_types_size();
}
inline void PartitionInfo::clear_gen_range_partition_types() {
  gen_range_partition_types_.Clear();
}
inline ::baikaldb::pb::RangePartitionType PartitionInfo::_internal_gen_range_partition_types(int index) const {
  return static_cast< ::baikaldb::pb::RangePartitionType >(gen_range_partition_types_.Get(index));
}
inline ::baikaldb::pb::RangePartitionType PartitionInfo::gen_range_partition_types(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionInfo.gen_range_partition_types)
  return _internal_gen_range_partition_types(index);
}
inline void PartitionInfo::set_gen_range_partition_types(int index, ::baikaldb::pb::RangePartitionType value) {
  assert(::baikaldb::pb::RangePartitionType_IsValid(value));
  gen_range_partition_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionInfo.gen_range_partition_types)
}
inline void PartitionInfo::_internal_add_gen_range_partition_types(::baikaldb::pb::RangePartitionType value) {
  assert(::baikaldb::pb::RangePartitionType_IsValid(value));
  gen_range_partition_types_.Add(value);
}
inline void PartitionInfo::add_gen_range_partition_types(::baikaldb::pb::RangePartitionType value) {
  _internal_add_gen_range_partition_types(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.PartitionInfo.gen_range_partition_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
PartitionInfo::gen_range_partition_types() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PartitionInfo.gen_range_partition_types)
  return gen_range_partition_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
PartitionInfo::_internal_mutable_gen_range_partition_types() {
  return &gen_range_partition_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
PartitionInfo::mutable_gen_range_partition_types() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PartitionInfo.gen_range_partition_types)
  return _internal_mutable_gen_range_partition_types();
}

// optional .baikaldb.pb.RangePartitionType primary_range_partition_type = 13;
inline bool PartitionInfo::_internal_has_primary_range_partition_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PartitionInfo::has_primary_range_partition_type() const {
  return _internal_has_primary_range_partition_type();
}
inline void PartitionInfo::clear_primary_range_partition_type() {
  primary_range_partition_type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::baikaldb::pb::RangePartitionType PartitionInfo::_internal_primary_range_partition_type() const {
  return static_cast< ::baikaldb::pb::RangePartitionType >(primary_range_partition_type_);
}
inline ::baikaldb::pb::RangePartitionType PartitionInfo::primary_range_partition_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionInfo.primary_range_partition_type)
  return _internal_primary_range_partition_type();
}
inline void PartitionInfo::_internal_set_primary_range_partition_type(::baikaldb::pb::RangePartitionType value) {
  assert(::baikaldb::pb::RangePartitionType_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  primary_range_partition_type_ = value;
}
inline void PartitionInfo::set_primary_range_partition_type(::baikaldb::pb::RangePartitionType value) {
  _internal_set_primary_range_partition_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionInfo.primary_range_partition_type)
}

// -------------------------------------------------------------------

// DBLinkInfo

// optional .baikaldb.pb.DBLinkType type = 1;
inline bool DBLinkInfo::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DBLinkInfo::has_type() const {
  return _internal_has_type();
}
inline void DBLinkInfo::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::baikaldb::pb::DBLinkType DBLinkInfo::_internal_type() const {
  return static_cast< ::baikaldb::pb::DBLinkType >(type_);
}
inline ::baikaldb::pb::DBLinkType DBLinkInfo::type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DBLinkInfo.type)
  return _internal_type();
}
inline void DBLinkInfo::_internal_set_type(::baikaldb::pb::DBLinkType value) {
  assert(::baikaldb::pb::DBLinkType_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  type_ = value;
}
inline void DBLinkInfo::set_type(::baikaldb::pb::DBLinkType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DBLinkInfo.type)
}

// optional string meta_name = 2;
inline bool DBLinkInfo::_internal_has_meta_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DBLinkInfo::has_meta_name() const {
  return _internal_has_meta_name();
}
inline void DBLinkInfo::clear_meta_name() {
  meta_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DBLinkInfo::meta_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DBLinkInfo.meta_name)
  return _internal_meta_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DBLinkInfo::set_meta_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 meta_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DBLinkInfo.meta_name)
}
inline std::string* DBLinkInfo::mutable_meta_name() {
  std::string* _s = _internal_mutable_meta_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DBLinkInfo.meta_name)
  return _s;
}
inline const std::string& DBLinkInfo::_internal_meta_name() const {
  return meta_name_.Get();
}
inline void DBLinkInfo::_internal_set_meta_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  meta_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DBLinkInfo::_internal_mutable_meta_name() {
  _has_bits_[0] |= 0x00000001u;
  return meta_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DBLinkInfo::release_meta_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DBLinkInfo.meta_name)
  if (!_internal_has_meta_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return meta_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DBLinkInfo::set_allocated_meta_name(std::string* meta_name) {
  if (meta_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  meta_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), meta_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DBLinkInfo.meta_name)
}

// optional string namespace_name = 3;
inline bool DBLinkInfo::_internal_has_namespace_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DBLinkInfo::has_namespace_name() const {
  return _internal_has_namespace_name();
}
inline void DBLinkInfo::clear_namespace_name() {
  namespace_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DBLinkInfo::namespace_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DBLinkInfo.namespace_name)
  return _internal_namespace_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DBLinkInfo::set_namespace_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DBLinkInfo.namespace_name)
}
inline std::string* DBLinkInfo::mutable_namespace_name() {
  std::string* _s = _internal_mutable_namespace_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DBLinkInfo.namespace_name)
  return _s;
}
inline const std::string& DBLinkInfo::_internal_namespace_name() const {
  return namespace_name_.Get();
}
inline void DBLinkInfo::_internal_set_namespace_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DBLinkInfo::_internal_mutable_namespace_name() {
  _has_bits_[0] |= 0x00000002u;
  return namespace_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DBLinkInfo::release_namespace_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DBLinkInfo.namespace_name)
  if (!_internal_has_namespace_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return namespace_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DBLinkInfo::set_allocated_namespace_name(std::string* namespace_name) {
  if (namespace_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  namespace_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DBLinkInfo.namespace_name)
}

// optional string database_name = 4;
inline bool DBLinkInfo::_internal_has_database_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DBLinkInfo::has_database_name() const {
  return _internal_has_database_name();
}
inline void DBLinkInfo::clear_database_name() {
  database_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DBLinkInfo::database_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DBLinkInfo.database_name)
  return _internal_database_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DBLinkInfo::set_database_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 database_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DBLinkInfo.database_name)
}
inline std::string* DBLinkInfo::mutable_database_name() {
  std::string* _s = _internal_mutable_database_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DBLinkInfo.database_name)
  return _s;
}
inline const std::string& DBLinkInfo::_internal_database_name() const {
  return database_name_.Get();
}
inline void DBLinkInfo::_internal_set_database_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  database_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DBLinkInfo::_internal_mutable_database_name() {
  _has_bits_[0] |= 0x00000004u;
  return database_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DBLinkInfo::release_database_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DBLinkInfo.database_name)
  if (!_internal_has_database_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return database_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DBLinkInfo::set_allocated_database_name(std::string* database_name) {
  if (database_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  database_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DBLinkInfo.database_name)
}

// optional string table_name = 5;
inline bool DBLinkInfo::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DBLinkInfo::has_table_name() const {
  return _internal_has_table_name();
}
inline void DBLinkInfo::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DBLinkInfo::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DBLinkInfo.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DBLinkInfo::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DBLinkInfo.table_name)
}
inline std::string* DBLinkInfo::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DBLinkInfo.table_name)
  return _s;
}
inline const std::string& DBLinkInfo::_internal_table_name() const {
  return table_name_.Get();
}
inline void DBLinkInfo::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DBLinkInfo::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000008u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DBLinkInfo::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DBLinkInfo.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DBLinkInfo::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DBLinkInfo.table_name)
}

// optional int64 meta_id = 6;
inline bool DBLinkInfo::_internal_has_meta_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DBLinkInfo::has_meta_id() const {
  return _internal_has_meta_id();
}
inline void DBLinkInfo::clear_meta_id() {
  meta_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DBLinkInfo::_internal_meta_id() const {
  return meta_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DBLinkInfo::meta_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DBLinkInfo.meta_id)
  return _internal_meta_id();
}
inline void DBLinkInfo::_internal_set_meta_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  meta_id_ = value;
}
inline void DBLinkInfo::set_meta_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_meta_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DBLinkInfo.meta_id)
}

// optional .baikaldb.pb.MysqlInfo mysql_info = 7;
inline bool DBLinkInfo::_internal_has_mysql_info() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || mysql_info_ != nullptr);
  return value;
}
inline bool DBLinkInfo::has_mysql_info() const {
  return _internal_has_mysql_info();
}
inline const ::baikaldb::pb::MysqlInfo& DBLinkInfo::_internal_mysql_info() const {
  const ::baikaldb::pb::MysqlInfo* p = mysql_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::MysqlInfo&>(
      ::baikaldb::pb::_MysqlInfo_default_instance_);
}
inline const ::baikaldb::pb::MysqlInfo& DBLinkInfo::mysql_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DBLinkInfo.mysql_info)
  return _internal_mysql_info();
}
inline void DBLinkInfo::unsafe_arena_set_allocated_mysql_info(
    ::baikaldb::pb::MysqlInfo* mysql_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mysql_info_);
  }
  mysql_info_ = mysql_info;
  if (mysql_info) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DBLinkInfo.mysql_info)
}
inline ::baikaldb::pb::MysqlInfo* DBLinkInfo::release_mysql_info() {
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::MysqlInfo* temp = mysql_info_;
  mysql_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::MysqlInfo* DBLinkInfo::unsafe_arena_release_mysql_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DBLinkInfo.mysql_info)
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::MysqlInfo* temp = mysql_info_;
  mysql_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::MysqlInfo* DBLinkInfo::_internal_mutable_mysql_info() {
  _has_bits_[0] |= 0x00000010u;
  if (mysql_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::MysqlInfo>(GetArenaForAllocation());
    mysql_info_ = p;
  }
  return mysql_info_;
}
inline ::baikaldb::pb::MysqlInfo* DBLinkInfo::mutable_mysql_info() {
  ::baikaldb::pb::MysqlInfo* _msg = _internal_mutable_mysql_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DBLinkInfo.mysql_info)
  return _msg;
}
inline void DBLinkInfo::set_allocated_mysql_info(::baikaldb::pb::MysqlInfo* mysql_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mysql_info_);
  }
  if (mysql_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mysql_info));
    if (message_arena != submessage_arena) {
      mysql_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mysql_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  mysql_info_ = mysql_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DBLinkInfo.mysql_info)
}

// -------------------------------------------------------------------

// SchemaInfo

// optional int64 table_id = 1;
inline bool SchemaInfo::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool SchemaInfo::has_table_id() const {
  return _internal_has_table_id();
}
inline void SchemaInfo::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.table_id)
  return _internal_table_id();
}
inline void SchemaInfo::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00008000u;
  table_id_ = value;
}
inline void SchemaInfo::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.table_id)
}

// required string table_name = 2;
inline bool SchemaInfo::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchemaInfo::has_table_name() const {
  return _internal_has_table_name();
}
inline void SchemaInfo::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchemaInfo::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaInfo::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.table_name)
}
inline std::string* SchemaInfo::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.table_name)
  return _s;
}
inline const std::string& SchemaInfo::_internal_table_name() const {
  return table_name_.Get();
}
inline void SchemaInfo::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaInfo::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000001u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaInfo::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaInfo.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaInfo::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaInfo.table_name)
}

// optional string new_table_name = 3;
inline bool SchemaInfo::_internal_has_new_table_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchemaInfo::has_new_table_name() const {
  return _internal_has_new_table_name();
}
inline void SchemaInfo::clear_new_table_name() {
  new_table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SchemaInfo::new_table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.new_table_name)
  return _internal_new_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaInfo::set_new_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 new_table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.new_table_name)
}
inline std::string* SchemaInfo::mutable_new_table_name() {
  std::string* _s = _internal_mutable_new_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.new_table_name)
  return _s;
}
inline const std::string& SchemaInfo::_internal_new_table_name() const {
  return new_table_name_.Get();
}
inline void SchemaInfo::_internal_set_new_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  new_table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaInfo::_internal_mutable_new_table_name() {
  _has_bits_[0] |= 0x00000002u;
  return new_table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaInfo::release_new_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaInfo.new_table_name)
  if (!_internal_has_new_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return new_table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaInfo::set_allocated_new_table_name(std::string* new_table_name) {
  if (new_table_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  new_table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaInfo.new_table_name)
}

// optional string upper_table_name = 4;
inline bool SchemaInfo::_internal_has_upper_table_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchemaInfo::has_upper_table_name() const {
  return _internal_has_upper_table_name();
}
inline void SchemaInfo::clear_upper_table_name() {
  upper_table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SchemaInfo::upper_table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.upper_table_name)
  return _internal_upper_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaInfo::set_upper_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 upper_table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.upper_table_name)
}
inline std::string* SchemaInfo::mutable_upper_table_name() {
  std::string* _s = _internal_mutable_upper_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.upper_table_name)
  return _s;
}
inline const std::string& SchemaInfo::_internal_upper_table_name() const {
  return upper_table_name_.Get();
}
inline void SchemaInfo::_internal_set_upper_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  upper_table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaInfo::_internal_mutable_upper_table_name() {
  _has_bits_[0] |= 0x00000004u;
  return upper_table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaInfo::release_upper_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaInfo.upper_table_name)
  if (!_internal_has_upper_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return upper_table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaInfo::set_allocated_upper_table_name(std::string* upper_table_name) {
  if (upper_table_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  upper_table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), upper_table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaInfo.upper_table_name)
}

// optional int64 upper_table_id = 5;
inline bool SchemaInfo::_internal_has_upper_table_id() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool SchemaInfo::has_upper_table_id() const {
  return _internal_has_upper_table_id();
}
inline void SchemaInfo::clear_upper_table_id() {
  upper_table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::_internal_upper_table_id() const {
  return upper_table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::upper_table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.upper_table_id)
  return _internal_upper_table_id();
}
inline void SchemaInfo::_internal_set_upper_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00010000u;
  upper_table_id_ = value;
}
inline void SchemaInfo::set_upper_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_upper_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.upper_table_id)
}

// optional int64 top_table_id = 6;
inline bool SchemaInfo::_internal_has_top_table_id() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool SchemaInfo::has_top_table_id() const {
  return _internal_has_top_table_id();
}
inline void SchemaInfo::clear_top_table_id() {
  top_table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::_internal_top_table_id() const {
  return top_table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::top_table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.top_table_id)
  return _internal_top_table_id();
}
inline void SchemaInfo::_internal_set_top_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00020000u;
  top_table_id_ = value;
}
inline void SchemaInfo::set_top_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_top_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.top_table_id)
}

// repeated int64 lower_table_ids = 7;
inline int SchemaInfo::_internal_lower_table_ids_size() const {
  return lower_table_ids_.size();
}
inline int SchemaInfo::lower_table_ids_size() const {
  return _internal_lower_table_ids_size();
}
inline void SchemaInfo::clear_lower_table_ids() {
  lower_table_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::_internal_lower_table_ids(int index) const {
  return lower_table_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::lower_table_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.lower_table_ids)
  return _internal_lower_table_ids(index);
}
inline void SchemaInfo::set_lower_table_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  lower_table_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.lower_table_ids)
}
inline void SchemaInfo::_internal_add_lower_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  lower_table_ids_.Add(value);
}
inline void SchemaInfo::add_lower_table_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_lower_table_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.SchemaInfo.lower_table_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
SchemaInfo::_internal_lower_table_ids() const {
  return lower_table_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
SchemaInfo::lower_table_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SchemaInfo.lower_table_ids)
  return _internal_lower_table_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
SchemaInfo::_internal_mutable_lower_table_ids() {
  return &lower_table_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
SchemaInfo::mutable_lower_table_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SchemaInfo.lower_table_ids)
  return _internal_mutable_lower_table_ids();
}

// required string database = 8;
inline bool SchemaInfo::_internal_has_database() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SchemaInfo::has_database() const {
  return _internal_has_database();
}
inline void SchemaInfo::clear_database() {
  database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SchemaInfo::database() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaInfo::set_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.database)
}
inline std::string* SchemaInfo::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.database)
  return _s;
}
inline const std::string& SchemaInfo::_internal_database() const {
  return database_.Get();
}
inline void SchemaInfo::_internal_set_database(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaInfo::_internal_mutable_database() {
  _has_bits_[0] |= 0x00000008u;
  return database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaInfo::release_database() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaInfo.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaInfo::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaInfo.database)
}

// optional int64 database_id = 9;
inline bool SchemaInfo::_internal_has_database_id() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool SchemaInfo::has_database_id() const {
  return _internal_has_database_id();
}
inline void SchemaInfo::clear_database_id() {
  database_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::_internal_database_id() const {
  return database_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::database_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.database_id)
  return _internal_database_id();
}
inline void SchemaInfo::_internal_set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00040000u;
  database_id_ = value;
}
inline void SchemaInfo::set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_database_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.database_id)
}

// required string namespace_name = 10;
inline bool SchemaInfo::_internal_has_namespace_name() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SchemaInfo::has_namespace_name() const {
  return _internal_has_namespace_name();
}
inline void SchemaInfo::clear_namespace_name() {
  namespace_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& SchemaInfo::namespace_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.namespace_name)
  return _internal_namespace_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaInfo::set_namespace_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.namespace_name)
}
inline std::string* SchemaInfo::mutable_namespace_name() {
  std::string* _s = _internal_mutable_namespace_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.namespace_name)
  return _s;
}
inline const std::string& SchemaInfo::_internal_namespace_name() const {
  return namespace_name_.Get();
}
inline void SchemaInfo::_internal_set_namespace_name(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaInfo::_internal_mutable_namespace_name() {
  _has_bits_[0] |= 0x00000010u;
  return namespace_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaInfo::release_namespace_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaInfo.namespace_name)
  if (!_internal_has_namespace_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return namespace_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaInfo::set_allocated_namespace_name(std::string* namespace_name) {
  if (namespace_name != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  namespace_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaInfo.namespace_name)
}

// optional int64 namespace_id = 11;
inline bool SchemaInfo::_internal_has_namespace_id() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool SchemaInfo::has_namespace_id() const {
  return _internal_has_namespace_id();
}
inline void SchemaInfo::clear_namespace_id() {
  namespace_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::_internal_namespace_id() const {
  return namespace_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::namespace_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.namespace_id)
  return _internal_namespace_id();
}
inline void SchemaInfo::_internal_set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00080000u;
  namespace_id_ = value;
}
inline void SchemaInfo::set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_namespace_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.namespace_id)
}

// optional int64 partition_num = 12;
inline bool SchemaInfo::_internal_has_partition_num() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool SchemaInfo::has_partition_num() const {
  return _internal_has_partition_num();
}
inline void SchemaInfo::clear_partition_num() {
  partition_num_ = int64_t{0};
  _has_bits_[0] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::_internal_partition_num() const {
  return partition_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::partition_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.partition_num)
  return _internal_partition_num();
}
inline void SchemaInfo::_internal_set_partition_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00100000u;
  partition_num_ = value;
}
inline void SchemaInfo::set_partition_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_partition_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.partition_num)
}

// optional string partition_exp = 13;
inline bool SchemaInfo::_internal_has_partition_exp() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SchemaInfo::has_partition_exp() const {
  return _internal_has_partition_exp();
}
inline void SchemaInfo::clear_partition_exp() {
  partition_exp_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& SchemaInfo::partition_exp() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.partition_exp)
  return _internal_partition_exp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaInfo::set_partition_exp(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 partition_exp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.partition_exp)
}
inline std::string* SchemaInfo::mutable_partition_exp() {
  std::string* _s = _internal_mutable_partition_exp();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.partition_exp)
  return _s;
}
inline const std::string& SchemaInfo::_internal_partition_exp() const {
  return partition_exp_.Get();
}
inline void SchemaInfo::_internal_set_partition_exp(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  partition_exp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaInfo::_internal_mutable_partition_exp() {
  _has_bits_[0] |= 0x00000020u;
  return partition_exp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaInfo::release_partition_exp() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaInfo.partition_exp)
  if (!_internal_has_partition_exp()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return partition_exp_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaInfo::set_allocated_partition_exp(std::string* partition_exp) {
  if (partition_exp != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  partition_exp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), partition_exp,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaInfo.partition_exp)
}

// repeated .baikaldb.pb.PartitionRegion regions = 14;
inline int SchemaInfo::_internal_regions_size() const {
  return regions_.size();
}
inline int SchemaInfo::regions_size() const {
  return _internal_regions_size();
}
inline void SchemaInfo::clear_regions() {
  regions_.Clear();
}
inline ::baikaldb::pb::PartitionRegion* SchemaInfo::mutable_regions(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.regions)
  return regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PartitionRegion >*
SchemaInfo::mutable_regions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SchemaInfo.regions)
  return &regions_;
}
inline const ::baikaldb::pb::PartitionRegion& SchemaInfo::_internal_regions(int index) const {
  return regions_.Get(index);
}
inline const ::baikaldb::pb::PartitionRegion& SchemaInfo::regions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.regions)
  return _internal_regions(index);
}
inline ::baikaldb::pb::PartitionRegion* SchemaInfo::_internal_add_regions() {
  return regions_.Add();
}
inline ::baikaldb::pb::PartitionRegion* SchemaInfo::add_regions() {
  ::baikaldb::pb::PartitionRegion* _add = _internal_add_regions();
  // @@protoc_insertion_point(field_add:baikaldb.pb.SchemaInfo.regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PartitionRegion >&
SchemaInfo::regions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SchemaInfo.regions)
  return regions_;
}

// optional int64 region_size = 15;
inline bool SchemaInfo::_internal_has_region_size() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool SchemaInfo::has_region_size() const {
  return _internal_has_region_size();
}
inline void SchemaInfo::clear_region_size() {
  region_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00200000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::_internal_region_size() const {
  return region_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::region_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.region_size)
  return _internal_region_size();
}
inline void SchemaInfo::_internal_set_region_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00200000u;
  region_size_ = value;
}
inline void SchemaInfo::set_region_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.region_size)
}

// optional int64 replica_num = 16;
inline bool SchemaInfo::_internal_has_replica_num() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool SchemaInfo::has_replica_num() const {
  return _internal_has_replica_num();
}
inline void SchemaInfo::clear_replica_num() {
  replica_num_ = int64_t{0};
  _has_bits_[0] &= ~0x00400000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::_internal_replica_num() const {
  return replica_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::replica_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.replica_num)
  return _internal_replica_num();
}
inline void SchemaInfo::_internal_set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00400000u;
  replica_num_ = value;
}
inline void SchemaInfo::set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_replica_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.replica_num)
}

// repeated .baikaldb.pb.FieldInfo fields = 17;
inline int SchemaInfo::_internal_fields_size() const {
  return fields_.size();
}
inline int SchemaInfo::fields_size() const {
  return _internal_fields_size();
}
inline void SchemaInfo::clear_fields() {
  fields_.Clear();
}
inline ::baikaldb::pb::FieldInfo* SchemaInfo::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.fields)
  return fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FieldInfo >*
SchemaInfo::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SchemaInfo.fields)
  return &fields_;
}
inline const ::baikaldb::pb::FieldInfo& SchemaInfo::_internal_fields(int index) const {
  return fields_.Get(index);
}
inline const ::baikaldb::pb::FieldInfo& SchemaInfo::fields(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.fields)
  return _internal_fields(index);
}
inline ::baikaldb::pb::FieldInfo* SchemaInfo::_internal_add_fields() {
  return fields_.Add();
}
inline ::baikaldb::pb::FieldInfo* SchemaInfo::add_fields() {
  ::baikaldb::pb::FieldInfo* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:baikaldb.pb.SchemaInfo.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FieldInfo >&
SchemaInfo::fields() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SchemaInfo.fields)
  return fields_;
}

// repeated .baikaldb.pb.IndexInfo indexs = 18;
inline int SchemaInfo::_internal_indexs_size() const {
  return indexs_.size();
}
inline int SchemaInfo::indexs_size() const {
  return _internal_indexs_size();
}
inline void SchemaInfo::clear_indexs() {
  indexs_.Clear();
}
inline ::baikaldb::pb::IndexInfo* SchemaInfo::mutable_indexs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.indexs)
  return indexs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::IndexInfo >*
SchemaInfo::mutable_indexs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SchemaInfo.indexs)
  return &indexs_;
}
inline const ::baikaldb::pb::IndexInfo& SchemaInfo::_internal_indexs(int index) const {
  return indexs_.Get(index);
}
inline const ::baikaldb::pb::IndexInfo& SchemaInfo::indexs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.indexs)
  return _internal_indexs(index);
}
inline ::baikaldb::pb::IndexInfo* SchemaInfo::_internal_add_indexs() {
  return indexs_.Add();
}
inline ::baikaldb::pb::IndexInfo* SchemaInfo::add_indexs() {
  ::baikaldb::pb::IndexInfo* _add = _internal_add_indexs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.SchemaInfo.indexs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::IndexInfo >&
SchemaInfo::indexs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SchemaInfo.indexs)
  return indexs_;
}

// optional string resource_tag = 19;
inline bool SchemaInfo::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SchemaInfo::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void SchemaInfo::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& SchemaInfo::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaInfo::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.resource_tag)
}
inline std::string* SchemaInfo::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.resource_tag)
  return _s;
}
inline const std::string& SchemaInfo::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void SchemaInfo::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaInfo::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000040u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaInfo::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaInfo.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaInfo::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaInfo.resource_tag)
}

// optional int32 max_field_id = 20;
inline bool SchemaInfo::_internal_has_max_field_id() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool SchemaInfo::has_max_field_id() const {
  return _internal_has_max_field_id();
}
inline void SchemaInfo::clear_max_field_id() {
  max_field_id_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaInfo::_internal_max_field_id() const {
  return max_field_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaInfo::max_field_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.max_field_id)
  return _internal_max_field_id();
}
inline void SchemaInfo::_internal_set_max_field_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x01000000u;
  max_field_id_ = value;
}
inline void SchemaInfo::set_max_field_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_field_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.max_field_id)
}

// optional int64 version = 21;
inline bool SchemaInfo::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool SchemaInfo::has_version() const {
  return _internal_has_version();
}
inline void SchemaInfo::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00800000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.version)
  return _internal_version();
}
inline void SchemaInfo::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00800000u;
  version_ = value;
}
inline void SchemaInfo::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.version)
}

// optional .baikaldb.pb.Status status = 22;
inline bool SchemaInfo::_internal_has_status() const {
  bool value = (_has_bits_[1] & 0x00000080u) != 0;
  return value;
}
inline bool SchemaInfo::has_status() const {
  return _internal_has_status();
}
inline void SchemaInfo::clear_status() {
  status_ = 1;
  _has_bits_[1] &= ~0x00000080u;
}
inline ::baikaldb::pb::Status SchemaInfo::_internal_status() const {
  return static_cast< ::baikaldb::pb::Status >(status_);
}
inline ::baikaldb::pb::Status SchemaInfo::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.status)
  return _internal_status();
}
inline void SchemaInfo::_internal_set_status(::baikaldb::pb::Status value) {
  assert(::baikaldb::pb::Status_IsValid(value));
  _has_bits_[1] |= 0x00000080u;
  status_ = value;
}
inline void SchemaInfo::set_status(::baikaldb::pb::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.status)
}

// optional .baikaldb.pb.SchemaType schema_type = 23;
inline bool SchemaInfo::_internal_has_schema_type() const {
  bool value = (_has_bits_[1] & 0x00000100u) != 0;
  return value;
}
inline bool SchemaInfo::has_schema_type() const {
  return _internal_has_schema_type();
}
inline void SchemaInfo::clear_schema_type() {
  schema_type_ = 1;
  _has_bits_[1] &= ~0x00000100u;
}
inline ::baikaldb::pb::SchemaType SchemaInfo::_internal_schema_type() const {
  return static_cast< ::baikaldb::pb::SchemaType >(schema_type_);
}
inline ::baikaldb::pb::SchemaType SchemaInfo::schema_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.schema_type)
  return _internal_schema_type();
}
inline void SchemaInfo::_internal_set_schema_type(::baikaldb::pb::SchemaType value) {
  assert(::baikaldb::pb::SchemaType_IsValid(value));
  _has_bits_[1] |= 0x00000100u;
  schema_type_ = value;
}
inline void SchemaInfo::set_schema_type(::baikaldb::pb::SchemaType value) {
  _internal_set_schema_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.schema_type)
}

// optional .baikaldb.pb.Engine engine = 24;
inline bool SchemaInfo::_internal_has_engine() const {
  bool value = (_has_bits_[1] & 0x00000040u) != 0;
  return value;
}
inline bool SchemaInfo::has_engine() const {
  return _internal_has_engine();
}
inline void SchemaInfo::clear_engine() {
  engine_ = 1;
  _has_bits_[1] &= ~0x00000040u;
}
inline ::baikaldb::pb::Engine SchemaInfo::_internal_engine() const {
  return static_cast< ::baikaldb::pb::Engine >(engine_);
}
inline ::baikaldb::pb::Engine SchemaInfo::engine() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.engine)
  return _internal_engine();
}
inline void SchemaInfo::_internal_set_engine(::baikaldb::pb::Engine value) {
  assert(::baikaldb::pb::Engine_IsValid(value));
  _has_bits_[1] |= 0x00000040u;
  engine_ = value;
}
inline void SchemaInfo::set_engine(::baikaldb::pb::Engine value) {
  _internal_set_engine(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.engine)
}

// repeated string init_store = 25;
inline int SchemaInfo::_internal_init_store_size() const {
  return init_store_.size();
}
inline int SchemaInfo::init_store_size() const {
  return _internal_init_store_size();
}
inline void SchemaInfo::clear_init_store() {
  init_store_.Clear();
}
inline std::string* SchemaInfo::add_init_store() {
  std::string* _s = _internal_add_init_store();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.SchemaInfo.init_store)
  return _s;
}
inline const std::string& SchemaInfo::_internal_init_store(int index) const {
  return init_store_.Get(index);
}
inline const std::string& SchemaInfo::init_store(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.init_store)
  return _internal_init_store(index);
}
inline std::string* SchemaInfo::mutable_init_store(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.init_store)
  return init_store_.Mutable(index);
}
inline void SchemaInfo::set_init_store(int index, const std::string& value) {
  init_store_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.init_store)
}
inline void SchemaInfo::set_init_store(int index, std::string&& value) {
  init_store_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.init_store)
}
inline void SchemaInfo::set_init_store(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  init_store_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.SchemaInfo.init_store)
}
inline void SchemaInfo::set_init_store(int index, const char* value, size_t size) {
  init_store_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.SchemaInfo.init_store)
}
inline std::string* SchemaInfo::_internal_add_init_store() {
  return init_store_.Add();
}
inline void SchemaInfo::add_init_store(const std::string& value) {
  init_store_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.SchemaInfo.init_store)
}
inline void SchemaInfo::add_init_store(std::string&& value) {
  init_store_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.SchemaInfo.init_store)
}
inline void SchemaInfo::add_init_store(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  init_store_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.SchemaInfo.init_store)
}
inline void SchemaInfo::add_init_store(const char* value, size_t size) {
  init_store_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.SchemaInfo.init_store)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SchemaInfo::init_store() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SchemaInfo.init_store)
  return init_store_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SchemaInfo::mutable_init_store() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SchemaInfo.init_store)
  return &init_store_;
}

// optional bool deleted = 27;
inline bool SchemaInfo::_internal_has_deleted() const {
  bool value = (_has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool SchemaInfo::has_deleted() const {
  return _internal_has_deleted();
}
inline void SchemaInfo::clear_deleted() {
  deleted_ = false;
  _has_bits_[0] &= ~0x80000000u;
}
inline bool SchemaInfo::_internal_deleted() const {
  return deleted_;
}
inline bool SchemaInfo::deleted() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.deleted)
  return _internal_deleted();
}
inline void SchemaInfo::_internal_set_deleted(bool value) {
  _has_bits_[0] |= 0x80000000u;
  deleted_ = value;
}
inline void SchemaInfo::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.deleted)
}

// optional int64 byte_size_per_record = 28;
inline bool SchemaInfo::_internal_has_byte_size_per_record() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool SchemaInfo::has_byte_size_per_record() const {
  return _internal_has_byte_size_per_record();
}
inline void SchemaInfo::clear_byte_size_per_record() {
  byte_size_per_record_ = int64_t{0};
  _has_bits_[0] &= ~0x04000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::_internal_byte_size_per_record() const {
  return byte_size_per_record_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::byte_size_per_record() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.byte_size_per_record)
  return _internal_byte_size_per_record();
}
inline void SchemaInfo::_internal_set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x04000000u;
  byte_size_per_record_ = value;
}
inline void SchemaInfo::set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_byte_size_per_record(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.byte_size_per_record)
}

// optional uint64 auto_increment_increment = 29;
inline bool SchemaInfo::_internal_has_auto_increment_increment() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool SchemaInfo::has_auto_increment_increment() const {
  return _internal_has_auto_increment_increment();
}
inline void SchemaInfo::clear_auto_increment_increment() {
  auto_increment_increment_ = uint64_t{0u};
  _has_bits_[0] &= ~0x08000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SchemaInfo::_internal_auto_increment_increment() const {
  return auto_increment_increment_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SchemaInfo::auto_increment_increment() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.auto_increment_increment)
  return _internal_auto_increment_increment();
}
inline void SchemaInfo::_internal_set_auto_increment_increment(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x08000000u;
  auto_increment_increment_ = value;
}
inline void SchemaInfo::set_auto_increment_increment(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_auto_increment_increment(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.auto_increment_increment)
}

// optional uint32 timestamp = 30;
inline bool SchemaInfo::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool SchemaInfo::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void SchemaInfo::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x02000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SchemaInfo::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SchemaInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.timestamp)
  return _internal_timestamp();
}
inline void SchemaInfo::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x02000000u;
  timestamp_ = value;
}
inline void SchemaInfo::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.timestamp)
}

// optional .baikaldb.pb.Charset charset = 31;
inline bool SchemaInfo::_internal_has_charset() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool SchemaInfo::has_charset() const {
  return _internal_has_charset();
}
inline void SchemaInfo::clear_charset() {
  charset_ = 0;
  _has_bits_[0] &= ~0x40000000u;
}
inline ::baikaldb::pb::Charset SchemaInfo::_internal_charset() const {
  return static_cast< ::baikaldb::pb::Charset >(charset_);
}
inline ::baikaldb::pb::Charset SchemaInfo::charset() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.charset)
  return _internal_charset();
}
inline void SchemaInfo::_internal_set_charset(::baikaldb::pb::Charset value) {
  assert(::baikaldb::pb::Charset_IsValid(value));
  _has_bits_[0] |= 0x40000000u;
  charset_ = value;
}
inline void SchemaInfo::set_charset(::baikaldb::pb::Charset value) {
  _internal_set_charset(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.charset)
}

// repeated .baikaldb.pb.ReplicaDist dists = 32;
inline int SchemaInfo::_internal_dists_size() const {
  return dists_.size();
}
inline int SchemaInfo::dists_size() const {
  return _internal_dists_size();
}
inline void SchemaInfo::clear_dists() {
  dists_.Clear();
}
inline ::baikaldb::pb::ReplicaDist* SchemaInfo::mutable_dists(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.dists)
  return dists_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ReplicaDist >*
SchemaInfo::mutable_dists() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SchemaInfo.dists)
  return &dists_;
}
inline const ::baikaldb::pb::ReplicaDist& SchemaInfo::_internal_dists(int index) const {
  return dists_.Get(index);
}
inline const ::baikaldb::pb::ReplicaDist& SchemaInfo::dists(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.dists)
  return _internal_dists(index);
}
inline ::baikaldb::pb::ReplicaDist* SchemaInfo::_internal_add_dists() {
  return dists_.Add();
}
inline ::baikaldb::pb::ReplicaDist* SchemaInfo::add_dists() {
  ::baikaldb::pb::ReplicaDist* _add = _internal_add_dists();
  // @@protoc_insertion_point(field_add:baikaldb.pb.SchemaInfo.dists)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ReplicaDist >&
SchemaInfo::dists() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SchemaInfo.dists)
  return dists_;
}

// optional string main_logical_room = 33;
inline bool SchemaInfo::_internal_has_main_logical_room() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SchemaInfo::has_main_logical_room() const {
  return _internal_has_main_logical_room();
}
inline void SchemaInfo::clear_main_logical_room() {
  main_logical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& SchemaInfo::main_logical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.main_logical_room)
  return _internal_main_logical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaInfo::set_main_logical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 main_logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.main_logical_room)
}
inline std::string* SchemaInfo::mutable_main_logical_room() {
  std::string* _s = _internal_mutable_main_logical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.main_logical_room)
  return _s;
}
inline const std::string& SchemaInfo::_internal_main_logical_room() const {
  return main_logical_room_.Get();
}
inline void SchemaInfo::_internal_set_main_logical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  main_logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaInfo::_internal_mutable_main_logical_room() {
  _has_bits_[0] |= 0x00000080u;
  return main_logical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaInfo::release_main_logical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaInfo.main_logical_room)
  if (!_internal_has_main_logical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return main_logical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaInfo::set_allocated_main_logical_room(std::string* main_logical_room) {
  if (main_logical_room != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  main_logical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), main_logical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaInfo.main_logical_room)
}

// optional int64 region_split_lines = 34;
inline bool SchemaInfo::_internal_has_region_split_lines() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool SchemaInfo::has_region_split_lines() const {
  return _internal_has_region_split_lines();
}
inline void SchemaInfo::clear_region_split_lines() {
  region_split_lines_ = int64_t{0};
  _has_bits_[0] &= ~0x10000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::_internal_region_split_lines() const {
  return region_split_lines_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::region_split_lines() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.region_split_lines)
  return _internal_region_split_lines();
}
inline void SchemaInfo::_internal_set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x10000000u;
  region_split_lines_ = value;
}
inline void SchemaInfo::set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_split_lines(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.region_split_lines)
}

// repeated .baikaldb.pb.SplitKey split_keys = 36;
inline int SchemaInfo::_internal_split_keys_size() const {
  return split_keys_.size();
}
inline int SchemaInfo::split_keys_size() const {
  return _internal_split_keys_size();
}
inline void SchemaInfo::clear_split_keys() {
  split_keys_.Clear();
}
inline ::baikaldb::pb::SplitKey* SchemaInfo::mutable_split_keys(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.split_keys)
  return split_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SplitKey >*
SchemaInfo::mutable_split_keys() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SchemaInfo.split_keys)
  return &split_keys_;
}
inline const ::baikaldb::pb::SplitKey& SchemaInfo::_internal_split_keys(int index) const {
  return split_keys_.Get(index);
}
inline const ::baikaldb::pb::SplitKey& SchemaInfo::split_keys(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.split_keys)
  return _internal_split_keys(index);
}
inline ::baikaldb::pb::SplitKey* SchemaInfo::_internal_add_split_keys() {
  return split_keys_.Add();
}
inline ::baikaldb::pb::SplitKey* SchemaInfo::add_split_keys() {
  ::baikaldb::pb::SplitKey* _add = _internal_add_split_keys();
  // @@protoc_insertion_point(field_add:baikaldb.pb.SchemaInfo.split_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SplitKey >&
SchemaInfo::split_keys() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SchemaInfo.split_keys)
  return split_keys_;
}

// optional .baikaldb.pb.SchemaConf schema_conf = 37;
inline bool SchemaInfo::_internal_has_schema_conf() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || schema_conf_ != nullptr);
  return value;
}
inline bool SchemaInfo::has_schema_conf() const {
  return _internal_has_schema_conf();
}
inline const ::baikaldb::pb::SchemaConf& SchemaInfo::_internal_schema_conf() const {
  const ::baikaldb::pb::SchemaConf* p = schema_conf_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::SchemaConf&>(
      ::baikaldb::pb::_SchemaConf_default_instance_);
}
inline const ::baikaldb::pb::SchemaConf& SchemaInfo::schema_conf() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.schema_conf)
  return _internal_schema_conf();
}
inline void SchemaInfo::unsafe_arena_set_allocated_schema_conf(
    ::baikaldb::pb::SchemaConf* schema_conf) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_conf_);
  }
  schema_conf_ = schema_conf;
  if (schema_conf) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.SchemaInfo.schema_conf)
}
inline ::baikaldb::pb::SchemaConf* SchemaInfo::release_schema_conf() {
  _has_bits_[0] &= ~0x00000400u;
  ::baikaldb::pb::SchemaConf* temp = schema_conf_;
  schema_conf_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::SchemaConf* SchemaInfo::unsafe_arena_release_schema_conf() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaInfo.schema_conf)
  _has_bits_[0] &= ~0x00000400u;
  ::baikaldb::pb::SchemaConf* temp = schema_conf_;
  schema_conf_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::SchemaConf* SchemaInfo::_internal_mutable_schema_conf() {
  _has_bits_[0] |= 0x00000400u;
  if (schema_conf_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::SchemaConf>(GetArenaForAllocation());
    schema_conf_ = p;
  }
  return schema_conf_;
}
inline ::baikaldb::pb::SchemaConf* SchemaInfo::mutable_schema_conf() {
  ::baikaldb::pb::SchemaConf* _msg = _internal_mutable_schema_conf();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.schema_conf)
  return _msg;
}
inline void SchemaInfo::set_allocated_schema_conf(::baikaldb::pb::SchemaConf* schema_conf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_conf_);
  }
  if (schema_conf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_conf));
    if (message_arena != submessage_arena) {
      schema_conf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema_conf, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  schema_conf_ = schema_conf;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaInfo.schema_conf)
}

// optional int64 ttl_duration = 38;
inline bool SchemaInfo::_internal_has_ttl_duration() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool SchemaInfo::has_ttl_duration() const {
  return _internal_has_ttl_duration();
}
inline void SchemaInfo::clear_ttl_duration() {
  ttl_duration_ = int64_t{0};
  _has_bits_[0] &= ~0x20000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::_internal_ttl_duration() const {
  return ttl_duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::ttl_duration() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.ttl_duration)
  return _internal_ttl_duration();
}
inline void SchemaInfo::_internal_set_ttl_duration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x20000000u;
  ttl_duration_ = value;
}
inline void SchemaInfo::set_ttl_duration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_ttl_duration(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.ttl_duration)
}

// optional .baikaldb.pb.BinlogInfo binlog_info = 39;
inline bool SchemaInfo::_internal_has_binlog_info() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || binlog_info_ != nullptr);
  return value;
}
inline bool SchemaInfo::has_binlog_info() const {
  return _internal_has_binlog_info();
}
inline void SchemaInfo::clear_binlog_info() {
  if (binlog_info_ != nullptr) binlog_info_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::baikaldb::pb::BinlogInfo& SchemaInfo::_internal_binlog_info() const {
  const ::baikaldb::pb::BinlogInfo* p = binlog_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::BinlogInfo&>(
      ::baikaldb::pb::_BinlogInfo_default_instance_);
}
inline const ::baikaldb::pb::BinlogInfo& SchemaInfo::binlog_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.binlog_info)
  return _internal_binlog_info();
}
inline void SchemaInfo::unsafe_arena_set_allocated_binlog_info(
    ::baikaldb::pb::BinlogInfo* binlog_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(binlog_info_);
  }
  binlog_info_ = binlog_info;
  if (binlog_info) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.SchemaInfo.binlog_info)
}
inline ::baikaldb::pb::BinlogInfo* SchemaInfo::release_binlog_info() {
  _has_bits_[0] &= ~0x00000800u;
  ::baikaldb::pb::BinlogInfo* temp = binlog_info_;
  binlog_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::BinlogInfo* SchemaInfo::unsafe_arena_release_binlog_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaInfo.binlog_info)
  _has_bits_[0] &= ~0x00000800u;
  ::baikaldb::pb::BinlogInfo* temp = binlog_info_;
  binlog_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::BinlogInfo* SchemaInfo::_internal_mutable_binlog_info() {
  _has_bits_[0] |= 0x00000800u;
  if (binlog_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::BinlogInfo>(GetArenaForAllocation());
    binlog_info_ = p;
  }
  return binlog_info_;
}
inline ::baikaldb::pb::BinlogInfo* SchemaInfo::mutable_binlog_info() {
  ::baikaldb::pb::BinlogInfo* _msg = _internal_mutable_binlog_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.binlog_info)
  return _msg;
}
inline void SchemaInfo::set_allocated_binlog_info(::baikaldb::pb::BinlogInfo* binlog_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete binlog_info_;
  }
  if (binlog_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::BinlogInfo>::GetOwningArena(binlog_info);
    if (message_arena != submessage_arena) {
      binlog_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, binlog_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  binlog_info_ = binlog_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaInfo.binlog_info)
}

// optional .baikaldb.pb.PartitionInfo partition_info = 40;
inline bool SchemaInfo::_internal_has_partition_info() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || partition_info_ != nullptr);
  return value;
}
inline bool SchemaInfo::has_partition_info() const {
  return _internal_has_partition_info();
}
inline void SchemaInfo::clear_partition_info() {
  if (partition_info_ != nullptr) partition_info_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::baikaldb::pb::PartitionInfo& SchemaInfo::_internal_partition_info() const {
  const ::baikaldb::pb::PartitionInfo* p = partition_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::PartitionInfo&>(
      ::baikaldb::pb::_PartitionInfo_default_instance_);
}
inline const ::baikaldb::pb::PartitionInfo& SchemaInfo::partition_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.partition_info)
  return _internal_partition_info();
}
inline void SchemaInfo::unsafe_arena_set_allocated_partition_info(
    ::baikaldb::pb::PartitionInfo* partition_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(partition_info_);
  }
  partition_info_ = partition_info;
  if (partition_info) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.SchemaInfo.partition_info)
}
inline ::baikaldb::pb::PartitionInfo* SchemaInfo::release_partition_info() {
  _has_bits_[0] &= ~0x00001000u;
  ::baikaldb::pb::PartitionInfo* temp = partition_info_;
  partition_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::PartitionInfo* SchemaInfo::unsafe_arena_release_partition_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaInfo.partition_info)
  _has_bits_[0] &= ~0x00001000u;
  ::baikaldb::pb::PartitionInfo* temp = partition_info_;
  partition_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::PartitionInfo* SchemaInfo::_internal_mutable_partition_info() {
  _has_bits_[0] |= 0x00001000u;
  if (partition_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::PartitionInfo>(GetArenaForAllocation());
    partition_info_ = p;
  }
  return partition_info_;
}
inline ::baikaldb::pb::PartitionInfo* SchemaInfo::mutable_partition_info() {
  ::baikaldb::pb::PartitionInfo* _msg = _internal_mutable_partition_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.partition_info)
  return _msg;
}
inline void SchemaInfo::set_allocated_partition_info(::baikaldb::pb::PartitionInfo* partition_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete partition_info_;
  }
  if (partition_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::PartitionInfo>::GetOwningArena(partition_info);
    if (message_arena != submessage_arena) {
      partition_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  partition_info_ = partition_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaInfo.partition_info)
}

// optional bool is_binlog = 41;
inline bool SchemaInfo::_internal_has_is_binlog() const {
  bool value = (_has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool SchemaInfo::has_is_binlog() const {
  return _internal_has_is_binlog();
}
inline void SchemaInfo::clear_is_binlog() {
  is_binlog_ = false;
  _has_bits_[1] &= ~0x00000001u;
}
inline bool SchemaInfo::_internal_is_binlog() const {
  return is_binlog_;
}
inline bool SchemaInfo::is_binlog() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.is_binlog)
  return _internal_is_binlog();
}
inline void SchemaInfo::_internal_set_is_binlog(bool value) {
  _has_bits_[1] |= 0x00000001u;
  is_binlog_ = value;
}
inline void SchemaInfo::set_is_binlog(bool value) {
  _internal_set_is_binlog(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.is_binlog)
}

// optional .baikaldb.pb.FieldInfo link_field = 42;
inline bool SchemaInfo::_internal_has_link_field() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || link_field_ != nullptr);
  return value;
}
inline bool SchemaInfo::has_link_field() const {
  return _internal_has_link_field();
}
inline void SchemaInfo::clear_link_field() {
  if (link_field_ != nullptr) link_field_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::baikaldb::pb::FieldInfo& SchemaInfo::_internal_link_field() const {
  const ::baikaldb::pb::FieldInfo* p = link_field_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::FieldInfo&>(
      ::baikaldb::pb::_FieldInfo_default_instance_);
}
inline const ::baikaldb::pb::FieldInfo& SchemaInfo::link_field() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.link_field)
  return _internal_link_field();
}
inline void SchemaInfo::unsafe_arena_set_allocated_link_field(
    ::baikaldb::pb::FieldInfo* link_field) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(link_field_);
  }
  link_field_ = link_field;
  if (link_field) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.SchemaInfo.link_field)
}
inline ::baikaldb::pb::FieldInfo* SchemaInfo::release_link_field() {
  _has_bits_[0] &= ~0x00002000u;
  ::baikaldb::pb::FieldInfo* temp = link_field_;
  link_field_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::FieldInfo* SchemaInfo::unsafe_arena_release_link_field() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaInfo.link_field)
  _has_bits_[0] &= ~0x00002000u;
  ::baikaldb::pb::FieldInfo* temp = link_field_;
  link_field_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::FieldInfo* SchemaInfo::_internal_mutable_link_field() {
  _has_bits_[0] |= 0x00002000u;
  if (link_field_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::FieldInfo>(GetArenaForAllocation());
    link_field_ = p;
  }
  return link_field_;
}
inline ::baikaldb::pb::FieldInfo* SchemaInfo::mutable_link_field() {
  ::baikaldb::pb::FieldInfo* _msg = _internal_mutable_link_field();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.link_field)
  return _msg;
}
inline void SchemaInfo::set_allocated_link_field(::baikaldb::pb::FieldInfo* link_field) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete link_field_;
  }
  if (link_field) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::FieldInfo>::GetOwningArena(link_field);
    if (message_arena != submessage_arena) {
      link_field = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, link_field, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  link_field_ = link_field;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaInfo.link_field)
}

// optional int32 region_num = 43;
inline bool SchemaInfo::_internal_has_region_num() const {
  bool value = (_has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline bool SchemaInfo::has_region_num() const {
  return _internal_has_region_num();
}
inline void SchemaInfo::clear_region_num() {
  region_num_ = 0;
  _has_bits_[1] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaInfo::_internal_region_num() const {
  return region_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaInfo::region_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.region_num)
  return _internal_region_num();
}
inline void SchemaInfo::_internal_set_region_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[1] |= 0x00000010u;
  region_num_ = value;
}
inline void SchemaInfo::set_region_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_region_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.region_num)
}

// repeated string learner_resource_tags = 44;
inline int SchemaInfo::_internal_learner_resource_tags_size() const {
  return learner_resource_tags_.size();
}
inline int SchemaInfo::learner_resource_tags_size() const {
  return _internal_learner_resource_tags_size();
}
inline void SchemaInfo::clear_learner_resource_tags() {
  learner_resource_tags_.Clear();
}
inline std::string* SchemaInfo::add_learner_resource_tags() {
  std::string* _s = _internal_add_learner_resource_tags();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.SchemaInfo.learner_resource_tags)
  return _s;
}
inline const std::string& SchemaInfo::_internal_learner_resource_tags(int index) const {
  return learner_resource_tags_.Get(index);
}
inline const std::string& SchemaInfo::learner_resource_tags(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.learner_resource_tags)
  return _internal_learner_resource_tags(index);
}
inline std::string* SchemaInfo::mutable_learner_resource_tags(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.learner_resource_tags)
  return learner_resource_tags_.Mutable(index);
}
inline void SchemaInfo::set_learner_resource_tags(int index, const std::string& value) {
  learner_resource_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.learner_resource_tags)
}
inline void SchemaInfo::set_learner_resource_tags(int index, std::string&& value) {
  learner_resource_tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.learner_resource_tags)
}
inline void SchemaInfo::set_learner_resource_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  learner_resource_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.SchemaInfo.learner_resource_tags)
}
inline void SchemaInfo::set_learner_resource_tags(int index, const char* value, size_t size) {
  learner_resource_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.SchemaInfo.learner_resource_tags)
}
inline std::string* SchemaInfo::_internal_add_learner_resource_tags() {
  return learner_resource_tags_.Add();
}
inline void SchemaInfo::add_learner_resource_tags(const std::string& value) {
  learner_resource_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.SchemaInfo.learner_resource_tags)
}
inline void SchemaInfo::add_learner_resource_tags(std::string&& value) {
  learner_resource_tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.SchemaInfo.learner_resource_tags)
}
inline void SchemaInfo::add_learner_resource_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  learner_resource_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.SchemaInfo.learner_resource_tags)
}
inline void SchemaInfo::add_learner_resource_tags(const char* value, size_t size) {
  learner_resource_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.SchemaInfo.learner_resource_tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SchemaInfo::learner_resource_tags() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SchemaInfo.learner_resource_tags)
  return learner_resource_tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SchemaInfo::mutable_learner_resource_tags() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SchemaInfo.learner_resource_tags)
  return &learner_resource_tags_;
}

// optional int64 online_ttl_expire_time_us = 45;
inline bool SchemaInfo::_internal_has_online_ttl_expire_time_us() const {
  bool value = (_has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline bool SchemaInfo::has_online_ttl_expire_time_us() const {
  return _internal_has_online_ttl_expire_time_us();
}
inline void SchemaInfo::clear_online_ttl_expire_time_us() {
  online_ttl_expire_time_us_ = int64_t{0};
  _has_bits_[1] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::_internal_online_ttl_expire_time_us() const {
  return online_ttl_expire_time_us_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaInfo::online_ttl_expire_time_us() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.online_ttl_expire_time_us)
  return _internal_online_ttl_expire_time_us();
}
inline void SchemaInfo::_internal_set_online_ttl_expire_time_us(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[1] |= 0x00000008u;
  online_ttl_expire_time_us_ = value;
}
inline void SchemaInfo::set_online_ttl_expire_time_us(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_online_ttl_expire_time_us(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.online_ttl_expire_time_us)
}

// optional string comment = 46;
inline bool SchemaInfo::_internal_has_comment() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SchemaInfo::has_comment() const {
  return _internal_has_comment();
}
inline void SchemaInfo::clear_comment() {
  comment_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& SchemaInfo::comment() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaInfo::set_comment(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 comment_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.comment)
}
inline std::string* SchemaInfo::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.comment)
  return _s;
}
inline const std::string& SchemaInfo::_internal_comment() const {
  return comment_.Get();
}
inline void SchemaInfo::_internal_set_comment(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  comment_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaInfo::_internal_mutable_comment() {
  _has_bits_[0] |= 0x00000100u;
  return comment_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaInfo::release_comment() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaInfo.comment)
  if (!_internal_has_comment()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  return comment_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaInfo::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  comment_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comment,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaInfo.comment)
}

// optional bool if_exist = 47;
inline bool SchemaInfo::_internal_has_if_exist() const {
  bool value = (_has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline bool SchemaInfo::has_if_exist() const {
  return _internal_has_if_exist();
}
inline void SchemaInfo::clear_if_exist() {
  if_exist_ = false;
  _has_bits_[1] &= ~0x00000002u;
}
inline bool SchemaInfo::_internal_if_exist() const {
  return if_exist_;
}
inline bool SchemaInfo::if_exist() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.if_exist)
  return _internal_if_exist();
}
inline void SchemaInfo::_internal_set_if_exist(bool value) {
  _has_bits_[1] |= 0x00000002u;
  if_exist_ = value;
}
inline void SchemaInfo::set_if_exist(bool value) {
  _internal_set_if_exist(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.if_exist)
}

// optional bool partition_is_same_hint = 48;
inline bool SchemaInfo::_internal_has_partition_is_same_hint() const {
  bool value = (_has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline bool SchemaInfo::has_partition_is_same_hint() const {
  return _internal_has_partition_is_same_hint();
}
inline void SchemaInfo::clear_partition_is_same_hint() {
  partition_is_same_hint_ = false;
  _has_bits_[1] &= ~0x00000004u;
}
inline bool SchemaInfo::_internal_partition_is_same_hint() const {
  return partition_is_same_hint_;
}
inline bool SchemaInfo::partition_is_same_hint() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.partition_is_same_hint)
  return _internal_partition_is_same_hint();
}
inline void SchemaInfo::_internal_set_partition_is_same_hint(bool value) {
  _has_bits_[1] |= 0x00000004u;
  partition_is_same_hint_ = value;
}
inline void SchemaInfo::set_partition_is_same_hint(bool value) {
  _internal_set_partition_is_same_hint(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.partition_is_same_hint)
}

// repeated .baikaldb.pb.BinlogInfo binlog_infos = 49;
inline int SchemaInfo::_internal_binlog_infos_size() const {
  return binlog_infos_.size();
}
inline int SchemaInfo::binlog_infos_size() const {
  return _internal_binlog_infos_size();
}
inline void SchemaInfo::clear_binlog_infos() {
  binlog_infos_.Clear();
}
inline ::baikaldb::pb::BinlogInfo* SchemaInfo::mutable_binlog_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.binlog_infos)
  return binlog_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogInfo >*
SchemaInfo::mutable_binlog_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SchemaInfo.binlog_infos)
  return &binlog_infos_;
}
inline const ::baikaldb::pb::BinlogInfo& SchemaInfo::_internal_binlog_infos(int index) const {
  return binlog_infos_.Get(index);
}
inline const ::baikaldb::pb::BinlogInfo& SchemaInfo::binlog_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.binlog_infos)
  return _internal_binlog_infos(index);
}
inline ::baikaldb::pb::BinlogInfo* SchemaInfo::_internal_add_binlog_infos() {
  return binlog_infos_.Add();
}
inline ::baikaldb::pb::BinlogInfo* SchemaInfo::add_binlog_infos() {
  ::baikaldb::pb::BinlogInfo* _add = _internal_add_binlog_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.SchemaInfo.binlog_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogInfo >&
SchemaInfo::binlog_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SchemaInfo.binlog_infos)
  return binlog_infos_;
}

// optional .baikaldb.pb.DBLinkInfo dblink_info = 50;
inline bool SchemaInfo::_internal_has_dblink_info() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || dblink_info_ != nullptr);
  return value;
}
inline bool SchemaInfo::has_dblink_info() const {
  return _internal_has_dblink_info();
}
inline void SchemaInfo::clear_dblink_info() {
  if (dblink_info_ != nullptr) dblink_info_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::baikaldb::pb::DBLinkInfo& SchemaInfo::_internal_dblink_info() const {
  const ::baikaldb::pb::DBLinkInfo* p = dblink_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::DBLinkInfo&>(
      ::baikaldb::pb::_DBLinkInfo_default_instance_);
}
inline const ::baikaldb::pb::DBLinkInfo& SchemaInfo::dblink_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.dblink_info)
  return _internal_dblink_info();
}
inline void SchemaInfo::unsafe_arena_set_allocated_dblink_info(
    ::baikaldb::pb::DBLinkInfo* dblink_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dblink_info_);
  }
  dblink_info_ = dblink_info;
  if (dblink_info) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.SchemaInfo.dblink_info)
}
inline ::baikaldb::pb::DBLinkInfo* SchemaInfo::release_dblink_info() {
  _has_bits_[0] &= ~0x00004000u;
  ::baikaldb::pb::DBLinkInfo* temp = dblink_info_;
  dblink_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::DBLinkInfo* SchemaInfo::unsafe_arena_release_dblink_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaInfo.dblink_info)
  _has_bits_[0] &= ~0x00004000u;
  ::baikaldb::pb::DBLinkInfo* temp = dblink_info_;
  dblink_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::DBLinkInfo* SchemaInfo::_internal_mutable_dblink_info() {
  _has_bits_[0] |= 0x00004000u;
  if (dblink_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::DBLinkInfo>(GetArenaForAllocation());
    dblink_info_ = p;
  }
  return dblink_info_;
}
inline ::baikaldb::pb::DBLinkInfo* SchemaInfo::mutable_dblink_info() {
  ::baikaldb::pb::DBLinkInfo* _msg = _internal_mutable_dblink_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.dblink_info)
  return _msg;
}
inline void SchemaInfo::set_allocated_dblink_info(::baikaldb::pb::DBLinkInfo* dblink_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dblink_info_;
  }
  if (dblink_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::DBLinkInfo>::GetOwningArena(dblink_info);
    if (message_arena != submessage_arena) {
      dblink_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dblink_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  dblink_info_ = dblink_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaInfo.dblink_info)
}

// optional bool or_replace = 51;
inline bool SchemaInfo::_internal_has_or_replace() const {
  bool value = (_has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline bool SchemaInfo::has_or_replace() const {
  return _internal_has_or_replace();
}
inline void SchemaInfo::clear_or_replace() {
  or_replace_ = false;
  _has_bits_[1] &= ~0x00000020u;
}
inline bool SchemaInfo::_internal_or_replace() const {
  return or_replace_;
}
inline bool SchemaInfo::or_replace() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.or_replace)
  return _internal_or_replace();
}
inline void SchemaInfo::_internal_set_or_replace(bool value) {
  _has_bits_[1] |= 0x00000020u;
  or_replace_ = value;
}
inline void SchemaInfo::set_or_replace(bool value) {
  _internal_set_or_replace(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.or_replace)
}

// optional string view_select_stmt = 52;
inline bool SchemaInfo::_internal_has_view_select_stmt() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool SchemaInfo::has_view_select_stmt() const {
  return _internal_has_view_select_stmt();
}
inline void SchemaInfo::clear_view_select_stmt() {
  view_select_stmt_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& SchemaInfo::view_select_stmt() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaInfo.view_select_stmt)
  return _internal_view_select_stmt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaInfo::set_view_select_stmt(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 view_select_stmt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaInfo.view_select_stmt)
}
inline std::string* SchemaInfo::mutable_view_select_stmt() {
  std::string* _s = _internal_mutable_view_select_stmt();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaInfo.view_select_stmt)
  return _s;
}
inline const std::string& SchemaInfo::_internal_view_select_stmt() const {
  return view_select_stmt_.Get();
}
inline void SchemaInfo::_internal_set_view_select_stmt(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  view_select_stmt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaInfo::_internal_mutable_view_select_stmt() {
  _has_bits_[0] |= 0x00000200u;
  return view_select_stmt_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaInfo::release_view_select_stmt() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaInfo.view_select_stmt)
  if (!_internal_has_view_select_stmt()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  return view_select_stmt_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaInfo::set_allocated_view_select_stmt(std::string* view_select_stmt) {
  if (view_select_stmt != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  view_select_stmt_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), view_select_stmt,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaInfo.view_select_stmt)
}

// -------------------------------------------------------------------

// PartitionRegion

// required int64 partition_id = 1;
inline bool PartitionRegion::_internal_has_partition_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PartitionRegion::has_partition_id() const {
  return _internal_has_partition_id();
}
inline void PartitionRegion::clear_partition_id() {
  partition_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PartitionRegion::_internal_partition_id() const {
  return partition_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PartitionRegion::partition_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionRegion.partition_id)
  return _internal_partition_id();
}
inline void PartitionRegion::_internal_set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  partition_id_ = value;
}
inline void PartitionRegion::set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_partition_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionRegion.partition_id)
}

// repeated int64 region_id = 2;
inline int PartitionRegion::_internal_region_id_size() const {
  return region_id_.size();
}
inline int PartitionRegion::region_id_size() const {
  return _internal_region_id_size();
}
inline void PartitionRegion::clear_region_id() {
  region_id_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PartitionRegion::_internal_region_id(int index) const {
  return region_id_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PartitionRegion::region_id(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionRegion.region_id)
  return _internal_region_id(index);
}
inline void PartitionRegion::set_region_id(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  region_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionRegion.region_id)
}
inline void PartitionRegion::_internal_add_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  region_id_.Add(value);
}
inline void PartitionRegion::add_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_region_id(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.PartitionRegion.region_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
PartitionRegion::_internal_region_id() const {
  return region_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
PartitionRegion::region_id() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PartitionRegion.region_id)
  return _internal_region_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
PartitionRegion::_internal_mutable_region_id() {
  return &region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
PartitionRegion::mutable_region_id() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PartitionRegion.region_id)
  return _internal_mutable_region_id();
}

// -------------------------------------------------------------------

// FieldInfo

// required string field_name = 1;
inline bool FieldInfo::_internal_has_field_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FieldInfo::has_field_name() const {
  return _internal_has_field_name();
}
inline void FieldInfo::clear_field_name() {
  field_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FieldInfo::field_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldInfo.field_name)
  return _internal_field_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldInfo::set_field_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 field_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldInfo.field_name)
}
inline std::string* FieldInfo::mutable_field_name() {
  std::string* _s = _internal_mutable_field_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FieldInfo.field_name)
  return _s;
}
inline const std::string& FieldInfo::_internal_field_name() const {
  return field_name_.Get();
}
inline void FieldInfo::_internal_set_field_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  field_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldInfo::_internal_mutable_field_name() {
  _has_bits_[0] |= 0x00000001u;
  return field_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldInfo::release_field_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.FieldInfo.field_name)
  if (!_internal_has_field_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return field_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldInfo::set_allocated_field_name(std::string* field_name) {
  if (field_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  field_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), field_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.FieldInfo.field_name)
}

// optional string new_field_name = 2;
inline bool FieldInfo::_internal_has_new_field_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FieldInfo::has_new_field_name() const {
  return _internal_has_new_field_name();
}
inline void FieldInfo::clear_new_field_name() {
  new_field_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FieldInfo::new_field_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldInfo.new_field_name)
  return _internal_new_field_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldInfo::set_new_field_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 new_field_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldInfo.new_field_name)
}
inline std::string* FieldInfo::mutable_new_field_name() {
  std::string* _s = _internal_mutable_new_field_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FieldInfo.new_field_name)
  return _s;
}
inline const std::string& FieldInfo::_internal_new_field_name() const {
  return new_field_name_.Get();
}
inline void FieldInfo::_internal_set_new_field_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  new_field_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldInfo::_internal_mutable_new_field_name() {
  _has_bits_[0] |= 0x00000002u;
  return new_field_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldInfo::release_new_field_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.FieldInfo.new_field_name)
  if (!_internal_has_new_field_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return new_field_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldInfo::set_allocated_new_field_name(std::string* new_field_name) {
  if (new_field_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  new_field_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_field_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.FieldInfo.new_field_name)
}

// optional .baikaldb.pb.PrimitiveType mysql_type = 3;
inline bool FieldInfo::_internal_has_mysql_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool FieldInfo::has_mysql_type() const {
  return _internal_has_mysql_type();
}
inline void FieldInfo::clear_mysql_type() {
  mysql_type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::baikaldb::pb::PrimitiveType FieldInfo::_internal_mysql_type() const {
  return static_cast< ::baikaldb::pb::PrimitiveType >(mysql_type_);
}
inline ::baikaldb::pb::PrimitiveType FieldInfo::mysql_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldInfo.mysql_type)
  return _internal_mysql_type();
}
inline void FieldInfo::_internal_set_mysql_type(::baikaldb::pb::PrimitiveType value) {
  assert(::baikaldb::pb::PrimitiveType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  mysql_type_ = value;
}
inline void FieldInfo::set_mysql_type(::baikaldb::pb::PrimitiveType value) {
  _internal_set_mysql_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldInfo.mysql_type)
}

// optional bool can_null = 4;
inline bool FieldInfo::_internal_has_can_null() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool FieldInfo::has_can_null() const {
  return _internal_has_can_null();
}
inline void FieldInfo::clear_can_null() {
  can_null_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool FieldInfo::_internal_can_null() const {
  return can_null_;
}
inline bool FieldInfo::can_null() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldInfo.can_null)
  return _internal_can_null();
}
inline void FieldInfo::_internal_set_can_null(bool value) {
  _has_bits_[0] |= 0x00000200u;
  can_null_ = value;
}
inline void FieldInfo::set_can_null(bool value) {
  _internal_set_can_null(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldInfo.can_null)
}

// optional int32 field_id = 5;
inline bool FieldInfo::_internal_has_field_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool FieldInfo::has_field_id() const {
  return _internal_has_field_id();
}
inline void FieldInfo::clear_field_id() {
  field_id_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FieldInfo::_internal_field_id() const {
  return field_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FieldInfo::field_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldInfo.field_id)
  return _internal_field_id();
}
inline void FieldInfo::_internal_set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  field_id_ = value;
}
inline void FieldInfo::set_field_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_field_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldInfo.field_id)
}

// optional bool auto_increment = 6;
inline bool FieldInfo::_internal_has_auto_increment() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool FieldInfo::has_auto_increment() const {
  return _internal_has_auto_increment();
}
inline void FieldInfo::clear_auto_increment() {
  auto_increment_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool FieldInfo::_internal_auto_increment() const {
  return auto_increment_;
}
inline bool FieldInfo::auto_increment() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldInfo.auto_increment)
  return _internal_auto_increment();
}
inline void FieldInfo::_internal_set_auto_increment(bool value) {
  _has_bits_[0] |= 0x00000400u;
  auto_increment_ = value;
}
inline void FieldInfo::set_auto_increment(bool value) {
  _internal_set_auto_increment(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldInfo.auto_increment)
}

// optional bool deleted = 7;
inline bool FieldInfo::_internal_has_deleted() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool FieldInfo::has_deleted() const {
  return _internal_has_deleted();
}
inline void FieldInfo::clear_deleted() {
  deleted_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool FieldInfo::_internal_deleted() const {
  return deleted_;
}
inline bool FieldInfo::deleted() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldInfo.deleted)
  return _internal_deleted();
}
inline void FieldInfo::_internal_set_deleted(bool value) {
  _has_bits_[0] |= 0x00000800u;
  deleted_ = value;
}
inline void FieldInfo::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldInfo.deleted)
}

// optional bytes default_value = 8;
inline bool FieldInfo::_internal_has_default_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FieldInfo::has_default_value() const {
  return _internal_has_default_value();
}
inline void FieldInfo::clear_default_value() {
  default_value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FieldInfo::default_value() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldInfo.default_value)
  return _internal_default_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldInfo::set_default_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 default_value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldInfo.default_value)
}
inline std::string* FieldInfo::mutable_default_value() {
  std::string* _s = _internal_mutable_default_value();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FieldInfo.default_value)
  return _s;
}
inline const std::string& FieldInfo::_internal_default_value() const {
  return default_value_.Get();
}
inline void FieldInfo::_internal_set_default_value(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  default_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldInfo::_internal_mutable_default_value() {
  _has_bits_[0] |= 0x00000004u;
  return default_value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldInfo::release_default_value() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.FieldInfo.default_value)
  if (!_internal_has_default_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return default_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldInfo::set_allocated_default_value(std::string* default_value) {
  if (default_value != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  default_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), default_value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.FieldInfo.default_value)
}

// optional bytes comment = 9;
inline bool FieldInfo::_internal_has_comment() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FieldInfo::has_comment() const {
  return _internal_has_comment();
}
inline void FieldInfo::clear_comment() {
  comment_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& FieldInfo::comment() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldInfo.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldInfo::set_comment(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 comment_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldInfo.comment)
}
inline std::string* FieldInfo::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FieldInfo.comment)
  return _s;
}
inline const std::string& FieldInfo::_internal_comment() const {
  return comment_.Get();
}
inline void FieldInfo::_internal_set_comment(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  comment_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldInfo::_internal_mutable_comment() {
  _has_bits_[0] |= 0x00000008u;
  return comment_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldInfo::release_comment() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.FieldInfo.comment)
  if (!_internal_has_comment()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return comment_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldInfo::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  comment_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comment,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.FieldInfo.comment)
}

// optional bytes on_update_value = 10;
inline bool FieldInfo::_internal_has_on_update_value() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FieldInfo::has_on_update_value() const {
  return _internal_has_on_update_value();
}
inline void FieldInfo::clear_on_update_value() {
  on_update_value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& FieldInfo::on_update_value() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldInfo.on_update_value)
  return _internal_on_update_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldInfo::set_on_update_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 on_update_value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldInfo.on_update_value)
}
inline std::string* FieldInfo::mutable_on_update_value() {
  std::string* _s = _internal_mutable_on_update_value();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FieldInfo.on_update_value)
  return _s;
}
inline const std::string& FieldInfo::_internal_on_update_value() const {
  return on_update_value_.Get();
}
inline void FieldInfo::_internal_set_on_update_value(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  on_update_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldInfo::_internal_mutable_on_update_value() {
  _has_bits_[0] |= 0x00000010u;
  return on_update_value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldInfo::release_on_update_value() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.FieldInfo.on_update_value)
  if (!_internal_has_on_update_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return on_update_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldInfo::set_allocated_on_update_value(std::string* on_update_value) {
  if (on_update_value != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  on_update_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), on_update_value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.FieldInfo.on_update_value)
}

// optional bytes encrypt = 11;
inline bool FieldInfo::_internal_has_encrypt() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FieldInfo::has_encrypt() const {
  return _internal_has_encrypt();
}
inline void FieldInfo::clear_encrypt() {
  encrypt_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& FieldInfo::encrypt() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldInfo.encrypt)
  return _internal_encrypt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldInfo::set_encrypt(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 encrypt_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldInfo.encrypt)
}
inline std::string* FieldInfo::mutable_encrypt() {
  std::string* _s = _internal_mutable_encrypt();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FieldInfo.encrypt)
  return _s;
}
inline const std::string& FieldInfo::_internal_encrypt() const {
  return encrypt_.Get();
}
inline void FieldInfo::_internal_set_encrypt(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  encrypt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldInfo::_internal_mutable_encrypt() {
  _has_bits_[0] |= 0x00000020u;
  return encrypt_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldInfo::release_encrypt() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.FieldInfo.encrypt)
  if (!_internal_has_encrypt()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return encrypt_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldInfo::set_allocated_encrypt(std::string* encrypt) {
  if (encrypt != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  encrypt_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encrypt,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.FieldInfo.encrypt)
}

// optional uint32 flag = 12;
inline bool FieldInfo::_internal_has_flag() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool FieldInfo::has_flag() const {
  return _internal_has_flag();
}
inline void FieldInfo::clear_flag() {
  flag_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FieldInfo::_internal_flag() const {
  return flag_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FieldInfo::flag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldInfo.flag)
  return _internal_flag();
}
inline void FieldInfo::_internal_set_flag(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  flag_ = value;
}
inline void FieldInfo::set_flag(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldInfo.flag)
}

// optional bytes default_literal = 13;
inline bool FieldInfo::_internal_has_default_literal() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool FieldInfo::has_default_literal() const {
  return _internal_has_default_literal();
}
inline void FieldInfo::clear_default_literal() {
  default_literal_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& FieldInfo::default_literal() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldInfo.default_literal)
  return _internal_default_literal();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldInfo::set_default_literal(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 default_literal_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldInfo.default_literal)
}
inline std::string* FieldInfo::mutable_default_literal() {
  std::string* _s = _internal_mutable_default_literal();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FieldInfo.default_literal)
  return _s;
}
inline const std::string& FieldInfo::_internal_default_literal() const {
  return default_literal_.Get();
}
inline void FieldInfo::_internal_set_default_literal(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  default_literal_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FieldInfo::_internal_mutable_default_literal() {
  _has_bits_[0] |= 0x00000040u;
  return default_literal_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FieldInfo::release_default_literal() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.FieldInfo.default_literal)
  if (!_internal_has_default_literal()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return default_literal_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FieldInfo::set_allocated_default_literal(std::string* default_literal) {
  if (default_literal != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  default_literal_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), default_literal,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.FieldInfo.default_literal)
}

// optional bool is_unique_indicator = 14;
inline bool FieldInfo::_internal_has_is_unique_indicator() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool FieldInfo::has_is_unique_indicator() const {
  return _internal_has_is_unique_indicator();
}
inline void FieldInfo::clear_is_unique_indicator() {
  is_unique_indicator_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool FieldInfo::_internal_is_unique_indicator() const {
  return is_unique_indicator_;
}
inline bool FieldInfo::is_unique_indicator() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldInfo.is_unique_indicator)
  return _internal_is_unique_indicator();
}
inline void FieldInfo::_internal_set_is_unique_indicator(bool value) {
  _has_bits_[0] |= 0x00001000u;
  is_unique_indicator_ = value;
}
inline void FieldInfo::set_is_unique_indicator(bool value) {
  _internal_set_is_unique_indicator(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldInfo.is_unique_indicator)
}

// optional int32 float_total_len = 15;
inline bool FieldInfo::_internal_has_float_total_len() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool FieldInfo::has_float_total_len() const {
  return _internal_has_float_total_len();
}
inline void FieldInfo::clear_float_total_len() {
  float_total_len_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FieldInfo::_internal_float_total_len() const {
  return float_total_len_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FieldInfo::float_total_len() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldInfo.float_total_len)
  return _internal_float_total_len();
}
inline void FieldInfo::_internal_set_float_total_len(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00004000u;
  float_total_len_ = value;
}
inline void FieldInfo::set_float_total_len(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_float_total_len(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldInfo.float_total_len)
}

// optional int32 float_precision_len = 16;
inline bool FieldInfo::_internal_has_float_precision_len() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool FieldInfo::has_float_precision_len() const {
  return _internal_has_float_precision_len();
}
inline void FieldInfo::clear_float_precision_len() {
  float_precision_len_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FieldInfo::_internal_float_precision_len() const {
  return float_precision_len_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FieldInfo::float_precision_len() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FieldInfo.float_precision_len)
  return _internal_float_precision_len();
}
inline void FieldInfo::_internal_set_float_precision_len(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00008000u;
  float_precision_len_ = value;
}
inline void FieldInfo::set_float_precision_len(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_float_precision_len(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FieldInfo.float_precision_len)
}

// -------------------------------------------------------------------

// IndexInfo

// required string index_name = 1;
inline bool IndexInfo::_internal_has_index_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IndexInfo::has_index_name() const {
  return _internal_has_index_name();
}
inline void IndexInfo::clear_index_name() {
  index_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IndexInfo::index_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.index_name)
  return _internal_index_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IndexInfo::set_index_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.index_name)
}
inline std::string* IndexInfo::mutable_index_name() {
  std::string* _s = _internal_mutable_index_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.IndexInfo.index_name)
  return _s;
}
inline const std::string& IndexInfo::_internal_index_name() const {
  return index_name_.Get();
}
inline void IndexInfo::_internal_set_index_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IndexInfo::_internal_mutable_index_name() {
  _has_bits_[0] |= 0x00000001u;
  return index_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IndexInfo::release_index_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.IndexInfo.index_name)
  if (!_internal_has_index_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return index_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IndexInfo::set_allocated_index_name(std::string* index_name) {
  if (index_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  index_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.IndexInfo.index_name)
}

// optional string new_index_name = 2;
inline bool IndexInfo::_internal_has_new_index_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IndexInfo::has_new_index_name() const {
  return _internal_has_new_index_name();
}
inline void IndexInfo::clear_new_index_name() {
  new_index_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IndexInfo::new_index_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.new_index_name)
  return _internal_new_index_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IndexInfo::set_new_index_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 new_index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.new_index_name)
}
inline std::string* IndexInfo::mutable_new_index_name() {
  std::string* _s = _internal_mutable_new_index_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.IndexInfo.new_index_name)
  return _s;
}
inline const std::string& IndexInfo::_internal_new_index_name() const {
  return new_index_name_.Get();
}
inline void IndexInfo::_internal_set_new_index_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  new_index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IndexInfo::_internal_mutable_new_index_name() {
  _has_bits_[0] |= 0x00000002u;
  return new_index_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IndexInfo::release_new_index_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.IndexInfo.new_index_name)
  if (!_internal_has_new_index_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return new_index_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IndexInfo::set_allocated_new_index_name(std::string* new_index_name) {
  if (new_index_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  new_index_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_index_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.IndexInfo.new_index_name)
}

// optional .baikaldb.pb.IndexType index_type = 3;
inline bool IndexInfo::_internal_has_index_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool IndexInfo::has_index_type() const {
  return _internal_has_index_type();
}
inline void IndexInfo::clear_index_type() {
  index_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::baikaldb::pb::IndexType IndexInfo::_internal_index_type() const {
  return static_cast< ::baikaldb::pb::IndexType >(index_type_);
}
inline ::baikaldb::pb::IndexType IndexInfo::index_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.index_type)
  return _internal_index_type();
}
inline void IndexInfo::_internal_set_index_type(::baikaldb::pb::IndexType value) {
  assert(::baikaldb::pb::IndexType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  index_type_ = value;
}
inline void IndexInfo::set_index_type(::baikaldb::pb::IndexType value) {
  _internal_set_index_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.index_type)
}

// repeated string field_names = 4;
inline int IndexInfo::_internal_field_names_size() const {
  return field_names_.size();
}
inline int IndexInfo::field_names_size() const {
  return _internal_field_names_size();
}
inline void IndexInfo::clear_field_names() {
  field_names_.Clear();
}
inline std::string* IndexInfo::add_field_names() {
  std::string* _s = _internal_add_field_names();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.IndexInfo.field_names)
  return _s;
}
inline const std::string& IndexInfo::_internal_field_names(int index) const {
  return field_names_.Get(index);
}
inline const std::string& IndexInfo::field_names(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.field_names)
  return _internal_field_names(index);
}
inline std::string* IndexInfo::mutable_field_names(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.IndexInfo.field_names)
  return field_names_.Mutable(index);
}
inline void IndexInfo::set_field_names(int index, const std::string& value) {
  field_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.field_names)
}
inline void IndexInfo::set_field_names(int index, std::string&& value) {
  field_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.field_names)
}
inline void IndexInfo::set_field_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.IndexInfo.field_names)
}
inline void IndexInfo::set_field_names(int index, const char* value, size_t size) {
  field_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.IndexInfo.field_names)
}
inline std::string* IndexInfo::_internal_add_field_names() {
  return field_names_.Add();
}
inline void IndexInfo::add_field_names(const std::string& value) {
  field_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.IndexInfo.field_names)
}
inline void IndexInfo::add_field_names(std::string&& value) {
  field_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.IndexInfo.field_names)
}
inline void IndexInfo::add_field_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.IndexInfo.field_names)
}
inline void IndexInfo::add_field_names(const char* value, size_t size) {
  field_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.IndexInfo.field_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IndexInfo::field_names() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.IndexInfo.field_names)
  return field_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IndexInfo::mutable_field_names() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.IndexInfo.field_names)
  return &field_names_;
}

// repeated int32 field_ids = 5;
inline int IndexInfo::_internal_field_ids_size() const {
  return field_ids_.size();
}
inline int IndexInfo::field_ids_size() const {
  return _internal_field_ids_size();
}
inline void IndexInfo::clear_field_ids() {
  field_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IndexInfo::_internal_field_ids(int index) const {
  return field_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IndexInfo::field_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.field_ids)
  return _internal_field_ids(index);
}
inline void IndexInfo::set_field_ids(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  field_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.field_ids)
}
inline void IndexInfo::_internal_add_field_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  field_ids_.Add(value);
}
inline void IndexInfo::add_field_ids(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_field_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.IndexInfo.field_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
IndexInfo::_internal_field_ids() const {
  return field_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
IndexInfo::field_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.IndexInfo.field_ids)
  return _internal_field_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
IndexInfo::_internal_mutable_field_ids() {
  return &field_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
IndexInfo::mutable_field_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.IndexInfo.field_ids)
  return _internal_mutable_field_ids();
}

// optional bool is_global = 6;
inline bool IndexInfo::_internal_has_is_global() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool IndexInfo::has_is_global() const {
  return _internal_has_is_global();
}
inline void IndexInfo::clear_is_global() {
  is_global_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool IndexInfo::_internal_is_global() const {
  return is_global_;
}
inline bool IndexInfo::is_global() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.is_global)
  return _internal_is_global();
}
inline void IndexInfo::_internal_set_is_global(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_global_ = value;
}
inline void IndexInfo::set_is_global(bool value) {
  _internal_set_is_global(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.is_global)
}

// optional int64 index_id = 7;
inline bool IndexInfo::_internal_has_index_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool IndexInfo::has_index_id() const {
  return _internal_has_index_id();
}
inline void IndexInfo::clear_index_id() {
  index_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexInfo::_internal_index_id() const {
  return index_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexInfo::index_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.index_id)
  return _internal_index_id();
}
inline void IndexInfo::_internal_set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  index_id_ = value;
}
inline void IndexInfo::set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_index_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.index_id)
}

// optional .baikaldb.pb.SegmentType segment_type = 8;
inline bool IndexInfo::_internal_has_segment_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool IndexInfo::has_segment_type() const {
  return _internal_has_segment_type();
}
inline void IndexInfo::clear_segment_type() {
  segment_type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::baikaldb::pb::SegmentType IndexInfo::_internal_segment_type() const {
  return static_cast< ::baikaldb::pb::SegmentType >(segment_type_);
}
inline ::baikaldb::pb::SegmentType IndexInfo::segment_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.segment_type)
  return _internal_segment_type();
}
inline void IndexInfo::_internal_set_segment_type(::baikaldb::pb::SegmentType value) {
  assert(::baikaldb::pb::SegmentType_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  segment_type_ = value;
}
inline void IndexInfo::set_segment_type(::baikaldb::pb::SegmentType value) {
  _internal_set_segment_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.segment_type)
}

// optional .baikaldb.pb.IndexState state = 9;
inline bool IndexInfo::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool IndexInfo::has_state() const {
  return _internal_has_state();
}
inline void IndexInfo::clear_state() {
  state_ = 1;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::baikaldb::pb::IndexState IndexInfo::_internal_state() const {
  return static_cast< ::baikaldb::pb::IndexState >(state_);
}
inline ::baikaldb::pb::IndexState IndexInfo::state() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.state)
  return _internal_state();
}
inline void IndexInfo::_internal_set_state(::baikaldb::pb::IndexState value) {
  assert(::baikaldb::pb::IndexState_IsValid(value));
  _has_bits_[0] |= 0x00010000u;
  state_ = value;
}
inline void IndexInfo::set_state(::baikaldb::pb::IndexState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.state)
}

// optional .baikaldb.pb.StorageType storage_type = 10;
inline bool IndexInfo::_internal_has_storage_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool IndexInfo::has_storage_type() const {
  return _internal_has_storage_type();
}
inline void IndexInfo::clear_storage_type() {
  storage_type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::baikaldb::pb::StorageType IndexInfo::_internal_storage_type() const {
  return static_cast< ::baikaldb::pb::StorageType >(storage_type_);
}
inline ::baikaldb::pb::StorageType IndexInfo::storage_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.storage_type)
  return _internal_storage_type();
}
inline void IndexInfo::_internal_set_storage_type(::baikaldb::pb::StorageType value) {
  assert(::baikaldb::pb::StorageType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  storage_type_ = value;
}
inline void IndexInfo::set_storage_type(::baikaldb::pb::StorageType value) {
  _internal_set_storage_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.storage_type)
}

// optional .baikaldb.pb.IndexHintStatus hint_status = 11;
inline bool IndexInfo::_internal_has_hint_status() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool IndexInfo::has_hint_status() const {
  return _internal_has_hint_status();
}
inline void IndexInfo::clear_hint_status() {
  hint_status_ = 1;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::baikaldb::pb::IndexHintStatus IndexInfo::_internal_hint_status() const {
  return static_cast< ::baikaldb::pb::IndexHintStatus >(hint_status_);
}
inline ::baikaldb::pb::IndexHintStatus IndexInfo::hint_status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.hint_status)
  return _internal_hint_status();
}
inline void IndexInfo::_internal_set_hint_status(::baikaldb::pb::IndexHintStatus value) {
  assert(::baikaldb::pb::IndexHintStatus_IsValid(value));
  _has_bits_[0] |= 0x00020000u;
  hint_status_ = value;
}
inline void IndexInfo::set_hint_status(::baikaldb::pb::IndexHintStatus value) {
  _internal_set_hint_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.hint_status)
}

// optional int64 drop_timestamp = 12;
inline bool IndexInfo::_internal_has_drop_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool IndexInfo::has_drop_timestamp() const {
  return _internal_has_drop_timestamp();
}
inline void IndexInfo::clear_drop_timestamp() {
  drop_timestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexInfo::_internal_drop_timestamp() const {
  return drop_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexInfo::drop_timestamp() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.drop_timestamp)
  return _internal_drop_timestamp();
}
inline void IndexInfo::_internal_set_drop_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  drop_timestamp_ = value;
}
inline void IndexInfo::set_drop_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_drop_timestamp(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.drop_timestamp)
}

// optional string vector_description = 13;
inline bool IndexInfo::_internal_has_vector_description() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool IndexInfo::has_vector_description() const {
  return _internal_has_vector_description();
}
inline void IndexInfo::clear_vector_description() {
  vector_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& IndexInfo::vector_description() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.vector_description)
  return _internal_vector_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IndexInfo::set_vector_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 vector_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.vector_description)
}
inline std::string* IndexInfo::mutable_vector_description() {
  std::string* _s = _internal_mutable_vector_description();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.IndexInfo.vector_description)
  return _s;
}
inline const std::string& IndexInfo::_internal_vector_description() const {
  return vector_description_.Get();
}
inline void IndexInfo::_internal_set_vector_description(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  vector_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IndexInfo::_internal_mutable_vector_description() {
  _has_bits_[0] |= 0x00000004u;
  return vector_description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IndexInfo::release_vector_description() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.IndexInfo.vector_description)
  if (!_internal_has_vector_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return vector_description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IndexInfo::set_allocated_vector_description(std::string* vector_description) {
  if (vector_description != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  vector_description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vector_description,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.IndexInfo.vector_description)
}

// optional int32 dimension = 14;
inline bool IndexInfo::_internal_has_dimension() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool IndexInfo::has_dimension() const {
  return _internal_has_dimension();
}
inline void IndexInfo::clear_dimension() {
  dimension_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IndexInfo::_internal_dimension() const {
  return dimension_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IndexInfo::dimension() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.dimension)
  return _internal_dimension();
}
inline void IndexInfo::_internal_set_dimension(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  dimension_ = value;
}
inline void IndexInfo::set_dimension(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dimension(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.dimension)
}

// optional .baikaldb.pb.MetricType metric_type = 15;
inline bool IndexInfo::_internal_has_metric_type() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool IndexInfo::has_metric_type() const {
  return _internal_has_metric_type();
}
inline void IndexInfo::clear_metric_type() {
  metric_type_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::baikaldb::pb::MetricType IndexInfo::_internal_metric_type() const {
  return static_cast< ::baikaldb::pb::MetricType >(metric_type_);
}
inline ::baikaldb::pb::MetricType IndexInfo::metric_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.metric_type)
  return _internal_metric_type();
}
inline void IndexInfo::_internal_set_metric_type(::baikaldb::pb::MetricType value) {
  assert(::baikaldb::pb::MetricType_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  metric_type_ = value;
}
inline void IndexInfo::set_metric_type(::baikaldb::pb::MetricType value) {
  _internal_set_metric_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.metric_type)
}

// optional int32 nprobe = 16;
inline bool IndexInfo::_internal_has_nprobe() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool IndexInfo::has_nprobe() const {
  return _internal_has_nprobe();
}
inline void IndexInfo::clear_nprobe() {
  nprobe_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IndexInfo::_internal_nprobe() const {
  return nprobe_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IndexInfo::nprobe() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.nprobe)
  return _internal_nprobe();
}
inline void IndexInfo::_internal_set_nprobe(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000800u;
  nprobe_ = value;
}
inline void IndexInfo::set_nprobe(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_nprobe(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.nprobe)
}

// optional int32 efsearch = 17;
inline bool IndexInfo::_internal_has_efsearch() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool IndexInfo::has_efsearch() const {
  return _internal_has_efsearch();
}
inline void IndexInfo::clear_efsearch() {
  efsearch_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IndexInfo::_internal_efsearch() const {
  return efsearch_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IndexInfo::efsearch() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.efsearch)
  return _internal_efsearch();
}
inline void IndexInfo::_internal_set_efsearch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00001000u;
  efsearch_ = value;
}
inline void IndexInfo::set_efsearch(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_efsearch(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.efsearch)
}

// optional int32 efconstruction = 18;
inline bool IndexInfo::_internal_has_efconstruction() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool IndexInfo::has_efconstruction() const {
  return _internal_has_efconstruction();
}
inline void IndexInfo::clear_efconstruction() {
  efconstruction_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IndexInfo::_internal_efconstruction() const {
  return efconstruction_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 IndexInfo::efconstruction() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.efconstruction)
  return _internal_efconstruction();
}
inline void IndexInfo::_internal_set_efconstruction(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00004000u;
  efconstruction_ = value;
}
inline void IndexInfo::set_efconstruction(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_efconstruction(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.efconstruction)
}

// optional .baikaldb.pb.RollupType rollup_type = 19;
inline bool IndexInfo::_internal_has_rollup_type() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool IndexInfo::has_rollup_type() const {
  return _internal_has_rollup_type();
}
inline void IndexInfo::clear_rollup_type() {
  rollup_type_ = 1;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::baikaldb::pb::RollupType IndexInfo::_internal_rollup_type() const {
  return static_cast< ::baikaldb::pb::RollupType >(rollup_type_);
}
inline ::baikaldb::pb::RollupType IndexInfo::rollup_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.rollup_type)
  return _internal_rollup_type();
}
inline void IndexInfo::_internal_set_rollup_type(::baikaldb::pb::RollupType value) {
  assert(::baikaldb::pb::RollupType_IsValid(value));
  _has_bits_[0] |= 0x00008000u;
  rollup_type_ = value;
}
inline void IndexInfo::set_rollup_type(::baikaldb::pb::RollupType value) {
  _internal_set_rollup_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.rollup_type)
}

// optional int64 publish_timestamp = 20;
inline bool IndexInfo::_internal_has_publish_timestamp() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool IndexInfo::has_publish_timestamp() const {
  return _internal_has_publish_timestamp();
}
inline void IndexInfo::clear_publish_timestamp() {
  publish_timestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexInfo::_internal_publish_timestamp() const {
  return publish_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexInfo::publish_timestamp() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexInfo.publish_timestamp)
  return _internal_publish_timestamp();
}
inline void IndexInfo::_internal_set_publish_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00002000u;
  publish_timestamp_ = value;
}
inline void IndexInfo::set_publish_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_publish_timestamp(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexInfo.publish_timestamp)
}

// -------------------------------------------------------------------

// RegionInfo

// required int64 region_id = 1;
inline bool RegionInfo::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RegionInfo::has_region_id() const {
  return _internal_has_region_id();
}
inline void RegionInfo::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.region_id)
  return _internal_region_id();
}
inline void RegionInfo::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  region_id_ = value;
}
inline void RegionInfo::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.region_id)
}

// optional string table_name = 2;
inline bool RegionInfo::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegionInfo::has_table_name() const {
  return _internal_has_table_name();
}
inline void RegionInfo::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionInfo::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionInfo::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.table_name)
}
inline std::string* RegionInfo::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionInfo.table_name)
  return _s;
}
inline const std::string& RegionInfo::_internal_table_name() const {
  return table_name_.Get();
}
inline void RegionInfo::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionInfo::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000001u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionInfo::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionInfo.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionInfo::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionInfo.table_name)
}

// required int64 table_id = 3;
inline bool RegionInfo::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RegionInfo::has_table_id() const {
  return _internal_has_table_id();
}
inline void RegionInfo::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.table_id)
  return _internal_table_id();
}
inline void RegionInfo::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  table_id_ = value;
}
inline void RegionInfo::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.table_id)
}

// required int64 partition_id = 4;
inline bool RegionInfo::_internal_has_partition_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RegionInfo::has_partition_id() const {
  return _internal_has_partition_id();
}
inline void RegionInfo::clear_partition_id() {
  partition_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::_internal_partition_id() const {
  return partition_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::partition_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.partition_id)
  return _internal_partition_id();
}
inline void RegionInfo::_internal_set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  partition_id_ = value;
}
inline void RegionInfo::set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_partition_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.partition_id)
}

// required int64 replica_num = 5;
inline bool RegionInfo::_internal_has_replica_num() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool RegionInfo::has_replica_num() const {
  return _internal_has_replica_num();
}
inline void RegionInfo::clear_replica_num() {
  replica_num_ = int64_t{0};
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::_internal_replica_num() const {
  return replica_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::replica_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.replica_num)
  return _internal_replica_num();
}
inline void RegionInfo::_internal_set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  replica_num_ = value;
}
inline void RegionInfo::set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_replica_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.replica_num)
}

// required int64 version = 6;
inline bool RegionInfo::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool RegionInfo::has_version() const {
  return _internal_has_version();
}
inline void RegionInfo::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.version)
  return _internal_version();
}
inline void RegionInfo::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  version_ = value;
}
inline void RegionInfo::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.version)
}

// required int64 conf_version = 7;
inline bool RegionInfo::_internal_has_conf_version() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool RegionInfo::has_conf_version() const {
  return _internal_has_conf_version();
}
inline void RegionInfo::clear_conf_version() {
  conf_version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::_internal_conf_version() const {
  return conf_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::conf_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.conf_version)
  return _internal_conf_version();
}
inline void RegionInfo::_internal_set_conf_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  conf_version_ = value;
}
inline void RegionInfo::set_conf_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_conf_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.conf_version)
}

// optional bytes start_key = 8;
inline bool RegionInfo::_internal_has_start_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionInfo::has_start_key() const {
  return _internal_has_start_key();
}
inline void RegionInfo::clear_start_key() {
  start_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RegionInfo::start_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.start_key)
  return _internal_start_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionInfo::set_start_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 start_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.start_key)
}
inline std::string* RegionInfo::mutable_start_key() {
  std::string* _s = _internal_mutable_start_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionInfo.start_key)
  return _s;
}
inline const std::string& RegionInfo::_internal_start_key() const {
  return start_key_.Get();
}
inline void RegionInfo::_internal_set_start_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  start_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionInfo::_internal_mutable_start_key() {
  _has_bits_[0] |= 0x00000002u;
  return start_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionInfo::release_start_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionInfo.start_key)
  if (!_internal_has_start_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return start_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionInfo::set_allocated_start_key(std::string* start_key) {
  if (start_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  start_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionInfo.start_key)
}

// optional bytes end_key = 9;
inline bool RegionInfo::_internal_has_end_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegionInfo::has_end_key() const {
  return _internal_has_end_key();
}
inline void RegionInfo::clear_end_key() {
  end_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RegionInfo::end_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.end_key)
  return _internal_end_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionInfo::set_end_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 end_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.end_key)
}
inline std::string* RegionInfo::mutable_end_key() {
  std::string* _s = _internal_mutable_end_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionInfo.end_key)
  return _s;
}
inline const std::string& RegionInfo::_internal_end_key() const {
  return end_key_.Get();
}
inline void RegionInfo::_internal_set_end_key(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  end_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionInfo::_internal_mutable_end_key() {
  _has_bits_[0] |= 0x00000004u;
  return end_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionInfo::release_end_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionInfo.end_key)
  if (!_internal_has_end_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return end_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionInfo::set_allocated_end_key(std::string* end_key) {
  if (end_key != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  end_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), end_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionInfo.end_key)
}

// repeated string peers = 10;
inline int RegionInfo::_internal_peers_size() const {
  return peers_.size();
}
inline int RegionInfo::peers_size() const {
  return _internal_peers_size();
}
inline void RegionInfo::clear_peers() {
  peers_.Clear();
}
inline std::string* RegionInfo::add_peers() {
  std::string* _s = _internal_add_peers();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.RegionInfo.peers)
  return _s;
}
inline const std::string& RegionInfo::_internal_peers(int index) const {
  return peers_.Get(index);
}
inline const std::string& RegionInfo::peers(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.peers)
  return _internal_peers(index);
}
inline std::string* RegionInfo::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionInfo.peers)
  return peers_.Mutable(index);
}
inline void RegionInfo::set_peers(int index, const std::string& value) {
  peers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.peers)
}
inline void RegionInfo::set_peers(int index, std::string&& value) {
  peers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.peers)
}
inline void RegionInfo::set_peers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  peers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.RegionInfo.peers)
}
inline void RegionInfo::set_peers(int index, const char* value, size_t size) {
  peers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.RegionInfo.peers)
}
inline std::string* RegionInfo::_internal_add_peers() {
  return peers_.Add();
}
inline void RegionInfo::add_peers(const std::string& value) {
  peers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionInfo.peers)
}
inline void RegionInfo::add_peers(std::string&& value) {
  peers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionInfo.peers)
}
inline void RegionInfo::add_peers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  peers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.RegionInfo.peers)
}
inline void RegionInfo::add_peers(const char* value, size_t size) {
  peers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.RegionInfo.peers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RegionInfo::peers() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RegionInfo.peers)
  return peers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RegionInfo::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RegionInfo.peers)
  return &peers_;
}

// optional string leader = 11;
inline bool RegionInfo::_internal_has_leader() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RegionInfo::has_leader() const {
  return _internal_has_leader();
}
inline void RegionInfo::clear_leader() {
  leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RegionInfo::leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionInfo::set_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.leader)
}
inline std::string* RegionInfo::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionInfo.leader)
  return _s;
}
inline const std::string& RegionInfo::_internal_leader() const {
  return leader_.Get();
}
inline void RegionInfo::_internal_set_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionInfo::_internal_mutable_leader() {
  _has_bits_[0] |= 0x00000008u;
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionInfo::release_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionInfo.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionInfo::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionInfo.leader)
}

// optional .baikaldb.pb.RegionStatus status = 12;
inline bool RegionInfo::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool RegionInfo::has_status() const {
  return _internal_has_status();
}
inline void RegionInfo::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::baikaldb::pb::RegionStatus RegionInfo::_internal_status() const {
  return static_cast< ::baikaldb::pb::RegionStatus >(status_);
}
inline ::baikaldb::pb::RegionStatus RegionInfo::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.status)
  return _internal_status();
}
inline void RegionInfo::_internal_set_status(::baikaldb::pb::RegionStatus value) {
  assert(::baikaldb::pb::RegionStatus_IsValid(value));
  _has_bits_[0] |= 0x00200000u;
  status_ = value;
}
inline void RegionInfo::set_status(::baikaldb::pb::RegionStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.status)
}

// optional int64 used_size = 13;
inline bool RegionInfo::_internal_has_used_size() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool RegionInfo::has_used_size() const {
  return _internal_has_used_size();
}
inline void RegionInfo::clear_used_size() {
  used_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::_internal_used_size() const {
  return used_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::used_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.used_size)
  return _internal_used_size();
}
inline void RegionInfo::_internal_set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  used_size_ = value;
}
inline void RegionInfo::set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_used_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.used_size)
}

// optional int64 log_index = 14;
inline bool RegionInfo::_internal_has_log_index() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool RegionInfo::has_log_index() const {
  return _internal_has_log_index();
}
inline void RegionInfo::clear_log_index() {
  log_index_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::_internal_log_index() const {
  return log_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::log_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.log_index)
  return _internal_log_index();
}
inline void RegionInfo::_internal_set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  log_index_ = value;
}
inline void RegionInfo::set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_log_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.log_index)
}

// optional bool deleted = 15;
inline bool RegionInfo::_internal_has_deleted() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool RegionInfo::has_deleted() const {
  return _internal_has_deleted();
}
inline void RegionInfo::clear_deleted() {
  deleted_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool RegionInfo::_internal_deleted() const {
  return deleted_;
}
inline bool RegionInfo::deleted() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.deleted)
  return _internal_deleted();
}
inline void RegionInfo::_internal_set_deleted(bool value) {
  _has_bits_[0] |= 0x00004000u;
  deleted_ = value;
}
inline void RegionInfo::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.deleted)
}

// optional bool can_add_peer = 16;
inline bool RegionInfo::_internal_has_can_add_peer() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool RegionInfo::has_can_add_peer() const {
  return _internal_has_can_add_peer();
}
inline void RegionInfo::clear_can_add_peer() {
  can_add_peer_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool RegionInfo::_internal_can_add_peer() const {
  return can_add_peer_;
}
inline bool RegionInfo::can_add_peer() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.can_add_peer)
  return _internal_can_add_peer();
}
inline void RegionInfo::_internal_set_can_add_peer(bool value) {
  _has_bits_[0] |= 0x00008000u;
  can_add_peer_ = value;
}
inline void RegionInfo::set_can_add_peer(bool value) {
  _internal_set_can_add_peer(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.can_add_peer)
}

// optional int64 parent = 17;
inline bool RegionInfo::_internal_has_parent() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool RegionInfo::has_parent() const {
  return _internal_has_parent();
}
inline void RegionInfo::clear_parent() {
  parent_ = int64_t{0};
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::_internal_parent() const {
  return parent_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::parent() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.parent)
  return _internal_parent();
}
inline void RegionInfo::_internal_set_parent(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00001000u;
  parent_ = value;
}
inline void RegionInfo::set_parent(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_parent(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.parent)
}

// optional uint32 timestamp = 18;
inline bool RegionInfo::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool RegionInfo::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void RegionInfo::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RegionInfo::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RegionInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.timestamp)
  return _internal_timestamp();
}
inline void RegionInfo::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  timestamp_ = value;
}
inline void RegionInfo::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.timestamp)
}

// optional int64 num_table_lines = 19;
inline bool RegionInfo::_internal_has_num_table_lines() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool RegionInfo::has_num_table_lines() const {
  return _internal_has_num_table_lines();
}
inline void RegionInfo::clear_num_table_lines() {
  num_table_lines_ = int64_t{0};
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::_internal_num_table_lines() const {
  return num_table_lines_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::num_table_lines() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.num_table_lines)
  return _internal_num_table_lines();
}
inline void RegionInfo::_internal_set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00040000u;
  num_table_lines_ = value;
}
inline void RegionInfo::set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_num_table_lines(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.num_table_lines)
}

// optional int64 main_table_id = 20;
inline bool RegionInfo::_internal_has_main_table_id() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool RegionInfo::has_main_table_id() const {
  return _internal_has_main_table_id();
}
inline void RegionInfo::clear_main_table_id() {
  main_table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::_internal_main_table_id() const {
  return main_table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::main_table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.main_table_id)
  return _internal_main_table_id();
}
inline void RegionInfo::_internal_set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00080000u;
  main_table_id_ = value;
}
inline void RegionInfo::set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_main_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.main_table_id)
}

// optional bool is_binlog_region = 21;
inline bool RegionInfo::_internal_has_is_binlog_region() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool RegionInfo::has_is_binlog_region() const {
  return _internal_has_is_binlog_region();
}
inline void RegionInfo::clear_is_binlog_region() {
  is_binlog_region_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool RegionInfo::_internal_is_binlog_region() const {
  return is_binlog_region_;
}
inline bool RegionInfo::is_binlog_region() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.is_binlog_region)
  return _internal_is_binlog_region();
}
inline void RegionInfo::_internal_set_is_binlog_region(bool value) {
  _has_bits_[0] |= 0x00010000u;
  is_binlog_region_ = value;
}
inline void RegionInfo::set_is_binlog_region(bool value) {
  _internal_set_is_binlog_region(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.is_binlog_region)
}

// optional int64 partition_num = 22;
inline bool RegionInfo::_internal_has_partition_num() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool RegionInfo::has_partition_num() const {
  return _internal_has_partition_num();
}
inline void RegionInfo::clear_partition_num() {
  partition_num_ = int64_t{0};
  _has_bits_[0] &= ~0x00100000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::_internal_partition_num() const {
  return partition_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionInfo::partition_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.partition_num)
  return _internal_partition_num();
}
inline void RegionInfo::_internal_set_partition_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00100000u;
  partition_num_ = value;
}
inline void RegionInfo::set_partition_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_partition_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.partition_num)
}

// repeated string learners = 23;
inline int RegionInfo::_internal_learners_size() const {
  return learners_.size();
}
inline int RegionInfo::learners_size() const {
  return _internal_learners_size();
}
inline void RegionInfo::clear_learners() {
  learners_.Clear();
}
inline std::string* RegionInfo::add_learners() {
  std::string* _s = _internal_add_learners();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.RegionInfo.learners)
  return _s;
}
inline const std::string& RegionInfo::_internal_learners(int index) const {
  return learners_.Get(index);
}
inline const std::string& RegionInfo::learners(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.learners)
  return _internal_learners(index);
}
inline std::string* RegionInfo::mutable_learners(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionInfo.learners)
  return learners_.Mutable(index);
}
inline void RegionInfo::set_learners(int index, const std::string& value) {
  learners_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.learners)
}
inline void RegionInfo::set_learners(int index, std::string&& value) {
  learners_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.learners)
}
inline void RegionInfo::set_learners(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  learners_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.RegionInfo.learners)
}
inline void RegionInfo::set_learners(int index, const char* value, size_t size) {
  learners_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.RegionInfo.learners)
}
inline std::string* RegionInfo::_internal_add_learners() {
  return learners_.Add();
}
inline void RegionInfo::add_learners(const std::string& value) {
  learners_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionInfo.learners)
}
inline void RegionInfo::add_learners(std::string&& value) {
  learners_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionInfo.learners)
}
inline void RegionInfo::add_learners(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  learners_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.RegionInfo.learners)
}
inline void RegionInfo::add_learners(const char* value, size_t size) {
  learners_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.RegionInfo.learners)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RegionInfo::learners() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RegionInfo.learners)
  return learners_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RegionInfo::mutable_learners() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RegionInfo.learners)
  return &learners_;
}

// optional bool is_learner = 24;
inline bool RegionInfo::_internal_has_is_learner() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool RegionInfo::has_is_learner() const {
  return _internal_has_is_learner();
}
inline void RegionInfo::clear_is_learner() {
  is_learner_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool RegionInfo::_internal_is_learner() const {
  return is_learner_;
}
inline bool RegionInfo::is_learner() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionInfo.is_learner)
  return _internal_is_learner();
}
inline void RegionInfo::_internal_set_is_learner(bool value) {
  _has_bits_[0] |= 0x00020000u;
  is_learner_ = value;
}
inline void RegionInfo::set_is_learner(bool value) {
  _internal_set_is_learner(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionInfo.is_learner)
}

// -------------------------------------------------------------------

// StoreRegionDdlInfo

// required int64 region_id = 1;
inline bool StoreRegionDdlInfo::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreRegionDdlInfo::has_region_id() const {
  return _internal_has_region_id();
}
inline void StoreRegionDdlInfo::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRegionDdlInfo::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreRegionDdlInfo::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRegionDdlInfo.region_id)
  return _internal_region_id();
}
inline void StoreRegionDdlInfo::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  region_id_ = value;
}
inline void StoreRegionDdlInfo::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreRegionDdlInfo.region_id)
}

// repeated .baikaldb.pb.DdlWorkInfo ddlwork_infos = 2;
inline int StoreRegionDdlInfo::_internal_ddlwork_infos_size() const {
  return ddlwork_infos_.size();
}
inline int StoreRegionDdlInfo::ddlwork_infos_size() const {
  return _internal_ddlwork_infos_size();
}
inline void StoreRegionDdlInfo::clear_ddlwork_infos() {
  ddlwork_infos_.Clear();
}
inline ::baikaldb::pb::DdlWorkInfo* StoreRegionDdlInfo::mutable_ddlwork_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreRegionDdlInfo.ddlwork_infos)
  return ddlwork_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >*
StoreRegionDdlInfo::mutable_ddlwork_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreRegionDdlInfo.ddlwork_infos)
  return &ddlwork_infos_;
}
inline const ::baikaldb::pb::DdlWorkInfo& StoreRegionDdlInfo::_internal_ddlwork_infos(int index) const {
  return ddlwork_infos_.Get(index);
}
inline const ::baikaldb::pb::DdlWorkInfo& StoreRegionDdlInfo::ddlwork_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreRegionDdlInfo.ddlwork_infos)
  return _internal_ddlwork_infos(index);
}
inline ::baikaldb::pb::DdlWorkInfo* StoreRegionDdlInfo::_internal_add_ddlwork_infos() {
  return ddlwork_infos_.Add();
}
inline ::baikaldb::pb::DdlWorkInfo* StoreRegionDdlInfo::add_ddlwork_infos() {
  ::baikaldb::pb::DdlWorkInfo* _add = _internal_add_ddlwork_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreRegionDdlInfo.ddlwork_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >&
StoreRegionDdlInfo::ddlwork_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreRegionDdlInfo.ddlwork_infos)
  return ddlwork_infos_;
}

// -------------------------------------------------------------------

// PrivilegeDatabase

// required string database = 1;
inline bool PrivilegeDatabase::_internal_has_database() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PrivilegeDatabase::has_database() const {
  return _internal_has_database();
}
inline void PrivilegeDatabase::clear_database() {
  database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PrivilegeDatabase::database() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PrivilegeDatabase.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivilegeDatabase::set_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.PrivilegeDatabase.database)
}
inline std::string* PrivilegeDatabase::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PrivilegeDatabase.database)
  return _s;
}
inline const std::string& PrivilegeDatabase::_internal_database() const {
  return database_.Get();
}
inline void PrivilegeDatabase::_internal_set_database(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivilegeDatabase::_internal_mutable_database() {
  _has_bits_[0] |= 0x00000001u;
  return database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivilegeDatabase::release_database() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PrivilegeDatabase.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivilegeDatabase::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PrivilegeDatabase.database)
}

// optional int64 database_id = 2;
inline bool PrivilegeDatabase::_internal_has_database_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PrivilegeDatabase::has_database_id() const {
  return _internal_has_database_id();
}
inline void PrivilegeDatabase::clear_database_id() {
  database_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivilegeDatabase::_internal_database_id() const {
  return database_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivilegeDatabase::database_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PrivilegeDatabase.database_id)
  return _internal_database_id();
}
inline void PrivilegeDatabase::_internal_set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  database_id_ = value;
}
inline void PrivilegeDatabase::set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_database_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PrivilegeDatabase.database_id)
}

// optional .baikaldb.pb.RW database_rw = 3;
inline bool PrivilegeDatabase::_internal_has_database_rw() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PrivilegeDatabase::has_database_rw() const {
  return _internal_has_database_rw();
}
inline void PrivilegeDatabase::clear_database_rw() {
  database_rw_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::baikaldb::pb::RW PrivilegeDatabase::_internal_database_rw() const {
  return static_cast< ::baikaldb::pb::RW >(database_rw_);
}
inline ::baikaldb::pb::RW PrivilegeDatabase::database_rw() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PrivilegeDatabase.database_rw)
  return _internal_database_rw();
}
inline void PrivilegeDatabase::_internal_set_database_rw(::baikaldb::pb::RW value) {
  assert(::baikaldb::pb::RW_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  database_rw_ = value;
}
inline void PrivilegeDatabase::set_database_rw(::baikaldb::pb::RW value) {
  _internal_set_database_rw(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PrivilegeDatabase.database_rw)
}

// optional bool force = 4;
inline bool PrivilegeDatabase::_internal_has_force() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PrivilegeDatabase::has_force() const {
  return _internal_has_force();
}
inline void PrivilegeDatabase::clear_force() {
  force_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool PrivilegeDatabase::_internal_force() const {
  return force_;
}
inline bool PrivilegeDatabase::force() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PrivilegeDatabase.force)
  return _internal_force();
}
inline void PrivilegeDatabase::_internal_set_force(bool value) {
  _has_bits_[0] |= 0x00000004u;
  force_ = value;
}
inline void PrivilegeDatabase::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PrivilegeDatabase.force)
}

// optional uint32 acl = 5;
inline bool PrivilegeDatabase::_internal_has_acl() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PrivilegeDatabase::has_acl() const {
  return _internal_has_acl();
}
inline void PrivilegeDatabase::clear_acl() {
  acl_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PrivilegeDatabase::_internal_acl() const {
  return acl_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PrivilegeDatabase::acl() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PrivilegeDatabase.acl)
  return _internal_acl();
}
inline void PrivilegeDatabase::_internal_set_acl(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  acl_ = value;
}
inline void PrivilegeDatabase::set_acl(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_acl(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PrivilegeDatabase.acl)
}

// -------------------------------------------------------------------

// PrivilegeTable

// required string database = 1;
inline bool PrivilegeTable::_internal_has_database() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PrivilegeTable::has_database() const {
  return _internal_has_database();
}
inline void PrivilegeTable::clear_database() {
  database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PrivilegeTable::database() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PrivilegeTable.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivilegeTable::set_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.PrivilegeTable.database)
}
inline std::string* PrivilegeTable::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PrivilegeTable.database)
  return _s;
}
inline const std::string& PrivilegeTable::_internal_database() const {
  return database_.Get();
}
inline void PrivilegeTable::_internal_set_database(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivilegeTable::_internal_mutable_database() {
  _has_bits_[0] |= 0x00000001u;
  return database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivilegeTable::release_database() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PrivilegeTable.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivilegeTable::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PrivilegeTable.database)
}

// optional int64 database_id = 2;
inline bool PrivilegeTable::_internal_has_database_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PrivilegeTable::has_database_id() const {
  return _internal_has_database_id();
}
inline void PrivilegeTable::clear_database_id() {
  database_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivilegeTable::_internal_database_id() const {
  return database_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivilegeTable::database_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PrivilegeTable.database_id)
  return _internal_database_id();
}
inline void PrivilegeTable::_internal_set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  database_id_ = value;
}
inline void PrivilegeTable::set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_database_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PrivilegeTable.database_id)
}

// required string table_name = 3;
inline bool PrivilegeTable::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PrivilegeTable::has_table_name() const {
  return _internal_has_table_name();
}
inline void PrivilegeTable::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PrivilegeTable::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PrivilegeTable.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PrivilegeTable::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.PrivilegeTable.table_name)
}
inline std::string* PrivilegeTable::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PrivilegeTable.table_name)
  return _s;
}
inline const std::string& PrivilegeTable::_internal_table_name() const {
  return table_name_.Get();
}
inline void PrivilegeTable::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PrivilegeTable::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000002u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PrivilegeTable::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PrivilegeTable.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PrivilegeTable::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PrivilegeTable.table_name)
}

// optional int64 table_id = 4;
inline bool PrivilegeTable::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PrivilegeTable::has_table_id() const {
  return _internal_has_table_id();
}
inline void PrivilegeTable::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivilegeTable::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PrivilegeTable::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PrivilegeTable.table_id)
  return _internal_table_id();
}
inline void PrivilegeTable::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  table_id_ = value;
}
inline void PrivilegeTable::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PrivilegeTable.table_id)
}

// optional .baikaldb.pb.RW table_rw = 5;
inline bool PrivilegeTable::_internal_has_table_rw() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PrivilegeTable::has_table_rw() const {
  return _internal_has_table_rw();
}
inline void PrivilegeTable::clear_table_rw() {
  table_rw_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::baikaldb::pb::RW PrivilegeTable::_internal_table_rw() const {
  return static_cast< ::baikaldb::pb::RW >(table_rw_);
}
inline ::baikaldb::pb::RW PrivilegeTable::table_rw() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PrivilegeTable.table_rw)
  return _internal_table_rw();
}
inline void PrivilegeTable::_internal_set_table_rw(::baikaldb::pb::RW value) {
  assert(::baikaldb::pb::RW_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  table_rw_ = value;
}
inline void PrivilegeTable::set_table_rw(::baikaldb::pb::RW value) {
  _internal_set_table_rw(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PrivilegeTable.table_rw)
}

// optional bool force = 6;
inline bool PrivilegeTable::_internal_has_force() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PrivilegeTable::has_force() const {
  return _internal_has_force();
}
inline void PrivilegeTable::clear_force() {
  force_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool PrivilegeTable::_internal_force() const {
  return force_;
}
inline bool PrivilegeTable::force() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PrivilegeTable.force)
  return _internal_force();
}
inline void PrivilegeTable::_internal_set_force(bool value) {
  _has_bits_[0] |= 0x00000010u;
  force_ = value;
}
inline void PrivilegeTable::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PrivilegeTable.force)
}

// optional uint32 acl = 7;
inline bool PrivilegeTable::_internal_has_acl() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PrivilegeTable::has_acl() const {
  return _internal_has_acl();
}
inline void PrivilegeTable::clear_acl() {
  acl_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PrivilegeTable::_internal_acl() const {
  return acl_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PrivilegeTable::acl() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PrivilegeTable.acl)
  return _internal_acl();
}
inline void PrivilegeTable::_internal_set_acl(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  acl_ = value;
}
inline void PrivilegeTable::set_acl(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_acl(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PrivilegeTable.acl)
}

// -------------------------------------------------------------------

// UserPrivilege

// required string username = 1;
inline bool UserPrivilege::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UserPrivilege::has_username() const {
  return _internal_has_username();
}
inline void UserPrivilege::clear_username() {
  username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserPrivilege::username() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserPrivilege::set_username(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.username)
}
inline std::string* UserPrivilege::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.UserPrivilege.username)
  return _s;
}
inline const std::string& UserPrivilege::_internal_username() const {
  return username_.Get();
}
inline void UserPrivilege::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserPrivilege::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserPrivilege::release_username() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.UserPrivilege.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserPrivilege::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.UserPrivilege.username)
}

// optional string password = 2;
inline bool UserPrivilege::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UserPrivilege::has_password() const {
  return _internal_has_password();
}
inline void UserPrivilege::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserPrivilege::password() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserPrivilege::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.password)
}
inline std::string* UserPrivilege::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.UserPrivilege.password)
  return _s;
}
inline const std::string& UserPrivilege::_internal_password() const {
  return password_.Get();
}
inline void UserPrivilege::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserPrivilege::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserPrivilege::release_password() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.UserPrivilege.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserPrivilege::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.UserPrivilege.password)
}

// required string namespace_name = 3;
inline bool UserPrivilege::_internal_has_namespace_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UserPrivilege::has_namespace_name() const {
  return _internal_has_namespace_name();
}
inline void UserPrivilege::clear_namespace_name() {
  namespace_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserPrivilege::namespace_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.namespace_name)
  return _internal_namespace_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserPrivilege::set_namespace_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.namespace_name)
}
inline std::string* UserPrivilege::mutable_namespace_name() {
  std::string* _s = _internal_mutable_namespace_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.UserPrivilege.namespace_name)
  return _s;
}
inline const std::string& UserPrivilege::_internal_namespace_name() const {
  return namespace_name_.Get();
}
inline void UserPrivilege::_internal_set_namespace_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserPrivilege::_internal_mutable_namespace_name() {
  _has_bits_[0] |= 0x00000004u;
  return namespace_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserPrivilege::release_namespace_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.UserPrivilege.namespace_name)
  if (!_internal_has_namespace_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return namespace_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserPrivilege::set_allocated_namespace_name(std::string* namespace_name) {
  if (namespace_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  namespace_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.UserPrivilege.namespace_name)
}

// optional int64 namespace_id = 4;
inline bool UserPrivilege::_internal_has_namespace_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UserPrivilege::has_namespace_id() const {
  return _internal_has_namespace_id();
}
inline void UserPrivilege::clear_namespace_id() {
  namespace_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UserPrivilege::_internal_namespace_id() const {
  return namespace_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UserPrivilege::namespace_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.namespace_id)
  return _internal_namespace_id();
}
inline void UserPrivilege::_internal_set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  namespace_id_ = value;
}
inline void UserPrivilege::set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_namespace_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.namespace_id)
}

// repeated .baikaldb.pb.PrivilegeDatabase privilege_database = 5;
inline int UserPrivilege::_internal_privilege_database_size() const {
  return privilege_database_.size();
}
inline int UserPrivilege::privilege_database_size() const {
  return _internal_privilege_database_size();
}
inline void UserPrivilege::clear_privilege_database() {
  privilege_database_.Clear();
}
inline ::baikaldb::pb::PrivilegeDatabase* UserPrivilege::mutable_privilege_database(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.UserPrivilege.privilege_database)
  return privilege_database_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PrivilegeDatabase >*
UserPrivilege::mutable_privilege_database() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.UserPrivilege.privilege_database)
  return &privilege_database_;
}
inline const ::baikaldb::pb::PrivilegeDatabase& UserPrivilege::_internal_privilege_database(int index) const {
  return privilege_database_.Get(index);
}
inline const ::baikaldb::pb::PrivilegeDatabase& UserPrivilege::privilege_database(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.privilege_database)
  return _internal_privilege_database(index);
}
inline ::baikaldb::pb::PrivilegeDatabase* UserPrivilege::_internal_add_privilege_database() {
  return privilege_database_.Add();
}
inline ::baikaldb::pb::PrivilegeDatabase* UserPrivilege::add_privilege_database() {
  ::baikaldb::pb::PrivilegeDatabase* _add = _internal_add_privilege_database();
  // @@protoc_insertion_point(field_add:baikaldb.pb.UserPrivilege.privilege_database)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PrivilegeDatabase >&
UserPrivilege::privilege_database() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.UserPrivilege.privilege_database)
  return privilege_database_;
}

// repeated .baikaldb.pb.PrivilegeTable privilege_table = 6;
inline int UserPrivilege::_internal_privilege_table_size() const {
  return privilege_table_.size();
}
inline int UserPrivilege::privilege_table_size() const {
  return _internal_privilege_table_size();
}
inline void UserPrivilege::clear_privilege_table() {
  privilege_table_.Clear();
}
inline ::baikaldb::pb::PrivilegeTable* UserPrivilege::mutable_privilege_table(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.UserPrivilege.privilege_table)
  return privilege_table_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PrivilegeTable >*
UserPrivilege::mutable_privilege_table() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.UserPrivilege.privilege_table)
  return &privilege_table_;
}
inline const ::baikaldb::pb::PrivilegeTable& UserPrivilege::_internal_privilege_table(int index) const {
  return privilege_table_.Get(index);
}
inline const ::baikaldb::pb::PrivilegeTable& UserPrivilege::privilege_table(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.privilege_table)
  return _internal_privilege_table(index);
}
inline ::baikaldb::pb::PrivilegeTable* UserPrivilege::_internal_add_privilege_table() {
  return privilege_table_.Add();
}
inline ::baikaldb::pb::PrivilegeTable* UserPrivilege::add_privilege_table() {
  ::baikaldb::pb::PrivilegeTable* _add = _internal_add_privilege_table();
  // @@protoc_insertion_point(field_add:baikaldb.pb.UserPrivilege.privilege_table)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PrivilegeTable >&
UserPrivilege::privilege_table() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.UserPrivilege.privilege_table)
  return privilege_table_;
}

// repeated string bns = 7;
inline int UserPrivilege::_internal_bns_size() const {
  return bns_.size();
}
inline int UserPrivilege::bns_size() const {
  return _internal_bns_size();
}
inline void UserPrivilege::clear_bns() {
  bns_.Clear();
}
inline std::string* UserPrivilege::add_bns() {
  std::string* _s = _internal_add_bns();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.UserPrivilege.bns)
  return _s;
}
inline const std::string& UserPrivilege::_internal_bns(int index) const {
  return bns_.Get(index);
}
inline const std::string& UserPrivilege::bns(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.bns)
  return _internal_bns(index);
}
inline std::string* UserPrivilege::mutable_bns(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.UserPrivilege.bns)
  return bns_.Mutable(index);
}
inline void UserPrivilege::set_bns(int index, const std::string& value) {
  bns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.bns)
}
inline void UserPrivilege::set_bns(int index, std::string&& value) {
  bns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.bns)
}
inline void UserPrivilege::set_bns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  bns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.UserPrivilege.bns)
}
inline void UserPrivilege::set_bns(int index, const char* value, size_t size) {
  bns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.UserPrivilege.bns)
}
inline std::string* UserPrivilege::_internal_add_bns() {
  return bns_.Add();
}
inline void UserPrivilege::add_bns(const std::string& value) {
  bns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.UserPrivilege.bns)
}
inline void UserPrivilege::add_bns(std::string&& value) {
  bns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.UserPrivilege.bns)
}
inline void UserPrivilege::add_bns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  bns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.UserPrivilege.bns)
}
inline void UserPrivilege::add_bns(const char* value, size_t size) {
  bns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.UserPrivilege.bns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UserPrivilege::bns() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.UserPrivilege.bns)
  return bns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UserPrivilege::mutable_bns() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.UserPrivilege.bns)
  return &bns_;
}

// repeated string ip = 8;
inline int UserPrivilege::_internal_ip_size() const {
  return ip_.size();
}
inline int UserPrivilege::ip_size() const {
  return _internal_ip_size();
}
inline void UserPrivilege::clear_ip() {
  ip_.Clear();
}
inline std::string* UserPrivilege::add_ip() {
  std::string* _s = _internal_add_ip();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.UserPrivilege.ip)
  return _s;
}
inline const std::string& UserPrivilege::_internal_ip(int index) const {
  return ip_.Get(index);
}
inline const std::string& UserPrivilege::ip(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.ip)
  return _internal_ip(index);
}
inline std::string* UserPrivilege::mutable_ip(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.UserPrivilege.ip)
  return ip_.Mutable(index);
}
inline void UserPrivilege::set_ip(int index, const std::string& value) {
  ip_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.ip)
}
inline void UserPrivilege::set_ip(int index, std::string&& value) {
  ip_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.ip)
}
inline void UserPrivilege::set_ip(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ip_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.UserPrivilege.ip)
}
inline void UserPrivilege::set_ip(int index, const char* value, size_t size) {
  ip_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.UserPrivilege.ip)
}
inline std::string* UserPrivilege::_internal_add_ip() {
  return ip_.Add();
}
inline void UserPrivilege::add_ip(const std::string& value) {
  ip_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.UserPrivilege.ip)
}
inline void UserPrivilege::add_ip(std::string&& value) {
  ip_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.UserPrivilege.ip)
}
inline void UserPrivilege::add_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ip_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.UserPrivilege.ip)
}
inline void UserPrivilege::add_ip(const char* value, size_t size) {
  ip_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.UserPrivilege.ip)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UserPrivilege::ip() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.UserPrivilege.ip)
  return ip_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UserPrivilege::mutable_ip() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.UserPrivilege.ip)
  return &ip_;
}

// optional int64 version = 9;
inline bool UserPrivilege::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UserPrivilege::has_version() const {
  return _internal_has_version();
}
inline void UserPrivilege::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UserPrivilege::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UserPrivilege::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.version)
  return _internal_version();
}
inline void UserPrivilege::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  version_ = value;
}
inline void UserPrivilege::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.version)
}

// optional bool encrypt = 10;
inline bool UserPrivilege::_internal_has_encrypt() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool UserPrivilege::has_encrypt() const {
  return _internal_has_encrypt();
}
inline void UserPrivilege::clear_encrypt() {
  encrypt_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool UserPrivilege::_internal_encrypt() const {
  return encrypt_;
}
inline bool UserPrivilege::encrypt() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.encrypt)
  return _internal_encrypt();
}
inline void UserPrivilege::_internal_set_encrypt(bool value) {
  _has_bits_[0] |= 0x00000040u;
  encrypt_ = value;
}
inline void UserPrivilege::set_encrypt(bool value) {
  _internal_set_encrypt(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.encrypt)
}

// optional bool need_auth_addr = 11;
inline bool UserPrivilege::_internal_has_need_auth_addr() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool UserPrivilege::has_need_auth_addr() const {
  return _internal_has_need_auth_addr();
}
inline void UserPrivilege::clear_need_auth_addr() {
  need_auth_addr_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool UserPrivilege::_internal_need_auth_addr() const {
  return need_auth_addr_;
}
inline bool UserPrivilege::need_auth_addr() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.need_auth_addr)
  return _internal_need_auth_addr();
}
inline void UserPrivilege::_internal_set_need_auth_addr(bool value) {
  _has_bits_[0] |= 0x00000080u;
  need_auth_addr_ = value;
}
inline void UserPrivilege::set_need_auth_addr(bool value) {
  _internal_set_need_auth_addr(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.need_auth_addr)
}

// optional string resource_tag = 12;
inline bool UserPrivilege::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UserPrivilege::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void UserPrivilege::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UserPrivilege::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserPrivilege::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.resource_tag)
}
inline std::string* UserPrivilege::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.UserPrivilege.resource_tag)
  return _s;
}
inline const std::string& UserPrivilege::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void UserPrivilege::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UserPrivilege::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000008u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UserPrivilege::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.UserPrivilege.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UserPrivilege::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.UserPrivilege.resource_tag)
}

// optional bool ddl_permission = 13;
inline bool UserPrivilege::_internal_has_ddl_permission() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool UserPrivilege::has_ddl_permission() const {
  return _internal_has_ddl_permission();
}
inline void UserPrivilege::clear_ddl_permission() {
  ddl_permission_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool UserPrivilege::_internal_ddl_permission() const {
  return ddl_permission_;
}
inline bool UserPrivilege::ddl_permission() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.ddl_permission)
  return _internal_ddl_permission();
}
inline void UserPrivilege::_internal_set_ddl_permission(bool value) {
  _has_bits_[0] |= 0x00000100u;
  ddl_permission_ = value;
}
inline void UserPrivilege::set_ddl_permission(bool value) {
  _internal_set_ddl_permission(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.ddl_permission)
}

// optional int64 txn_lock_timeout = 14;
inline bool UserPrivilege::_internal_has_txn_lock_timeout() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool UserPrivilege::has_txn_lock_timeout() const {
  return _internal_has_txn_lock_timeout();
}
inline void UserPrivilege::clear_txn_lock_timeout() {
  txn_lock_timeout_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UserPrivilege::_internal_txn_lock_timeout() const {
  return txn_lock_timeout_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UserPrivilege::txn_lock_timeout() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.txn_lock_timeout)
  return _internal_txn_lock_timeout();
}
inline void UserPrivilege::_internal_set_txn_lock_timeout(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  txn_lock_timeout_ = value;
}
inline void UserPrivilege::set_txn_lock_timeout(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_txn_lock_timeout(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.txn_lock_timeout)
}

// optional bool use_read_index = 15;
inline bool UserPrivilege::_internal_has_use_read_index() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool UserPrivilege::has_use_read_index() const {
  return _internal_has_use_read_index();
}
inline void UserPrivilege::clear_use_read_index() {
  use_read_index_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool UserPrivilege::_internal_use_read_index() const {
  return use_read_index_;
}
inline bool UserPrivilege::use_read_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.use_read_index)
  return _internal_use_read_index();
}
inline void UserPrivilege::_internal_set_use_read_index(bool value) {
  _has_bits_[0] |= 0x00000200u;
  use_read_index_ = value;
}
inline void UserPrivilege::set_use_read_index(bool value) {
  _internal_set_use_read_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.use_read_index)
}

// optional bool enable_plan_cache = 16;
inline bool UserPrivilege::_internal_has_enable_plan_cache() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool UserPrivilege::has_enable_plan_cache() const {
  return _internal_has_enable_plan_cache();
}
inline void UserPrivilege::clear_enable_plan_cache() {
  enable_plan_cache_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool UserPrivilege::_internal_enable_plan_cache() const {
  return enable_plan_cache_;
}
inline bool UserPrivilege::enable_plan_cache() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.enable_plan_cache)
  return _internal_enable_plan_cache();
}
inline void UserPrivilege::_internal_set_enable_plan_cache(bool value) {
  _has_bits_[0] |= 0x00001000u;
  enable_plan_cache_ = value;
}
inline void UserPrivilege::set_enable_plan_cache(bool value) {
  _internal_set_enable_plan_cache(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.enable_plan_cache)
}

// optional .baikaldb.pb.RangePartitionType request_range_partition_type = 17;
inline bool UserPrivilege::_internal_has_request_range_partition_type() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool UserPrivilege::has_request_range_partition_type() const {
  return _internal_has_request_range_partition_type();
}
inline void UserPrivilege::clear_request_range_partition_type() {
  request_range_partition_type_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::baikaldb::pb::RangePartitionType UserPrivilege::_internal_request_range_partition_type() const {
  return static_cast< ::baikaldb::pb::RangePartitionType >(request_range_partition_type_);
}
inline ::baikaldb::pb::RangePartitionType UserPrivilege::request_range_partition_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.request_range_partition_type)
  return _internal_request_range_partition_type();
}
inline void UserPrivilege::_internal_set_request_range_partition_type(::baikaldb::pb::RangePartitionType value) {
  assert(::baikaldb::pb::RangePartitionType_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  request_range_partition_type_ = value;
}
inline void UserPrivilege::set_request_range_partition_type(::baikaldb::pb::RangePartitionType value) {
  _internal_set_request_range_partition_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.request_range_partition_type)
}

// optional bool is_super = 18;
inline bool UserPrivilege::_internal_has_is_super() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool UserPrivilege::has_is_super() const {
  return _internal_has_is_super();
}
inline void UserPrivilege::clear_is_super() {
  is_super_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool UserPrivilege::_internal_is_super() const {
  return is_super_;
}
inline bool UserPrivilege::is_super() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.is_super)
  return _internal_is_super();
}
inline void UserPrivilege::_internal_set_is_super(bool value) {
  _has_bits_[0] |= 0x00002000u;
  is_super_ = value;
}
inline void UserPrivilege::set_is_super(bool value) {
  _internal_set_is_super(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.is_super)
}

// repeated int64 switch_tables = 19;
inline int UserPrivilege::_internal_switch_tables_size() const {
  return switch_tables_.size();
}
inline int UserPrivilege::switch_tables_size() const {
  return _internal_switch_tables_size();
}
inline void UserPrivilege::clear_switch_tables() {
  switch_tables_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UserPrivilege::_internal_switch_tables(int index) const {
  return switch_tables_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UserPrivilege::switch_tables(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.switch_tables)
  return _internal_switch_tables(index);
}
inline void UserPrivilege::set_switch_tables(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  switch_tables_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.switch_tables)
}
inline void UserPrivilege::_internal_add_switch_tables(::PROTOBUF_NAMESPACE_ID::int64 value) {
  switch_tables_.Add(value);
}
inline void UserPrivilege::add_switch_tables(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_switch_tables(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.UserPrivilege.switch_tables)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
UserPrivilege::_internal_switch_tables() const {
  return switch_tables_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
UserPrivilege::switch_tables() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.UserPrivilege.switch_tables)
  return _internal_switch_tables();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
UserPrivilege::_internal_mutable_switch_tables() {
  return &switch_tables_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
UserPrivilege::mutable_switch_tables() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.UserPrivilege.switch_tables)
  return _internal_mutable_switch_tables();
}

// optional uint32 acl = 20;
inline bool UserPrivilege::_internal_has_acl() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool UserPrivilege::has_acl() const {
  return _internal_has_acl();
}
inline void UserPrivilege::clear_acl() {
  acl_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserPrivilege::_internal_acl() const {
  return acl_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UserPrivilege::acl() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.acl)
  return _internal_acl();
}
inline void UserPrivilege::_internal_set_acl(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  acl_ = value;
}
inline void UserPrivilege::set_acl(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_acl(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.acl)
}

// optional bool if_exist = 21;
inline bool UserPrivilege::_internal_has_if_exist() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool UserPrivilege::has_if_exist() const {
  return _internal_has_if_exist();
}
inline void UserPrivilege::clear_if_exist() {
  if_exist_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool UserPrivilege::_internal_if_exist() const {
  return if_exist_;
}
inline bool UserPrivilege::if_exist() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.if_exist)
  return _internal_if_exist();
}
inline void UserPrivilege::_internal_set_if_exist(bool value) {
  _has_bits_[0] |= 0x00004000u;
  if_exist_ = value;
}
inline void UserPrivilege::set_if_exist(bool value) {
  _internal_set_if_exist(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.if_exist)
}

// optional bool is_request_additional = 24;
inline bool UserPrivilege::_internal_has_is_request_additional() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool UserPrivilege::has_is_request_additional() const {
  return _internal_has_is_request_additional();
}
inline void UserPrivilege::clear_is_request_additional() {
  is_request_additional_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool UserPrivilege::_internal_is_request_additional() const {
  return is_request_additional_;
}
inline bool UserPrivilege::is_request_additional() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.UserPrivilege.is_request_additional)
  return _internal_is_request_additional();
}
inline void UserPrivilege::_internal_set_is_request_additional(bool value) {
  _has_bits_[0] |= 0x00008000u;
  is_request_additional_ = value;
}
inline void UserPrivilege::set_is_request_additional(bool value) {
  _internal_set_is_request_additional(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.UserPrivilege.is_request_additional)
}

// -------------------------------------------------------------------

// LogicalRoom

// repeated string logical_rooms = 1;
inline int LogicalRoom::_internal_logical_rooms_size() const {
  return logical_rooms_.size();
}
inline int LogicalRoom::logical_rooms_size() const {
  return _internal_logical_rooms_size();
}
inline void LogicalRoom::clear_logical_rooms() {
  logical_rooms_.Clear();
}
inline std::string* LogicalRoom::add_logical_rooms() {
  std::string* _s = _internal_add_logical_rooms();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.LogicalRoom.logical_rooms)
  return _s;
}
inline const std::string& LogicalRoom::_internal_logical_rooms(int index) const {
  return logical_rooms_.Get(index);
}
inline const std::string& LogicalRoom::logical_rooms(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LogicalRoom.logical_rooms)
  return _internal_logical_rooms(index);
}
inline std::string* LogicalRoom::mutable_logical_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LogicalRoom.logical_rooms)
  return logical_rooms_.Mutable(index);
}
inline void LogicalRoom::set_logical_rooms(int index, const std::string& value) {
  logical_rooms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LogicalRoom.logical_rooms)
}
inline void LogicalRoom::set_logical_rooms(int index, std::string&& value) {
  logical_rooms_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.LogicalRoom.logical_rooms)
}
inline void LogicalRoom::set_logical_rooms(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  logical_rooms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.LogicalRoom.logical_rooms)
}
inline void LogicalRoom::set_logical_rooms(int index, const char* value, size_t size) {
  logical_rooms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.LogicalRoom.logical_rooms)
}
inline std::string* LogicalRoom::_internal_add_logical_rooms() {
  return logical_rooms_.Add();
}
inline void LogicalRoom::add_logical_rooms(const std::string& value) {
  logical_rooms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.LogicalRoom.logical_rooms)
}
inline void LogicalRoom::add_logical_rooms(std::string&& value) {
  logical_rooms_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.LogicalRoom.logical_rooms)
}
inline void LogicalRoom::add_logical_rooms(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  logical_rooms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.LogicalRoom.logical_rooms)
}
inline void LogicalRoom::add_logical_rooms(const char* value, size_t size) {
  logical_rooms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.LogicalRoom.logical_rooms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LogicalRoom::logical_rooms() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.LogicalRoom.logical_rooms)
  return logical_rooms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LogicalRoom::mutable_logical_rooms() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.LogicalRoom.logical_rooms)
  return &logical_rooms_;
}

// -------------------------------------------------------------------

// PhysicalRoom

// required string logical_room = 1;
inline bool PhysicalRoom::_internal_has_logical_room() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PhysicalRoom::has_logical_room() const {
  return _internal_has_logical_room();
}
inline void PhysicalRoom::clear_logical_room() {
  logical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PhysicalRoom::logical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PhysicalRoom.logical_room)
  return _internal_logical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhysicalRoom::set_logical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.PhysicalRoom.logical_room)
}
inline std::string* PhysicalRoom::mutable_logical_room() {
  std::string* _s = _internal_mutable_logical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PhysicalRoom.logical_room)
  return _s;
}
inline const std::string& PhysicalRoom::_internal_logical_room() const {
  return logical_room_.Get();
}
inline void PhysicalRoom::_internal_set_logical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PhysicalRoom::_internal_mutable_logical_room() {
  _has_bits_[0] |= 0x00000001u;
  return logical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PhysicalRoom::release_logical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PhysicalRoom.logical_room)
  if (!_internal_has_logical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return logical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PhysicalRoom::set_allocated_logical_room(std::string* logical_room) {
  if (logical_room != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  logical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PhysicalRoom.logical_room)
}

// repeated string physical_rooms = 2;
inline int PhysicalRoom::_internal_physical_rooms_size() const {
  return physical_rooms_.size();
}
inline int PhysicalRoom::physical_rooms_size() const {
  return _internal_physical_rooms_size();
}
inline void PhysicalRoom::clear_physical_rooms() {
  physical_rooms_.Clear();
}
inline std::string* PhysicalRoom::add_physical_rooms() {
  std::string* _s = _internal_add_physical_rooms();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.PhysicalRoom.physical_rooms)
  return _s;
}
inline const std::string& PhysicalRoom::_internal_physical_rooms(int index) const {
  return physical_rooms_.Get(index);
}
inline const std::string& PhysicalRoom::physical_rooms(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PhysicalRoom.physical_rooms)
  return _internal_physical_rooms(index);
}
inline std::string* PhysicalRoom::mutable_physical_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PhysicalRoom.physical_rooms)
  return physical_rooms_.Mutable(index);
}
inline void PhysicalRoom::set_physical_rooms(int index, const std::string& value) {
  physical_rooms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PhysicalRoom.physical_rooms)
}
inline void PhysicalRoom::set_physical_rooms(int index, std::string&& value) {
  physical_rooms_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.PhysicalRoom.physical_rooms)
}
inline void PhysicalRoom::set_physical_rooms(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  physical_rooms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.PhysicalRoom.physical_rooms)
}
inline void PhysicalRoom::set_physical_rooms(int index, const char* value, size_t size) {
  physical_rooms_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.PhysicalRoom.physical_rooms)
}
inline std::string* PhysicalRoom::_internal_add_physical_rooms() {
  return physical_rooms_.Add();
}
inline void PhysicalRoom::add_physical_rooms(const std::string& value) {
  physical_rooms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.PhysicalRoom.physical_rooms)
}
inline void PhysicalRoom::add_physical_rooms(std::string&& value) {
  physical_rooms_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.PhysicalRoom.physical_rooms)
}
inline void PhysicalRoom::add_physical_rooms(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  physical_rooms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.PhysicalRoom.physical_rooms)
}
inline void PhysicalRoom::add_physical_rooms(const char* value, size_t size) {
  physical_rooms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.PhysicalRoom.physical_rooms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PhysicalRoom::physical_rooms() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PhysicalRoom.physical_rooms)
  return physical_rooms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PhysicalRoom::mutable_physical_rooms() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PhysicalRoom.physical_rooms)
  return &physical_rooms_;
}

// -------------------------------------------------------------------

// InstanceInfo

// optional string address = 1;
inline bool InstanceInfo::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InstanceInfo::has_address() const {
  return _internal_has_address();
}
inline void InstanceInfo::clear_address() {
  address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InstanceInfo::address() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceInfo::set_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.address)
}
inline std::string* InstanceInfo::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.InstanceInfo.address)
  return _s;
}
inline const std::string& InstanceInfo::_internal_address() const {
  return address_.Get();
}
inline void InstanceInfo::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstanceInfo::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstanceInfo::release_address() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.InstanceInfo.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstanceInfo::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.InstanceInfo.address)
}

// optional int64 capacity = 2;
inline bool InstanceInfo::_internal_has_capacity() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool InstanceInfo::has_capacity() const {
  return _internal_has_capacity();
}
inline void InstanceInfo::clear_capacity() {
  capacity_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::_internal_capacity() const {
  return capacity_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::capacity() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.capacity)
  return _internal_capacity();
}
inline void InstanceInfo::_internal_set_capacity(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  capacity_ = value;
}
inline void InstanceInfo::set_capacity(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.capacity)
}

// optional int64 used_size = 3;
inline bool InstanceInfo::_internal_has_used_size() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool InstanceInfo::has_used_size() const {
  return _internal_has_used_size();
}
inline void InstanceInfo::clear_used_size() {
  used_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::_internal_used_size() const {
  return used_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::used_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.used_size)
  return _internal_used_size();
}
inline void InstanceInfo::_internal_set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  used_size_ = value;
}
inline void InstanceInfo::set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_used_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.used_size)
}

// optional string resource_tag = 4;
inline bool InstanceInfo::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InstanceInfo::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void InstanceInfo::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InstanceInfo::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceInfo::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.resource_tag)
}
inline std::string* InstanceInfo::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.InstanceInfo.resource_tag)
  return _s;
}
inline const std::string& InstanceInfo::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void InstanceInfo::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstanceInfo::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000002u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstanceInfo::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.InstanceInfo.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstanceInfo::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.InstanceInfo.resource_tag)
}

// optional string physical_room = 5;
inline bool InstanceInfo::_internal_has_physical_room() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InstanceInfo::has_physical_room() const {
  return _internal_has_physical_room();
}
inline void InstanceInfo::clear_physical_room() {
  physical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& InstanceInfo::physical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.physical_room)
  return _internal_physical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceInfo::set_physical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.physical_room)
}
inline std::string* InstanceInfo::mutable_physical_room() {
  std::string* _s = _internal_mutable_physical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.InstanceInfo.physical_room)
  return _s;
}
inline const std::string& InstanceInfo::_internal_physical_room() const {
  return physical_room_.Get();
}
inline void InstanceInfo::_internal_set_physical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstanceInfo::_internal_mutable_physical_room() {
  _has_bits_[0] |= 0x00000004u;
  return physical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstanceInfo::release_physical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.InstanceInfo.physical_room)
  if (!_internal_has_physical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return physical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstanceInfo::set_allocated_physical_room(std::string* physical_room) {
  if (physical_room != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  physical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), physical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.InstanceInfo.physical_room)
}

// optional .baikaldb.pb.Status status = 6;
inline bool InstanceInfo::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool InstanceInfo::has_status() const {
  return _internal_has_status();
}
inline void InstanceInfo::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00020000u;
}
inline ::baikaldb::pb::Status InstanceInfo::_internal_status() const {
  return static_cast< ::baikaldb::pb::Status >(status_);
}
inline ::baikaldb::pb::Status InstanceInfo::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.status)
  return _internal_status();
}
inline void InstanceInfo::_internal_set_status(::baikaldb::pb::Status value) {
  assert(::baikaldb::pb::Status_IsValid(value));
  _has_bits_[0] |= 0x00020000u;
  status_ = value;
}
inline void InstanceInfo::set_status(::baikaldb::pb::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.status)
}

// optional string logical_room = 7;
inline bool InstanceInfo::_internal_has_logical_room() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InstanceInfo::has_logical_room() const {
  return _internal_has_logical_room();
}
inline void InstanceInfo::clear_logical_room() {
  logical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& InstanceInfo::logical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.logical_room)
  return _internal_logical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceInfo::set_logical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.logical_room)
}
inline std::string* InstanceInfo::mutable_logical_room() {
  std::string* _s = _internal_mutable_logical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.InstanceInfo.logical_room)
  return _s;
}
inline const std::string& InstanceInfo::_internal_logical_room() const {
  return logical_room_.Get();
}
inline void InstanceInfo::_internal_set_logical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstanceInfo::_internal_mutable_logical_room() {
  _has_bits_[0] |= 0x00000008u;
  return logical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstanceInfo::release_logical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.InstanceInfo.logical_room)
  if (!_internal_has_logical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return logical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstanceInfo::set_allocated_logical_room(std::string* logical_room) {
  if (logical_room != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  logical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.InstanceInfo.logical_room)
}

// optional string version = 8;
inline bool InstanceInfo::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InstanceInfo::has_version() const {
  return _internal_has_version();
}
inline void InstanceInfo::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& InstanceInfo::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceInfo::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.version)
}
inline std::string* InstanceInfo::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.InstanceInfo.version)
  return _s;
}
inline const std::string& InstanceInfo::_internal_version() const {
  return version_.Get();
}
inline void InstanceInfo::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstanceInfo::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000010u;
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstanceInfo::release_version() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.InstanceInfo.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstanceInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.InstanceInfo.version)
}

// optional int64 dml_latency = 9;
inline bool InstanceInfo::_internal_has_dml_latency() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool InstanceInfo::has_dml_latency() const {
  return _internal_has_dml_latency();
}
inline void InstanceInfo::clear_dml_latency() {
  dml_latency_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::_internal_dml_latency() const {
  return dml_latency_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::dml_latency() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.dml_latency)
  return _internal_dml_latency();
}
inline void InstanceInfo::_internal_set_dml_latency(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  dml_latency_ = value;
}
inline void InstanceInfo::set_dml_latency(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_dml_latency(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.dml_latency)
}

// optional int64 dml_qps = 10;
inline bool InstanceInfo::_internal_has_dml_qps() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool InstanceInfo::has_dml_qps() const {
  return _internal_has_dml_qps();
}
inline void InstanceInfo::clear_dml_qps() {
  dml_qps_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::_internal_dml_qps() const {
  return dml_qps_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::dml_qps() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.dml_qps)
  return _internal_dml_qps();
}
inline void InstanceInfo::_internal_set_dml_qps(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  dml_qps_ = value;
}
inline void InstanceInfo::set_dml_qps(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_dml_qps(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.dml_qps)
}

// optional int64 raft_total_latency = 11;
inline bool InstanceInfo::_internal_has_raft_total_latency() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool InstanceInfo::has_raft_total_latency() const {
  return _internal_has_raft_total_latency();
}
inline void InstanceInfo::clear_raft_total_latency() {
  raft_total_latency_ = int64_t{0};
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::_internal_raft_total_latency() const {
  return raft_total_latency_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::raft_total_latency() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.raft_total_latency)
  return _internal_raft_total_latency();
}
inline void InstanceInfo::_internal_set_raft_total_latency(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00001000u;
  raft_total_latency_ = value;
}
inline void InstanceInfo::set_raft_total_latency(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_raft_total_latency(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.raft_total_latency)
}

// optional int64 raft_total_qps = 12;
inline bool InstanceInfo::_internal_has_raft_total_qps() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool InstanceInfo::has_raft_total_qps() const {
  return _internal_has_raft_total_qps();
}
inline void InstanceInfo::clear_raft_total_qps() {
  raft_total_qps_ = int64_t{0};
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::_internal_raft_total_qps() const {
  return raft_total_qps_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::raft_total_qps() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.raft_total_qps)
  return _internal_raft_total_qps();
}
inline void InstanceInfo::_internal_set_raft_total_qps(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00002000u;
  raft_total_qps_ = value;
}
inline void InstanceInfo::set_raft_total_qps(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_raft_total_qps(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.raft_total_qps)
}

// optional int64 select_latency = 13;
inline bool InstanceInfo::_internal_has_select_latency() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool InstanceInfo::has_select_latency() const {
  return _internal_has_select_latency();
}
inline void InstanceInfo::clear_select_latency() {
  select_latency_ = int64_t{0};
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::_internal_select_latency() const {
  return select_latency_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::select_latency() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.select_latency)
  return _internal_select_latency();
}
inline void InstanceInfo::_internal_set_select_latency(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00004000u;
  select_latency_ = value;
}
inline void InstanceInfo::set_select_latency(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_select_latency(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.select_latency)
}

// optional int64 select_qps = 14;
inline bool InstanceInfo::_internal_has_select_qps() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool InstanceInfo::has_select_qps() const {
  return _internal_has_select_qps();
}
inline void InstanceInfo::clear_select_qps() {
  select_qps_ = int64_t{0};
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::_internal_select_qps() const {
  return select_qps_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::select_qps() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.select_qps)
  return _internal_select_qps();
}
inline void InstanceInfo::_internal_set_select_qps(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00008000u;
  select_qps_ = value;
}
inline void InstanceInfo::set_select_qps(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_select_qps(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.select_qps)
}

// optional string network_segment = 15;
inline bool InstanceInfo::_internal_has_network_segment() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InstanceInfo::has_network_segment() const {
  return _internal_has_network_segment();
}
inline void InstanceInfo::clear_network_segment() {
  network_segment_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& InstanceInfo::network_segment() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.network_segment)
  return _internal_network_segment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceInfo::set_network_segment(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 network_segment_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.network_segment)
}
inline std::string* InstanceInfo::mutable_network_segment() {
  std::string* _s = _internal_mutable_network_segment();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.InstanceInfo.network_segment)
  return _s;
}
inline const std::string& InstanceInfo::_internal_network_segment() const {
  return network_segment_.Get();
}
inline void InstanceInfo::_internal_set_network_segment(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  network_segment_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstanceInfo::_internal_mutable_network_segment() {
  _has_bits_[0] |= 0x00000020u;
  return network_segment_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstanceInfo::release_network_segment() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.InstanceInfo.network_segment)
  if (!_internal_has_network_segment()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return network_segment_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstanceInfo::set_allocated_network_segment(std::string* network_segment) {
  if (network_segment != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  network_segment_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), network_segment,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.InstanceInfo.network_segment)
}

// optional string container_id = 16;
inline bool InstanceInfo::_internal_has_container_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool InstanceInfo::has_container_id() const {
  return _internal_has_container_id();
}
inline void InstanceInfo::clear_container_id() {
  container_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& InstanceInfo::container_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.container_id)
  return _internal_container_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceInfo::set_container_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.container_id)
}
inline std::string* InstanceInfo::mutable_container_id() {
  std::string* _s = _internal_mutable_container_id();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.InstanceInfo.container_id)
  return _s;
}
inline const std::string& InstanceInfo::_internal_container_id() const {
  return container_id_.Get();
}
inline void InstanceInfo::_internal_set_container_id(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  container_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstanceInfo::_internal_mutable_container_id() {
  _has_bits_[0] |= 0x00000040u;
  return container_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstanceInfo::release_container_id() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.InstanceInfo.container_id)
  if (!_internal_has_container_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return container_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstanceInfo::set_allocated_container_id(std::string* container_id) {
  if (container_id != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  container_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), container_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.InstanceInfo.container_id)
}

// optional int64 rocks_hang_check_cost = 17;
inline bool InstanceInfo::_internal_has_rocks_hang_check_cost() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool InstanceInfo::has_rocks_hang_check_cost() const {
  return _internal_has_rocks_hang_check_cost();
}
inline void InstanceInfo::clear_rocks_hang_check_cost() {
  rocks_hang_check_cost_ = int64_t{0};
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::_internal_rocks_hang_check_cost() const {
  return rocks_hang_check_cost_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 InstanceInfo::rocks_hang_check_cost() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.rocks_hang_check_cost)
  return _internal_rocks_hang_check_cost();
}
inline void InstanceInfo::_internal_set_rocks_hang_check_cost(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00010000u;
  rocks_hang_check_cost_ = value;
}
inline void InstanceInfo::set_rocks_hang_check_cost(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_rocks_hang_check_cost(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.rocks_hang_check_cost)
}

// optional string init_address = 18;
inline bool InstanceInfo::_internal_has_init_address() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool InstanceInfo::has_init_address() const {
  return _internal_has_init_address();
}
inline void InstanceInfo::clear_init_address() {
  init_address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& InstanceInfo::init_address() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceInfo.init_address)
  return _internal_init_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceInfo::set_init_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 init_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceInfo.init_address)
}
inline std::string* InstanceInfo::mutable_init_address() {
  std::string* _s = _internal_mutable_init_address();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.InstanceInfo.init_address)
  return _s;
}
inline const std::string& InstanceInfo::_internal_init_address() const {
  return init_address_.Get();
}
inline void InstanceInfo::_internal_set_init_address(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  init_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstanceInfo::_internal_mutable_init_address() {
  _has_bits_[0] |= 0x00000080u;
  return init_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstanceInfo::release_init_address() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.InstanceInfo.init_address)
  if (!_internal_has_init_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return init_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstanceInfo::set_allocated_init_address(std::string* init_address) {
  if (init_address != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  init_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), init_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.InstanceInfo.init_address)
}

// -------------------------------------------------------------------

// BaikalStatus

// required string address = 1;
inline bool BaikalStatus::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BaikalStatus::has_address() const {
  return _internal_has_address();
}
inline void BaikalStatus::clear_address() {
  address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BaikalStatus::address() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalStatus.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaikalStatus::set_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalStatus.address)
}
inline std::string* BaikalStatus::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalStatus.address)
  return _s;
}
inline const std::string& BaikalStatus::_internal_address() const {
  return address_.Get();
}
inline void BaikalStatus::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BaikalStatus::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BaikalStatus::release_address() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BaikalStatus.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BaikalStatus::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BaikalStatus.address)
}

// required string resource_tag = 2;
inline bool BaikalStatus::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BaikalStatus::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void BaikalStatus::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BaikalStatus::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalStatus.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaikalStatus::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalStatus.resource_tag)
}
inline std::string* BaikalStatus::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalStatus.resource_tag)
  return _s;
}
inline const std::string& BaikalStatus::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void BaikalStatus::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BaikalStatus::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000002u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BaikalStatus::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BaikalStatus.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BaikalStatus::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BaikalStatus.resource_tag)
}

// required .baikaldb.pb.Status status = 3;
inline bool BaikalStatus::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BaikalStatus::has_status() const {
  return _internal_has_status();
}
inline void BaikalStatus::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::baikaldb::pb::Status BaikalStatus::_internal_status() const {
  return static_cast< ::baikaldb::pb::Status >(status_);
}
inline ::baikaldb::pb::Status BaikalStatus::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalStatus.status)
  return _internal_status();
}
inline void BaikalStatus::_internal_set_status(::baikaldb::pb::Status value) {
  assert(::baikaldb::pb::Status_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  status_ = value;
}
inline void BaikalStatus::set_status(::baikaldb::pb::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalStatus.status)
}

// optional int64 last_heartbeat_timestamp = 4;
inline bool BaikalStatus::_internal_has_last_heartbeat_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BaikalStatus::has_last_heartbeat_timestamp() const {
  return _internal_has_last_heartbeat_timestamp();
}
inline void BaikalStatus::clear_last_heartbeat_timestamp() {
  last_heartbeat_timestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalStatus::_internal_last_heartbeat_timestamp() const {
  return last_heartbeat_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalStatus::last_heartbeat_timestamp() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalStatus.last_heartbeat_timestamp)
  return _internal_last_heartbeat_timestamp();
}
inline void BaikalStatus::_internal_set_last_heartbeat_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  last_heartbeat_timestamp_ = value;
}
inline void BaikalStatus::set_last_heartbeat_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_last_heartbeat_timestamp(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalStatus.last_heartbeat_timestamp)
}

// -------------------------------------------------------------------

// MovePhysicalRequest

// required string physical_room = 1;
inline bool MovePhysicalRequest::_internal_has_physical_room() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MovePhysicalRequest::has_physical_room() const {
  return _internal_has_physical_room();
}
inline void MovePhysicalRequest::clear_physical_room() {
  physical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MovePhysicalRequest::physical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MovePhysicalRequest.physical_room)
  return _internal_physical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MovePhysicalRequest::set_physical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MovePhysicalRequest.physical_room)
}
inline std::string* MovePhysicalRequest::mutable_physical_room() {
  std::string* _s = _internal_mutable_physical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MovePhysicalRequest.physical_room)
  return _s;
}
inline const std::string& MovePhysicalRequest::_internal_physical_room() const {
  return physical_room_.Get();
}
inline void MovePhysicalRequest::_internal_set_physical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MovePhysicalRequest::_internal_mutable_physical_room() {
  _has_bits_[0] |= 0x00000001u;
  return physical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MovePhysicalRequest::release_physical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MovePhysicalRequest.physical_room)
  if (!_internal_has_physical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return physical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MovePhysicalRequest::set_allocated_physical_room(std::string* physical_room) {
  if (physical_room != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  physical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), physical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MovePhysicalRequest.physical_room)
}

// required string old_logical_room = 2;
inline bool MovePhysicalRequest::_internal_has_old_logical_room() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MovePhysicalRequest::has_old_logical_room() const {
  return _internal_has_old_logical_room();
}
inline void MovePhysicalRequest::clear_old_logical_room() {
  old_logical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MovePhysicalRequest::old_logical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MovePhysicalRequest.old_logical_room)
  return _internal_old_logical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MovePhysicalRequest::set_old_logical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 old_logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MovePhysicalRequest.old_logical_room)
}
inline std::string* MovePhysicalRequest::mutable_old_logical_room() {
  std::string* _s = _internal_mutable_old_logical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MovePhysicalRequest.old_logical_room)
  return _s;
}
inline const std::string& MovePhysicalRequest::_internal_old_logical_room() const {
  return old_logical_room_.Get();
}
inline void MovePhysicalRequest::_internal_set_old_logical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  old_logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MovePhysicalRequest::_internal_mutable_old_logical_room() {
  _has_bits_[0] |= 0x00000002u;
  return old_logical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MovePhysicalRequest::release_old_logical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MovePhysicalRequest.old_logical_room)
  if (!_internal_has_old_logical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return old_logical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MovePhysicalRequest::set_allocated_old_logical_room(std::string* old_logical_room) {
  if (old_logical_room != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  old_logical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), old_logical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MovePhysicalRequest.old_logical_room)
}

// required string new_logical_room = 3;
inline bool MovePhysicalRequest::_internal_has_new_logical_room() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MovePhysicalRequest::has_new_logical_room() const {
  return _internal_has_new_logical_room();
}
inline void MovePhysicalRequest::clear_new_logical_room() {
  new_logical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MovePhysicalRequest::new_logical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MovePhysicalRequest.new_logical_room)
  return _internal_new_logical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MovePhysicalRequest::set_new_logical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 new_logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MovePhysicalRequest.new_logical_room)
}
inline std::string* MovePhysicalRequest::mutable_new_logical_room() {
  std::string* _s = _internal_mutable_new_logical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MovePhysicalRequest.new_logical_room)
  return _s;
}
inline const std::string& MovePhysicalRequest::_internal_new_logical_room() const {
  return new_logical_room_.Get();
}
inline void MovePhysicalRequest::_internal_set_new_logical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  new_logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MovePhysicalRequest::_internal_mutable_new_logical_room() {
  _has_bits_[0] |= 0x00000004u;
  return new_logical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MovePhysicalRequest::release_new_logical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MovePhysicalRequest.new_logical_room)
  if (!_internal_has_new_logical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return new_logical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MovePhysicalRequest::set_allocated_new_logical_room(std::string* new_logical_room) {
  if (new_logical_room != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  new_logical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_logical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MovePhysicalRequest.new_logical_room)
}

// -------------------------------------------------------------------

// AlterTableRequest

// required string table_name = 1;
inline bool AlterTableRequest::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AlterTableRequest::has_table_name() const {
  return _internal_has_table_name();
}
inline void AlterTableRequest::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AlterTableRequest::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AlterTableRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlterTableRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.AlterTableRequest.table_name)
}
inline std::string* AlterTableRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.AlterTableRequest.table_name)
  return _s;
}
inline const std::string& AlterTableRequest::_internal_table_name() const {
  return table_name_.Get();
}
inline void AlterTableRequest::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AlterTableRequest::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000001u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AlterTableRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.AlterTableRequest.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AlterTableRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.AlterTableRequest.table_name)
}

// required string namespace = 2;
inline bool AlterTableRequest::_internal_has_namespace_() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AlterTableRequest::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void AlterTableRequest::clear_namespace_() {
  namespace__.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AlterTableRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AlterTableRequest.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlterTableRequest::set_namespace_(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.AlterTableRequest.namespace)
}
inline std::string* AlterTableRequest::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.AlterTableRequest.namespace)
  return _s;
}
inline const std::string& AlterTableRequest::_internal_namespace_() const {
  return namespace__.Get();
}
inline void AlterTableRequest::_internal_set_namespace_(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AlterTableRequest::_internal_mutable_namespace_() {
  _has_bits_[0] |= 0x00000002u;
  return namespace__.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AlterTableRequest::release_namespace_() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.AlterTableRequest.namespace)
  if (!_internal_has_namespace_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return namespace__.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AlterTableRequest::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  namespace__.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.AlterTableRequest.namespace)
}

// required string database = 3;
inline bool AlterTableRequest::_internal_has_database() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AlterTableRequest::has_database() const {
  return _internal_has_database();
}
inline void AlterTableRequest::clear_database() {
  database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AlterTableRequest::database() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AlterTableRequest.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AlterTableRequest::set_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.AlterTableRequest.database)
}
inline std::string* AlterTableRequest::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.AlterTableRequest.database)
  return _s;
}
inline const std::string& AlterTableRequest::_internal_database() const {
  return database_.Get();
}
inline void AlterTableRequest::_internal_set_database(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AlterTableRequest::_internal_mutable_database() {
  _has_bits_[0] |= 0x00000004u;
  return database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AlterTableRequest::release_database() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.AlterTableRequest.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AlterTableRequest::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.AlterTableRequest.database)
}

// optional int64 table_id = 4;
inline bool AlterTableRequest::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AlterTableRequest::has_table_id() const {
  return _internal_has_table_id();
}
inline void AlterTableRequest::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AlterTableRequest::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AlterTableRequest::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AlterTableRequest.table_id)
  return _internal_table_id();
}
inline void AlterTableRequest::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  table_id_ = value;
}
inline void AlterTableRequest::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AlterTableRequest.table_id)
}

// optional int64 namespace_id = 5;
inline bool AlterTableRequest::_internal_has_namespace_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AlterTableRequest::has_namespace_id() const {
  return _internal_has_namespace_id();
}
inline void AlterTableRequest::clear_namespace_id() {
  namespace_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AlterTableRequest::_internal_namespace_id() const {
  return namespace_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AlterTableRequest::namespace_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AlterTableRequest.namespace_id)
  return _internal_namespace_id();
}
inline void AlterTableRequest::_internal_set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  namespace_id_ = value;
}
inline void AlterTableRequest::set_namespace_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_namespace_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AlterTableRequest.namespace_id)
}

// optional int64 database_id = 6;
inline bool AlterTableRequest::_internal_has_database_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AlterTableRequest::has_database_id() const {
  return _internal_has_database_id();
}
inline void AlterTableRequest::clear_database_id() {
  database_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AlterTableRequest::_internal_database_id() const {
  return database_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AlterTableRequest::database_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AlterTableRequest.database_id)
  return _internal_database_id();
}
inline void AlterTableRequest::_internal_set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  database_id_ = value;
}
inline void AlterTableRequest::set_database_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_database_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AlterTableRequest.database_id)
}

// repeated .baikaldb.pb.FieldInfo fields = 7;
inline int AlterTableRequest::_internal_fields_size() const {
  return fields_.size();
}
inline int AlterTableRequest::fields_size() const {
  return _internal_fields_size();
}
inline void AlterTableRequest::clear_fields() {
  fields_.Clear();
}
inline ::baikaldb::pb::FieldInfo* AlterTableRequest::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.AlterTableRequest.fields)
  return fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FieldInfo >*
AlterTableRequest::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.AlterTableRequest.fields)
  return &fields_;
}
inline const ::baikaldb::pb::FieldInfo& AlterTableRequest::_internal_fields(int index) const {
  return fields_.Get(index);
}
inline const ::baikaldb::pb::FieldInfo& AlterTableRequest::fields(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AlterTableRequest.fields)
  return _internal_fields(index);
}
inline ::baikaldb::pb::FieldInfo* AlterTableRequest::_internal_add_fields() {
  return fields_.Add();
}
inline ::baikaldb::pb::FieldInfo* AlterTableRequest::add_fields() {
  ::baikaldb::pb::FieldInfo* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:baikaldb.pb.AlterTableRequest.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FieldInfo >&
AlterTableRequest::fields() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.AlterTableRequest.fields)
  return fields_;
}

// repeated .baikaldb.pb.IndexInfo indexs = 8;
inline int AlterTableRequest::_internal_indexs_size() const {
  return indexs_.size();
}
inline int AlterTableRequest::indexs_size() const {
  return _internal_indexs_size();
}
inline void AlterTableRequest::clear_indexs() {
  indexs_.Clear();
}
inline ::baikaldb::pb::IndexInfo* AlterTableRequest::mutable_indexs(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.AlterTableRequest.indexs)
  return indexs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::IndexInfo >*
AlterTableRequest::mutable_indexs() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.AlterTableRequest.indexs)
  return &indexs_;
}
inline const ::baikaldb::pb::IndexInfo& AlterTableRequest::_internal_indexs(int index) const {
  return indexs_.Get(index);
}
inline const ::baikaldb::pb::IndexInfo& AlterTableRequest::indexs(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AlterTableRequest.indexs)
  return _internal_indexs(index);
}
inline ::baikaldb::pb::IndexInfo* AlterTableRequest::_internal_add_indexs() {
  return indexs_.Add();
}
inline ::baikaldb::pb::IndexInfo* AlterTableRequest::add_indexs() {
  ::baikaldb::pb::IndexInfo* _add = _internal_add_indexs();
  // @@protoc_insertion_point(field_add:baikaldb.pb.AlterTableRequest.indexs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::IndexInfo >&
AlterTableRequest::indexs() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.AlterTableRequest.indexs)
  return indexs_;
}

// -------------------------------------------------------------------

// RegionMergeRequest

// required int64 src_region_id = 1;
inline bool RegionMergeRequest::_internal_has_src_region_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegionMergeRequest::has_src_region_id() const {
  return _internal_has_src_region_id();
}
inline void RegionMergeRequest::clear_src_region_id() {
  src_region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionMergeRequest::_internal_src_region_id() const {
  return src_region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionMergeRequest::src_region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionMergeRequest.src_region_id)
  return _internal_src_region_id();
}
inline void RegionMergeRequest::_internal_set_src_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  src_region_id_ = value;
}
inline void RegionMergeRequest::set_src_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_src_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionMergeRequest.src_region_id)
}

// required bytes src_start_key = 2;
inline bool RegionMergeRequest::_internal_has_src_start_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegionMergeRequest::has_src_start_key() const {
  return _internal_has_src_start_key();
}
inline void RegionMergeRequest::clear_src_start_key() {
  src_start_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionMergeRequest::src_start_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionMergeRequest.src_start_key)
  return _internal_src_start_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionMergeRequest::set_src_start_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 src_start_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionMergeRequest.src_start_key)
}
inline std::string* RegionMergeRequest::mutable_src_start_key() {
  std::string* _s = _internal_mutable_src_start_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionMergeRequest.src_start_key)
  return _s;
}
inline const std::string& RegionMergeRequest::_internal_src_start_key() const {
  return src_start_key_.Get();
}
inline void RegionMergeRequest::_internal_set_src_start_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  src_start_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionMergeRequest::_internal_mutable_src_start_key() {
  _has_bits_[0] |= 0x00000001u;
  return src_start_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionMergeRequest::release_src_start_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionMergeRequest.src_start_key)
  if (!_internal_has_src_start_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return src_start_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionMergeRequest::set_allocated_src_start_key(std::string* src_start_key) {
  if (src_start_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  src_start_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), src_start_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionMergeRequest.src_start_key)
}

// required bytes src_end_key = 3;
inline bool RegionMergeRequest::_internal_has_src_end_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionMergeRequest::has_src_end_key() const {
  return _internal_has_src_end_key();
}
inline void RegionMergeRequest::clear_src_end_key() {
  src_end_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RegionMergeRequest::src_end_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionMergeRequest.src_end_key)
  return _internal_src_end_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionMergeRequest::set_src_end_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 src_end_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionMergeRequest.src_end_key)
}
inline std::string* RegionMergeRequest::mutable_src_end_key() {
  std::string* _s = _internal_mutable_src_end_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionMergeRequest.src_end_key)
  return _s;
}
inline const std::string& RegionMergeRequest::_internal_src_end_key() const {
  return src_end_key_.Get();
}
inline void RegionMergeRequest::_internal_set_src_end_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  src_end_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionMergeRequest::_internal_mutable_src_end_key() {
  _has_bits_[0] |= 0x00000002u;
  return src_end_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionMergeRequest::release_src_end_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionMergeRequest.src_end_key)
  if (!_internal_has_src_end_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return src_end_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionMergeRequest::set_allocated_src_end_key(std::string* src_end_key) {
  if (src_end_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  src_end_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), src_end_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionMergeRequest.src_end_key)
}

// required int64 table_id = 4;
inline bool RegionMergeRequest::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RegionMergeRequest::has_table_id() const {
  return _internal_has_table_id();
}
inline void RegionMergeRequest::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionMergeRequest::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionMergeRequest::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionMergeRequest.table_id)
  return _internal_table_id();
}
inline void RegionMergeRequest::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  table_id_ = value;
}
inline void RegionMergeRequest::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionMergeRequest.table_id)
}

// optional int64 partition_id = 5;
inline bool RegionMergeRequest::_internal_has_partition_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RegionMergeRequest::has_partition_id() const {
  return _internal_has_partition_id();
}
inline void RegionMergeRequest::clear_partition_id() {
  partition_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionMergeRequest::_internal_partition_id() const {
  return partition_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionMergeRequest::partition_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionMergeRequest.partition_id)
  return _internal_partition_id();
}
inline void RegionMergeRequest::_internal_set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  partition_id_ = value;
}
inline void RegionMergeRequest::set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_partition_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionMergeRequest.partition_id)
}

// -------------------------------------------------------------------

// RegionMergeResponse

// optional int64 dst_region_id = 1;
inline bool RegionMergeResponse::_internal_has_dst_region_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RegionMergeResponse::has_dst_region_id() const {
  return _internal_has_dst_region_id();
}
inline void RegionMergeResponse::clear_dst_region_id() {
  dst_region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionMergeResponse::_internal_dst_region_id() const {
  return dst_region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionMergeResponse::dst_region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionMergeResponse.dst_region_id)
  return _internal_dst_region_id();
}
inline void RegionMergeResponse::_internal_set_dst_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  dst_region_id_ = value;
}
inline void RegionMergeResponse::set_dst_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_dst_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionMergeResponse.dst_region_id)
}

// optional string dst_instance = 2;
inline bool RegionMergeResponse::_internal_has_dst_instance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegionMergeResponse::has_dst_instance() const {
  return _internal_has_dst_instance();
}
inline void RegionMergeResponse::clear_dst_instance() {
  dst_instance_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionMergeResponse::dst_instance() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionMergeResponse.dst_instance)
  return _internal_dst_instance();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionMergeResponse::set_dst_instance(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 dst_instance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionMergeResponse.dst_instance)
}
inline std::string* RegionMergeResponse::mutable_dst_instance() {
  std::string* _s = _internal_mutable_dst_instance();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionMergeResponse.dst_instance)
  return _s;
}
inline const std::string& RegionMergeResponse::_internal_dst_instance() const {
  return dst_instance_.Get();
}
inline void RegionMergeResponse::_internal_set_dst_instance(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  dst_instance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionMergeResponse::_internal_mutable_dst_instance() {
  _has_bits_[0] |= 0x00000001u;
  return dst_instance_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionMergeResponse::release_dst_instance() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionMergeResponse.dst_instance)
  if (!_internal_has_dst_instance()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return dst_instance_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionMergeResponse::set_allocated_dst_instance(std::string* dst_instance) {
  if (dst_instance != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  dst_instance_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dst_instance,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionMergeResponse.dst_instance)
}

// optional bytes dst_start_key = 3;
inline bool RegionMergeResponse::_internal_has_dst_start_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionMergeResponse::has_dst_start_key() const {
  return _internal_has_dst_start_key();
}
inline void RegionMergeResponse::clear_dst_start_key() {
  dst_start_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RegionMergeResponse::dst_start_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionMergeResponse.dst_start_key)
  return _internal_dst_start_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionMergeResponse::set_dst_start_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 dst_start_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionMergeResponse.dst_start_key)
}
inline std::string* RegionMergeResponse::mutable_dst_start_key() {
  std::string* _s = _internal_mutable_dst_start_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionMergeResponse.dst_start_key)
  return _s;
}
inline const std::string& RegionMergeResponse::_internal_dst_start_key() const {
  return dst_start_key_.Get();
}
inline void RegionMergeResponse::_internal_set_dst_start_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  dst_start_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionMergeResponse::_internal_mutable_dst_start_key() {
  _has_bits_[0] |= 0x00000002u;
  return dst_start_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionMergeResponse::release_dst_start_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionMergeResponse.dst_start_key)
  if (!_internal_has_dst_start_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return dst_start_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionMergeResponse::set_allocated_dst_start_key(std::string* dst_start_key) {
  if (dst_start_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  dst_start_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dst_start_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionMergeResponse.dst_start_key)
}

// optional bytes dst_end_key = 4;
inline bool RegionMergeResponse::_internal_has_dst_end_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegionMergeResponse::has_dst_end_key() const {
  return _internal_has_dst_end_key();
}
inline void RegionMergeResponse::clear_dst_end_key() {
  dst_end_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RegionMergeResponse::dst_end_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionMergeResponse.dst_end_key)
  return _internal_dst_end_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionMergeResponse::set_dst_end_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 dst_end_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionMergeResponse.dst_end_key)
}
inline std::string* RegionMergeResponse::mutable_dst_end_key() {
  std::string* _s = _internal_mutable_dst_end_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionMergeResponse.dst_end_key)
  return _s;
}
inline const std::string& RegionMergeResponse::_internal_dst_end_key() const {
  return dst_end_key_.Get();
}
inline void RegionMergeResponse::_internal_set_dst_end_key(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  dst_end_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionMergeResponse::_internal_mutable_dst_end_key() {
  _has_bits_[0] |= 0x00000004u;
  return dst_end_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionMergeResponse::release_dst_end_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionMergeResponse.dst_end_key)
  if (!_internal_has_dst_end_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return dst_end_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionMergeResponse::set_allocated_dst_end_key(std::string* dst_end_key) {
  if (dst_end_key != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  dst_end_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dst_end_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionMergeResponse.dst_end_key)
}

// optional int64 version = 5;
inline bool RegionMergeResponse::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RegionMergeResponse::has_version() const {
  return _internal_has_version();
}
inline void RegionMergeResponse::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionMergeResponse::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionMergeResponse::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionMergeResponse.version)
  return _internal_version();
}
inline void RegionMergeResponse::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  version_ = value;
}
inline void RegionMergeResponse::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionMergeResponse.version)
}

// optional .baikaldb.pb.RegionInfo dst_region = 6;
inline bool RegionMergeResponse::_internal_has_dst_region() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || dst_region_ != nullptr);
  return value;
}
inline bool RegionMergeResponse::has_dst_region() const {
  return _internal_has_dst_region();
}
inline void RegionMergeResponse::clear_dst_region() {
  if (dst_region_ != nullptr) dst_region_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::baikaldb::pb::RegionInfo& RegionMergeResponse::_internal_dst_region() const {
  const ::baikaldb::pb::RegionInfo* p = dst_region_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionInfo&>(
      ::baikaldb::pb::_RegionInfo_default_instance_);
}
inline const ::baikaldb::pb::RegionInfo& RegionMergeResponse::dst_region() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionMergeResponse.dst_region)
  return _internal_dst_region();
}
inline void RegionMergeResponse::unsafe_arena_set_allocated_dst_region(
    ::baikaldb::pb::RegionInfo* dst_region) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dst_region_);
  }
  dst_region_ = dst_region;
  if (dst_region) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.RegionMergeResponse.dst_region)
}
inline ::baikaldb::pb::RegionInfo* RegionMergeResponse::release_dst_region() {
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::RegionInfo* temp = dst_region_;
  dst_region_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionInfo* RegionMergeResponse::unsafe_arena_release_dst_region() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionMergeResponse.dst_region)
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::RegionInfo* temp = dst_region_;
  dst_region_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionInfo* RegionMergeResponse::_internal_mutable_dst_region() {
  _has_bits_[0] |= 0x00000008u;
  if (dst_region_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionInfo>(GetArenaForAllocation());
    dst_region_ = p;
  }
  return dst_region_;
}
inline ::baikaldb::pb::RegionInfo* RegionMergeResponse::mutable_dst_region() {
  ::baikaldb::pb::RegionInfo* _msg = _internal_mutable_dst_region();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionMergeResponse.dst_region)
  return _msg;
}
inline void RegionMergeResponse::set_allocated_dst_region(::baikaldb::pb::RegionInfo* dst_region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dst_region_;
  }
  if (dst_region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::RegionInfo>::GetOwningArena(dst_region);
    if (message_arena != submessage_arena) {
      dst_region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dst_region, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  dst_region_ = dst_region;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionMergeResponse.dst_region)
}

// -------------------------------------------------------------------

// RegionSplitRequest

// required int64 region_id = 1;
inline bool RegionSplitRequest::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RegionSplitRequest::has_region_id() const {
  return _internal_has_region_id();
}
inline void RegionSplitRequest::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionSplitRequest::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionSplitRequest::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionSplitRequest.region_id)
  return _internal_region_id();
}
inline void RegionSplitRequest::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  region_id_ = value;
}
inline void RegionSplitRequest::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionSplitRequest.region_id)
}

// required bytes split_key = 2;
inline bool RegionSplitRequest::_internal_has_split_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegionSplitRequest::has_split_key() const {
  return _internal_has_split_key();
}
inline void RegionSplitRequest::clear_split_key() {
  split_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionSplitRequest::split_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionSplitRequest.split_key)
  return _internal_split_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionSplitRequest::set_split_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 split_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionSplitRequest.split_key)
}
inline std::string* RegionSplitRequest::mutable_split_key() {
  std::string* _s = _internal_mutable_split_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionSplitRequest.split_key)
  return _s;
}
inline const std::string& RegionSplitRequest::_internal_split_key() const {
  return split_key_.Get();
}
inline void RegionSplitRequest::_internal_set_split_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  split_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionSplitRequest::_internal_mutable_split_key() {
  _has_bits_[0] |= 0x00000001u;
  return split_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionSplitRequest::release_split_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionSplitRequest.split_key)
  if (!_internal_has_split_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return split_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionSplitRequest::set_allocated_split_key(std::string* split_key) {
  if (split_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  split_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), split_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionSplitRequest.split_key)
}

// optional string new_instance = 3;
inline bool RegionSplitRequest::_internal_has_new_instance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionSplitRequest::has_new_instance() const {
  return _internal_has_new_instance();
}
inline void RegionSplitRequest::clear_new_instance() {
  new_instance_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RegionSplitRequest::new_instance() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionSplitRequest.new_instance)
  return _internal_new_instance();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionSplitRequest::set_new_instance(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 new_instance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionSplitRequest.new_instance)
}
inline std::string* RegionSplitRequest::mutable_new_instance() {
  std::string* _s = _internal_mutable_new_instance();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionSplitRequest.new_instance)
  return _s;
}
inline const std::string& RegionSplitRequest::_internal_new_instance() const {
  return new_instance_.Get();
}
inline void RegionSplitRequest::_internal_set_new_instance(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  new_instance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionSplitRequest::_internal_mutable_new_instance() {
  _has_bits_[0] |= 0x00000002u;
  return new_instance_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionSplitRequest::release_new_instance() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionSplitRequest.new_instance)
  if (!_internal_has_new_instance()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return new_instance_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionSplitRequest::set_allocated_new_instance(std::string* new_instance) {
  if (new_instance != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  new_instance_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_instance,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionSplitRequest.new_instance)
}

// optional bool tail_split = 4;
inline bool RegionSplitRequest::_internal_has_tail_split() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RegionSplitRequest::has_tail_split() const {
  return _internal_has_tail_split();
}
inline void RegionSplitRequest::clear_tail_split() {
  tail_split_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool RegionSplitRequest::_internal_tail_split() const {
  return tail_split_;
}
inline bool RegionSplitRequest::tail_split() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionSplitRequest.tail_split)
  return _internal_tail_split();
}
inline void RegionSplitRequest::_internal_set_tail_split(bool value) {
  _has_bits_[0] |= 0x00000040u;
  tail_split_ = value;
}
inline void RegionSplitRequest::set_tail_split(bool value) {
  _internal_set_tail_split(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionSplitRequest.tail_split)
}

// optional int64 table_id = 5;
inline bool RegionSplitRequest::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RegionSplitRequest::has_table_id() const {
  return _internal_has_table_id();
}
inline void RegionSplitRequest::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionSplitRequest::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionSplitRequest::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionSplitRequest.table_id)
  return _internal_table_id();
}
inline void RegionSplitRequest::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  table_id_ = value;
}
inline void RegionSplitRequest::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionSplitRequest.table_id)
}

// optional string resource_tag = 6;
inline bool RegionSplitRequest::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegionSplitRequest::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void RegionSplitRequest::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RegionSplitRequest::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionSplitRequest.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionSplitRequest::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionSplitRequest.resource_tag)
}
inline std::string* RegionSplitRequest::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionSplitRequest.resource_tag)
  return _s;
}
inline const std::string& RegionSplitRequest::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void RegionSplitRequest::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionSplitRequest::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000004u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionSplitRequest::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionSplitRequest.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionSplitRequest::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionSplitRequest.resource_tag)
}

// optional int64 new_region_num = 7;
inline bool RegionSplitRequest::_internal_has_new_region_num() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RegionSplitRequest::has_new_region_num() const {
  return _internal_has_new_region_num();
}
inline void RegionSplitRequest::clear_new_region_num() {
  new_region_num_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionSplitRequest::_internal_new_region_num() const {
  return new_region_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionSplitRequest::new_region_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionSplitRequest.new_region_num)
  return _internal_new_region_num();
}
inline void RegionSplitRequest::_internal_set_new_region_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  new_region_num_ = value;
}
inline void RegionSplitRequest::set_new_region_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_new_region_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionSplitRequest.new_region_num)
}

// -------------------------------------------------------------------

// MultiSplitRegion

// optional int64 new_region_id = 1;
inline bool MultiSplitRegion::_internal_has_new_region_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MultiSplitRegion::has_new_region_id() const {
  return _internal_has_new_region_id();
}
inline void MultiSplitRegion::clear_new_region_id() {
  new_region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MultiSplitRegion::_internal_new_region_id() const {
  return new_region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MultiSplitRegion::new_region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MultiSplitRegion.new_region_id)
  return _internal_new_region_id();
}
inline void MultiSplitRegion::_internal_set_new_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  new_region_id_ = value;
}
inline void MultiSplitRegion::set_new_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_new_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.MultiSplitRegion.new_region_id)
}

// optional string new_instance = 2;
inline bool MultiSplitRegion::_internal_has_new_instance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MultiSplitRegion::has_new_instance() const {
  return _internal_has_new_instance();
}
inline void MultiSplitRegion::clear_new_instance() {
  new_instance_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MultiSplitRegion::new_instance() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MultiSplitRegion.new_instance)
  return _internal_new_instance();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultiSplitRegion::set_new_instance(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 new_instance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MultiSplitRegion.new_instance)
}
inline std::string* MultiSplitRegion::mutable_new_instance() {
  std::string* _s = _internal_mutable_new_instance();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MultiSplitRegion.new_instance)
  return _s;
}
inline const std::string& MultiSplitRegion::_internal_new_instance() const {
  return new_instance_.Get();
}
inline void MultiSplitRegion::_internal_set_new_instance(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  new_instance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MultiSplitRegion::_internal_mutable_new_instance() {
  _has_bits_[0] |= 0x00000001u;
  return new_instance_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MultiSplitRegion::release_new_instance() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MultiSplitRegion.new_instance)
  if (!_internal_has_new_instance()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return new_instance_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MultiSplitRegion::set_allocated_new_instance(std::string* new_instance) {
  if (new_instance != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  new_instance_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_instance,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MultiSplitRegion.new_instance)
}

// repeated string add_peer_instance = 3;
inline int MultiSplitRegion::_internal_add_peer_instance_size() const {
  return add_peer_instance_.size();
}
inline int MultiSplitRegion::add_peer_instance_size() const {
  return _internal_add_peer_instance_size();
}
inline void MultiSplitRegion::clear_add_peer_instance() {
  add_peer_instance_.Clear();
}
inline std::string* MultiSplitRegion::add_add_peer_instance() {
  std::string* _s = _internal_add_add_peer_instance();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.MultiSplitRegion.add_peer_instance)
  return _s;
}
inline const std::string& MultiSplitRegion::_internal_add_peer_instance(int index) const {
  return add_peer_instance_.Get(index);
}
inline const std::string& MultiSplitRegion::add_peer_instance(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MultiSplitRegion.add_peer_instance)
  return _internal_add_peer_instance(index);
}
inline std::string* MultiSplitRegion::mutable_add_peer_instance(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MultiSplitRegion.add_peer_instance)
  return add_peer_instance_.Mutable(index);
}
inline void MultiSplitRegion::set_add_peer_instance(int index, const std::string& value) {
  add_peer_instance_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.MultiSplitRegion.add_peer_instance)
}
inline void MultiSplitRegion::set_add_peer_instance(int index, std::string&& value) {
  add_peer_instance_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.MultiSplitRegion.add_peer_instance)
}
inline void MultiSplitRegion::set_add_peer_instance(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  add_peer_instance_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.MultiSplitRegion.add_peer_instance)
}
inline void MultiSplitRegion::set_add_peer_instance(int index, const char* value, size_t size) {
  add_peer_instance_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.MultiSplitRegion.add_peer_instance)
}
inline std::string* MultiSplitRegion::_internal_add_add_peer_instance() {
  return add_peer_instance_.Add();
}
inline void MultiSplitRegion::add_add_peer_instance(const std::string& value) {
  add_peer_instance_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.MultiSplitRegion.add_peer_instance)
}
inline void MultiSplitRegion::add_add_peer_instance(std::string&& value) {
  add_peer_instance_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.MultiSplitRegion.add_peer_instance)
}
inline void MultiSplitRegion::add_add_peer_instance(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  add_peer_instance_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.MultiSplitRegion.add_peer_instance)
}
inline void MultiSplitRegion::add_add_peer_instance(const char* value, size_t size) {
  add_peer_instance_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.MultiSplitRegion.add_peer_instance)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MultiSplitRegion::add_peer_instance() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.MultiSplitRegion.add_peer_instance)
  return add_peer_instance_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MultiSplitRegion::mutable_add_peer_instance() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.MultiSplitRegion.add_peer_instance)
  return &add_peer_instance_;
}

// -------------------------------------------------------------------

// RegionSplitResponse

// required int64 old_region_id = 1;
inline bool RegionSplitResponse::_internal_has_old_region_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionSplitResponse::has_old_region_id() const {
  return _internal_has_old_region_id();
}
inline void RegionSplitResponse::clear_old_region_id() {
  old_region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionSplitResponse::_internal_old_region_id() const {
  return old_region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionSplitResponse::old_region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionSplitResponse.old_region_id)
  return _internal_old_region_id();
}
inline void RegionSplitResponse::_internal_set_old_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  old_region_id_ = value;
}
inline void RegionSplitResponse::set_old_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_old_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionSplitResponse.old_region_id)
}

// optional int64 new_region_id = 2;
inline bool RegionSplitResponse::_internal_has_new_region_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegionSplitResponse::has_new_region_id() const {
  return _internal_has_new_region_id();
}
inline void RegionSplitResponse::clear_new_region_id() {
  new_region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionSplitResponse::_internal_new_region_id() const {
  return new_region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionSplitResponse::new_region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionSplitResponse.new_region_id)
  return _internal_new_region_id();
}
inline void RegionSplitResponse::_internal_set_new_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  new_region_id_ = value;
}
inline void RegionSplitResponse::set_new_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_new_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionSplitResponse.new_region_id)
}

// optional string new_instance = 3;
inline bool RegionSplitResponse::_internal_has_new_instance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegionSplitResponse::has_new_instance() const {
  return _internal_has_new_instance();
}
inline void RegionSplitResponse::clear_new_instance() {
  new_instance_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionSplitResponse::new_instance() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionSplitResponse.new_instance)
  return _internal_new_instance();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionSplitResponse::set_new_instance(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 new_instance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionSplitResponse.new_instance)
}
inline std::string* RegionSplitResponse::mutable_new_instance() {
  std::string* _s = _internal_mutable_new_instance();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionSplitResponse.new_instance)
  return _s;
}
inline const std::string& RegionSplitResponse::_internal_new_instance() const {
  return new_instance_.Get();
}
inline void RegionSplitResponse::_internal_set_new_instance(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  new_instance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionSplitResponse::_internal_mutable_new_instance() {
  _has_bits_[0] |= 0x00000001u;
  return new_instance_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionSplitResponse::release_new_instance() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionSplitResponse.new_instance)
  if (!_internal_has_new_instance()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return new_instance_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionSplitResponse::set_allocated_new_instance(std::string* new_instance) {
  if (new_instance != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  new_instance_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_instance,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionSplitResponse.new_instance)
}

// repeated string add_peer_instance = 4;
inline int RegionSplitResponse::_internal_add_peer_instance_size() const {
  return add_peer_instance_.size();
}
inline int RegionSplitResponse::add_peer_instance_size() const {
  return _internal_add_peer_instance_size();
}
inline void RegionSplitResponse::clear_add_peer_instance() {
  add_peer_instance_.Clear();
}
inline std::string* RegionSplitResponse::add_add_peer_instance() {
  std::string* _s = _internal_add_add_peer_instance();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.RegionSplitResponse.add_peer_instance)
  return _s;
}
inline const std::string& RegionSplitResponse::_internal_add_peer_instance(int index) const {
  return add_peer_instance_.Get(index);
}
inline const std::string& RegionSplitResponse::add_peer_instance(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionSplitResponse.add_peer_instance)
  return _internal_add_peer_instance(index);
}
inline std::string* RegionSplitResponse::mutable_add_peer_instance(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionSplitResponse.add_peer_instance)
  return add_peer_instance_.Mutable(index);
}
inline void RegionSplitResponse::set_add_peer_instance(int index, const std::string& value) {
  add_peer_instance_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionSplitResponse.add_peer_instance)
}
inline void RegionSplitResponse::set_add_peer_instance(int index, std::string&& value) {
  add_peer_instance_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionSplitResponse.add_peer_instance)
}
inline void RegionSplitResponse::set_add_peer_instance(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  add_peer_instance_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.RegionSplitResponse.add_peer_instance)
}
inline void RegionSplitResponse::set_add_peer_instance(int index, const char* value, size_t size) {
  add_peer_instance_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.RegionSplitResponse.add_peer_instance)
}
inline std::string* RegionSplitResponse::_internal_add_add_peer_instance() {
  return add_peer_instance_.Add();
}
inline void RegionSplitResponse::add_add_peer_instance(const std::string& value) {
  add_peer_instance_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionSplitResponse.add_peer_instance)
}
inline void RegionSplitResponse::add_add_peer_instance(std::string&& value) {
  add_peer_instance_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionSplitResponse.add_peer_instance)
}
inline void RegionSplitResponse::add_add_peer_instance(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  add_peer_instance_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.RegionSplitResponse.add_peer_instance)
}
inline void RegionSplitResponse::add_add_peer_instance(const char* value, size_t size) {
  add_peer_instance_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.RegionSplitResponse.add_peer_instance)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RegionSplitResponse::add_peer_instance() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RegionSplitResponse.add_peer_instance)
  return add_peer_instance_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RegionSplitResponse::mutable_add_peer_instance() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RegionSplitResponse.add_peer_instance)
  return &add_peer_instance_;
}

// repeated .baikaldb.pb.MultiSplitRegion multi_new_regions = 5;
inline int RegionSplitResponse::_internal_multi_new_regions_size() const {
  return multi_new_regions_.size();
}
inline int RegionSplitResponse::multi_new_regions_size() const {
  return _internal_multi_new_regions_size();
}
inline void RegionSplitResponse::clear_multi_new_regions() {
  multi_new_regions_.Clear();
}
inline ::baikaldb::pb::MultiSplitRegion* RegionSplitResponse::mutable_multi_new_regions(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionSplitResponse.multi_new_regions)
  return multi_new_regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::MultiSplitRegion >*
RegionSplitResponse::mutable_multi_new_regions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RegionSplitResponse.multi_new_regions)
  return &multi_new_regions_;
}
inline const ::baikaldb::pb::MultiSplitRegion& RegionSplitResponse::_internal_multi_new_regions(int index) const {
  return multi_new_regions_.Get(index);
}
inline const ::baikaldb::pb::MultiSplitRegion& RegionSplitResponse::multi_new_regions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionSplitResponse.multi_new_regions)
  return _internal_multi_new_regions(index);
}
inline ::baikaldb::pb::MultiSplitRegion* RegionSplitResponse::_internal_add_multi_new_regions() {
  return multi_new_regions_.Add();
}
inline ::baikaldb::pb::MultiSplitRegion* RegionSplitResponse::add_multi_new_regions() {
  ::baikaldb::pb::MultiSplitRegion* _add = _internal_add_multi_new_regions();
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionSplitResponse.multi_new_regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::MultiSplitRegion >&
RegionSplitResponse::multi_new_regions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RegionSplitResponse.multi_new_regions)
  return multi_new_regions_;
}

// -------------------------------------------------------------------

// AutoIncrementRequest

// required int64 table_id = 1;
inline bool AutoIncrementRequest::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AutoIncrementRequest::has_table_id() const {
  return _internal_has_table_id();
}
inline void AutoIncrementRequest::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AutoIncrementRequest::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AutoIncrementRequest::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AutoIncrementRequest.table_id)
  return _internal_table_id();
}
inline void AutoIncrementRequest::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  table_id_ = value;
}
inline void AutoIncrementRequest::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AutoIncrementRequest.table_id)
}

// optional uint64 count = 2;
inline bool AutoIncrementRequest::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AutoIncrementRequest::has_count() const {
  return _internal_has_count();
}
inline void AutoIncrementRequest::clear_count() {
  count_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AutoIncrementRequest::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AutoIncrementRequest::count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AutoIncrementRequest.count)
  return _internal_count();
}
inline void AutoIncrementRequest::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  count_ = value;
}
inline void AutoIncrementRequest::set_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AutoIncrementRequest.count)
}

// optional uint64 start_id = 3;
inline bool AutoIncrementRequest::_internal_has_start_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AutoIncrementRequest::has_start_id() const {
  return _internal_has_start_id();
}
inline void AutoIncrementRequest::clear_start_id() {
  start_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AutoIncrementRequest::_internal_start_id() const {
  return start_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AutoIncrementRequest::start_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AutoIncrementRequest.start_id)
  return _internal_start_id();
}
inline void AutoIncrementRequest::_internal_set_start_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  start_id_ = value;
}
inline void AutoIncrementRequest::set_start_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_start_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AutoIncrementRequest.start_id)
}

// optional uint64 increment_id = 4;
inline bool AutoIncrementRequest::_internal_has_increment_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AutoIncrementRequest::has_increment_id() const {
  return _internal_has_increment_id();
}
inline void AutoIncrementRequest::clear_increment_id() {
  increment_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AutoIncrementRequest::_internal_increment_id() const {
  return increment_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AutoIncrementRequest::increment_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AutoIncrementRequest.increment_id)
  return _internal_increment_id();
}
inline void AutoIncrementRequest::_internal_set_increment_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  increment_id_ = value;
}
inline void AutoIncrementRequest::set_increment_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_increment_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AutoIncrementRequest.increment_id)
}

// optional bool force = 5;
inline bool AutoIncrementRequest::_internal_has_force() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AutoIncrementRequest::has_force() const {
  return _internal_has_force();
}
inline void AutoIncrementRequest::clear_force() {
  force_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool AutoIncrementRequest::_internal_force() const {
  return force_;
}
inline bool AutoIncrementRequest::force() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AutoIncrementRequest.force)
  return _internal_force();
}
inline void AutoIncrementRequest::_internal_set_force(bool value) {
  _has_bits_[0] |= 0x00000010u;
  force_ = value;
}
inline void AutoIncrementRequest::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AutoIncrementRequest.force)
}

// -------------------------------------------------------------------

// RestoreRegionRequest

// optional int64 restore_region_id = 1;
inline bool RestoreRegionRequest::_internal_has_restore_region_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RestoreRegionRequest::has_restore_region_id() const {
  return _internal_has_restore_region_id();
}
inline void RestoreRegionRequest::clear_restore_region_id() {
  restore_region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RestoreRegionRequest::_internal_restore_region_id() const {
  return restore_region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RestoreRegionRequest::restore_region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RestoreRegionRequest.restore_region_id)
  return _internal_restore_region_id();
}
inline void RestoreRegionRequest::_internal_set_restore_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  restore_region_id_ = value;
}
inline void RestoreRegionRequest::set_restore_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_restore_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RestoreRegionRequest.restore_region_id)
}

// optional int64 lower_region_id = 2;
inline bool RestoreRegionRequest::_internal_has_lower_region_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RestoreRegionRequest::has_lower_region_id() const {
  return _internal_has_lower_region_id();
}
inline void RestoreRegionRequest::clear_lower_region_id() {
  lower_region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RestoreRegionRequest::_internal_lower_region_id() const {
  return lower_region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RestoreRegionRequest::lower_region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RestoreRegionRequest.lower_region_id)
  return _internal_lower_region_id();
}
inline void RestoreRegionRequest::_internal_set_lower_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  lower_region_id_ = value;
}
inline void RestoreRegionRequest::set_lower_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_lower_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RestoreRegionRequest.lower_region_id)
}

// optional int64 upper_region_id = 3;
inline bool RestoreRegionRequest::_internal_has_upper_region_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RestoreRegionRequest::has_upper_region_id() const {
  return _internal_has_upper_region_id();
}
inline void RestoreRegionRequest::clear_upper_region_id() {
  upper_region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RestoreRegionRequest::_internal_upper_region_id() const {
  return upper_region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RestoreRegionRequest::upper_region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RestoreRegionRequest.upper_region_id)
  return _internal_upper_region_id();
}
inline void RestoreRegionRequest::_internal_set_upper_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  upper_region_id_ = value;
}
inline void RestoreRegionRequest::set_upper_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_upper_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RestoreRegionRequest.upper_region_id)
}

// -------------------------------------------------------------------

// IndexDdlRequest

// optional int64 table_id = 1;
inline bool IndexDdlRequest::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IndexDdlRequest::has_table_id() const {
  return _internal_has_table_id();
}
inline void IndexDdlRequest::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexDdlRequest::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexDdlRequest::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexDdlRequest.table_id)
  return _internal_table_id();
}
inline void IndexDdlRequest::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  table_id_ = value;
}
inline void IndexDdlRequest::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexDdlRequest.table_id)
}

// optional int64 region_id = 2;
inline bool IndexDdlRequest::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool IndexDdlRequest::has_region_id() const {
  return _internal_has_region_id();
}
inline void IndexDdlRequest::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexDdlRequest::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 IndexDdlRequest::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexDdlRequest.region_id)
  return _internal_region_id();
}
inline void IndexDdlRequest::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  region_id_ = value;
}
inline void IndexDdlRequest::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexDdlRequest.region_id)
}

// repeated string add_keys = 3;
inline int IndexDdlRequest::_internal_add_keys_size() const {
  return add_keys_.size();
}
inline int IndexDdlRequest::add_keys_size() const {
  return _internal_add_keys_size();
}
inline void IndexDdlRequest::clear_add_keys() {
  add_keys_.Clear();
}
inline std::string* IndexDdlRequest::add_add_keys() {
  std::string* _s = _internal_add_add_keys();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.IndexDdlRequest.add_keys)
  return _s;
}
inline const std::string& IndexDdlRequest::_internal_add_keys(int index) const {
  return add_keys_.Get(index);
}
inline const std::string& IndexDdlRequest::add_keys(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexDdlRequest.add_keys)
  return _internal_add_keys(index);
}
inline std::string* IndexDdlRequest::mutable_add_keys(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.IndexDdlRequest.add_keys)
  return add_keys_.Mutable(index);
}
inline void IndexDdlRequest::set_add_keys(int index, const std::string& value) {
  add_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexDdlRequest.add_keys)
}
inline void IndexDdlRequest::set_add_keys(int index, std::string&& value) {
  add_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexDdlRequest.add_keys)
}
inline void IndexDdlRequest::set_add_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  add_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.IndexDdlRequest.add_keys)
}
inline void IndexDdlRequest::set_add_keys(int index, const char* value, size_t size) {
  add_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.IndexDdlRequest.add_keys)
}
inline std::string* IndexDdlRequest::_internal_add_add_keys() {
  return add_keys_.Add();
}
inline void IndexDdlRequest::add_add_keys(const std::string& value) {
  add_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.IndexDdlRequest.add_keys)
}
inline void IndexDdlRequest::add_add_keys(std::string&& value) {
  add_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.IndexDdlRequest.add_keys)
}
inline void IndexDdlRequest::add_add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  add_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.IndexDdlRequest.add_keys)
}
inline void IndexDdlRequest::add_add_keys(const char* value, size_t size) {
  add_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.IndexDdlRequest.add_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IndexDdlRequest::add_keys() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.IndexDdlRequest.add_keys)
  return add_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IndexDdlRequest::mutable_add_keys() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.IndexDdlRequest.add_keys)
  return &add_keys_;
}

// repeated string add_vals = 4;
inline int IndexDdlRequest::_internal_add_vals_size() const {
  return add_vals_.size();
}
inline int IndexDdlRequest::add_vals_size() const {
  return _internal_add_vals_size();
}
inline void IndexDdlRequest::clear_add_vals() {
  add_vals_.Clear();
}
inline std::string* IndexDdlRequest::add_add_vals() {
  std::string* _s = _internal_add_add_vals();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.IndexDdlRequest.add_vals)
  return _s;
}
inline const std::string& IndexDdlRequest::_internal_add_vals(int index) const {
  return add_vals_.Get(index);
}
inline const std::string& IndexDdlRequest::add_vals(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexDdlRequest.add_vals)
  return _internal_add_vals(index);
}
inline std::string* IndexDdlRequest::mutable_add_vals(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.IndexDdlRequest.add_vals)
  return add_vals_.Mutable(index);
}
inline void IndexDdlRequest::set_add_vals(int index, const std::string& value) {
  add_vals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexDdlRequest.add_vals)
}
inline void IndexDdlRequest::set_add_vals(int index, std::string&& value) {
  add_vals_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.IndexDdlRequest.add_vals)
}
inline void IndexDdlRequest::set_add_vals(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  add_vals_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.IndexDdlRequest.add_vals)
}
inline void IndexDdlRequest::set_add_vals(int index, const char* value, size_t size) {
  add_vals_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.IndexDdlRequest.add_vals)
}
inline std::string* IndexDdlRequest::_internal_add_add_vals() {
  return add_vals_.Add();
}
inline void IndexDdlRequest::add_add_vals(const std::string& value) {
  add_vals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.IndexDdlRequest.add_vals)
}
inline void IndexDdlRequest::add_add_vals(std::string&& value) {
  add_vals_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.IndexDdlRequest.add_vals)
}
inline void IndexDdlRequest::add_add_vals(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  add_vals_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.IndexDdlRequest.add_vals)
}
inline void IndexDdlRequest::add_add_vals(const char* value, size_t size) {
  add_vals_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.IndexDdlRequest.add_vals)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
IndexDdlRequest::add_vals() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.IndexDdlRequest.add_vals)
  return add_vals_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
IndexDdlRequest::mutable_add_vals() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.IndexDdlRequest.add_vals)
  return &add_vals_;
}

// optional .baikaldb.pb.RegionDdlWork region_ddl_work = 5;
inline bool IndexDdlRequest::_internal_has_region_ddl_work() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || region_ddl_work_ != nullptr);
  return value;
}
inline bool IndexDdlRequest::has_region_ddl_work() const {
  return _internal_has_region_ddl_work();
}
inline void IndexDdlRequest::clear_region_ddl_work() {
  if (region_ddl_work_ != nullptr) region_ddl_work_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::RegionDdlWork& IndexDdlRequest::_internal_region_ddl_work() const {
  const ::baikaldb::pb::RegionDdlWork* p = region_ddl_work_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionDdlWork&>(
      ::baikaldb::pb::_RegionDdlWork_default_instance_);
}
inline const ::baikaldb::pb::RegionDdlWork& IndexDdlRequest::region_ddl_work() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IndexDdlRequest.region_ddl_work)
  return _internal_region_ddl_work();
}
inline void IndexDdlRequest::unsafe_arena_set_allocated_region_ddl_work(
    ::baikaldb::pb::RegionDdlWork* region_ddl_work) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_ddl_work_);
  }
  region_ddl_work_ = region_ddl_work;
  if (region_ddl_work) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.IndexDdlRequest.region_ddl_work)
}
inline ::baikaldb::pb::RegionDdlWork* IndexDdlRequest::release_region_ddl_work() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::RegionDdlWork* temp = region_ddl_work_;
  region_ddl_work_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionDdlWork* IndexDdlRequest::unsafe_arena_release_region_ddl_work() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.IndexDdlRequest.region_ddl_work)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::RegionDdlWork* temp = region_ddl_work_;
  region_ddl_work_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionDdlWork* IndexDdlRequest::_internal_mutable_region_ddl_work() {
  _has_bits_[0] |= 0x00000001u;
  if (region_ddl_work_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionDdlWork>(GetArenaForAllocation());
    region_ddl_work_ = p;
  }
  return region_ddl_work_;
}
inline ::baikaldb::pb::RegionDdlWork* IndexDdlRequest::mutable_region_ddl_work() {
  ::baikaldb::pb::RegionDdlWork* _msg = _internal_mutable_region_ddl_work();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.IndexDdlRequest.region_ddl_work)
  return _msg;
}
inline void IndexDdlRequest::set_allocated_region_ddl_work(::baikaldb::pb::RegionDdlWork* region_ddl_work) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete region_ddl_work_;
  }
  if (region_ddl_work) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::RegionDdlWork>::GetOwningArena(region_ddl_work);
    if (message_arena != submessage_arena) {
      region_ddl_work = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_ddl_work, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_ddl_work_ = region_ddl_work;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.IndexDdlRequest.region_ddl_work)
}

// -------------------------------------------------------------------

// ParamDesc

// optional string key = 1;
inline bool ParamDesc::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ParamDesc::has_key() const {
  return _internal_has_key();
}
inline void ParamDesc::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ParamDesc::key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ParamDesc.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParamDesc::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ParamDesc.key)
}
inline std::string* ParamDesc::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ParamDesc.key)
  return _s;
}
inline const std::string& ParamDesc::_internal_key() const {
  return key_.Get();
}
inline void ParamDesc::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ParamDesc::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ParamDesc::release_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ParamDesc.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ParamDesc::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ParamDesc.key)
}

// optional string value = 2;
inline bool ParamDesc::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ParamDesc::has_value() const {
  return _internal_has_value();
}
inline void ParamDesc::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ParamDesc::value() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ParamDesc.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParamDesc::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ParamDesc.value)
}
inline std::string* ParamDesc::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ParamDesc.value)
  return _s;
}
inline const std::string& ParamDesc::_internal_value() const {
  return value_.Get();
}
inline void ParamDesc::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ParamDesc::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ParamDesc::release_value() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ParamDesc.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ParamDesc::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ParamDesc.value)
}

// optional bool is_meta_param = 3;
inline bool ParamDesc::_internal_has_is_meta_param() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ParamDesc::has_is_meta_param() const {
  return _internal_has_is_meta_param();
}
inline void ParamDesc::clear_is_meta_param() {
  is_meta_param_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ParamDesc::_internal_is_meta_param() const {
  return is_meta_param_;
}
inline bool ParamDesc::is_meta_param() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ParamDesc.is_meta_param)
  return _internal_is_meta_param();
}
inline void ParamDesc::_internal_set_is_meta_param(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_meta_param_ = value;
}
inline void ParamDesc::set_is_meta_param(bool value) {
  _internal_set_is_meta_param(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ParamDesc.is_meta_param)
}

// optional bool need_delete = 4;
inline bool ParamDesc::_internal_has_need_delete() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ParamDesc::has_need_delete() const {
  return _internal_has_need_delete();
}
inline void ParamDesc::clear_need_delete() {
  need_delete_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ParamDesc::_internal_need_delete() const {
  return need_delete_;
}
inline bool ParamDesc::need_delete() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ParamDesc.need_delete)
  return _internal_need_delete();
}
inline void ParamDesc::_internal_set_need_delete(bool value) {
  _has_bits_[0] |= 0x00000008u;
  need_delete_ = value;
}
inline void ParamDesc::set_need_delete(bool value) {
  _internal_set_need_delete(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ParamDesc.need_delete)
}

// -------------------------------------------------------------------

// InstanceParam

// optional string resource_tag_or_address = 1;
inline bool InstanceParam::_internal_has_resource_tag_or_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InstanceParam::has_resource_tag_or_address() const {
  return _internal_has_resource_tag_or_address();
}
inline void InstanceParam::clear_resource_tag_or_address() {
  resource_tag_or_address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InstanceParam::resource_tag_or_address() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceParam.resource_tag_or_address)
  return _internal_resource_tag_or_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstanceParam::set_resource_tag_or_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 resource_tag_or_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.InstanceParam.resource_tag_or_address)
}
inline std::string* InstanceParam::mutable_resource_tag_or_address() {
  std::string* _s = _internal_mutable_resource_tag_or_address();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.InstanceParam.resource_tag_or_address)
  return _s;
}
inline const std::string& InstanceParam::_internal_resource_tag_or_address() const {
  return resource_tag_or_address_.Get();
}
inline void InstanceParam::_internal_set_resource_tag_or_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  resource_tag_or_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InstanceParam::_internal_mutable_resource_tag_or_address() {
  _has_bits_[0] |= 0x00000001u;
  return resource_tag_or_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InstanceParam::release_resource_tag_or_address() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.InstanceParam.resource_tag_or_address)
  if (!_internal_has_resource_tag_or_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return resource_tag_or_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InstanceParam::set_allocated_resource_tag_or_address(std::string* resource_tag_or_address) {
  if (resource_tag_or_address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  resource_tag_or_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag_or_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.InstanceParam.resource_tag_or_address)
}

// repeated .baikaldb.pb.ParamDesc params = 2;
inline int InstanceParam::_internal_params_size() const {
  return params_.size();
}
inline int InstanceParam::params_size() const {
  return _internal_params_size();
}
inline void InstanceParam::clear_params() {
  params_.Clear();
}
inline ::baikaldb::pb::ParamDesc* InstanceParam::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.InstanceParam.params)
  return params_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ParamDesc >*
InstanceParam::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.InstanceParam.params)
  return &params_;
}
inline const ::baikaldb::pb::ParamDesc& InstanceParam::_internal_params(int index) const {
  return params_.Get(index);
}
inline const ::baikaldb::pb::ParamDesc& InstanceParam::params(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.InstanceParam.params)
  return _internal_params(index);
}
inline ::baikaldb::pb::ParamDesc* InstanceParam::_internal_add_params() {
  return params_.Add();
}
inline ::baikaldb::pb::ParamDesc* InstanceParam::add_params() {
  ::baikaldb::pb::ParamDesc* _add = _internal_add_params();
  // @@protoc_insertion_point(field_add:baikaldb.pb.InstanceParam.params)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ParamDesc >&
InstanceParam::params() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.InstanceParam.params)
  return params_;
}

// -------------------------------------------------------------------

// VirtualIndexInfluence

// optional int64 virtual_index_id = 1;
inline bool VirtualIndexInfluence::_internal_has_virtual_index_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VirtualIndexInfluence::has_virtual_index_id() const {
  return _internal_has_virtual_index_id();
}
inline void VirtualIndexInfluence::clear_virtual_index_id() {
  virtual_index_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VirtualIndexInfluence::_internal_virtual_index_id() const {
  return virtual_index_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VirtualIndexInfluence::virtual_index_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.VirtualIndexInfluence.virtual_index_id)
  return _internal_virtual_index_id();
}
inline void VirtualIndexInfluence::_internal_set_virtual_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  virtual_index_id_ = value;
}
inline void VirtualIndexInfluence::set_virtual_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_virtual_index_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.VirtualIndexInfluence.virtual_index_id)
}

// optional string virtual_index_name = 2;
inline bool VirtualIndexInfluence::_internal_has_virtual_index_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VirtualIndexInfluence::has_virtual_index_name() const {
  return _internal_has_virtual_index_name();
}
inline void VirtualIndexInfluence::clear_virtual_index_name() {
  virtual_index_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VirtualIndexInfluence::virtual_index_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.VirtualIndexInfluence.virtual_index_name)
  return _internal_virtual_index_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VirtualIndexInfluence::set_virtual_index_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 virtual_index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.VirtualIndexInfluence.virtual_index_name)
}
inline std::string* VirtualIndexInfluence::mutable_virtual_index_name() {
  std::string* _s = _internal_mutable_virtual_index_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.VirtualIndexInfluence.virtual_index_name)
  return _s;
}
inline const std::string& VirtualIndexInfluence::_internal_virtual_index_name() const {
  return virtual_index_name_.Get();
}
inline void VirtualIndexInfluence::_internal_set_virtual_index_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  virtual_index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VirtualIndexInfluence::_internal_mutable_virtual_index_name() {
  _has_bits_[0] |= 0x00000001u;
  return virtual_index_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VirtualIndexInfluence::release_virtual_index_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.VirtualIndexInfluence.virtual_index_name)
  if (!_internal_has_virtual_index_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return virtual_index_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VirtualIndexInfluence::set_allocated_virtual_index_name(std::string* virtual_index_name) {
  if (virtual_index_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  virtual_index_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), virtual_index_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.VirtualIndexInfluence.virtual_index_name)
}

// optional string influenced_sql = 3;
inline bool VirtualIndexInfluence::_internal_has_influenced_sql() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VirtualIndexInfluence::has_influenced_sql() const {
  return _internal_has_influenced_sql();
}
inline void VirtualIndexInfluence::clear_influenced_sql() {
  influenced_sql_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VirtualIndexInfluence::influenced_sql() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.VirtualIndexInfluence.influenced_sql)
  return _internal_influenced_sql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VirtualIndexInfluence::set_influenced_sql(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 influenced_sql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.VirtualIndexInfluence.influenced_sql)
}
inline std::string* VirtualIndexInfluence::mutable_influenced_sql() {
  std::string* _s = _internal_mutable_influenced_sql();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.VirtualIndexInfluence.influenced_sql)
  return _s;
}
inline const std::string& VirtualIndexInfluence::_internal_influenced_sql() const {
  return influenced_sql_.Get();
}
inline void VirtualIndexInfluence::_internal_set_influenced_sql(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  influenced_sql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VirtualIndexInfluence::_internal_mutable_influenced_sql() {
  _has_bits_[0] |= 0x00000002u;
  return influenced_sql_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VirtualIndexInfluence::release_influenced_sql() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.VirtualIndexInfluence.influenced_sql)
  if (!_internal_has_influenced_sql()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return influenced_sql_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VirtualIndexInfluence::set_allocated_influenced_sql(std::string* influenced_sql) {
  if (influenced_sql != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  influenced_sql_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), influenced_sql,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.VirtualIndexInfluence.influenced_sql)
}

// -------------------------------------------------------------------

// MetaManagerRequest

// required .baikaldb.pb.OpType op_type = 1;
inline bool MetaManagerRequest::_internal_has_op_type() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool MetaManagerRequest::has_op_type() const {
  return _internal_has_op_type();
}
inline void MetaManagerRequest::clear_op_type() {
  op_type_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::baikaldb::pb::OpType MetaManagerRequest::_internal_op_type() const {
  return static_cast< ::baikaldb::pb::OpType >(op_type_);
}
inline ::baikaldb::pb::OpType MetaManagerRequest::op_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.op_type)
  return _internal_op_type();
}
inline void MetaManagerRequest::_internal_set_op_type(::baikaldb::pb::OpType value) {
  assert(::baikaldb::pb::OpType_IsValid(value));
  _has_bits_[0] |= 0x00040000u;
  op_type_ = value;
}
inline void MetaManagerRequest::set_op_type(::baikaldb::pb::OpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.MetaManagerRequest.op_type)
}

// optional .baikaldb.pb.SchemaInfo table_info = 2;
inline bool MetaManagerRequest::_internal_has_table_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || table_info_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_table_info() const {
  return _internal_has_table_info();
}
inline void MetaManagerRequest::clear_table_info() {
  if (table_info_ != nullptr) table_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::SchemaInfo& MetaManagerRequest::_internal_table_info() const {
  const ::baikaldb::pb::SchemaInfo* p = table_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::SchemaInfo&>(
      ::baikaldb::pb::_SchemaInfo_default_instance_);
}
inline const ::baikaldb::pb::SchemaInfo& MetaManagerRequest::table_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.table_info)
  return _internal_table_info();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_table_info(
    ::baikaldb::pb::SchemaInfo* table_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_info_);
  }
  table_info_ = table_info;
  if (table_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.table_info)
}
inline ::baikaldb::pb::SchemaInfo* MetaManagerRequest::release_table_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::SchemaInfo* temp = table_info_;
  table_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::SchemaInfo* MetaManagerRequest::unsafe_arena_release_table_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.table_info)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::SchemaInfo* temp = table_info_;
  table_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::SchemaInfo* MetaManagerRequest::_internal_mutable_table_info() {
  _has_bits_[0] |= 0x00000001u;
  if (table_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::SchemaInfo>(GetArenaForAllocation());
    table_info_ = p;
  }
  return table_info_;
}
inline ::baikaldb::pb::SchemaInfo* MetaManagerRequest::mutable_table_info() {
  ::baikaldb::pb::SchemaInfo* _msg = _internal_mutable_table_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.table_info)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_table_info(::baikaldb::pb::SchemaInfo* table_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete table_info_;
  }
  if (table_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::SchemaInfo>::GetOwningArena(table_info);
    if (message_arena != submessage_arena) {
      table_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_info_ = table_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.table_info)
}

// optional .baikaldb.pb.NameSpaceInfo namespace_info = 3;
inline bool MetaManagerRequest::_internal_has_namespace_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || namespace_info_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_namespace_info() const {
  return _internal_has_namespace_info();
}
inline void MetaManagerRequest::clear_namespace_info() {
  if (namespace_info_ != nullptr) namespace_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::baikaldb::pb::NameSpaceInfo& MetaManagerRequest::_internal_namespace_info() const {
  const ::baikaldb::pb::NameSpaceInfo* p = namespace_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::NameSpaceInfo&>(
      ::baikaldb::pb::_NameSpaceInfo_default_instance_);
}
inline const ::baikaldb::pb::NameSpaceInfo& MetaManagerRequest::namespace_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.namespace_info)
  return _internal_namespace_info();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_namespace_info(
    ::baikaldb::pb::NameSpaceInfo* namespace_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_info_);
  }
  namespace_info_ = namespace_info;
  if (namespace_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.namespace_info)
}
inline ::baikaldb::pb::NameSpaceInfo* MetaManagerRequest::release_namespace_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::NameSpaceInfo* temp = namespace_info_;
  namespace_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::NameSpaceInfo* MetaManagerRequest::unsafe_arena_release_namespace_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.namespace_info)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::NameSpaceInfo* temp = namespace_info_;
  namespace_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::NameSpaceInfo* MetaManagerRequest::_internal_mutable_namespace_info() {
  _has_bits_[0] |= 0x00000002u;
  if (namespace_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::NameSpaceInfo>(GetArenaForAllocation());
    namespace_info_ = p;
  }
  return namespace_info_;
}
inline ::baikaldb::pb::NameSpaceInfo* MetaManagerRequest::mutable_namespace_info() {
  ::baikaldb::pb::NameSpaceInfo* _msg = _internal_mutable_namespace_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.namespace_info)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_namespace_info(::baikaldb::pb::NameSpaceInfo* namespace_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete namespace_info_;
  }
  if (namespace_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::NameSpaceInfo>::GetOwningArena(namespace_info);
    if (message_arena != submessage_arena) {
      namespace_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  namespace_info_ = namespace_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.namespace_info)
}

// optional .baikaldb.pb.DataBaseInfo database_info = 4;
inline bool MetaManagerRequest::_internal_has_database_info() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || database_info_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_database_info() const {
  return _internal_has_database_info();
}
inline void MetaManagerRequest::clear_database_info() {
  if (database_info_ != nullptr) database_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::baikaldb::pb::DataBaseInfo& MetaManagerRequest::_internal_database_info() const {
  const ::baikaldb::pb::DataBaseInfo* p = database_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::DataBaseInfo&>(
      ::baikaldb::pb::_DataBaseInfo_default_instance_);
}
inline const ::baikaldb::pb::DataBaseInfo& MetaManagerRequest::database_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.database_info)
  return _internal_database_info();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_database_info(
    ::baikaldb::pb::DataBaseInfo* database_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(database_info_);
  }
  database_info_ = database_info;
  if (database_info) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.database_info)
}
inline ::baikaldb::pb::DataBaseInfo* MetaManagerRequest::release_database_info() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::DataBaseInfo* temp = database_info_;
  database_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::DataBaseInfo* MetaManagerRequest::unsafe_arena_release_database_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.database_info)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::DataBaseInfo* temp = database_info_;
  database_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::DataBaseInfo* MetaManagerRequest::_internal_mutable_database_info() {
  _has_bits_[0] |= 0x00000004u;
  if (database_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::DataBaseInfo>(GetArenaForAllocation());
    database_info_ = p;
  }
  return database_info_;
}
inline ::baikaldb::pb::DataBaseInfo* MetaManagerRequest::mutable_database_info() {
  ::baikaldb::pb::DataBaseInfo* _msg = _internal_mutable_database_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.database_info)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_database_info(::baikaldb::pb::DataBaseInfo* database_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete database_info_;
  }
  if (database_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::DataBaseInfo>::GetOwningArena(database_info);
    if (message_arena != submessage_arena) {
      database_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, database_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  database_info_ = database_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.database_info)
}

// optional .baikaldb.pb.UserPrivilege user_privilege = 5;
inline bool MetaManagerRequest::_internal_has_user_privilege() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || user_privilege_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_user_privilege() const {
  return _internal_has_user_privilege();
}
inline void MetaManagerRequest::clear_user_privilege() {
  if (user_privilege_ != nullptr) user_privilege_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::baikaldb::pb::UserPrivilege& MetaManagerRequest::_internal_user_privilege() const {
  const ::baikaldb::pb::UserPrivilege* p = user_privilege_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::UserPrivilege&>(
      ::baikaldb::pb::_UserPrivilege_default_instance_);
}
inline const ::baikaldb::pb::UserPrivilege& MetaManagerRequest::user_privilege() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.user_privilege)
  return _internal_user_privilege();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_user_privilege(
    ::baikaldb::pb::UserPrivilege* user_privilege) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_privilege_);
  }
  user_privilege_ = user_privilege;
  if (user_privilege) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.user_privilege)
}
inline ::baikaldb::pb::UserPrivilege* MetaManagerRequest::release_user_privilege() {
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::UserPrivilege* temp = user_privilege_;
  user_privilege_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::UserPrivilege* MetaManagerRequest::unsafe_arena_release_user_privilege() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.user_privilege)
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::UserPrivilege* temp = user_privilege_;
  user_privilege_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::UserPrivilege* MetaManagerRequest::_internal_mutable_user_privilege() {
  _has_bits_[0] |= 0x00000008u;
  if (user_privilege_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::UserPrivilege>(GetArenaForAllocation());
    user_privilege_ = p;
  }
  return user_privilege_;
}
inline ::baikaldb::pb::UserPrivilege* MetaManagerRequest::mutable_user_privilege() {
  ::baikaldb::pb::UserPrivilege* _msg = _internal_mutable_user_privilege();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.user_privilege)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_user_privilege(::baikaldb::pb::UserPrivilege* user_privilege) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_privilege_;
  }
  if (user_privilege) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::UserPrivilege>::GetOwningArena(user_privilege);
    if (message_arena != submessage_arena) {
      user_privilege = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_privilege, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  user_privilege_ = user_privilege;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.user_privilege)
}

// optional .baikaldb.pb.AlterTableRequest alter_table = 6;
inline bool MetaManagerRequest::_internal_has_alter_table() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || alter_table_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_alter_table() const {
  return _internal_has_alter_table();
}
inline void MetaManagerRequest::clear_alter_table() {
  if (alter_table_ != nullptr) alter_table_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::baikaldb::pb::AlterTableRequest& MetaManagerRequest::_internal_alter_table() const {
  const ::baikaldb::pb::AlterTableRequest* p = alter_table_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::AlterTableRequest&>(
      ::baikaldb::pb::_AlterTableRequest_default_instance_);
}
inline const ::baikaldb::pb::AlterTableRequest& MetaManagerRequest::alter_table() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.alter_table)
  return _internal_alter_table();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_alter_table(
    ::baikaldb::pb::AlterTableRequest* alter_table) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alter_table_);
  }
  alter_table_ = alter_table;
  if (alter_table) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.alter_table)
}
inline ::baikaldb::pb::AlterTableRequest* MetaManagerRequest::release_alter_table() {
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::AlterTableRequest* temp = alter_table_;
  alter_table_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::AlterTableRequest* MetaManagerRequest::unsafe_arena_release_alter_table() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.alter_table)
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::AlterTableRequest* temp = alter_table_;
  alter_table_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::AlterTableRequest* MetaManagerRequest::_internal_mutable_alter_table() {
  _has_bits_[0] |= 0x00000010u;
  if (alter_table_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::AlterTableRequest>(GetArenaForAllocation());
    alter_table_ = p;
  }
  return alter_table_;
}
inline ::baikaldb::pb::AlterTableRequest* MetaManagerRequest::mutable_alter_table() {
  ::baikaldb::pb::AlterTableRequest* _msg = _internal_mutable_alter_table();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.alter_table)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_alter_table(::baikaldb::pb::AlterTableRequest* alter_table) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete alter_table_;
  }
  if (alter_table) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::AlterTableRequest>::GetOwningArena(alter_table);
    if (message_arena != submessage_arena) {
      alter_table = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alter_table, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  alter_table_ = alter_table;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.alter_table)
}

// optional .baikaldb.pb.LogicalRoom logical_rooms = 7;
inline bool MetaManagerRequest::_internal_has_logical_rooms() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || logical_rooms_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_logical_rooms() const {
  return _internal_has_logical_rooms();
}
inline void MetaManagerRequest::clear_logical_rooms() {
  if (logical_rooms_ != nullptr) logical_rooms_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::baikaldb::pb::LogicalRoom& MetaManagerRequest::_internal_logical_rooms() const {
  const ::baikaldb::pb::LogicalRoom* p = logical_rooms_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::LogicalRoom&>(
      ::baikaldb::pb::_LogicalRoom_default_instance_);
}
inline const ::baikaldb::pb::LogicalRoom& MetaManagerRequest::logical_rooms() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.logical_rooms)
  return _internal_logical_rooms();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_logical_rooms(
    ::baikaldb::pb::LogicalRoom* logical_rooms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logical_rooms_);
  }
  logical_rooms_ = logical_rooms;
  if (logical_rooms) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.logical_rooms)
}
inline ::baikaldb::pb::LogicalRoom* MetaManagerRequest::release_logical_rooms() {
  _has_bits_[0] &= ~0x00000020u;
  ::baikaldb::pb::LogicalRoom* temp = logical_rooms_;
  logical_rooms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::LogicalRoom* MetaManagerRequest::unsafe_arena_release_logical_rooms() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.logical_rooms)
  _has_bits_[0] &= ~0x00000020u;
  ::baikaldb::pb::LogicalRoom* temp = logical_rooms_;
  logical_rooms_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::LogicalRoom* MetaManagerRequest::_internal_mutable_logical_rooms() {
  _has_bits_[0] |= 0x00000020u;
  if (logical_rooms_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::LogicalRoom>(GetArenaForAllocation());
    logical_rooms_ = p;
  }
  return logical_rooms_;
}
inline ::baikaldb::pb::LogicalRoom* MetaManagerRequest::mutable_logical_rooms() {
  ::baikaldb::pb::LogicalRoom* _msg = _internal_mutable_logical_rooms();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.logical_rooms)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_logical_rooms(::baikaldb::pb::LogicalRoom* logical_rooms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete logical_rooms_;
  }
  if (logical_rooms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::LogicalRoom>::GetOwningArena(logical_rooms);
    if (message_arena != submessage_arena) {
      logical_rooms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logical_rooms, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  logical_rooms_ = logical_rooms;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.logical_rooms)
}

// optional .baikaldb.pb.PhysicalRoom physical_rooms = 8;
inline bool MetaManagerRequest::_internal_has_physical_rooms() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || physical_rooms_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_physical_rooms() const {
  return _internal_has_physical_rooms();
}
inline void MetaManagerRequest::clear_physical_rooms() {
  if (physical_rooms_ != nullptr) physical_rooms_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::baikaldb::pb::PhysicalRoom& MetaManagerRequest::_internal_physical_rooms() const {
  const ::baikaldb::pb::PhysicalRoom* p = physical_rooms_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::PhysicalRoom&>(
      ::baikaldb::pb::_PhysicalRoom_default_instance_);
}
inline const ::baikaldb::pb::PhysicalRoom& MetaManagerRequest::physical_rooms() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.physical_rooms)
  return _internal_physical_rooms();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_physical_rooms(
    ::baikaldb::pb::PhysicalRoom* physical_rooms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(physical_rooms_);
  }
  physical_rooms_ = physical_rooms;
  if (physical_rooms) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.physical_rooms)
}
inline ::baikaldb::pb::PhysicalRoom* MetaManagerRequest::release_physical_rooms() {
  _has_bits_[0] &= ~0x00000040u;
  ::baikaldb::pb::PhysicalRoom* temp = physical_rooms_;
  physical_rooms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::PhysicalRoom* MetaManagerRequest::unsafe_arena_release_physical_rooms() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.physical_rooms)
  _has_bits_[0] &= ~0x00000040u;
  ::baikaldb::pb::PhysicalRoom* temp = physical_rooms_;
  physical_rooms_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::PhysicalRoom* MetaManagerRequest::_internal_mutable_physical_rooms() {
  _has_bits_[0] |= 0x00000040u;
  if (physical_rooms_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::PhysicalRoom>(GetArenaForAllocation());
    physical_rooms_ = p;
  }
  return physical_rooms_;
}
inline ::baikaldb::pb::PhysicalRoom* MetaManagerRequest::mutable_physical_rooms() {
  ::baikaldb::pb::PhysicalRoom* _msg = _internal_mutable_physical_rooms();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.physical_rooms)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_physical_rooms(::baikaldb::pb::PhysicalRoom* physical_rooms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete physical_rooms_;
  }
  if (physical_rooms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::PhysicalRoom>::GetOwningArena(physical_rooms);
    if (message_arena != submessage_arena) {
      physical_rooms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, physical_rooms, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  physical_rooms_ = physical_rooms;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.physical_rooms)
}

// optional .baikaldb.pb.InstanceInfo instance = 9;
inline bool MetaManagerRequest::_internal_has_instance() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || instance_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_instance() const {
  return _internal_has_instance();
}
inline void MetaManagerRequest::clear_instance() {
  if (instance_ != nullptr) instance_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::baikaldb::pb::InstanceInfo& MetaManagerRequest::_internal_instance() const {
  const ::baikaldb::pb::InstanceInfo* p = instance_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::InstanceInfo&>(
      ::baikaldb::pb::_InstanceInfo_default_instance_);
}
inline const ::baikaldb::pb::InstanceInfo& MetaManagerRequest::instance() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.instance)
  return _internal_instance();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_instance(
    ::baikaldb::pb::InstanceInfo* instance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(instance_);
  }
  instance_ = instance;
  if (instance) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.instance)
}
inline ::baikaldb::pb::InstanceInfo* MetaManagerRequest::release_instance() {
  _has_bits_[0] &= ~0x00000080u;
  ::baikaldb::pb::InstanceInfo* temp = instance_;
  instance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::InstanceInfo* MetaManagerRequest::unsafe_arena_release_instance() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.instance)
  _has_bits_[0] &= ~0x00000080u;
  ::baikaldb::pb::InstanceInfo* temp = instance_;
  instance_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::InstanceInfo* MetaManagerRequest::_internal_mutable_instance() {
  _has_bits_[0] |= 0x00000080u;
  if (instance_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::InstanceInfo>(GetArenaForAllocation());
    instance_ = p;
  }
  return instance_;
}
inline ::baikaldb::pb::InstanceInfo* MetaManagerRequest::mutable_instance() {
  ::baikaldb::pb::InstanceInfo* _msg = _internal_mutable_instance();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.instance)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_instance(::baikaldb::pb::InstanceInfo* instance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete instance_;
  }
  if (instance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::InstanceInfo>::GetOwningArena(instance);
    if (message_arena != submessage_arena) {
      instance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instance, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  instance_ = instance;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.instance)
}

// optional .baikaldb.pb.MovePhysicalRequest move_physical_request = 10;
inline bool MetaManagerRequest::_internal_has_move_physical_request() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || move_physical_request_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_move_physical_request() const {
  return _internal_has_move_physical_request();
}
inline void MetaManagerRequest::clear_move_physical_request() {
  if (move_physical_request_ != nullptr) move_physical_request_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::baikaldb::pb::MovePhysicalRequest& MetaManagerRequest::_internal_move_physical_request() const {
  const ::baikaldb::pb::MovePhysicalRequest* p = move_physical_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::MovePhysicalRequest&>(
      ::baikaldb::pb::_MovePhysicalRequest_default_instance_);
}
inline const ::baikaldb::pb::MovePhysicalRequest& MetaManagerRequest::move_physical_request() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.move_physical_request)
  return _internal_move_physical_request();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_move_physical_request(
    ::baikaldb::pb::MovePhysicalRequest* move_physical_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(move_physical_request_);
  }
  move_physical_request_ = move_physical_request;
  if (move_physical_request) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.move_physical_request)
}
inline ::baikaldb::pb::MovePhysicalRequest* MetaManagerRequest::release_move_physical_request() {
  _has_bits_[0] &= ~0x00000100u;
  ::baikaldb::pb::MovePhysicalRequest* temp = move_physical_request_;
  move_physical_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::MovePhysicalRequest* MetaManagerRequest::unsafe_arena_release_move_physical_request() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.move_physical_request)
  _has_bits_[0] &= ~0x00000100u;
  ::baikaldb::pb::MovePhysicalRequest* temp = move_physical_request_;
  move_physical_request_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::MovePhysicalRequest* MetaManagerRequest::_internal_mutable_move_physical_request() {
  _has_bits_[0] |= 0x00000100u;
  if (move_physical_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::MovePhysicalRequest>(GetArenaForAllocation());
    move_physical_request_ = p;
  }
  return move_physical_request_;
}
inline ::baikaldb::pb::MovePhysicalRequest* MetaManagerRequest::mutable_move_physical_request() {
  ::baikaldb::pb::MovePhysicalRequest* _msg = _internal_mutable_move_physical_request();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.move_physical_request)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_move_physical_request(::baikaldb::pb::MovePhysicalRequest* move_physical_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete move_physical_request_;
  }
  if (move_physical_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::MovePhysicalRequest>::GetOwningArena(move_physical_request);
    if (message_arena != submessage_arena) {
      move_physical_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, move_physical_request, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  move_physical_request_ = move_physical_request;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.move_physical_request)
}

// optional .baikaldb.pb.RegionInfo region_info = 11;
inline bool MetaManagerRequest::_internal_has_region_info() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || region_info_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_region_info() const {
  return _internal_has_region_info();
}
inline void MetaManagerRequest::clear_region_info() {
  if (region_info_ != nullptr) region_info_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::baikaldb::pb::RegionInfo& MetaManagerRequest::_internal_region_info() const {
  const ::baikaldb::pb::RegionInfo* p = region_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionInfo&>(
      ::baikaldb::pb::_RegionInfo_default_instance_);
}
inline const ::baikaldb::pb::RegionInfo& MetaManagerRequest::region_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.region_info)
  return _internal_region_info();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_region_info(
    ::baikaldb::pb::RegionInfo* region_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_info_);
  }
  region_info_ = region_info;
  if (region_info) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.region_info)
}
inline ::baikaldb::pb::RegionInfo* MetaManagerRequest::release_region_info() {
  _has_bits_[0] &= ~0x00000200u;
  ::baikaldb::pb::RegionInfo* temp = region_info_;
  region_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionInfo* MetaManagerRequest::unsafe_arena_release_region_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.region_info)
  _has_bits_[0] &= ~0x00000200u;
  ::baikaldb::pb::RegionInfo* temp = region_info_;
  region_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionInfo* MetaManagerRequest::_internal_mutable_region_info() {
  _has_bits_[0] |= 0x00000200u;
  if (region_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionInfo>(GetArenaForAllocation());
    region_info_ = p;
  }
  return region_info_;
}
inline ::baikaldb::pb::RegionInfo* MetaManagerRequest::mutable_region_info() {
  ::baikaldb::pb::RegionInfo* _msg = _internal_mutable_region_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.region_info)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_region_info(::baikaldb::pb::RegionInfo* region_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete region_info_;
  }
  if (region_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::RegionInfo>::GetOwningArena(region_info);
    if (message_arena != submessage_arena) {
      region_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  region_info_ = region_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.region_info)
}

// repeated int64 drop_region_ids = 12;
inline int MetaManagerRequest::_internal_drop_region_ids_size() const {
  return drop_region_ids_.size();
}
inline int MetaManagerRequest::drop_region_ids_size() const {
  return _internal_drop_region_ids_size();
}
inline void MetaManagerRequest::clear_drop_region_ids() {
  drop_region_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MetaManagerRequest::_internal_drop_region_ids(int index) const {
  return drop_region_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MetaManagerRequest::drop_region_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.drop_region_ids)
  return _internal_drop_region_ids(index);
}
inline void MetaManagerRequest::set_drop_region_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  drop_region_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.MetaManagerRequest.drop_region_ids)
}
inline void MetaManagerRequest::_internal_add_drop_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  drop_region_ids_.Add(value);
}
inline void MetaManagerRequest::add_drop_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_drop_region_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.MetaManagerRequest.drop_region_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
MetaManagerRequest::_internal_drop_region_ids() const {
  return drop_region_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
MetaManagerRequest::drop_region_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.MetaManagerRequest.drop_region_ids)
  return _internal_drop_region_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
MetaManagerRequest::_internal_mutable_drop_region_ids() {
  return &drop_region_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
MetaManagerRequest::mutable_drop_region_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.MetaManagerRequest.drop_region_ids)
  return _internal_mutable_drop_region_ids();
}

// optional .baikaldb.pb.RegionSplitRequest region_split = 13;
inline bool MetaManagerRequest::_internal_has_region_split() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || region_split_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_region_split() const {
  return _internal_has_region_split();
}
inline void MetaManagerRequest::clear_region_split() {
  if (region_split_ != nullptr) region_split_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::baikaldb::pb::RegionSplitRequest& MetaManagerRequest::_internal_region_split() const {
  const ::baikaldb::pb::RegionSplitRequest* p = region_split_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionSplitRequest&>(
      ::baikaldb::pb::_RegionSplitRequest_default_instance_);
}
inline const ::baikaldb::pb::RegionSplitRequest& MetaManagerRequest::region_split() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.region_split)
  return _internal_region_split();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_region_split(
    ::baikaldb::pb::RegionSplitRequest* region_split) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_split_);
  }
  region_split_ = region_split;
  if (region_split) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.region_split)
}
inline ::baikaldb::pb::RegionSplitRequest* MetaManagerRequest::release_region_split() {
  _has_bits_[0] &= ~0x00000400u;
  ::baikaldb::pb::RegionSplitRequest* temp = region_split_;
  region_split_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionSplitRequest* MetaManagerRequest::unsafe_arena_release_region_split() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.region_split)
  _has_bits_[0] &= ~0x00000400u;
  ::baikaldb::pb::RegionSplitRequest* temp = region_split_;
  region_split_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionSplitRequest* MetaManagerRequest::_internal_mutable_region_split() {
  _has_bits_[0] |= 0x00000400u;
  if (region_split_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionSplitRequest>(GetArenaForAllocation());
    region_split_ = p;
  }
  return region_split_;
}
inline ::baikaldb::pb::RegionSplitRequest* MetaManagerRequest::mutable_region_split() {
  ::baikaldb::pb::RegionSplitRequest* _msg = _internal_mutable_region_split();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.region_split)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_region_split(::baikaldb::pb::RegionSplitRequest* region_split) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete region_split_;
  }
  if (region_split) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::RegionSplitRequest>::GetOwningArena(region_split);
    if (message_arena != submessage_arena) {
      region_split = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_split, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  region_split_ = region_split;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.region_split)
}

// optional .baikaldb.pb.AutoIncrementRequest auto_increment = 14;
inline bool MetaManagerRequest::_internal_has_auto_increment() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || auto_increment_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_auto_increment() const {
  return _internal_has_auto_increment();
}
inline void MetaManagerRequest::clear_auto_increment() {
  if (auto_increment_ != nullptr) auto_increment_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::baikaldb::pb::AutoIncrementRequest& MetaManagerRequest::_internal_auto_increment() const {
  const ::baikaldb::pb::AutoIncrementRequest* p = auto_increment_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::AutoIncrementRequest&>(
      ::baikaldb::pb::_AutoIncrementRequest_default_instance_);
}
inline const ::baikaldb::pb::AutoIncrementRequest& MetaManagerRequest::auto_increment() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.auto_increment)
  return _internal_auto_increment();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_auto_increment(
    ::baikaldb::pb::AutoIncrementRequest* auto_increment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(auto_increment_);
  }
  auto_increment_ = auto_increment;
  if (auto_increment) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.auto_increment)
}
inline ::baikaldb::pb::AutoIncrementRequest* MetaManagerRequest::release_auto_increment() {
  _has_bits_[0] &= ~0x00000800u;
  ::baikaldb::pb::AutoIncrementRequest* temp = auto_increment_;
  auto_increment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::AutoIncrementRequest* MetaManagerRequest::unsafe_arena_release_auto_increment() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.auto_increment)
  _has_bits_[0] &= ~0x00000800u;
  ::baikaldb::pb::AutoIncrementRequest* temp = auto_increment_;
  auto_increment_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::AutoIncrementRequest* MetaManagerRequest::_internal_mutable_auto_increment() {
  _has_bits_[0] |= 0x00000800u;
  if (auto_increment_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::AutoIncrementRequest>(GetArenaForAllocation());
    auto_increment_ = p;
  }
  return auto_increment_;
}
inline ::baikaldb::pb::AutoIncrementRequest* MetaManagerRequest::mutable_auto_increment() {
  ::baikaldb::pb::AutoIncrementRequest* _msg = _internal_mutable_auto_increment();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.auto_increment)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_auto_increment(::baikaldb::pb::AutoIncrementRequest* auto_increment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete auto_increment_;
  }
  if (auto_increment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::AutoIncrementRequest>::GetOwningArena(auto_increment);
    if (message_arena != submessage_arena) {
      auto_increment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auto_increment, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  auto_increment_ = auto_increment;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.auto_increment)
}

// optional .baikaldb.pb.RestoreRegionRequest restore_region = 15;
inline bool MetaManagerRequest::_internal_has_restore_region() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || restore_region_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_restore_region() const {
  return _internal_has_restore_region();
}
inline void MetaManagerRequest::clear_restore_region() {
  if (restore_region_ != nullptr) restore_region_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::baikaldb::pb::RestoreRegionRequest& MetaManagerRequest::_internal_restore_region() const {
  const ::baikaldb::pb::RestoreRegionRequest* p = restore_region_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RestoreRegionRequest&>(
      ::baikaldb::pb::_RestoreRegionRequest_default_instance_);
}
inline const ::baikaldb::pb::RestoreRegionRequest& MetaManagerRequest::restore_region() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.restore_region)
  return _internal_restore_region();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_restore_region(
    ::baikaldb::pb::RestoreRegionRequest* restore_region) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(restore_region_);
  }
  restore_region_ = restore_region;
  if (restore_region) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.restore_region)
}
inline ::baikaldb::pb::RestoreRegionRequest* MetaManagerRequest::release_restore_region() {
  _has_bits_[0] &= ~0x00001000u;
  ::baikaldb::pb::RestoreRegionRequest* temp = restore_region_;
  restore_region_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RestoreRegionRequest* MetaManagerRequest::unsafe_arena_release_restore_region() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.restore_region)
  _has_bits_[0] &= ~0x00001000u;
  ::baikaldb::pb::RestoreRegionRequest* temp = restore_region_;
  restore_region_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RestoreRegionRequest* MetaManagerRequest::_internal_mutable_restore_region() {
  _has_bits_[0] |= 0x00001000u;
  if (restore_region_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RestoreRegionRequest>(GetArenaForAllocation());
    restore_region_ = p;
  }
  return restore_region_;
}
inline ::baikaldb::pb::RestoreRegionRequest* MetaManagerRequest::mutable_restore_region() {
  ::baikaldb::pb::RestoreRegionRequest* _msg = _internal_mutable_restore_region();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.restore_region)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_restore_region(::baikaldb::pb::RestoreRegionRequest* restore_region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete restore_region_;
  }
  if (restore_region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::RestoreRegionRequest>::GetOwningArena(restore_region);
    if (message_arena != submessage_arena) {
      restore_region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, restore_region, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  restore_region_ = restore_region;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.restore_region)
}

// repeated string resource_tags = 16;
inline int MetaManagerRequest::_internal_resource_tags_size() const {
  return resource_tags_.size();
}
inline int MetaManagerRequest::resource_tags_size() const {
  return _internal_resource_tags_size();
}
inline void MetaManagerRequest::clear_resource_tags() {
  resource_tags_.Clear();
}
inline std::string* MetaManagerRequest::add_resource_tags() {
  std::string* _s = _internal_add_resource_tags();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.MetaManagerRequest.resource_tags)
  return _s;
}
inline const std::string& MetaManagerRequest::_internal_resource_tags(int index) const {
  return resource_tags_.Get(index);
}
inline const std::string& MetaManagerRequest::resource_tags(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.resource_tags)
  return _internal_resource_tags(index);
}
inline std::string* MetaManagerRequest::mutable_resource_tags(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.resource_tags)
  return resource_tags_.Mutable(index);
}
inline void MetaManagerRequest::set_resource_tags(int index, const std::string& value) {
  resource_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.MetaManagerRequest.resource_tags)
}
inline void MetaManagerRequest::set_resource_tags(int index, std::string&& value) {
  resource_tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.MetaManagerRequest.resource_tags)
}
inline void MetaManagerRequest::set_resource_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  resource_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.MetaManagerRequest.resource_tags)
}
inline void MetaManagerRequest::set_resource_tags(int index, const char* value, size_t size) {
  resource_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.MetaManagerRequest.resource_tags)
}
inline std::string* MetaManagerRequest::_internal_add_resource_tags() {
  return resource_tags_.Add();
}
inline void MetaManagerRequest::add_resource_tags(const std::string& value) {
  resource_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.MetaManagerRequest.resource_tags)
}
inline void MetaManagerRequest::add_resource_tags(std::string&& value) {
  resource_tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.MetaManagerRequest.resource_tags)
}
inline void MetaManagerRequest::add_resource_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  resource_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.MetaManagerRequest.resource_tags)
}
inline void MetaManagerRequest::add_resource_tags(const char* value, size_t size) {
  resource_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.MetaManagerRequest.resource_tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MetaManagerRequest::resource_tags() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.MetaManagerRequest.resource_tags)
  return resource_tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MetaManagerRequest::mutable_resource_tags() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.MetaManagerRequest.resource_tags)
  return &resource_tags_;
}

// optional .baikaldb.pb.RegionMergeRequest region_merge = 17;
inline bool MetaManagerRequest::_internal_has_region_merge() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || region_merge_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_region_merge() const {
  return _internal_has_region_merge();
}
inline void MetaManagerRequest::clear_region_merge() {
  if (region_merge_ != nullptr) region_merge_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::baikaldb::pb::RegionMergeRequest& MetaManagerRequest::_internal_region_merge() const {
  const ::baikaldb::pb::RegionMergeRequest* p = region_merge_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionMergeRequest&>(
      ::baikaldb::pb::_RegionMergeRequest_default_instance_);
}
inline const ::baikaldb::pb::RegionMergeRequest& MetaManagerRequest::region_merge() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.region_merge)
  return _internal_region_merge();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_region_merge(
    ::baikaldb::pb::RegionMergeRequest* region_merge) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_merge_);
  }
  region_merge_ = region_merge;
  if (region_merge) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.region_merge)
}
inline ::baikaldb::pb::RegionMergeRequest* MetaManagerRequest::release_region_merge() {
  _has_bits_[0] &= ~0x00002000u;
  ::baikaldb::pb::RegionMergeRequest* temp = region_merge_;
  region_merge_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionMergeRequest* MetaManagerRequest::unsafe_arena_release_region_merge() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.region_merge)
  _has_bits_[0] &= ~0x00002000u;
  ::baikaldb::pb::RegionMergeRequest* temp = region_merge_;
  region_merge_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionMergeRequest* MetaManagerRequest::_internal_mutable_region_merge() {
  _has_bits_[0] |= 0x00002000u;
  if (region_merge_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionMergeRequest>(GetArenaForAllocation());
    region_merge_ = p;
  }
  return region_merge_;
}
inline ::baikaldb::pb::RegionMergeRequest* MetaManagerRequest::mutable_region_merge() {
  ::baikaldb::pb::RegionMergeRequest* _msg = _internal_mutable_region_merge();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.region_merge)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_region_merge(::baikaldb::pb::RegionMergeRequest* region_merge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete region_merge_;
  }
  if (region_merge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::RegionMergeRequest>::GetOwningArena(region_merge);
    if (message_arena != submessage_arena) {
      region_merge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_merge, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  region_merge_ = region_merge;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.region_merge)
}

// optional bool need_merge = 18;
inline bool MetaManagerRequest::_internal_has_need_merge() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool MetaManagerRequest::has_need_merge() const {
  return _internal_has_need_merge();
}
inline void MetaManagerRequest::clear_need_merge() {
  need_merge_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool MetaManagerRequest::_internal_need_merge() const {
  return need_merge_;
}
inline bool MetaManagerRequest::need_merge() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.need_merge)
  return _internal_need_merge();
}
inline void MetaManagerRequest::_internal_set_need_merge(bool value) {
  _has_bits_[0] |= 0x00080000u;
  need_merge_ = value;
}
inline void MetaManagerRequest::set_need_merge(bool value) {
  _internal_set_need_merge(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.MetaManagerRequest.need_merge)
}

// repeated .baikaldb.pb.RegionInfo region_infos = 19;
inline int MetaManagerRequest::_internal_region_infos_size() const {
  return region_infos_.size();
}
inline int MetaManagerRequest::region_infos_size() const {
  return _internal_region_infos_size();
}
inline void MetaManagerRequest::clear_region_infos() {
  region_infos_.Clear();
}
inline ::baikaldb::pb::RegionInfo* MetaManagerRequest::mutable_region_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.region_infos)
  return region_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >*
MetaManagerRequest::mutable_region_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.MetaManagerRequest.region_infos)
  return &region_infos_;
}
inline const ::baikaldb::pb::RegionInfo& MetaManagerRequest::_internal_region_infos(int index) const {
  return region_infos_.Get(index);
}
inline const ::baikaldb::pb::RegionInfo& MetaManagerRequest::region_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.region_infos)
  return _internal_region_infos(index);
}
inline ::baikaldb::pb::RegionInfo* MetaManagerRequest::_internal_add_region_infos() {
  return region_infos_.Add();
}
inline ::baikaldb::pb::RegionInfo* MetaManagerRequest::add_region_infos() {
  ::baikaldb::pb::RegionInfo* _add = _internal_add_region_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.MetaManagerRequest.region_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >&
MetaManagerRequest::region_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.MetaManagerRequest.region_infos)
  return region_infos_;
}

// optional .baikaldb.pb.DdlWorkInfo ddlwork_info = 20;
inline bool MetaManagerRequest::_internal_has_ddlwork_info() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || ddlwork_info_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_ddlwork_info() const {
  return _internal_has_ddlwork_info();
}
inline void MetaManagerRequest::clear_ddlwork_info() {
  if (ddlwork_info_ != nullptr) ddlwork_info_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::baikaldb::pb::DdlWorkInfo& MetaManagerRequest::_internal_ddlwork_info() const {
  const ::baikaldb::pb::DdlWorkInfo* p = ddlwork_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::DdlWorkInfo&>(
      ::baikaldb::pb::_DdlWorkInfo_default_instance_);
}
inline const ::baikaldb::pb::DdlWorkInfo& MetaManagerRequest::ddlwork_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.ddlwork_info)
  return _internal_ddlwork_info();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_ddlwork_info(
    ::baikaldb::pb::DdlWorkInfo* ddlwork_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ddlwork_info_);
  }
  ddlwork_info_ = ddlwork_info;
  if (ddlwork_info) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.ddlwork_info)
}
inline ::baikaldb::pb::DdlWorkInfo* MetaManagerRequest::release_ddlwork_info() {
  _has_bits_[0] &= ~0x00004000u;
  ::baikaldb::pb::DdlWorkInfo* temp = ddlwork_info_;
  ddlwork_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::DdlWorkInfo* MetaManagerRequest::unsafe_arena_release_ddlwork_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.ddlwork_info)
  _has_bits_[0] &= ~0x00004000u;
  ::baikaldb::pb::DdlWorkInfo* temp = ddlwork_info_;
  ddlwork_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::DdlWorkInfo* MetaManagerRequest::_internal_mutable_ddlwork_info() {
  _has_bits_[0] |= 0x00004000u;
  if (ddlwork_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::DdlWorkInfo>(GetArenaForAllocation());
    ddlwork_info_ = p;
  }
  return ddlwork_info_;
}
inline ::baikaldb::pb::DdlWorkInfo* MetaManagerRequest::mutable_ddlwork_info() {
  ::baikaldb::pb::DdlWorkInfo* _msg = _internal_mutable_ddlwork_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.ddlwork_info)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_ddlwork_info(::baikaldb::pb::DdlWorkInfo* ddlwork_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ddlwork_info_;
  }
  if (ddlwork_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::DdlWorkInfo>::GetOwningArena(ddlwork_info);
    if (message_arena != submessage_arena) {
      ddlwork_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ddlwork_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  ddlwork_info_ = ddlwork_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.ddlwork_info)
}

// optional bool add_delete_region = 21;
inline bool MetaManagerRequest::_internal_has_add_delete_region() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool MetaManagerRequest::has_add_delete_region() const {
  return _internal_has_add_delete_region();
}
inline void MetaManagerRequest::clear_add_delete_region() {
  add_delete_region_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool MetaManagerRequest::_internal_add_delete_region() const {
  return add_delete_region_;
}
inline bool MetaManagerRequest::add_delete_region() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.add_delete_region)
  return _internal_add_delete_region();
}
inline void MetaManagerRequest::_internal_set_add_delete_region(bool value) {
  _has_bits_[0] |= 0x00100000u;
  add_delete_region_ = value;
}
inline void MetaManagerRequest::set_add_delete_region(bool value) {
  _internal_set_add_delete_region(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.MetaManagerRequest.add_delete_region)
}

// optional .baikaldb.pb.Statistics statistics = 22;
inline bool MetaManagerRequest::_internal_has_statistics() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || statistics_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_statistics() const {
  return _internal_has_statistics();
}
inline const ::baikaldb::pb::Statistics& MetaManagerRequest::_internal_statistics() const {
  const ::baikaldb::pb::Statistics* p = statistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::Statistics&>(
      ::baikaldb::pb::_Statistics_default_instance_);
}
inline const ::baikaldb::pb::Statistics& MetaManagerRequest::statistics() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.statistics)
  return _internal_statistics();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_statistics(
    ::baikaldb::pb::Statistics* statistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statistics_);
  }
  statistics_ = statistics;
  if (statistics) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.statistics)
}
inline ::baikaldb::pb::Statistics* MetaManagerRequest::release_statistics() {
  _has_bits_[0] &= ~0x00008000u;
  ::baikaldb::pb::Statistics* temp = statistics_;
  statistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::Statistics* MetaManagerRequest::unsafe_arena_release_statistics() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.statistics)
  _has_bits_[0] &= ~0x00008000u;
  ::baikaldb::pb::Statistics* temp = statistics_;
  statistics_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::Statistics* MetaManagerRequest::_internal_mutable_statistics() {
  _has_bits_[0] |= 0x00008000u;
  if (statistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::Statistics>(GetArenaForAllocation());
    statistics_ = p;
  }
  return statistics_;
}
inline ::baikaldb::pb::Statistics* MetaManagerRequest::mutable_statistics() {
  ::baikaldb::pb::Statistics* _msg = _internal_mutable_statistics();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.statistics)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_statistics(::baikaldb::pb::Statistics* statistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(statistics_);
  }
  if (statistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statistics));
    if (message_arena != submessage_arena) {
      statistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statistics, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  statistics_ = statistics;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.statistics)
}

// optional .baikaldb.pb.SchemaInfo binlog_info = 23;
inline bool MetaManagerRequest::_internal_has_binlog_info() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || binlog_info_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_binlog_info() const {
  return _internal_has_binlog_info();
}
inline void MetaManagerRequest::clear_binlog_info() {
  if (binlog_info_ != nullptr) binlog_info_->Clear();
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::baikaldb::pb::SchemaInfo& MetaManagerRequest::_internal_binlog_info() const {
  const ::baikaldb::pb::SchemaInfo* p = binlog_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::SchemaInfo&>(
      ::baikaldb::pb::_SchemaInfo_default_instance_);
}
inline const ::baikaldb::pb::SchemaInfo& MetaManagerRequest::binlog_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.binlog_info)
  return _internal_binlog_info();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_binlog_info(
    ::baikaldb::pb::SchemaInfo* binlog_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(binlog_info_);
  }
  binlog_info_ = binlog_info;
  if (binlog_info) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.binlog_info)
}
inline ::baikaldb::pb::SchemaInfo* MetaManagerRequest::release_binlog_info() {
  _has_bits_[0] &= ~0x00010000u;
  ::baikaldb::pb::SchemaInfo* temp = binlog_info_;
  binlog_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::SchemaInfo* MetaManagerRequest::unsafe_arena_release_binlog_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.binlog_info)
  _has_bits_[0] &= ~0x00010000u;
  ::baikaldb::pb::SchemaInfo* temp = binlog_info_;
  binlog_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::SchemaInfo* MetaManagerRequest::_internal_mutable_binlog_info() {
  _has_bits_[0] |= 0x00010000u;
  if (binlog_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::SchemaInfo>(GetArenaForAllocation());
    binlog_info_ = p;
  }
  return binlog_info_;
}
inline ::baikaldb::pb::SchemaInfo* MetaManagerRequest::mutable_binlog_info() {
  ::baikaldb::pb::SchemaInfo* _msg = _internal_mutable_binlog_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.binlog_info)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_binlog_info(::baikaldb::pb::SchemaInfo* binlog_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete binlog_info_;
  }
  if (binlog_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::SchemaInfo>::GetOwningArena(binlog_info);
    if (message_arena != submessage_arena) {
      binlog_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, binlog_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  binlog_info_ = binlog_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.binlog_info)
}

// repeated .baikaldb.pb.InstanceParam instance_params = 24;
inline int MetaManagerRequest::_internal_instance_params_size() const {
  return instance_params_.size();
}
inline int MetaManagerRequest::instance_params_size() const {
  return _internal_instance_params_size();
}
inline void MetaManagerRequest::clear_instance_params() {
  instance_params_.Clear();
}
inline ::baikaldb::pb::InstanceParam* MetaManagerRequest::mutable_instance_params(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.instance_params)
  return instance_params_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam >*
MetaManagerRequest::mutable_instance_params() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.MetaManagerRequest.instance_params)
  return &instance_params_;
}
inline const ::baikaldb::pb::InstanceParam& MetaManagerRequest::_internal_instance_params(int index) const {
  return instance_params_.Get(index);
}
inline const ::baikaldb::pb::InstanceParam& MetaManagerRequest::instance_params(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.instance_params)
  return _internal_instance_params(index);
}
inline ::baikaldb::pb::InstanceParam* MetaManagerRequest::_internal_add_instance_params() {
  return instance_params_.Add();
}
inline ::baikaldb::pb::InstanceParam* MetaManagerRequest::add_instance_params() {
  ::baikaldb::pb::InstanceParam* _add = _internal_add_instance_params();
  // @@protoc_insertion_point(field_add:baikaldb.pb.MetaManagerRequest.instance_params)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam >&
MetaManagerRequest::instance_params() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.MetaManagerRequest.instance_params)
  return instance_params_;
}

// optional .baikaldb.pb.RecoverOpt recover_opt = 25;
inline bool MetaManagerRequest::_internal_has_recover_opt() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool MetaManagerRequest::has_recover_opt() const {
  return _internal_has_recover_opt();
}
inline void MetaManagerRequest::clear_recover_opt() {
  recover_opt_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::baikaldb::pb::RecoverOpt MetaManagerRequest::_internal_recover_opt() const {
  return static_cast< ::baikaldb::pb::RecoverOpt >(recover_opt_);
}
inline ::baikaldb::pb::RecoverOpt MetaManagerRequest::recover_opt() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.recover_opt)
  return _internal_recover_opt();
}
inline void MetaManagerRequest::_internal_set_recover_opt(::baikaldb::pb::RecoverOpt value) {
  assert(::baikaldb::pb::RecoverOpt_IsValid(value));
  _has_bits_[0] |= 0x01000000u;
  recover_opt_ = value;
}
inline void MetaManagerRequest::set_recover_opt(::baikaldb::pb::RecoverOpt value) {
  _internal_set_recover_opt(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.MetaManagerRequest.recover_opt)
}

// optional .baikaldb.pb.IndexDdlRequest index_ddl_request = 26;
inline bool MetaManagerRequest::_internal_has_index_ddl_request() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || index_ddl_request_ != nullptr);
  return value;
}
inline bool MetaManagerRequest::has_index_ddl_request() const {
  return _internal_has_index_ddl_request();
}
inline void MetaManagerRequest::clear_index_ddl_request() {
  if (index_ddl_request_ != nullptr) index_ddl_request_->Clear();
  _has_bits_[0] &= ~0x00020000u;
}
inline const ::baikaldb::pb::IndexDdlRequest& MetaManagerRequest::_internal_index_ddl_request() const {
  const ::baikaldb::pb::IndexDdlRequest* p = index_ddl_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::IndexDdlRequest&>(
      ::baikaldb::pb::_IndexDdlRequest_default_instance_);
}
inline const ::baikaldb::pb::IndexDdlRequest& MetaManagerRequest::index_ddl_request() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.index_ddl_request)
  return _internal_index_ddl_request();
}
inline void MetaManagerRequest::unsafe_arena_set_allocated_index_ddl_request(
    ::baikaldb::pb::IndexDdlRequest* index_ddl_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(index_ddl_request_);
  }
  index_ddl_request_ = index_ddl_request;
  if (index_ddl_request) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerRequest.index_ddl_request)
}
inline ::baikaldb::pb::IndexDdlRequest* MetaManagerRequest::release_index_ddl_request() {
  _has_bits_[0] &= ~0x00020000u;
  ::baikaldb::pb::IndexDdlRequest* temp = index_ddl_request_;
  index_ddl_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::IndexDdlRequest* MetaManagerRequest::unsafe_arena_release_index_ddl_request() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerRequest.index_ddl_request)
  _has_bits_[0] &= ~0x00020000u;
  ::baikaldb::pb::IndexDdlRequest* temp = index_ddl_request_;
  index_ddl_request_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::IndexDdlRequest* MetaManagerRequest::_internal_mutable_index_ddl_request() {
  _has_bits_[0] |= 0x00020000u;
  if (index_ddl_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::IndexDdlRequest>(GetArenaForAllocation());
    index_ddl_request_ = p;
  }
  return index_ddl_request_;
}
inline ::baikaldb::pb::IndexDdlRequest* MetaManagerRequest::mutable_index_ddl_request() {
  ::baikaldb::pb::IndexDdlRequest* _msg = _internal_mutable_index_ddl_request();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerRequest.index_ddl_request)
  return _msg;
}
inline void MetaManagerRequest::set_allocated_index_ddl_request(::baikaldb::pb::IndexDdlRequest* index_ddl_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete index_ddl_request_;
  }
  if (index_ddl_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::IndexDdlRequest>::GetOwningArena(index_ddl_request);
    if (message_arena != submessage_arena) {
      index_ddl_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, index_ddl_request, submessage_arena);
    }
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  index_ddl_request_ = index_ddl_request;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerRequest.index_ddl_request)
}

// optional int64 learner_replica_num = 27;
inline bool MetaManagerRequest::_internal_has_learner_replica_num() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool MetaManagerRequest::has_learner_replica_num() const {
  return _internal_has_learner_replica_num();
}
inline void MetaManagerRequest::clear_learner_replica_num() {
  learner_replica_num_ = int64_t{0};
  _has_bits_[0] &= ~0x00800000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MetaManagerRequest::_internal_learner_replica_num() const {
  return learner_replica_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MetaManagerRequest::learner_replica_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.learner_replica_num)
  return _internal_learner_replica_num();
}
inline void MetaManagerRequest::_internal_set_learner_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00800000u;
  learner_replica_num_ = value;
}
inline void MetaManagerRequest::set_learner_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_learner_replica_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.MetaManagerRequest.learner_replica_num)
}

// optional bool is_dynamic_change = 28;
inline bool MetaManagerRequest::_internal_has_is_dynamic_change() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool MetaManagerRequest::has_is_dynamic_change() const {
  return _internal_has_is_dynamic_change();
}
inline void MetaManagerRequest::clear_is_dynamic_change() {
  is_dynamic_change_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool MetaManagerRequest::_internal_is_dynamic_change() const {
  return is_dynamic_change_;
}
inline bool MetaManagerRequest::is_dynamic_change() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.is_dynamic_change)
  return _internal_is_dynamic_change();
}
inline void MetaManagerRequest::_internal_set_is_dynamic_change(bool value) {
  _has_bits_[0] |= 0x00200000u;
  is_dynamic_change_ = value;
}
inline void MetaManagerRequest::set_is_dynamic_change(bool value) {
  _internal_set_is_dynamic_change(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.MetaManagerRequest.is_dynamic_change)
}

// optional bool is_force_setting = 29;
inline bool MetaManagerRequest::_internal_has_is_force_setting() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool MetaManagerRequest::has_is_force_setting() const {
  return _internal_has_is_force_setting();
}
inline void MetaManagerRequest::clear_is_force_setting() {
  is_force_setting_ = false;
  _has_bits_[0] &= ~0x00400000u;
}
inline bool MetaManagerRequest::_internal_is_force_setting() const {
  return is_force_setting_;
}
inline bool MetaManagerRequest::is_force_setting() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerRequest.is_force_setting)
  return _internal_is_force_setting();
}
inline void MetaManagerRequest::_internal_set_is_force_setting(bool value) {
  _has_bits_[0] |= 0x00400000u;
  is_force_setting_ = value;
}
inline void MetaManagerRequest::set_is_force_setting(bool value) {
  _internal_set_is_force_setting(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.MetaManagerRequest.is_force_setting)
}

// -------------------------------------------------------------------

// CreateTableResponse

// optional .baikaldb.pb.SchemaInfo schema_info = 1;
inline bool CreateTableResponse::_internal_has_schema_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || schema_info_ != nullptr);
  return value;
}
inline bool CreateTableResponse::has_schema_info() const {
  return _internal_has_schema_info();
}
inline void CreateTableResponse::clear_schema_info() {
  if (schema_info_ != nullptr) schema_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::SchemaInfo& CreateTableResponse::_internal_schema_info() const {
  const ::baikaldb::pb::SchemaInfo* p = schema_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::SchemaInfo&>(
      ::baikaldb::pb::_SchemaInfo_default_instance_);
}
inline const ::baikaldb::pb::SchemaInfo& CreateTableResponse::schema_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CreateTableResponse.schema_info)
  return _internal_schema_info();
}
inline void CreateTableResponse::unsafe_arena_set_allocated_schema_info(
    ::baikaldb::pb::SchemaInfo* schema_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_info_);
  }
  schema_info_ = schema_info;
  if (schema_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.CreateTableResponse.schema_info)
}
inline ::baikaldb::pb::SchemaInfo* CreateTableResponse::release_schema_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::SchemaInfo* temp = schema_info_;
  schema_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::SchemaInfo* CreateTableResponse::unsafe_arena_release_schema_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.CreateTableResponse.schema_info)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::SchemaInfo* temp = schema_info_;
  schema_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::SchemaInfo* CreateTableResponse::_internal_mutable_schema_info() {
  _has_bits_[0] |= 0x00000001u;
  if (schema_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::SchemaInfo>(GetArenaForAllocation());
    schema_info_ = p;
  }
  return schema_info_;
}
inline ::baikaldb::pb::SchemaInfo* CreateTableResponse::mutable_schema_info() {
  ::baikaldb::pb::SchemaInfo* _msg = _internal_mutable_schema_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.CreateTableResponse.schema_info)
  return _msg;
}
inline void CreateTableResponse::set_allocated_schema_info(::baikaldb::pb::SchemaInfo* schema_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete schema_info_;
  }
  if (schema_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::SchemaInfo>::GetOwningArena(schema_info);
    if (message_arena != submessage_arena) {
      schema_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  schema_info_ = schema_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.CreateTableResponse.schema_info)
}

// repeated .baikaldb.pb.RegionInfo region_infos = 2;
inline int CreateTableResponse::_internal_region_infos_size() const {
  return region_infos_.size();
}
inline int CreateTableResponse::region_infos_size() const {
  return _internal_region_infos_size();
}
inline void CreateTableResponse::clear_region_infos() {
  region_infos_.Clear();
}
inline ::baikaldb::pb::RegionInfo* CreateTableResponse::mutable_region_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.CreateTableResponse.region_infos)
  return region_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >*
CreateTableResponse::mutable_region_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.CreateTableResponse.region_infos)
  return &region_infos_;
}
inline const ::baikaldb::pb::RegionInfo& CreateTableResponse::_internal_region_infos(int index) const {
  return region_infos_.Get(index);
}
inline const ::baikaldb::pb::RegionInfo& CreateTableResponse::region_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CreateTableResponse.region_infos)
  return _internal_region_infos(index);
}
inline ::baikaldb::pb::RegionInfo* CreateTableResponse::_internal_add_region_infos() {
  return region_infos_.Add();
}
inline ::baikaldb::pb::RegionInfo* CreateTableResponse::add_region_infos() {
  ::baikaldb::pb::RegionInfo* _add = _internal_add_region_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.CreateTableResponse.region_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >&
CreateTableResponse::region_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.CreateTableResponse.region_infos)
  return region_infos_;
}

// -------------------------------------------------------------------

// MetaManagerResponse

// required .baikaldb.pb.ErrCode errcode = 1;
inline bool MetaManagerResponse::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MetaManagerResponse::has_errcode() const {
  return _internal_has_errcode();
}
inline void MetaManagerResponse::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::baikaldb::pb::ErrCode MetaManagerResponse::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::ErrCode >(errcode_);
}
inline ::baikaldb::pb::ErrCode MetaManagerResponse::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerResponse.errcode)
  return _internal_errcode();
}
inline void MetaManagerResponse::_internal_set_errcode(::baikaldb::pb::ErrCode value) {
  assert(::baikaldb::pb::ErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  errcode_ = value;
}
inline void MetaManagerResponse::set_errcode(::baikaldb::pb::ErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.MetaManagerResponse.errcode)
}

// optional string errmsg = 2;
inline bool MetaManagerResponse::_internal_has_errmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MetaManagerResponse::has_errmsg() const {
  return _internal_has_errmsg();
}
inline void MetaManagerResponse::clear_errmsg() {
  errmsg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MetaManagerResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerResponse.errmsg)
  return _internal_errmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetaManagerResponse::set_errmsg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MetaManagerResponse.errmsg)
}
inline std::string* MetaManagerResponse::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerResponse.errmsg)
  return _s;
}
inline const std::string& MetaManagerResponse::_internal_errmsg() const {
  return errmsg_.Get();
}
inline void MetaManagerResponse::_internal_set_errmsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetaManagerResponse::_internal_mutable_errmsg() {
  _has_bits_[0] |= 0x00000001u;
  return errmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetaManagerResponse::release_errmsg() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerResponse.errmsg)
  if (!_internal_has_errmsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return errmsg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetaManagerResponse::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerResponse.errmsg)
}

// optional string leader = 3;
inline bool MetaManagerResponse::_internal_has_leader() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MetaManagerResponse::has_leader() const {
  return _internal_has_leader();
}
inline void MetaManagerResponse::clear_leader() {
  leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MetaManagerResponse::leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerResponse.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetaManagerResponse::set_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MetaManagerResponse.leader)
}
inline std::string* MetaManagerResponse::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerResponse.leader)
  return _s;
}
inline const std::string& MetaManagerResponse::_internal_leader() const {
  return leader_.Get();
}
inline void MetaManagerResponse::_internal_set_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetaManagerResponse::_internal_mutable_leader() {
  _has_bits_[0] |= 0x00000002u;
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetaManagerResponse::release_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerResponse.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetaManagerResponse::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerResponse.leader)
}

// optional .baikaldb.pb.RegionSplitResponse split_response = 4;
inline bool MetaManagerResponse::_internal_has_split_response() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || split_response_ != nullptr);
  return value;
}
inline bool MetaManagerResponse::has_split_response() const {
  return _internal_has_split_response();
}
inline void MetaManagerResponse::clear_split_response() {
  if (split_response_ != nullptr) split_response_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::baikaldb::pb::RegionSplitResponse& MetaManagerResponse::_internal_split_response() const {
  const ::baikaldb::pb::RegionSplitResponse* p = split_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionSplitResponse&>(
      ::baikaldb::pb::_RegionSplitResponse_default_instance_);
}
inline const ::baikaldb::pb::RegionSplitResponse& MetaManagerResponse::split_response() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerResponse.split_response)
  return _internal_split_response();
}
inline void MetaManagerResponse::unsafe_arena_set_allocated_split_response(
    ::baikaldb::pb::RegionSplitResponse* split_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(split_response_);
  }
  split_response_ = split_response;
  if (split_response) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerResponse.split_response)
}
inline ::baikaldb::pb::RegionSplitResponse* MetaManagerResponse::release_split_response() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::RegionSplitResponse* temp = split_response_;
  split_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionSplitResponse* MetaManagerResponse::unsafe_arena_release_split_response() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerResponse.split_response)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::RegionSplitResponse* temp = split_response_;
  split_response_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionSplitResponse* MetaManagerResponse::_internal_mutable_split_response() {
  _has_bits_[0] |= 0x00000004u;
  if (split_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionSplitResponse>(GetArenaForAllocation());
    split_response_ = p;
  }
  return split_response_;
}
inline ::baikaldb::pb::RegionSplitResponse* MetaManagerResponse::mutable_split_response() {
  ::baikaldb::pb::RegionSplitResponse* _msg = _internal_mutable_split_response();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerResponse.split_response)
  return _msg;
}
inline void MetaManagerResponse::set_allocated_split_response(::baikaldb::pb::RegionSplitResponse* split_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete split_response_;
  }
  if (split_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::RegionSplitResponse>::GetOwningArena(split_response);
    if (message_arena != submessage_arena) {
      split_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, split_response, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  split_response_ = split_response;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerResponse.split_response)
}

// optional .baikaldb.pb.OpType op_type = 5;
inline bool MetaManagerResponse::_internal_has_op_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MetaManagerResponse::has_op_type() const {
  return _internal_has_op_type();
}
inline void MetaManagerResponse::clear_op_type() {
  op_type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::baikaldb::pb::OpType MetaManagerResponse::_internal_op_type() const {
  return static_cast< ::baikaldb::pb::OpType >(op_type_);
}
inline ::baikaldb::pb::OpType MetaManagerResponse::op_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerResponse.op_type)
  return _internal_op_type();
}
inline void MetaManagerResponse::_internal_set_op_type(::baikaldb::pb::OpType value) {
  assert(::baikaldb::pb::OpType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  op_type_ = value;
}
inline void MetaManagerResponse::set_op_type(::baikaldb::pb::OpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.MetaManagerResponse.op_type)
}

// optional uint64 start_id = 6;
inline bool MetaManagerResponse::_internal_has_start_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool MetaManagerResponse::has_start_id() const {
  return _internal_has_start_id();
}
inline void MetaManagerResponse::clear_start_id() {
  start_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MetaManagerResponse::_internal_start_id() const {
  return start_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MetaManagerResponse::start_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerResponse.start_id)
  return _internal_start_id();
}
inline void MetaManagerResponse::_internal_set_start_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000100u;
  start_id_ = value;
}
inline void MetaManagerResponse::set_start_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_start_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.MetaManagerResponse.start_id)
}

// optional uint64 end_id = 7;
inline bool MetaManagerResponse::_internal_has_end_id() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool MetaManagerResponse::has_end_id() const {
  return _internal_has_end_id();
}
inline void MetaManagerResponse::clear_end_id() {
  end_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MetaManagerResponse::_internal_end_id() const {
  return end_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MetaManagerResponse::end_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerResponse.end_id)
  return _internal_end_id();
}
inline void MetaManagerResponse::_internal_set_end_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000200u;
  end_id_ = value;
}
inline void MetaManagerResponse::set_end_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_end_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.MetaManagerResponse.end_id)
}

// optional .baikaldb.pb.RegionMergeResponse merge_response = 8;
inline bool MetaManagerResponse::_internal_has_merge_response() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || merge_response_ != nullptr);
  return value;
}
inline bool MetaManagerResponse::has_merge_response() const {
  return _internal_has_merge_response();
}
inline void MetaManagerResponse::clear_merge_response() {
  if (merge_response_ != nullptr) merge_response_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::baikaldb::pb::RegionMergeResponse& MetaManagerResponse::_internal_merge_response() const {
  const ::baikaldb::pb::RegionMergeResponse* p = merge_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionMergeResponse&>(
      ::baikaldb::pb::_RegionMergeResponse_default_instance_);
}
inline const ::baikaldb::pb::RegionMergeResponse& MetaManagerResponse::merge_response() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerResponse.merge_response)
  return _internal_merge_response();
}
inline void MetaManagerResponse::unsafe_arena_set_allocated_merge_response(
    ::baikaldb::pb::RegionMergeResponse* merge_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(merge_response_);
  }
  merge_response_ = merge_response;
  if (merge_response) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerResponse.merge_response)
}
inline ::baikaldb::pb::RegionMergeResponse* MetaManagerResponse::release_merge_response() {
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::RegionMergeResponse* temp = merge_response_;
  merge_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionMergeResponse* MetaManagerResponse::unsafe_arena_release_merge_response() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerResponse.merge_response)
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::RegionMergeResponse* temp = merge_response_;
  merge_response_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionMergeResponse* MetaManagerResponse::_internal_mutable_merge_response() {
  _has_bits_[0] |= 0x00000008u;
  if (merge_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionMergeResponse>(GetArenaForAllocation());
    merge_response_ = p;
  }
  return merge_response_;
}
inline ::baikaldb::pb::RegionMergeResponse* MetaManagerResponse::mutable_merge_response() {
  ::baikaldb::pb::RegionMergeResponse* _msg = _internal_mutable_merge_response();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerResponse.merge_response)
  return _msg;
}
inline void MetaManagerResponse::set_allocated_merge_response(::baikaldb::pb::RegionMergeResponse* merge_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete merge_response_;
  }
  if (merge_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::RegionMergeResponse>::GetOwningArena(merge_response);
    if (message_arena != submessage_arena) {
      merge_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, merge_response, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  merge_response_ = merge_response;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerResponse.merge_response)
}

// optional .baikaldb.pb.RegionRecoverResponse recover_response = 9;
inline bool MetaManagerResponse::_internal_has_recover_response() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || recover_response_ != nullptr);
  return value;
}
inline bool MetaManagerResponse::has_recover_response() const {
  return _internal_has_recover_response();
}
inline void MetaManagerResponse::clear_recover_response() {
  if (recover_response_ != nullptr) recover_response_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::baikaldb::pb::RegionRecoverResponse& MetaManagerResponse::_internal_recover_response() const {
  const ::baikaldb::pb::RegionRecoverResponse* p = recover_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionRecoverResponse&>(
      ::baikaldb::pb::_RegionRecoverResponse_default_instance_);
}
inline const ::baikaldb::pb::RegionRecoverResponse& MetaManagerResponse::recover_response() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerResponse.recover_response)
  return _internal_recover_response();
}
inline void MetaManagerResponse::unsafe_arena_set_allocated_recover_response(
    ::baikaldb::pb::RegionRecoverResponse* recover_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(recover_response_);
  }
  recover_response_ = recover_response;
  if (recover_response) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerResponse.recover_response)
}
inline ::baikaldb::pb::RegionRecoverResponse* MetaManagerResponse::release_recover_response() {
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::RegionRecoverResponse* temp = recover_response_;
  recover_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionRecoverResponse* MetaManagerResponse::unsafe_arena_release_recover_response() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerResponse.recover_response)
  _has_bits_[0] &= ~0x00000010u;
  ::baikaldb::pb::RegionRecoverResponse* temp = recover_response_;
  recover_response_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionRecoverResponse* MetaManagerResponse::_internal_mutable_recover_response() {
  _has_bits_[0] |= 0x00000010u;
  if (recover_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionRecoverResponse>(GetArenaForAllocation());
    recover_response_ = p;
  }
  return recover_response_;
}
inline ::baikaldb::pb::RegionRecoverResponse* MetaManagerResponse::mutable_recover_response() {
  ::baikaldb::pb::RegionRecoverResponse* _msg = _internal_mutable_recover_response();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerResponse.recover_response)
  return _msg;
}
inline void MetaManagerResponse::set_allocated_recover_response(::baikaldb::pb::RegionRecoverResponse* recover_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete recover_response_;
  }
  if (recover_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::RegionRecoverResponse>::GetOwningArena(recover_response);
    if (message_arena != submessage_arena) {
      recover_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recover_response, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  recover_response_ = recover_response;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerResponse.recover_response)
}

// optional .baikaldb.pb.CreateTableResponse create_table_response = 10;
inline bool MetaManagerResponse::_internal_has_create_table_response() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || create_table_response_ != nullptr);
  return value;
}
inline bool MetaManagerResponse::has_create_table_response() const {
  return _internal_has_create_table_response();
}
inline void MetaManagerResponse::clear_create_table_response() {
  if (create_table_response_ != nullptr) create_table_response_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::baikaldb::pb::CreateTableResponse& MetaManagerResponse::_internal_create_table_response() const {
  const ::baikaldb::pb::CreateTableResponse* p = create_table_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::CreateTableResponse&>(
      ::baikaldb::pb::_CreateTableResponse_default_instance_);
}
inline const ::baikaldb::pb::CreateTableResponse& MetaManagerResponse::create_table_response() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MetaManagerResponse.create_table_response)
  return _internal_create_table_response();
}
inline void MetaManagerResponse::unsafe_arena_set_allocated_create_table_response(
    ::baikaldb::pb::CreateTableResponse* create_table_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(create_table_response_);
  }
  create_table_response_ = create_table_response;
  if (create_table_response) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MetaManagerResponse.create_table_response)
}
inline ::baikaldb::pb::CreateTableResponse* MetaManagerResponse::release_create_table_response() {
  _has_bits_[0] &= ~0x00000020u;
  ::baikaldb::pb::CreateTableResponse* temp = create_table_response_;
  create_table_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::CreateTableResponse* MetaManagerResponse::unsafe_arena_release_create_table_response() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MetaManagerResponse.create_table_response)
  _has_bits_[0] &= ~0x00000020u;
  ::baikaldb::pb::CreateTableResponse* temp = create_table_response_;
  create_table_response_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::CreateTableResponse* MetaManagerResponse::_internal_mutable_create_table_response() {
  _has_bits_[0] |= 0x00000020u;
  if (create_table_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::CreateTableResponse>(GetArenaForAllocation());
    create_table_response_ = p;
  }
  return create_table_response_;
}
inline ::baikaldb::pb::CreateTableResponse* MetaManagerResponse::mutable_create_table_response() {
  ::baikaldb::pb::CreateTableResponse* _msg = _internal_mutable_create_table_response();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MetaManagerResponse.create_table_response)
  return _msg;
}
inline void MetaManagerResponse::set_allocated_create_table_response(::baikaldb::pb::CreateTableResponse* create_table_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete create_table_response_;
  }
  if (create_table_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::CreateTableResponse>::GetOwningArena(create_table_response);
    if (message_arena != submessage_arena) {
      create_table_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, create_table_response, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  create_table_response_ = create_table_response;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MetaManagerResponse.create_table_response)
}

// -------------------------------------------------------------------

// RegionRecoverResponse

// repeated .baikaldb.pb.PeerStateInfo set_peer_regions = 1;
inline int RegionRecoverResponse::_internal_set_peer_regions_size() const {
  return set_peer_regions_.size();
}
inline int RegionRecoverResponse::set_peer_regions_size() const {
  return _internal_set_peer_regions_size();
}
inline void RegionRecoverResponse::clear_set_peer_regions() {
  set_peer_regions_.Clear();
}
inline ::baikaldb::pb::PeerStateInfo* RegionRecoverResponse::mutable_set_peer_regions(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionRecoverResponse.set_peer_regions)
  return set_peer_regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >*
RegionRecoverResponse::mutable_set_peer_regions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RegionRecoverResponse.set_peer_regions)
  return &set_peer_regions_;
}
inline const ::baikaldb::pb::PeerStateInfo& RegionRecoverResponse::_internal_set_peer_regions(int index) const {
  return set_peer_regions_.Get(index);
}
inline const ::baikaldb::pb::PeerStateInfo& RegionRecoverResponse::set_peer_regions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionRecoverResponse.set_peer_regions)
  return _internal_set_peer_regions(index);
}
inline ::baikaldb::pb::PeerStateInfo* RegionRecoverResponse::_internal_add_set_peer_regions() {
  return set_peer_regions_.Add();
}
inline ::baikaldb::pb::PeerStateInfo* RegionRecoverResponse::add_set_peer_regions() {
  ::baikaldb::pb::PeerStateInfo* _add = _internal_add_set_peer_regions();
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionRecoverResponse.set_peer_regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >&
RegionRecoverResponse::set_peer_regions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RegionRecoverResponse.set_peer_regions)
  return set_peer_regions_;
}

// repeated .baikaldb.pb.PeerStateInfo inited_regions = 2;
inline int RegionRecoverResponse::_internal_inited_regions_size() const {
  return inited_regions_.size();
}
inline int RegionRecoverResponse::inited_regions_size() const {
  return _internal_inited_regions_size();
}
inline void RegionRecoverResponse::clear_inited_regions() {
  inited_regions_.Clear();
}
inline ::baikaldb::pb::PeerStateInfo* RegionRecoverResponse::mutable_inited_regions(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionRecoverResponse.inited_regions)
  return inited_regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >*
RegionRecoverResponse::mutable_inited_regions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RegionRecoverResponse.inited_regions)
  return &inited_regions_;
}
inline const ::baikaldb::pb::PeerStateInfo& RegionRecoverResponse::_internal_inited_regions(int index) const {
  return inited_regions_.Get(index);
}
inline const ::baikaldb::pb::PeerStateInfo& RegionRecoverResponse::inited_regions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionRecoverResponse.inited_regions)
  return _internal_inited_regions(index);
}
inline ::baikaldb::pb::PeerStateInfo* RegionRecoverResponse::_internal_add_inited_regions() {
  return inited_regions_.Add();
}
inline ::baikaldb::pb::PeerStateInfo* RegionRecoverResponse::add_inited_regions() {
  ::baikaldb::pb::PeerStateInfo* _add = _internal_add_inited_regions();
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionRecoverResponse.inited_regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >&
RegionRecoverResponse::inited_regions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RegionRecoverResponse.inited_regions)
  return inited_regions_;
}

// repeated .baikaldb.pb.PeerStateInfo illegal_regions = 3;
inline int RegionRecoverResponse::_internal_illegal_regions_size() const {
  return illegal_regions_.size();
}
inline int RegionRecoverResponse::illegal_regions_size() const {
  return _internal_illegal_regions_size();
}
inline void RegionRecoverResponse::clear_illegal_regions() {
  illegal_regions_.Clear();
}
inline ::baikaldb::pb::PeerStateInfo* RegionRecoverResponse::mutable_illegal_regions(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionRecoverResponse.illegal_regions)
  return illegal_regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >*
RegionRecoverResponse::mutable_illegal_regions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RegionRecoverResponse.illegal_regions)
  return &illegal_regions_;
}
inline const ::baikaldb::pb::PeerStateInfo& RegionRecoverResponse::_internal_illegal_regions(int index) const {
  return illegal_regions_.Get(index);
}
inline const ::baikaldb::pb::PeerStateInfo& RegionRecoverResponse::illegal_regions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionRecoverResponse.illegal_regions)
  return _internal_illegal_regions(index);
}
inline ::baikaldb::pb::PeerStateInfo* RegionRecoverResponse::_internal_add_illegal_regions() {
  return illegal_regions_.Add();
}
inline ::baikaldb::pb::PeerStateInfo* RegionRecoverResponse::add_illegal_regions() {
  ::baikaldb::pb::PeerStateInfo* _add = _internal_add_illegal_regions();
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionRecoverResponse.illegal_regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >&
RegionRecoverResponse::illegal_regions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RegionRecoverResponse.illegal_regions)
  return illegal_regions_;
}

// -------------------------------------------------------------------

// SchemaHeartBeat

// required int64 table_id = 1;
inline bool SchemaHeartBeat::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchemaHeartBeat::has_table_id() const {
  return _internal_has_table_id();
}
inline void SchemaHeartBeat::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaHeartBeat::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaHeartBeat::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaHeartBeat.table_id)
  return _internal_table_id();
}
inline void SchemaHeartBeat::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  table_id_ = value;
}
inline void SchemaHeartBeat::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaHeartBeat.table_id)
}

// required int64 version = 2;
inline bool SchemaHeartBeat::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchemaHeartBeat::has_version() const {
  return _internal_has_version();
}
inline void SchemaHeartBeat::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaHeartBeat::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SchemaHeartBeat::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaHeartBeat.version)
  return _internal_version();
}
inline void SchemaHeartBeat::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
}
inline void SchemaHeartBeat::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaHeartBeat.version)
}

// -------------------------------------------------------------------

// BinlogPeerState

// required int64 region_id = 1;
inline bool BinlogPeerState::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BinlogPeerState::has_region_id() const {
  return _internal_has_region_id();
}
inline void BinlogPeerState::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogPeerState::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogPeerState::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogPeerState.region_id)
  return _internal_region_id();
}
inline void BinlogPeerState::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  region_id_ = value;
}
inline void BinlogPeerState::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogPeerState.region_id)
}

// optional uint32 oldest_timestamp_to_now_interval = 2;
inline bool BinlogPeerState::_internal_has_oldest_timestamp_to_now_interval() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BinlogPeerState::has_oldest_timestamp_to_now_interval() const {
  return _internal_has_oldest_timestamp_to_now_interval();
}
inline void BinlogPeerState::clear_oldest_timestamp_to_now_interval() {
  oldest_timestamp_to_now_interval_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BinlogPeerState::_internal_oldest_timestamp_to_now_interval() const {
  return oldest_timestamp_to_now_interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BinlogPeerState::oldest_timestamp_to_now_interval() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogPeerState.oldest_timestamp_to_now_interval)
  return _internal_oldest_timestamp_to_now_interval();
}
inline void BinlogPeerState::_internal_set_oldest_timestamp_to_now_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  oldest_timestamp_to_now_interval_ = value;
}
inline void BinlogPeerState::set_oldest_timestamp_to_now_interval(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_oldest_timestamp_to_now_interval(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogPeerState.oldest_timestamp_to_now_interval)
}

// -------------------------------------------------------------------

// PeerStateInfo

// optional string peer_id = 1;
inline bool PeerStateInfo::_internal_has_peer_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PeerStateInfo::has_peer_id() const {
  return _internal_has_peer_id();
}
inline void PeerStateInfo::clear_peer_id() {
  peer_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PeerStateInfo::peer_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PeerStateInfo.peer_id)
  return _internal_peer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerStateInfo::set_peer_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 peer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.PeerStateInfo.peer_id)
}
inline std::string* PeerStateInfo::mutable_peer_id() {
  std::string* _s = _internal_mutable_peer_id();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PeerStateInfo.peer_id)
  return _s;
}
inline const std::string& PeerStateInfo::_internal_peer_id() const {
  return peer_id_.Get();
}
inline void PeerStateInfo::_internal_set_peer_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  peer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PeerStateInfo::_internal_mutable_peer_id() {
  _has_bits_[0] |= 0x00000001u;
  return peer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PeerStateInfo::release_peer_id() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PeerStateInfo.peer_id)
  if (!_internal_has_peer_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return peer_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PeerStateInfo::set_allocated_peer_id(std::string* peer_id) {
  if (peer_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  peer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peer_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PeerStateInfo.peer_id)
}

// optional .baikaldb.pb.PeerStatus peer_status = 2;
inline bool PeerStateInfo::_internal_has_peer_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PeerStateInfo::has_peer_status() const {
  return _internal_has_peer_status();
}
inline void PeerStateInfo::clear_peer_status() {
  peer_status_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::baikaldb::pb::PeerStatus PeerStateInfo::_internal_peer_status() const {
  return static_cast< ::baikaldb::pb::PeerStatus >(peer_status_);
}
inline ::baikaldb::pb::PeerStatus PeerStateInfo::peer_status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PeerStateInfo.peer_status)
  return _internal_peer_status();
}
inline void PeerStateInfo::_internal_set_peer_status(::baikaldb::pb::PeerStatus value) {
  assert(::baikaldb::pb::PeerStatus_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  peer_status_ = value;
}
inline void PeerStateInfo::set_peer_status(::baikaldb::pb::PeerStatus value) {
  _internal_set_peer_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PeerStateInfo.peer_status)
}

// optional int64 table_id = 3;
inline bool PeerStateInfo::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PeerStateInfo::has_table_id() const {
  return _internal_has_table_id();
}
inline void PeerStateInfo::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PeerStateInfo::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PeerStateInfo::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PeerStateInfo.table_id)
  return _internal_table_id();
}
inline void PeerStateInfo::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  table_id_ = value;
}
inline void PeerStateInfo::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PeerStateInfo.table_id)
}

// optional int64 timestamp = 4;
inline bool PeerStateInfo::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PeerStateInfo::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void PeerStateInfo::clear_timestamp() {
  timestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PeerStateInfo::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PeerStateInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PeerStateInfo.timestamp)
  return _internal_timestamp();
}
inline void PeerStateInfo::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  timestamp_ = value;
}
inline void PeerStateInfo::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PeerStateInfo.timestamp)
}

// optional int64 region_id = 5;
inline bool PeerStateInfo::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PeerStateInfo::has_region_id() const {
  return _internal_has_region_id();
}
inline void PeerStateInfo::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PeerStateInfo::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PeerStateInfo::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PeerStateInfo.region_id)
  return _internal_region_id();
}
inline void PeerStateInfo::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  region_id_ = value;
}
inline void PeerStateInfo::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PeerStateInfo.region_id)
}

// optional bool is_learner = 6;
inline bool PeerStateInfo::_internal_has_is_learner() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PeerStateInfo::has_is_learner() const {
  return _internal_has_is_learner();
}
inline void PeerStateInfo::clear_is_learner() {
  is_learner_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool PeerStateInfo::_internal_is_learner() const {
  return is_learner_;
}
inline bool PeerStateInfo::is_learner() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PeerStateInfo.is_learner)
  return _internal_is_learner();
}
inline void PeerStateInfo::_internal_set_is_learner(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_learner_ = value;
}
inline void PeerStateInfo::set_is_learner(bool value) {
  _internal_set_is_learner(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PeerStateInfo.is_learner)
}

// -------------------------------------------------------------------

// RegionStateInfo

// optional int64 table_id = 1;
inline bool RegionStateInfo::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionStateInfo::has_table_id() const {
  return _internal_has_table_id();
}
inline void RegionStateInfo::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionStateInfo::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionStateInfo::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionStateInfo.table_id)
  return _internal_table_id();
}
inline void RegionStateInfo::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  table_id_ = value;
}
inline void RegionStateInfo::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionStateInfo.table_id)
}

// optional int64 region_id = 2;
inline bool RegionStateInfo::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegionStateInfo::has_region_id() const {
  return _internal_has_region_id();
}
inline void RegionStateInfo::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionStateInfo::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionStateInfo::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionStateInfo.region_id)
  return _internal_region_id();
}
inline void RegionStateInfo::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  region_id_ = value;
}
inline void RegionStateInfo::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionStateInfo.region_id)
}

// optional bool is_healthy = 3;
inline bool RegionStateInfo::_internal_has_is_healthy() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RegionStateInfo::has_is_healthy() const {
  return _internal_has_is_healthy();
}
inline void RegionStateInfo::clear_is_healthy() {
  is_healthy_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool RegionStateInfo::_internal_is_healthy() const {
  return is_healthy_;
}
inline bool RegionStateInfo::is_healthy() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionStateInfo.is_healthy)
  return _internal_is_healthy();
}
inline void RegionStateInfo::_internal_set_is_healthy(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_healthy_ = value;
}
inline void RegionStateInfo::set_is_healthy(bool value) {
  _internal_set_is_healthy(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionStateInfo.is_healthy)
}

// optional string table_name = 4;
inline bool RegionStateInfo::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegionStateInfo::has_table_name() const {
  return _internal_has_table_name();
}
inline void RegionStateInfo::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionStateInfo::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionStateInfo.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionStateInfo::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionStateInfo.table_name)
}
inline std::string* RegionStateInfo::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionStateInfo.table_name)
  return _s;
}
inline const std::string& RegionStateInfo::_internal_table_name() const {
  return table_name_.Get();
}
inline void RegionStateInfo::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionStateInfo::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000001u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionStateInfo::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionStateInfo.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionStateInfo::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionStateInfo.table_name)
}

// repeated .baikaldb.pb.PeerStateInfo peer_status_infos = 5;
inline int RegionStateInfo::_internal_peer_status_infos_size() const {
  return peer_status_infos_.size();
}
inline int RegionStateInfo::peer_status_infos_size() const {
  return _internal_peer_status_infos_size();
}
inline void RegionStateInfo::clear_peer_status_infos() {
  peer_status_infos_.Clear();
}
inline ::baikaldb::pb::PeerStateInfo* RegionStateInfo::mutable_peer_status_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionStateInfo.peer_status_infos)
  return peer_status_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >*
RegionStateInfo::mutable_peer_status_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.RegionStateInfo.peer_status_infos)
  return &peer_status_infos_;
}
inline const ::baikaldb::pb::PeerStateInfo& RegionStateInfo::_internal_peer_status_infos(int index) const {
  return peer_status_infos_.Get(index);
}
inline const ::baikaldb::pb::PeerStateInfo& RegionStateInfo::peer_status_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionStateInfo.peer_status_infos)
  return _internal_peer_status_infos(index);
}
inline ::baikaldb::pb::PeerStateInfo* RegionStateInfo::_internal_add_peer_status_infos() {
  return peer_status_infos_.Add();
}
inline ::baikaldb::pb::PeerStateInfo* RegionStateInfo::add_peer_status_infos() {
  ::baikaldb::pb::PeerStateInfo* _add = _internal_add_peer_status_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.RegionStateInfo.peer_status_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >&
RegionStateInfo::peer_status_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.RegionStateInfo.peer_status_infos)
  return peer_status_infos_;
}

// -------------------------------------------------------------------

// LeaderHeartBeat

// required .baikaldb.pb.RegionInfo region = 1;
inline bool LeaderHeartBeat::_internal_has_region() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || region_ != nullptr);
  return value;
}
inline bool LeaderHeartBeat::has_region() const {
  return _internal_has_region();
}
inline void LeaderHeartBeat::clear_region() {
  if (region_ != nullptr) region_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::RegionInfo& LeaderHeartBeat::_internal_region() const {
  const ::baikaldb::pb::RegionInfo* p = region_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionInfo&>(
      ::baikaldb::pb::_RegionInfo_default_instance_);
}
inline const ::baikaldb::pb::RegionInfo& LeaderHeartBeat::region() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LeaderHeartBeat.region)
  return _internal_region();
}
inline void LeaderHeartBeat::unsafe_arena_set_allocated_region(
    ::baikaldb::pb::RegionInfo* region) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  region_ = region;
  if (region) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.LeaderHeartBeat.region)
}
inline ::baikaldb::pb::RegionInfo* LeaderHeartBeat::release_region() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::RegionInfo* temp = region_;
  region_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionInfo* LeaderHeartBeat::unsafe_arena_release_region() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.LeaderHeartBeat.region)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::RegionInfo* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionInfo* LeaderHeartBeat::_internal_mutable_region() {
  _has_bits_[0] |= 0x00000001u;
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionInfo>(GetArenaForAllocation());
    region_ = p;
  }
  return region_;
}
inline ::baikaldb::pb::RegionInfo* LeaderHeartBeat::mutable_region() {
  ::baikaldb::pb::RegionInfo* _msg = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LeaderHeartBeat.region)
  return _msg;
}
inline void LeaderHeartBeat::set_allocated_region(::baikaldb::pb::RegionInfo* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete region_;
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::RegionInfo>::GetOwningArena(region);
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.LeaderHeartBeat.region)
}

// optional .baikaldb.pb.RegionStatus status = 2;
inline bool LeaderHeartBeat::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LeaderHeartBeat::has_status() const {
  return _internal_has_status();
}
inline void LeaderHeartBeat::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::baikaldb::pb::RegionStatus LeaderHeartBeat::_internal_status() const {
  return static_cast< ::baikaldb::pb::RegionStatus >(status_);
}
inline ::baikaldb::pb::RegionStatus LeaderHeartBeat::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LeaderHeartBeat.status)
  return _internal_status();
}
inline void LeaderHeartBeat::_internal_set_status(::baikaldb::pb::RegionStatus value) {
  assert(::baikaldb::pb::RegionStatus_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  status_ = value;
}
inline void LeaderHeartBeat::set_status(::baikaldb::pb::RegionStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LeaderHeartBeat.status)
}

// repeated .baikaldb.pb.PeerStateInfo peers_status = 3;
inline int LeaderHeartBeat::_internal_peers_status_size() const {
  return peers_status_.size();
}
inline int LeaderHeartBeat::peers_status_size() const {
  return _internal_peers_status_size();
}
inline void LeaderHeartBeat::clear_peers_status() {
  peers_status_.Clear();
}
inline ::baikaldb::pb::PeerStateInfo* LeaderHeartBeat::mutable_peers_status(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LeaderHeartBeat.peers_status)
  return peers_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >*
LeaderHeartBeat::mutable_peers_status() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.LeaderHeartBeat.peers_status)
  return &peers_status_;
}
inline const ::baikaldb::pb::PeerStateInfo& LeaderHeartBeat::_internal_peers_status(int index) const {
  return peers_status_.Get(index);
}
inline const ::baikaldb::pb::PeerStateInfo& LeaderHeartBeat::peers_status(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LeaderHeartBeat.peers_status)
  return _internal_peers_status(index);
}
inline ::baikaldb::pb::PeerStateInfo* LeaderHeartBeat::_internal_add_peers_status() {
  return peers_status_.Add();
}
inline ::baikaldb::pb::PeerStateInfo* LeaderHeartBeat::add_peers_status() {
  ::baikaldb::pb::PeerStateInfo* _add = _internal_add_peers_status();
  // @@protoc_insertion_point(field_add:baikaldb.pb.LeaderHeartBeat.peers_status)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerStateInfo >&
LeaderHeartBeat::peers_status() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.LeaderHeartBeat.peers_status)
  return peers_status_;
}

// optional bool simple = 4;
inline bool LeaderHeartBeat::_internal_has_simple() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LeaderHeartBeat::has_simple() const {
  return _internal_has_simple();
}
inline void LeaderHeartBeat::clear_simple() {
  simple_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool LeaderHeartBeat::_internal_simple() const {
  return simple_;
}
inline bool LeaderHeartBeat::simple() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LeaderHeartBeat.simple)
  return _internal_simple();
}
inline void LeaderHeartBeat::_internal_set_simple(bool value) {
  _has_bits_[0] |= 0x00000002u;
  simple_ = value;
}
inline void LeaderHeartBeat::set_simple(bool value) {
  _internal_set_simple(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LeaderHeartBeat.simple)
}

// -------------------------------------------------------------------

// LearnerHeartBeat

// required .baikaldb.pb.RegionInfo region = 1;
inline bool LearnerHeartBeat::_internal_has_region() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || region_ != nullptr);
  return value;
}
inline bool LearnerHeartBeat::has_region() const {
  return _internal_has_region();
}
inline void LearnerHeartBeat::clear_region() {
  if (region_ != nullptr) region_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::RegionInfo& LearnerHeartBeat::_internal_region() const {
  const ::baikaldb::pb::RegionInfo* p = region_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionInfo&>(
      ::baikaldb::pb::_RegionInfo_default_instance_);
}
inline const ::baikaldb::pb::RegionInfo& LearnerHeartBeat::region() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LearnerHeartBeat.region)
  return _internal_region();
}
inline void LearnerHeartBeat::unsafe_arena_set_allocated_region(
    ::baikaldb::pb::RegionInfo* region) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  region_ = region;
  if (region) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.LearnerHeartBeat.region)
}
inline ::baikaldb::pb::RegionInfo* LearnerHeartBeat::release_region() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::RegionInfo* temp = region_;
  region_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionInfo* LearnerHeartBeat::unsafe_arena_release_region() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.LearnerHeartBeat.region)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::RegionInfo* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionInfo* LearnerHeartBeat::_internal_mutable_region() {
  _has_bits_[0] |= 0x00000001u;
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionInfo>(GetArenaForAllocation());
    region_ = p;
  }
  return region_;
}
inline ::baikaldb::pb::RegionInfo* LearnerHeartBeat::mutable_region() {
  ::baikaldb::pb::RegionInfo* _msg = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.LearnerHeartBeat.region)
  return _msg;
}
inline void LearnerHeartBeat::set_allocated_region(::baikaldb::pb::RegionInfo* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete region_;
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::RegionInfo>::GetOwningArena(region);
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.LearnerHeartBeat.region)
}

// optional .baikaldb.pb.RegionStatus status = 2;
inline bool LearnerHeartBeat::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LearnerHeartBeat::has_status() const {
  return _internal_has_status();
}
inline void LearnerHeartBeat::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::baikaldb::pb::RegionStatus LearnerHeartBeat::_internal_status() const {
  return static_cast< ::baikaldb::pb::RegionStatus >(status_);
}
inline ::baikaldb::pb::RegionStatus LearnerHeartBeat::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LearnerHeartBeat.status)
  return _internal_status();
}
inline void LearnerHeartBeat::_internal_set_status(::baikaldb::pb::RegionStatus value) {
  assert(::baikaldb::pb::RegionStatus_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  status_ = value;
}
inline void LearnerHeartBeat::set_status(::baikaldb::pb::RegionStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LearnerHeartBeat.status)
}

// optional .baikaldb.pb.PeerStatus state = 3;
inline bool LearnerHeartBeat::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LearnerHeartBeat::has_state() const {
  return _internal_has_state();
}
inline void LearnerHeartBeat::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::baikaldb::pb::PeerStatus LearnerHeartBeat::_internal_state() const {
  return static_cast< ::baikaldb::pb::PeerStatus >(state_);
}
inline ::baikaldb::pb::PeerStatus LearnerHeartBeat::state() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.LearnerHeartBeat.state)
  return _internal_state();
}
inline void LearnerHeartBeat::_internal_set_state(::baikaldb::pb::PeerStatus value) {
  assert(::baikaldb::pb::PeerStatus_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  state_ = value;
}
inline void LearnerHeartBeat::set_state(::baikaldb::pb::PeerStatus value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.LearnerHeartBeat.state)
}

// -------------------------------------------------------------------

// PeerHeartBeat

// required int64 region_id = 1;
inline bool PeerHeartBeat::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PeerHeartBeat::has_region_id() const {
  return _internal_has_region_id();
}
inline void PeerHeartBeat::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PeerHeartBeat::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PeerHeartBeat::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PeerHeartBeat.region_id)
  return _internal_region_id();
}
inline void PeerHeartBeat::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  region_id_ = value;
}
inline void PeerHeartBeat::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PeerHeartBeat.region_id)
}

// required int64 table_id = 2;
inline bool PeerHeartBeat::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PeerHeartBeat::has_table_id() const {
  return _internal_has_table_id();
}
inline void PeerHeartBeat::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PeerHeartBeat::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PeerHeartBeat::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PeerHeartBeat.table_id)
  return _internal_table_id();
}
inline void PeerHeartBeat::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  table_id_ = value;
}
inline void PeerHeartBeat::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PeerHeartBeat.table_id)
}

// required int64 log_index = 3;
inline bool PeerHeartBeat::_internal_has_log_index() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PeerHeartBeat::has_log_index() const {
  return _internal_has_log_index();
}
inline void PeerHeartBeat::clear_log_index() {
  log_index_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PeerHeartBeat::_internal_log_index() const {
  return log_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PeerHeartBeat::log_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PeerHeartBeat.log_index)
  return _internal_log_index();
}
inline void PeerHeartBeat::_internal_set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  log_index_ = value;
}
inline void PeerHeartBeat::set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_log_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PeerHeartBeat.log_index)
}

// optional bytes start_key = 4;
inline bool PeerHeartBeat::_internal_has_start_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PeerHeartBeat::has_start_key() const {
  return _internal_has_start_key();
}
inline void PeerHeartBeat::clear_start_key() {
  start_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PeerHeartBeat::start_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PeerHeartBeat.start_key)
  return _internal_start_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerHeartBeat::set_start_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 start_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.PeerHeartBeat.start_key)
}
inline std::string* PeerHeartBeat::mutable_start_key() {
  std::string* _s = _internal_mutable_start_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PeerHeartBeat.start_key)
  return _s;
}
inline const std::string& PeerHeartBeat::_internal_start_key() const {
  return start_key_.Get();
}
inline void PeerHeartBeat::_internal_set_start_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  start_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PeerHeartBeat::_internal_mutable_start_key() {
  _has_bits_[0] |= 0x00000001u;
  return start_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PeerHeartBeat::release_start_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PeerHeartBeat.start_key)
  if (!_internal_has_start_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return start_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PeerHeartBeat::set_allocated_start_key(std::string* start_key) {
  if (start_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  start_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PeerHeartBeat.start_key)
}

// optional bytes end_key = 5;
inline bool PeerHeartBeat::_internal_has_end_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PeerHeartBeat::has_end_key() const {
  return _internal_has_end_key();
}
inline void PeerHeartBeat::clear_end_key() {
  end_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PeerHeartBeat::end_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PeerHeartBeat.end_key)
  return _internal_end_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PeerHeartBeat::set_end_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 end_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.PeerHeartBeat.end_key)
}
inline std::string* PeerHeartBeat::mutable_end_key() {
  std::string* _s = _internal_mutable_end_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PeerHeartBeat.end_key)
  return _s;
}
inline const std::string& PeerHeartBeat::_internal_end_key() const {
  return end_key_.Get();
}
inline void PeerHeartBeat::_internal_set_end_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  end_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PeerHeartBeat::_internal_mutable_end_key() {
  _has_bits_[0] |= 0x00000002u;
  return end_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PeerHeartBeat::release_end_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PeerHeartBeat.end_key)
  if (!_internal_has_end_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return end_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PeerHeartBeat::set_allocated_end_key(std::string* end_key) {
  if (end_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  end_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), end_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PeerHeartBeat.end_key)
}

// optional int64 main_table_id = 6;
inline bool PeerHeartBeat::_internal_has_main_table_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PeerHeartBeat::has_main_table_id() const {
  return _internal_has_main_table_id();
}
inline void PeerHeartBeat::clear_main_table_id() {
  main_table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PeerHeartBeat::_internal_main_table_id() const {
  return main_table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PeerHeartBeat::main_table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PeerHeartBeat.main_table_id)
  return _internal_main_table_id();
}
inline void PeerHeartBeat::_internal_set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  main_table_id_ = value;
}
inline void PeerHeartBeat::set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_main_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PeerHeartBeat.main_table_id)
}

// optional bool exist_leader = 7;
inline bool PeerHeartBeat::_internal_has_exist_leader() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PeerHeartBeat::has_exist_leader() const {
  return _internal_has_exist_leader();
}
inline void PeerHeartBeat::clear_exist_leader() {
  exist_leader_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool PeerHeartBeat::_internal_exist_leader() const {
  return exist_leader_;
}
inline bool PeerHeartBeat::exist_leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PeerHeartBeat.exist_leader)
  return _internal_exist_leader();
}
inline void PeerHeartBeat::_internal_set_exist_leader(bool value) {
  _has_bits_[0] |= 0x00000080u;
  exist_leader_ = value;
}
inline void PeerHeartBeat::set_exist_leader(bool value) {
  _internal_set_exist_leader(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PeerHeartBeat.exist_leader)
}

// optional bool is_learner = 8;
inline bool PeerHeartBeat::_internal_has_is_learner() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PeerHeartBeat::has_is_learner() const {
  return _internal_has_is_learner();
}
inline void PeerHeartBeat::clear_is_learner() {
  is_learner_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool PeerHeartBeat::_internal_is_learner() const {
  return is_learner_;
}
inline bool PeerHeartBeat::is_learner() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PeerHeartBeat.is_learner)
  return _internal_is_learner();
}
inline void PeerHeartBeat::_internal_set_is_learner(bool value) {
  _has_bits_[0] |= 0x00000100u;
  is_learner_ = value;
}
inline void PeerHeartBeat::set_is_learner(bool value) {
  _internal_set_is_learner(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PeerHeartBeat.is_learner)
}

// optional int64 partition_id = 9;
inline bool PeerHeartBeat::_internal_has_partition_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PeerHeartBeat::has_partition_id() const {
  return _internal_has_partition_id();
}
inline void PeerHeartBeat::clear_partition_id() {
  partition_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PeerHeartBeat::_internal_partition_id() const {
  return partition_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PeerHeartBeat::partition_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PeerHeartBeat.partition_id)
  return _internal_partition_id();
}
inline void PeerHeartBeat::_internal_set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  partition_id_ = value;
}
inline void PeerHeartBeat::set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_partition_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PeerHeartBeat.partition_id)
}

// -------------------------------------------------------------------

// AddPeer

// required int64 region_id = 1;
inline bool AddPeer::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AddPeer::has_region_id() const {
  return _internal_has_region_id();
}
inline void AddPeer::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AddPeer::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AddPeer::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AddPeer.region_id)
  return _internal_region_id();
}
inline void AddPeer::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  region_id_ = value;
}
inline void AddPeer::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AddPeer.region_id)
}

// repeated string old_peers = 2;
inline int AddPeer::_internal_old_peers_size() const {
  return old_peers_.size();
}
inline int AddPeer::old_peers_size() const {
  return _internal_old_peers_size();
}
inline void AddPeer::clear_old_peers() {
  old_peers_.Clear();
}
inline std::string* AddPeer::add_old_peers() {
  std::string* _s = _internal_add_old_peers();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.AddPeer.old_peers)
  return _s;
}
inline const std::string& AddPeer::_internal_old_peers(int index) const {
  return old_peers_.Get(index);
}
inline const std::string& AddPeer::old_peers(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AddPeer.old_peers)
  return _internal_old_peers(index);
}
inline std::string* AddPeer::mutable_old_peers(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.AddPeer.old_peers)
  return old_peers_.Mutable(index);
}
inline void AddPeer::set_old_peers(int index, const std::string& value) {
  old_peers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AddPeer.old_peers)
}
inline void AddPeer::set_old_peers(int index, std::string&& value) {
  old_peers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.AddPeer.old_peers)
}
inline void AddPeer::set_old_peers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  old_peers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.AddPeer.old_peers)
}
inline void AddPeer::set_old_peers(int index, const char* value, size_t size) {
  old_peers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.AddPeer.old_peers)
}
inline std::string* AddPeer::_internal_add_old_peers() {
  return old_peers_.Add();
}
inline void AddPeer::add_old_peers(const std::string& value) {
  old_peers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.AddPeer.old_peers)
}
inline void AddPeer::add_old_peers(std::string&& value) {
  old_peers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.AddPeer.old_peers)
}
inline void AddPeer::add_old_peers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  old_peers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.AddPeer.old_peers)
}
inline void AddPeer::add_old_peers(const char* value, size_t size) {
  old_peers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.AddPeer.old_peers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AddPeer::old_peers() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.AddPeer.old_peers)
  return old_peers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AddPeer::mutable_old_peers() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.AddPeer.old_peers)
  return &old_peers_;
}

// repeated string new_peers = 3;
inline int AddPeer::_internal_new_peers_size() const {
  return new_peers_.size();
}
inline int AddPeer::new_peers_size() const {
  return _internal_new_peers_size();
}
inline void AddPeer::clear_new_peers() {
  new_peers_.Clear();
}
inline std::string* AddPeer::add_new_peers() {
  std::string* _s = _internal_add_new_peers();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.AddPeer.new_peers)
  return _s;
}
inline const std::string& AddPeer::_internal_new_peers(int index) const {
  return new_peers_.Get(index);
}
inline const std::string& AddPeer::new_peers(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AddPeer.new_peers)
  return _internal_new_peers(index);
}
inline std::string* AddPeer::mutable_new_peers(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.AddPeer.new_peers)
  return new_peers_.Mutable(index);
}
inline void AddPeer::set_new_peers(int index, const std::string& value) {
  new_peers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AddPeer.new_peers)
}
inline void AddPeer::set_new_peers(int index, std::string&& value) {
  new_peers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.AddPeer.new_peers)
}
inline void AddPeer::set_new_peers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  new_peers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.AddPeer.new_peers)
}
inline void AddPeer::set_new_peers(int index, const char* value, size_t size) {
  new_peers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.AddPeer.new_peers)
}
inline std::string* AddPeer::_internal_add_new_peers() {
  return new_peers_.Add();
}
inline void AddPeer::add_new_peers(const std::string& value) {
  new_peers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.AddPeer.new_peers)
}
inline void AddPeer::add_new_peers(std::string&& value) {
  new_peers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.AddPeer.new_peers)
}
inline void AddPeer::add_new_peers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  new_peers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.AddPeer.new_peers)
}
inline void AddPeer::add_new_peers(const char* value, size_t size) {
  new_peers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.AddPeer.new_peers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AddPeer::new_peers() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.AddPeer.new_peers)
  return new_peers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AddPeer::mutable_new_peers() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.AddPeer.new_peers)
  return &new_peers_;
}

// optional bool is_split = 4;
inline bool AddPeer::_internal_has_is_split() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AddPeer::has_is_split() const {
  return _internal_has_is_split();
}
inline void AddPeer::clear_is_split() {
  is_split_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool AddPeer::_internal_is_split() const {
  return is_split_;
}
inline bool AddPeer::is_split() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.AddPeer.is_split)
  return _internal_is_split();
}
inline void AddPeer::_internal_set_is_split(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_split_ = value;
}
inline void AddPeer::set_is_split(bool value) {
  _internal_set_is_split(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.AddPeer.is_split)
}

// -------------------------------------------------------------------

// TransLeaderRequest

// required int64 region_id = 1;
inline bool TransLeaderRequest::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TransLeaderRequest::has_region_id() const {
  return _internal_has_region_id();
}
inline void TransLeaderRequest::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransLeaderRequest::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransLeaderRequest::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransLeaderRequest.region_id)
  return _internal_region_id();
}
inline void TransLeaderRequest::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  region_id_ = value;
}
inline void TransLeaderRequest::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransLeaderRequest.region_id)
}

// required string old_leader = 2;
inline bool TransLeaderRequest::_internal_has_old_leader() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TransLeaderRequest::has_old_leader() const {
  return _internal_has_old_leader();
}
inline void TransLeaderRequest::clear_old_leader() {
  old_leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransLeaderRequest::old_leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransLeaderRequest.old_leader)
  return _internal_old_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransLeaderRequest::set_old_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 old_leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransLeaderRequest.old_leader)
}
inline std::string* TransLeaderRequest::mutable_old_leader() {
  std::string* _s = _internal_mutable_old_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TransLeaderRequest.old_leader)
  return _s;
}
inline const std::string& TransLeaderRequest::_internal_old_leader() const {
  return old_leader_.Get();
}
inline void TransLeaderRequest::_internal_set_old_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  old_leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransLeaderRequest::_internal_mutable_old_leader() {
  _has_bits_[0] |= 0x00000001u;
  return old_leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransLeaderRequest::release_old_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TransLeaderRequest.old_leader)
  if (!_internal_has_old_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return old_leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransLeaderRequest::set_allocated_old_leader(std::string* old_leader) {
  if (old_leader != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  old_leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), old_leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TransLeaderRequest.old_leader)
}

// required string new_leader = 3;
inline bool TransLeaderRequest::_internal_has_new_leader() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TransLeaderRequest::has_new_leader() const {
  return _internal_has_new_leader();
}
inline void TransLeaderRequest::clear_new_leader() {
  new_leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TransLeaderRequest::new_leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransLeaderRequest.new_leader)
  return _internal_new_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransLeaderRequest::set_new_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 new_leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransLeaderRequest.new_leader)
}
inline std::string* TransLeaderRequest::mutable_new_leader() {
  std::string* _s = _internal_mutable_new_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TransLeaderRequest.new_leader)
  return _s;
}
inline const std::string& TransLeaderRequest::_internal_new_leader() const {
  return new_leader_.Get();
}
inline void TransLeaderRequest::_internal_set_new_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  new_leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransLeaderRequest::_internal_mutable_new_leader() {
  _has_bits_[0] |= 0x00000002u;
  return new_leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransLeaderRequest::release_new_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TransLeaderRequest.new_leader)
  if (!_internal_has_new_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return new_leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransLeaderRequest::set_allocated_new_leader(std::string* new_leader) {
  if (new_leader != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  new_leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TransLeaderRequest.new_leader)
}

// optional int64 table_id = 4;
inline bool TransLeaderRequest::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TransLeaderRequest::has_table_id() const {
  return _internal_has_table_id();
}
inline void TransLeaderRequest::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransLeaderRequest::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TransLeaderRequest::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TransLeaderRequest.table_id)
  return _internal_table_id();
}
inline void TransLeaderRequest::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  table_id_ = value;
}
inline void TransLeaderRequest::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TransLeaderRequest.table_id)
}

// -------------------------------------------------------------------

// StoreHeartBeatRequest

// required .baikaldb.pb.InstanceInfo instance_info = 1;
inline bool StoreHeartBeatRequest::_internal_has_instance_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || instance_info_ != nullptr);
  return value;
}
inline bool StoreHeartBeatRequest::has_instance_info() const {
  return _internal_has_instance_info();
}
inline void StoreHeartBeatRequest::clear_instance_info() {
  if (instance_info_ != nullptr) instance_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::InstanceInfo& StoreHeartBeatRequest::_internal_instance_info() const {
  const ::baikaldb::pb::InstanceInfo* p = instance_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::InstanceInfo&>(
      ::baikaldb::pb::_InstanceInfo_default_instance_);
}
inline const ::baikaldb::pb::InstanceInfo& StoreHeartBeatRequest::instance_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatRequest.instance_info)
  return _internal_instance_info();
}
inline void StoreHeartBeatRequest::unsafe_arena_set_allocated_instance_info(
    ::baikaldb::pb::InstanceInfo* instance_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(instance_info_);
  }
  instance_info_ = instance_info;
  if (instance_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.StoreHeartBeatRequest.instance_info)
}
inline ::baikaldb::pb::InstanceInfo* StoreHeartBeatRequest::release_instance_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::InstanceInfo* temp = instance_info_;
  instance_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::InstanceInfo* StoreHeartBeatRequest::unsafe_arena_release_instance_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreHeartBeatRequest.instance_info)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::InstanceInfo* temp = instance_info_;
  instance_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::InstanceInfo* StoreHeartBeatRequest::_internal_mutable_instance_info() {
  _has_bits_[0] |= 0x00000001u;
  if (instance_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::InstanceInfo>(GetArenaForAllocation());
    instance_info_ = p;
  }
  return instance_info_;
}
inline ::baikaldb::pb::InstanceInfo* StoreHeartBeatRequest::mutable_instance_info() {
  ::baikaldb::pb::InstanceInfo* _msg = _internal_mutable_instance_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreHeartBeatRequest.instance_info)
  return _msg;
}
inline void StoreHeartBeatRequest::set_allocated_instance_info(::baikaldb::pb::InstanceInfo* instance_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete instance_info_;
  }
  if (instance_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::InstanceInfo>::GetOwningArena(instance_info);
    if (message_arena != submessage_arena) {
      instance_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instance_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  instance_info_ = instance_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreHeartBeatRequest.instance_info)
}

// repeated .baikaldb.pb.SchemaHeartBeat schema_infos = 2;
inline int StoreHeartBeatRequest::_internal_schema_infos_size() const {
  return schema_infos_.size();
}
inline int StoreHeartBeatRequest::schema_infos_size() const {
  return _internal_schema_infos_size();
}
inline void StoreHeartBeatRequest::clear_schema_infos() {
  schema_infos_.Clear();
}
inline ::baikaldb::pb::SchemaHeartBeat* StoreHeartBeatRequest::mutable_schema_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreHeartBeatRequest.schema_infos)
  return schema_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaHeartBeat >*
StoreHeartBeatRequest::mutable_schema_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreHeartBeatRequest.schema_infos)
  return &schema_infos_;
}
inline const ::baikaldb::pb::SchemaHeartBeat& StoreHeartBeatRequest::_internal_schema_infos(int index) const {
  return schema_infos_.Get(index);
}
inline const ::baikaldb::pb::SchemaHeartBeat& StoreHeartBeatRequest::schema_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatRequest.schema_infos)
  return _internal_schema_infos(index);
}
inline ::baikaldb::pb::SchemaHeartBeat* StoreHeartBeatRequest::_internal_add_schema_infos() {
  return schema_infos_.Add();
}
inline ::baikaldb::pb::SchemaHeartBeat* StoreHeartBeatRequest::add_schema_infos() {
  ::baikaldb::pb::SchemaHeartBeat* _add = _internal_add_schema_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreHeartBeatRequest.schema_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaHeartBeat >&
StoreHeartBeatRequest::schema_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreHeartBeatRequest.schema_infos)
  return schema_infos_;
}

// repeated .baikaldb.pb.LeaderHeartBeat leader_regions = 3;
inline int StoreHeartBeatRequest::_internal_leader_regions_size() const {
  return leader_regions_.size();
}
inline int StoreHeartBeatRequest::leader_regions_size() const {
  return _internal_leader_regions_size();
}
inline void StoreHeartBeatRequest::clear_leader_regions() {
  leader_regions_.Clear();
}
inline ::baikaldb::pb::LeaderHeartBeat* StoreHeartBeatRequest::mutable_leader_regions(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreHeartBeatRequest.leader_regions)
  return leader_regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::LeaderHeartBeat >*
StoreHeartBeatRequest::mutable_leader_regions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreHeartBeatRequest.leader_regions)
  return &leader_regions_;
}
inline const ::baikaldb::pb::LeaderHeartBeat& StoreHeartBeatRequest::_internal_leader_regions(int index) const {
  return leader_regions_.Get(index);
}
inline const ::baikaldb::pb::LeaderHeartBeat& StoreHeartBeatRequest::leader_regions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatRequest.leader_regions)
  return _internal_leader_regions(index);
}
inline ::baikaldb::pb::LeaderHeartBeat* StoreHeartBeatRequest::_internal_add_leader_regions() {
  return leader_regions_.Add();
}
inline ::baikaldb::pb::LeaderHeartBeat* StoreHeartBeatRequest::add_leader_regions() {
  ::baikaldb::pb::LeaderHeartBeat* _add = _internal_add_leader_regions();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreHeartBeatRequest.leader_regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::LeaderHeartBeat >&
StoreHeartBeatRequest::leader_regions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreHeartBeatRequest.leader_regions)
  return leader_regions_;
}

// repeated .baikaldb.pb.PeerHeartBeat peer_infos = 4;
inline int StoreHeartBeatRequest::_internal_peer_infos_size() const {
  return peer_infos_.size();
}
inline int StoreHeartBeatRequest::peer_infos_size() const {
  return _internal_peer_infos_size();
}
inline void StoreHeartBeatRequest::clear_peer_infos() {
  peer_infos_.Clear();
}
inline ::baikaldb::pb::PeerHeartBeat* StoreHeartBeatRequest::mutable_peer_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreHeartBeatRequest.peer_infos)
  return peer_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerHeartBeat >*
StoreHeartBeatRequest::mutable_peer_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreHeartBeatRequest.peer_infos)
  return &peer_infos_;
}
inline const ::baikaldb::pb::PeerHeartBeat& StoreHeartBeatRequest::_internal_peer_infos(int index) const {
  return peer_infos_.Get(index);
}
inline const ::baikaldb::pb::PeerHeartBeat& StoreHeartBeatRequest::peer_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatRequest.peer_infos)
  return _internal_peer_infos(index);
}
inline ::baikaldb::pb::PeerHeartBeat* StoreHeartBeatRequest::_internal_add_peer_infos() {
  return peer_infos_.Add();
}
inline ::baikaldb::pb::PeerHeartBeat* StoreHeartBeatRequest::add_peer_infos() {
  ::baikaldb::pb::PeerHeartBeat* _add = _internal_add_peer_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreHeartBeatRequest.peer_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PeerHeartBeat >&
StoreHeartBeatRequest::peer_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreHeartBeatRequest.peer_infos)
  return peer_infos_;
}

// optional bool need_leader_balance = 5;
inline bool StoreHeartBeatRequest::_internal_has_need_leader_balance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreHeartBeatRequest::has_need_leader_balance() const {
  return _internal_has_need_leader_balance();
}
inline void StoreHeartBeatRequest::clear_need_leader_balance() {
  need_leader_balance_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool StoreHeartBeatRequest::_internal_need_leader_balance() const {
  return need_leader_balance_;
}
inline bool StoreHeartBeatRequest::need_leader_balance() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatRequest.need_leader_balance)
  return _internal_need_leader_balance();
}
inline void StoreHeartBeatRequest::_internal_set_need_leader_balance(bool value) {
  _has_bits_[0] |= 0x00000002u;
  need_leader_balance_ = value;
}
inline void StoreHeartBeatRequest::set_need_leader_balance(bool value) {
  _internal_set_need_leader_balance(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreHeartBeatRequest.need_leader_balance)
}

// optional bool need_peer_balance = 6;
inline bool StoreHeartBeatRequest::_internal_has_need_peer_balance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreHeartBeatRequest::has_need_peer_balance() const {
  return _internal_has_need_peer_balance();
}
inline void StoreHeartBeatRequest::clear_need_peer_balance() {
  need_peer_balance_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool StoreHeartBeatRequest::_internal_need_peer_balance() const {
  return need_peer_balance_;
}
inline bool StoreHeartBeatRequest::need_peer_balance() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatRequest.need_peer_balance)
  return _internal_need_peer_balance();
}
inline void StoreHeartBeatRequest::_internal_set_need_peer_balance(bool value) {
  _has_bits_[0] |= 0x00000004u;
  need_peer_balance_ = value;
}
inline void StoreHeartBeatRequest::set_need_peer_balance(bool value) {
  _internal_set_need_peer_balance(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreHeartBeatRequest.need_peer_balance)
}

// repeated .baikaldb.pb.DdlWorkInfoHeartBeat ddlwork_infos = 7;
inline int StoreHeartBeatRequest::_internal_ddlwork_infos_size() const {
  return ddlwork_infos_.size();
}
inline int StoreHeartBeatRequest::ddlwork_infos_size() const {
  return _internal_ddlwork_infos_size();
}
inline void StoreHeartBeatRequest::clear_ddlwork_infos() {
  ddlwork_infos_.Clear();
}
inline ::baikaldb::pb::DdlWorkInfoHeartBeat* StoreHeartBeatRequest::mutable_ddlwork_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreHeartBeatRequest.ddlwork_infos)
  return ddlwork_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfoHeartBeat >*
StoreHeartBeatRequest::mutable_ddlwork_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreHeartBeatRequest.ddlwork_infos)
  return &ddlwork_infos_;
}
inline const ::baikaldb::pb::DdlWorkInfoHeartBeat& StoreHeartBeatRequest::_internal_ddlwork_infos(int index) const {
  return ddlwork_infos_.Get(index);
}
inline const ::baikaldb::pb::DdlWorkInfoHeartBeat& StoreHeartBeatRequest::ddlwork_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatRequest.ddlwork_infos)
  return _internal_ddlwork_infos(index);
}
inline ::baikaldb::pb::DdlWorkInfoHeartBeat* StoreHeartBeatRequest::_internal_add_ddlwork_infos() {
  return ddlwork_infos_.Add();
}
inline ::baikaldb::pb::DdlWorkInfoHeartBeat* StoreHeartBeatRequest::add_ddlwork_infos() {
  ::baikaldb::pb::DdlWorkInfoHeartBeat* _add = _internal_add_ddlwork_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreHeartBeatRequest.ddlwork_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfoHeartBeat >&
StoreHeartBeatRequest::ddlwork_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreHeartBeatRequest.ddlwork_infos)
  return ddlwork_infos_;
}

// repeated .baikaldb.pb.LearnerHeartBeat learner_regions = 8;
inline int StoreHeartBeatRequest::_internal_learner_regions_size() const {
  return learner_regions_.size();
}
inline int StoreHeartBeatRequest::learner_regions_size() const {
  return _internal_learner_regions_size();
}
inline void StoreHeartBeatRequest::clear_learner_regions() {
  learner_regions_.Clear();
}
inline ::baikaldb::pb::LearnerHeartBeat* StoreHeartBeatRequest::mutable_learner_regions(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreHeartBeatRequest.learner_regions)
  return learner_regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::LearnerHeartBeat >*
StoreHeartBeatRequest::mutable_learner_regions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreHeartBeatRequest.learner_regions)
  return &learner_regions_;
}
inline const ::baikaldb::pb::LearnerHeartBeat& StoreHeartBeatRequest::_internal_learner_regions(int index) const {
  return learner_regions_.Get(index);
}
inline const ::baikaldb::pb::LearnerHeartBeat& StoreHeartBeatRequest::learner_regions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatRequest.learner_regions)
  return _internal_learner_regions(index);
}
inline ::baikaldb::pb::LearnerHeartBeat* StoreHeartBeatRequest::_internal_add_learner_regions() {
  return learner_regions_.Add();
}
inline ::baikaldb::pb::LearnerHeartBeat* StoreHeartBeatRequest::add_learner_regions() {
  ::baikaldb::pb::LearnerHeartBeat* _add = _internal_add_learner_regions();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreHeartBeatRequest.learner_regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::LearnerHeartBeat >&
StoreHeartBeatRequest::learner_regions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreHeartBeatRequest.learner_regions)
  return learner_regions_;
}

// repeated .baikaldb.pb.BinlogPeerState binlog_ts_infos = 9;
inline int StoreHeartBeatRequest::_internal_binlog_ts_infos_size() const {
  return binlog_ts_infos_.size();
}
inline int StoreHeartBeatRequest::binlog_ts_infos_size() const {
  return _internal_binlog_ts_infos_size();
}
inline void StoreHeartBeatRequest::clear_binlog_ts_infos() {
  binlog_ts_infos_.Clear();
}
inline ::baikaldb::pb::BinlogPeerState* StoreHeartBeatRequest::mutable_binlog_ts_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreHeartBeatRequest.binlog_ts_infos)
  return binlog_ts_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogPeerState >*
StoreHeartBeatRequest::mutable_binlog_ts_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreHeartBeatRequest.binlog_ts_infos)
  return &binlog_ts_infos_;
}
inline const ::baikaldb::pb::BinlogPeerState& StoreHeartBeatRequest::_internal_binlog_ts_infos(int index) const {
  return binlog_ts_infos_.Get(index);
}
inline const ::baikaldb::pb::BinlogPeerState& StoreHeartBeatRequest::binlog_ts_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatRequest.binlog_ts_infos)
  return _internal_binlog_ts_infos(index);
}
inline ::baikaldb::pb::BinlogPeerState* StoreHeartBeatRequest::_internal_add_binlog_ts_infos() {
  return binlog_ts_infos_.Add();
}
inline ::baikaldb::pb::BinlogPeerState* StoreHeartBeatRequest::add_binlog_ts_infos() {
  ::baikaldb::pb::BinlogPeerState* _add = _internal_add_binlog_ts_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreHeartBeatRequest.binlog_ts_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogPeerState >&
StoreHeartBeatRequest::binlog_ts_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreHeartBeatRequest.binlog_ts_infos)
  return binlog_ts_infos_;
}

// -------------------------------------------------------------------

// StoreHeartBeatResponse

// required .baikaldb.pb.ErrCode errcode = 1;
inline bool StoreHeartBeatResponse::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreHeartBeatResponse::has_errcode() const {
  return _internal_has_errcode();
}
inline void StoreHeartBeatResponse::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::baikaldb::pb::ErrCode StoreHeartBeatResponse::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::ErrCode >(errcode_);
}
inline ::baikaldb::pb::ErrCode StoreHeartBeatResponse::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatResponse.errcode)
  return _internal_errcode();
}
inline void StoreHeartBeatResponse::_internal_set_errcode(::baikaldb::pb::ErrCode value) {
  assert(::baikaldb::pb::ErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  errcode_ = value;
}
inline void StoreHeartBeatResponse::set_errcode(::baikaldb::pb::ErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreHeartBeatResponse.errcode)
}

// optional string errmsg = 2;
inline bool StoreHeartBeatResponse::_internal_has_errmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreHeartBeatResponse::has_errmsg() const {
  return _internal_has_errmsg();
}
inline void StoreHeartBeatResponse::clear_errmsg() {
  errmsg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreHeartBeatResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatResponse.errmsg)
  return _internal_errmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreHeartBeatResponse::set_errmsg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreHeartBeatResponse.errmsg)
}
inline std::string* StoreHeartBeatResponse::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreHeartBeatResponse.errmsg)
  return _s;
}
inline const std::string& StoreHeartBeatResponse::_internal_errmsg() const {
  return errmsg_.Get();
}
inline void StoreHeartBeatResponse::_internal_set_errmsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreHeartBeatResponse::_internal_mutable_errmsg() {
  _has_bits_[0] |= 0x00000001u;
  return errmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreHeartBeatResponse::release_errmsg() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreHeartBeatResponse.errmsg)
  if (!_internal_has_errmsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return errmsg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StoreHeartBeatResponse::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreHeartBeatResponse.errmsg)
}

// repeated .baikaldb.pb.SchemaInfo schema_change_info = 3;
inline int StoreHeartBeatResponse::_internal_schema_change_info_size() const {
  return schema_change_info_.size();
}
inline int StoreHeartBeatResponse::schema_change_info_size() const {
  return _internal_schema_change_info_size();
}
inline void StoreHeartBeatResponse::clear_schema_change_info() {
  schema_change_info_.Clear();
}
inline ::baikaldb::pb::SchemaInfo* StoreHeartBeatResponse::mutable_schema_change_info(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreHeartBeatResponse.schema_change_info)
  return schema_change_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaInfo >*
StoreHeartBeatResponse::mutable_schema_change_info() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreHeartBeatResponse.schema_change_info)
  return &schema_change_info_;
}
inline const ::baikaldb::pb::SchemaInfo& StoreHeartBeatResponse::_internal_schema_change_info(int index) const {
  return schema_change_info_.Get(index);
}
inline const ::baikaldb::pb::SchemaInfo& StoreHeartBeatResponse::schema_change_info(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatResponse.schema_change_info)
  return _internal_schema_change_info(index);
}
inline ::baikaldb::pb::SchemaInfo* StoreHeartBeatResponse::_internal_add_schema_change_info() {
  return schema_change_info_.Add();
}
inline ::baikaldb::pb::SchemaInfo* StoreHeartBeatResponse::add_schema_change_info() {
  ::baikaldb::pb::SchemaInfo* _add = _internal_add_schema_change_info();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreHeartBeatResponse.schema_change_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaInfo >&
StoreHeartBeatResponse::schema_change_info() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreHeartBeatResponse.schema_change_info)
  return schema_change_info_;
}

// repeated int64 delete_region_ids = 4;
inline int StoreHeartBeatResponse::_internal_delete_region_ids_size() const {
  return delete_region_ids_.size();
}
inline int StoreHeartBeatResponse::delete_region_ids_size() const {
  return _internal_delete_region_ids_size();
}
inline void StoreHeartBeatResponse::clear_delete_region_ids() {
  delete_region_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreHeartBeatResponse::_internal_delete_region_ids(int index) const {
  return delete_region_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreHeartBeatResponse::delete_region_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatResponse.delete_region_ids)
  return _internal_delete_region_ids(index);
}
inline void StoreHeartBeatResponse::set_delete_region_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  delete_region_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreHeartBeatResponse.delete_region_ids)
}
inline void StoreHeartBeatResponse::_internal_add_delete_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  delete_region_ids_.Add(value);
}
inline void StoreHeartBeatResponse::add_delete_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_delete_region_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreHeartBeatResponse.delete_region_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
StoreHeartBeatResponse::_internal_delete_region_ids() const {
  return delete_region_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
StoreHeartBeatResponse::delete_region_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreHeartBeatResponse.delete_region_ids)
  return _internal_delete_region_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
StoreHeartBeatResponse::_internal_mutable_delete_region_ids() {
  return &delete_region_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
StoreHeartBeatResponse::mutable_delete_region_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreHeartBeatResponse.delete_region_ids)
  return _internal_mutable_delete_region_ids();
}

// repeated .baikaldb.pb.AddPeer add_peers = 5;
inline int StoreHeartBeatResponse::_internal_add_peers_size() const {
  return add_peers_.size();
}
inline int StoreHeartBeatResponse::add_peers_size() const {
  return _internal_add_peers_size();
}
inline void StoreHeartBeatResponse::clear_add_peers() {
  add_peers_.Clear();
}
inline ::baikaldb::pb::AddPeer* StoreHeartBeatResponse::mutable_add_peers(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreHeartBeatResponse.add_peers)
  return add_peers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::AddPeer >*
StoreHeartBeatResponse::mutable_add_peers() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreHeartBeatResponse.add_peers)
  return &add_peers_;
}
inline const ::baikaldb::pb::AddPeer& StoreHeartBeatResponse::_internal_add_peers(int index) const {
  return add_peers_.Get(index);
}
inline const ::baikaldb::pb::AddPeer& StoreHeartBeatResponse::add_peers(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatResponse.add_peers)
  return _internal_add_peers(index);
}
inline ::baikaldb::pb::AddPeer* StoreHeartBeatResponse::_internal_add_add_peers() {
  return add_peers_.Add();
}
inline ::baikaldb::pb::AddPeer* StoreHeartBeatResponse::add_add_peers() {
  ::baikaldb::pb::AddPeer* _add = _internal_add_add_peers();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreHeartBeatResponse.add_peers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::AddPeer >&
StoreHeartBeatResponse::add_peers() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreHeartBeatResponse.add_peers)
  return add_peers_;
}

// optional string leader = 6;
inline bool StoreHeartBeatResponse::_internal_has_leader() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreHeartBeatResponse::has_leader() const {
  return _internal_has_leader();
}
inline void StoreHeartBeatResponse::clear_leader() {
  leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StoreHeartBeatResponse::leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatResponse.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreHeartBeatResponse::set_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreHeartBeatResponse.leader)
}
inline std::string* StoreHeartBeatResponse::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreHeartBeatResponse.leader)
  return _s;
}
inline const std::string& StoreHeartBeatResponse::_internal_leader() const {
  return leader_.Get();
}
inline void StoreHeartBeatResponse::_internal_set_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreHeartBeatResponse::_internal_mutable_leader() {
  _has_bits_[0] |= 0x00000002u;
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreHeartBeatResponse::release_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.StoreHeartBeatResponse.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StoreHeartBeatResponse::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.StoreHeartBeatResponse.leader)
}

// repeated .baikaldb.pb.TransLeaderRequest trans_leader = 7;
inline int StoreHeartBeatResponse::_internal_trans_leader_size() const {
  return trans_leader_.size();
}
inline int StoreHeartBeatResponse::trans_leader_size() const {
  return _internal_trans_leader_size();
}
inline void StoreHeartBeatResponse::clear_trans_leader() {
  trans_leader_.Clear();
}
inline ::baikaldb::pb::TransLeaderRequest* StoreHeartBeatResponse::mutable_trans_leader(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreHeartBeatResponse.trans_leader)
  return trans_leader_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TransLeaderRequest >*
StoreHeartBeatResponse::mutable_trans_leader() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreHeartBeatResponse.trans_leader)
  return &trans_leader_;
}
inline const ::baikaldb::pb::TransLeaderRequest& StoreHeartBeatResponse::_internal_trans_leader(int index) const {
  return trans_leader_.Get(index);
}
inline const ::baikaldb::pb::TransLeaderRequest& StoreHeartBeatResponse::trans_leader(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatResponse.trans_leader)
  return _internal_trans_leader(index);
}
inline ::baikaldb::pb::TransLeaderRequest* StoreHeartBeatResponse::_internal_add_trans_leader() {
  return trans_leader_.Add();
}
inline ::baikaldb::pb::TransLeaderRequest* StoreHeartBeatResponse::add_trans_leader() {
  ::baikaldb::pb::TransLeaderRequest* _add = _internal_add_trans_leader();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreHeartBeatResponse.trans_leader)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TransLeaderRequest >&
StoreHeartBeatResponse::trans_leader() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreHeartBeatResponse.trans_leader)
  return trans_leader_;
}

// repeated int64 trans_leader_table_id = 8;
inline int StoreHeartBeatResponse::_internal_trans_leader_table_id_size() const {
  return trans_leader_table_id_.size();
}
inline int StoreHeartBeatResponse::trans_leader_table_id_size() const {
  return _internal_trans_leader_table_id_size();
}
inline void StoreHeartBeatResponse::clear_trans_leader_table_id() {
  trans_leader_table_id_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreHeartBeatResponse::_internal_trans_leader_table_id(int index) const {
  return trans_leader_table_id_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreHeartBeatResponse::trans_leader_table_id(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatResponse.trans_leader_table_id)
  return _internal_trans_leader_table_id(index);
}
inline void StoreHeartBeatResponse::set_trans_leader_table_id(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  trans_leader_table_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreHeartBeatResponse.trans_leader_table_id)
}
inline void StoreHeartBeatResponse::_internal_add_trans_leader_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  trans_leader_table_id_.Add(value);
}
inline void StoreHeartBeatResponse::add_trans_leader_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_trans_leader_table_id(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreHeartBeatResponse.trans_leader_table_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
StoreHeartBeatResponse::_internal_trans_leader_table_id() const {
  return trans_leader_table_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
StoreHeartBeatResponse::trans_leader_table_id() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreHeartBeatResponse.trans_leader_table_id)
  return _internal_trans_leader_table_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
StoreHeartBeatResponse::_internal_mutable_trans_leader_table_id() {
  return &trans_leader_table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
StoreHeartBeatResponse::mutable_trans_leader_table_id() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreHeartBeatResponse.trans_leader_table_id)
  return _internal_mutable_trans_leader_table_id();
}

// repeated int64 trans_leader_count = 9;
inline int StoreHeartBeatResponse::_internal_trans_leader_count_size() const {
  return trans_leader_count_.size();
}
inline int StoreHeartBeatResponse::trans_leader_count_size() const {
  return _internal_trans_leader_count_size();
}
inline void StoreHeartBeatResponse::clear_trans_leader_count() {
  trans_leader_count_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreHeartBeatResponse::_internal_trans_leader_count(int index) const {
  return trans_leader_count_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StoreHeartBeatResponse::trans_leader_count(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatResponse.trans_leader_count)
  return _internal_trans_leader_count(index);
}
inline void StoreHeartBeatResponse::set_trans_leader_count(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  trans_leader_count_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreHeartBeatResponse.trans_leader_count)
}
inline void StoreHeartBeatResponse::_internal_add_trans_leader_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  trans_leader_count_.Add(value);
}
inline void StoreHeartBeatResponse::add_trans_leader_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_trans_leader_count(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreHeartBeatResponse.trans_leader_count)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
StoreHeartBeatResponse::_internal_trans_leader_count() const {
  return trans_leader_count_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
StoreHeartBeatResponse::trans_leader_count() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreHeartBeatResponse.trans_leader_count)
  return _internal_trans_leader_count();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
StoreHeartBeatResponse::_internal_mutable_trans_leader_count() {
  return &trans_leader_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
StoreHeartBeatResponse::mutable_trans_leader_count() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreHeartBeatResponse.trans_leader_count)
  return _internal_mutable_trans_leader_count();
}

// repeated .baikaldb.pb.DdlWorkInfo ddlwork_infos = 10;
inline int StoreHeartBeatResponse::_internal_ddlwork_infos_size() const {
  return ddlwork_infos_.size();
}
inline int StoreHeartBeatResponse::ddlwork_infos_size() const {
  return _internal_ddlwork_infos_size();
}
inline void StoreHeartBeatResponse::clear_ddlwork_infos() {
  ddlwork_infos_.Clear();
}
inline ::baikaldb::pb::DdlWorkInfo* StoreHeartBeatResponse::mutable_ddlwork_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreHeartBeatResponse.ddlwork_infos)
  return ddlwork_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >*
StoreHeartBeatResponse::mutable_ddlwork_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreHeartBeatResponse.ddlwork_infos)
  return &ddlwork_infos_;
}
inline const ::baikaldb::pb::DdlWorkInfo& StoreHeartBeatResponse::_internal_ddlwork_infos(int index) const {
  return ddlwork_infos_.Get(index);
}
inline const ::baikaldb::pb::DdlWorkInfo& StoreHeartBeatResponse::ddlwork_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatResponse.ddlwork_infos)
  return _internal_ddlwork_infos(index);
}
inline ::baikaldb::pb::DdlWorkInfo* StoreHeartBeatResponse::_internal_add_ddlwork_infos() {
  return ddlwork_infos_.Add();
}
inline ::baikaldb::pb::DdlWorkInfo* StoreHeartBeatResponse::add_ddlwork_infos() {
  ::baikaldb::pb::DdlWorkInfo* _add = _internal_add_ddlwork_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreHeartBeatResponse.ddlwork_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >&
StoreHeartBeatResponse::ddlwork_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreHeartBeatResponse.ddlwork_infos)
  return ddlwork_infos_;
}

// repeated .baikaldb.pb.InstanceParam instance_params = 11;
inline int StoreHeartBeatResponse::_internal_instance_params_size() const {
  return instance_params_.size();
}
inline int StoreHeartBeatResponse::instance_params_size() const {
  return _internal_instance_params_size();
}
inline void StoreHeartBeatResponse::clear_instance_params() {
  instance_params_.Clear();
}
inline ::baikaldb::pb::InstanceParam* StoreHeartBeatResponse::mutable_instance_params(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.StoreHeartBeatResponse.instance_params)
  return instance_params_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam >*
StoreHeartBeatResponse::mutable_instance_params() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.StoreHeartBeatResponse.instance_params)
  return &instance_params_;
}
inline const ::baikaldb::pb::InstanceParam& StoreHeartBeatResponse::_internal_instance_params(int index) const {
  return instance_params_.Get(index);
}
inline const ::baikaldb::pb::InstanceParam& StoreHeartBeatResponse::instance_params(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatResponse.instance_params)
  return _internal_instance_params(index);
}
inline ::baikaldb::pb::InstanceParam* StoreHeartBeatResponse::_internal_add_instance_params() {
  return instance_params_.Add();
}
inline ::baikaldb::pb::InstanceParam* StoreHeartBeatResponse::add_instance_params() {
  ::baikaldb::pb::InstanceParam* _add = _internal_add_instance_params();
  // @@protoc_insertion_point(field_add:baikaldb.pb.StoreHeartBeatResponse.instance_params)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam >&
StoreHeartBeatResponse::instance_params() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.StoreHeartBeatResponse.instance_params)
  return instance_params_;
}

// optional bool need_report = 12;
inline bool StoreHeartBeatResponse::_internal_has_need_report() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StoreHeartBeatResponse::has_need_report() const {
  return _internal_has_need_report();
}
inline void StoreHeartBeatResponse::clear_need_report() {
  need_report_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool StoreHeartBeatResponse::_internal_need_report() const {
  return need_report_;
}
inline bool StoreHeartBeatResponse::need_report() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.StoreHeartBeatResponse.need_report)
  return _internal_need_report();
}
inline void StoreHeartBeatResponse::_internal_set_need_report(bool value) {
  _has_bits_[0] |= 0x00000008u;
  need_report_ = value;
}
inline void StoreHeartBeatResponse::set_need_report(bool value) {
  _internal_set_need_report(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.StoreHeartBeatResponse.need_report)
}

// -------------------------------------------------------------------

// RegionHeartBeat

// required int64 region_id = 1;
inline bool RegionHeartBeat::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionHeartBeat::has_region_id() const {
  return _internal_has_region_id();
}
inline void RegionHeartBeat::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionHeartBeat::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionHeartBeat::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionHeartBeat.region_id)
  return _internal_region_id();
}
inline void RegionHeartBeat::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  region_id_ = value;
}
inline void RegionHeartBeat::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionHeartBeat.region_id)
}

// required int64 version = 2;
inline bool RegionHeartBeat::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegionHeartBeat::has_version() const {
  return _internal_has_version();
}
inline void RegionHeartBeat::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionHeartBeat::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionHeartBeat::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionHeartBeat.version)
  return _internal_version();
}
inline void RegionHeartBeat::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  version_ = value;
}
inline void RegionHeartBeat::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionHeartBeat.version)
}

// required int64 conf_version = 3;
inline bool RegionHeartBeat::_internal_has_conf_version() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RegionHeartBeat::has_conf_version() const {
  return _internal_has_conf_version();
}
inline void RegionHeartBeat::clear_conf_version() {
  conf_version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionHeartBeat::_internal_conf_version() const {
  return conf_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionHeartBeat::conf_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionHeartBeat.conf_version)
  return _internal_conf_version();
}
inline void RegionHeartBeat::_internal_set_conf_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  conf_version_ = value;
}
inline void RegionHeartBeat::set_conf_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_conf_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionHeartBeat.conf_version)
}

// optional string leader = 4;
inline bool RegionHeartBeat::_internal_has_leader() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegionHeartBeat::has_leader() const {
  return _internal_has_leader();
}
inline void RegionHeartBeat::clear_leader() {
  leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionHeartBeat::leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionHeartBeat.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionHeartBeat::set_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionHeartBeat.leader)
}
inline std::string* RegionHeartBeat::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionHeartBeat.leader)
  return _s;
}
inline const std::string& RegionHeartBeat::_internal_leader() const {
  return leader_.Get();
}
inline void RegionHeartBeat::_internal_set_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionHeartBeat::_internal_mutable_leader() {
  _has_bits_[0] |= 0x00000001u;
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionHeartBeat::release_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionHeartBeat.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionHeartBeat::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionHeartBeat.leader)
}

// optional bool need_update = 5;
inline bool RegionHeartBeat::_internal_has_need_update() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RegionHeartBeat::has_need_update() const {
  return _internal_has_need_update();
}
inline void RegionHeartBeat::clear_need_update() {
  need_update_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool RegionHeartBeat::_internal_need_update() const {
  return need_update_;
}
inline bool RegionHeartBeat::need_update() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionHeartBeat.need_update)
  return _internal_need_update();
}
inline void RegionHeartBeat::_internal_set_need_update(bool value) {
  _has_bits_[0] |= 0x00000040u;
  need_update_ = value;
}
inline void RegionHeartBeat::set_need_update(bool value) {
  _internal_set_need_update(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionHeartBeat.need_update)
}

// optional int64 num_table_lines = 6;
inline bool RegionHeartBeat::_internal_has_num_table_lines() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RegionHeartBeat::has_num_table_lines() const {
  return _internal_has_num_table_lines();
}
inline void RegionHeartBeat::clear_num_table_lines() {
  num_table_lines_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionHeartBeat::_internal_num_table_lines() const {
  return num_table_lines_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionHeartBeat::num_table_lines() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionHeartBeat.num_table_lines)
  return _internal_num_table_lines();
}
inline void RegionHeartBeat::_internal_set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  num_table_lines_ = value;
}
inline void RegionHeartBeat::set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_num_table_lines(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionHeartBeat.num_table_lines)
}

// optional int64 used_size = 7;
inline bool RegionHeartBeat::_internal_has_used_size() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RegionHeartBeat::has_used_size() const {
  return _internal_has_used_size();
}
inline void RegionHeartBeat::clear_used_size() {
  used_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionHeartBeat::_internal_used_size() const {
  return used_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionHeartBeat::used_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionHeartBeat.used_size)
  return _internal_used_size();
}
inline void RegionHeartBeat::_internal_set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  used_size_ = value;
}
inline void RegionHeartBeat::set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_used_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionHeartBeat.used_size)
}

// -------------------------------------------------------------------

// BaikalSchemaHeartBeat

// required int64 table_id = 1;
inline bool BaikalSchemaHeartBeat::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BaikalSchemaHeartBeat::has_table_id() const {
  return _internal_has_table_id();
}
inline void BaikalSchemaHeartBeat::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalSchemaHeartBeat::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalSchemaHeartBeat::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalSchemaHeartBeat.table_id)
  return _internal_table_id();
}
inline void BaikalSchemaHeartBeat::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  table_id_ = value;
}
inline void BaikalSchemaHeartBeat::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalSchemaHeartBeat.table_id)
}

// required int64 version = 2;
inline bool BaikalSchemaHeartBeat::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BaikalSchemaHeartBeat::has_version() const {
  return _internal_has_version();
}
inline void BaikalSchemaHeartBeat::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalSchemaHeartBeat::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalSchemaHeartBeat::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalSchemaHeartBeat.version)
  return _internal_version();
}
inline void BaikalSchemaHeartBeat::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
}
inline void BaikalSchemaHeartBeat::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalSchemaHeartBeat.version)
}

// -------------------------------------------------------------------

// BaikalHeartBeatTable

// required string namespace_name = 1;
inline bool BaikalHeartBeatTable::_internal_has_namespace_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BaikalHeartBeatTable::has_namespace_name() const {
  return _internal_has_namespace_name();
}
inline void BaikalHeartBeatTable::clear_namespace_name() {
  namespace_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BaikalHeartBeatTable::namespace_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatTable.namespace_name)
  return _internal_namespace_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaikalHeartBeatTable::set_namespace_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalHeartBeatTable.namespace_name)
}
inline std::string* BaikalHeartBeatTable::mutable_namespace_name() {
  std::string* _s = _internal_mutable_namespace_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatTable.namespace_name)
  return _s;
}
inline const std::string& BaikalHeartBeatTable::_internal_namespace_name() const {
  return namespace_name_.Get();
}
inline void BaikalHeartBeatTable::_internal_set_namespace_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BaikalHeartBeatTable::_internal_mutable_namespace_name() {
  _has_bits_[0] |= 0x00000001u;
  return namespace_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BaikalHeartBeatTable::release_namespace_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BaikalHeartBeatTable.namespace_name)
  if (!_internal_has_namespace_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return namespace_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BaikalHeartBeatTable::set_allocated_namespace_name(std::string* namespace_name) {
  if (namespace_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  namespace_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BaikalHeartBeatTable.namespace_name)
}

// required string database = 2;
inline bool BaikalHeartBeatTable::_internal_has_database() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BaikalHeartBeatTable::has_database() const {
  return _internal_has_database();
}
inline void BaikalHeartBeatTable::clear_database() {
  database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BaikalHeartBeatTable::database() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatTable.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaikalHeartBeatTable::set_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalHeartBeatTable.database)
}
inline std::string* BaikalHeartBeatTable::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatTable.database)
  return _s;
}
inline const std::string& BaikalHeartBeatTable::_internal_database() const {
  return database_.Get();
}
inline void BaikalHeartBeatTable::_internal_set_database(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BaikalHeartBeatTable::_internal_mutable_database() {
  _has_bits_[0] |= 0x00000002u;
  return database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BaikalHeartBeatTable::release_database() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BaikalHeartBeatTable.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BaikalHeartBeatTable::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BaikalHeartBeatTable.database)
}

// required string table_name = 3;
inline bool BaikalHeartBeatTable::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BaikalHeartBeatTable::has_table_name() const {
  return _internal_has_table_name();
}
inline void BaikalHeartBeatTable::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BaikalHeartBeatTable::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatTable.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaikalHeartBeatTable::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalHeartBeatTable.table_name)
}
inline std::string* BaikalHeartBeatTable::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatTable.table_name)
  return _s;
}
inline const std::string& BaikalHeartBeatTable::_internal_table_name() const {
  return table_name_.Get();
}
inline void BaikalHeartBeatTable::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BaikalHeartBeatTable::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000004u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BaikalHeartBeatTable::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BaikalHeartBeatTable.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BaikalHeartBeatTable::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BaikalHeartBeatTable.table_name)
}

// optional int64 table_id = 4;
inline bool BaikalHeartBeatTable::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BaikalHeartBeatTable::has_table_id() const {
  return _internal_has_table_id();
}
inline void BaikalHeartBeatTable::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalHeartBeatTable::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalHeartBeatTable::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatTable.table_id)
  return _internal_table_id();
}
inline void BaikalHeartBeatTable::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  table_id_ = value;
}
inline void BaikalHeartBeatTable::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalHeartBeatTable.table_id)
}

// optional bool is_new = 5;
inline bool BaikalHeartBeatTable::_internal_has_is_new() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BaikalHeartBeatTable::has_is_new() const {
  return _internal_has_is_new();
}
inline void BaikalHeartBeatTable::clear_is_new() {
  is_new_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool BaikalHeartBeatTable::_internal_is_new() const {
  return is_new_;
}
inline bool BaikalHeartBeatTable::is_new() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatTable.is_new)
  return _internal_is_new();
}
inline void BaikalHeartBeatTable::_internal_set_is_new(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_new_ = value;
}
inline void BaikalHeartBeatTable::set_is_new(bool value) {
  _internal_set_is_new(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalHeartBeatTable.is_new)
}

// repeated int64 partition_ids = 6;
inline int BaikalHeartBeatTable::_internal_partition_ids_size() const {
  return partition_ids_.size();
}
inline int BaikalHeartBeatTable::partition_ids_size() const {
  return _internal_partition_ids_size();
}
inline void BaikalHeartBeatTable::clear_partition_ids() {
  partition_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalHeartBeatTable::_internal_partition_ids(int index) const {
  return partition_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalHeartBeatTable::partition_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatTable.partition_ids)
  return _internal_partition_ids(index);
}
inline void BaikalHeartBeatTable::set_partition_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  partition_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalHeartBeatTable.partition_ids)
}
inline void BaikalHeartBeatTable::_internal_add_partition_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  partition_ids_.Add(value);
}
inline void BaikalHeartBeatTable::add_partition_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_partition_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalHeartBeatTable.partition_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
BaikalHeartBeatTable::_internal_partition_ids() const {
  return partition_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
BaikalHeartBeatTable::partition_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalHeartBeatTable.partition_ids)
  return _internal_partition_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
BaikalHeartBeatTable::_internal_mutable_partition_ids() {
  return &partition_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
BaikalHeartBeatTable::mutable_partition_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalHeartBeatTable.partition_ids)
  return _internal_mutable_partition_ids();
}

// -------------------------------------------------------------------

// BaikalHeartBeatRequest

// repeated .baikaldb.pb.BaikalSchemaHeartBeat schema_infos = 1;
inline int BaikalHeartBeatRequest::_internal_schema_infos_size() const {
  return schema_infos_.size();
}
inline int BaikalHeartBeatRequest::schema_infos_size() const {
  return _internal_schema_infos_size();
}
inline void BaikalHeartBeatRequest::clear_schema_infos() {
  schema_infos_.Clear();
}
inline ::baikaldb::pb::BaikalSchemaHeartBeat* BaikalHeartBeatRequest::mutable_schema_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatRequest.schema_infos)
  return schema_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalSchemaHeartBeat >*
BaikalHeartBeatRequest::mutable_schema_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalHeartBeatRequest.schema_infos)
  return &schema_infos_;
}
inline const ::baikaldb::pb::BaikalSchemaHeartBeat& BaikalHeartBeatRequest::_internal_schema_infos(int index) const {
  return schema_infos_.Get(index);
}
inline const ::baikaldb::pb::BaikalSchemaHeartBeat& BaikalHeartBeatRequest::schema_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatRequest.schema_infos)
  return _internal_schema_infos(index);
}
inline ::baikaldb::pb::BaikalSchemaHeartBeat* BaikalHeartBeatRequest::_internal_add_schema_infos() {
  return schema_infos_.Add();
}
inline ::baikaldb::pb::BaikalSchemaHeartBeat* BaikalHeartBeatRequest::add_schema_infos() {
  ::baikaldb::pb::BaikalSchemaHeartBeat* _add = _internal_add_schema_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalHeartBeatRequest.schema_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalSchemaHeartBeat >&
BaikalHeartBeatRequest::schema_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalHeartBeatRequest.schema_infos)
  return schema_infos_;
}

// optional int64 last_updated_index = 2;
inline bool BaikalHeartBeatRequest::_internal_has_last_updated_index() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BaikalHeartBeatRequest::has_last_updated_index() const {
  return _internal_has_last_updated_index();
}
inline void BaikalHeartBeatRequest::clear_last_updated_index() {
  last_updated_index_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalHeartBeatRequest::_internal_last_updated_index() const {
  return last_updated_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalHeartBeatRequest::last_updated_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatRequest.last_updated_index)
  return _internal_last_updated_index();
}
inline void BaikalHeartBeatRequest::_internal_set_last_updated_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  last_updated_index_ = value;
}
inline void BaikalHeartBeatRequest::set_last_updated_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_last_updated_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalHeartBeatRequest.last_updated_index)
}

// repeated .baikaldb.pb.RegionDdlWork region_ddl_works = 4;
inline int BaikalHeartBeatRequest::_internal_region_ddl_works_size() const {
  return region_ddl_works_.size();
}
inline int BaikalHeartBeatRequest::region_ddl_works_size() const {
  return _internal_region_ddl_works_size();
}
inline void BaikalHeartBeatRequest::clear_region_ddl_works() {
  region_ddl_works_.Clear();
}
inline ::baikaldb::pb::RegionDdlWork* BaikalHeartBeatRequest::mutable_region_ddl_works(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatRequest.region_ddl_works)
  return region_ddl_works_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionDdlWork >*
BaikalHeartBeatRequest::mutable_region_ddl_works() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalHeartBeatRequest.region_ddl_works)
  return &region_ddl_works_;
}
inline const ::baikaldb::pb::RegionDdlWork& BaikalHeartBeatRequest::_internal_region_ddl_works(int index) const {
  return region_ddl_works_.Get(index);
}
inline const ::baikaldb::pb::RegionDdlWork& BaikalHeartBeatRequest::region_ddl_works(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatRequest.region_ddl_works)
  return _internal_region_ddl_works(index);
}
inline ::baikaldb::pb::RegionDdlWork* BaikalHeartBeatRequest::_internal_add_region_ddl_works() {
  return region_ddl_works_.Add();
}
inline ::baikaldb::pb::RegionDdlWork* BaikalHeartBeatRequest::add_region_ddl_works() {
  ::baikaldb::pb::RegionDdlWork* _add = _internal_add_region_ddl_works();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalHeartBeatRequest.region_ddl_works)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionDdlWork >&
BaikalHeartBeatRequest::region_ddl_works() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalHeartBeatRequest.region_ddl_works)
  return region_ddl_works_;
}

// repeated .baikaldb.pb.DdlWorkInfo ddl_works = 5;
inline int BaikalHeartBeatRequest::_internal_ddl_works_size() const {
  return ddl_works_.size();
}
inline int BaikalHeartBeatRequest::ddl_works_size() const {
  return _internal_ddl_works_size();
}
inline void BaikalHeartBeatRequest::clear_ddl_works() {
  ddl_works_.Clear();
}
inline ::baikaldb::pb::DdlWorkInfo* BaikalHeartBeatRequest::mutable_ddl_works(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatRequest.ddl_works)
  return ddl_works_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >*
BaikalHeartBeatRequest::mutable_ddl_works() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalHeartBeatRequest.ddl_works)
  return &ddl_works_;
}
inline const ::baikaldb::pb::DdlWorkInfo& BaikalHeartBeatRequest::_internal_ddl_works(int index) const {
  return ddl_works_.Get(index);
}
inline const ::baikaldb::pb::DdlWorkInfo& BaikalHeartBeatRequest::ddl_works(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatRequest.ddl_works)
  return _internal_ddl_works(index);
}
inline ::baikaldb::pb::DdlWorkInfo* BaikalHeartBeatRequest::_internal_add_ddl_works() {
  return ddl_works_.Add();
}
inline ::baikaldb::pb::DdlWorkInfo* BaikalHeartBeatRequest::add_ddl_works() {
  ::baikaldb::pb::DdlWorkInfo* _add = _internal_add_ddl_works();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalHeartBeatRequest.ddl_works)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >&
BaikalHeartBeatRequest::ddl_works() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalHeartBeatRequest.ddl_works)
  return ddl_works_;
}

// optional bool can_do_ddlwork = 6;
inline bool BaikalHeartBeatRequest::_internal_has_can_do_ddlwork() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BaikalHeartBeatRequest::has_can_do_ddlwork() const {
  return _internal_has_can_do_ddlwork();
}
inline void BaikalHeartBeatRequest::clear_can_do_ddlwork() {
  can_do_ddlwork_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool BaikalHeartBeatRequest::_internal_can_do_ddlwork() const {
  return can_do_ddlwork_;
}
inline bool BaikalHeartBeatRequest::can_do_ddlwork() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatRequest.can_do_ddlwork)
  return _internal_can_do_ddlwork();
}
inline void BaikalHeartBeatRequest::_internal_set_can_do_ddlwork(bool value) {
  _has_bits_[0] |= 0x00000008u;
  can_do_ddlwork_ = value;
}
inline void BaikalHeartBeatRequest::set_can_do_ddlwork(bool value) {
  _internal_set_can_do_ddlwork(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalHeartBeatRequest.can_do_ddlwork)
}

// optional string physical_room = 7;
inline bool BaikalHeartBeatRequest::_internal_has_physical_room() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BaikalHeartBeatRequest::has_physical_room() const {
  return _internal_has_physical_room();
}
inline void BaikalHeartBeatRequest::clear_physical_room() {
  physical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BaikalHeartBeatRequest::physical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatRequest.physical_room)
  return _internal_physical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaikalHeartBeatRequest::set_physical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalHeartBeatRequest.physical_room)
}
inline std::string* BaikalHeartBeatRequest::mutable_physical_room() {
  std::string* _s = _internal_mutable_physical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatRequest.physical_room)
  return _s;
}
inline const std::string& BaikalHeartBeatRequest::_internal_physical_room() const {
  return physical_room_.Get();
}
inline void BaikalHeartBeatRequest::_internal_set_physical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BaikalHeartBeatRequest::_internal_mutable_physical_room() {
  _has_bits_[0] |= 0x00000001u;
  return physical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BaikalHeartBeatRequest::release_physical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BaikalHeartBeatRequest.physical_room)
  if (!_internal_has_physical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return physical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BaikalHeartBeatRequest::set_allocated_physical_room(std::string* physical_room) {
  if (physical_room != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  physical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), physical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BaikalHeartBeatRequest.physical_room)
}

// repeated .baikaldb.pb.VirtualIndexInfluence info_affect = 8;
inline int BaikalHeartBeatRequest::_internal_info_affect_size() const {
  return info_affect_.size();
}
inline int BaikalHeartBeatRequest::info_affect_size() const {
  return _internal_info_affect_size();
}
inline void BaikalHeartBeatRequest::clear_info_affect() {
  info_affect_.Clear();
}
inline ::baikaldb::pb::VirtualIndexInfluence* BaikalHeartBeatRequest::mutable_info_affect(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatRequest.info_affect)
  return info_affect_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::VirtualIndexInfluence >*
BaikalHeartBeatRequest::mutable_info_affect() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalHeartBeatRequest.info_affect)
  return &info_affect_;
}
inline const ::baikaldb::pb::VirtualIndexInfluence& BaikalHeartBeatRequest::_internal_info_affect(int index) const {
  return info_affect_.Get(index);
}
inline const ::baikaldb::pb::VirtualIndexInfluence& BaikalHeartBeatRequest::info_affect(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatRequest.info_affect)
  return _internal_info_affect(index);
}
inline ::baikaldb::pb::VirtualIndexInfluence* BaikalHeartBeatRequest::_internal_add_info_affect() {
  return info_affect_.Add();
}
inline ::baikaldb::pb::VirtualIndexInfluence* BaikalHeartBeatRequest::add_info_affect() {
  ::baikaldb::pb::VirtualIndexInfluence* _add = _internal_add_info_affect();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalHeartBeatRequest.info_affect)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::VirtualIndexInfluence >&
BaikalHeartBeatRequest::info_affect() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalHeartBeatRequest.info_affect)
  return info_affect_;
}

// optional bool need_heartbeat_table = 9;
inline bool BaikalHeartBeatRequest::_internal_has_need_heartbeat_table() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BaikalHeartBeatRequest::has_need_heartbeat_table() const {
  return _internal_has_need_heartbeat_table();
}
inline void BaikalHeartBeatRequest::clear_need_heartbeat_table() {
  need_heartbeat_table_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool BaikalHeartBeatRequest::_internal_need_heartbeat_table() const {
  return need_heartbeat_table_;
}
inline bool BaikalHeartBeatRequest::need_heartbeat_table() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatRequest.need_heartbeat_table)
  return _internal_need_heartbeat_table();
}
inline void BaikalHeartBeatRequest::_internal_set_need_heartbeat_table(bool value) {
  _has_bits_[0] |= 0x00000010u;
  need_heartbeat_table_ = value;
}
inline void BaikalHeartBeatRequest::set_need_heartbeat_table(bool value) {
  _internal_set_need_heartbeat_table(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalHeartBeatRequest.need_heartbeat_table)
}

// optional bool need_binlog_heartbeat = 10;
inline bool BaikalHeartBeatRequest::_internal_has_need_binlog_heartbeat() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BaikalHeartBeatRequest::has_need_binlog_heartbeat() const {
  return _internal_has_need_binlog_heartbeat();
}
inline void BaikalHeartBeatRequest::clear_need_binlog_heartbeat() {
  need_binlog_heartbeat_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool BaikalHeartBeatRequest::_internal_need_binlog_heartbeat() const {
  return need_binlog_heartbeat_;
}
inline bool BaikalHeartBeatRequest::need_binlog_heartbeat() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatRequest.need_binlog_heartbeat)
  return _internal_need_binlog_heartbeat();
}
inline void BaikalHeartBeatRequest::_internal_set_need_binlog_heartbeat(bool value) {
  _has_bits_[0] |= 0x00000020u;
  need_binlog_heartbeat_ = value;
}
inline void BaikalHeartBeatRequest::set_need_binlog_heartbeat(bool value) {
  _internal_set_need_binlog_heartbeat(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalHeartBeatRequest.need_binlog_heartbeat)
}

// repeated .baikaldb.pb.BaikalHeartBeatTable heartbeat_tables = 11;
inline int BaikalHeartBeatRequest::_internal_heartbeat_tables_size() const {
  return heartbeat_tables_.size();
}
inline int BaikalHeartBeatRequest::heartbeat_tables_size() const {
  return _internal_heartbeat_tables_size();
}
inline void BaikalHeartBeatRequest::clear_heartbeat_tables() {
  heartbeat_tables_.Clear();
}
inline ::baikaldb::pb::BaikalHeartBeatTable* BaikalHeartBeatRequest::mutable_heartbeat_tables(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatRequest.heartbeat_tables)
  return heartbeat_tables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalHeartBeatTable >*
BaikalHeartBeatRequest::mutable_heartbeat_tables() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalHeartBeatRequest.heartbeat_tables)
  return &heartbeat_tables_;
}
inline const ::baikaldb::pb::BaikalHeartBeatTable& BaikalHeartBeatRequest::_internal_heartbeat_tables(int index) const {
  return heartbeat_tables_.Get(index);
}
inline const ::baikaldb::pb::BaikalHeartBeatTable& BaikalHeartBeatRequest::heartbeat_tables(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatRequest.heartbeat_tables)
  return _internal_heartbeat_tables(index);
}
inline ::baikaldb::pb::BaikalHeartBeatTable* BaikalHeartBeatRequest::_internal_add_heartbeat_tables() {
  return heartbeat_tables_.Add();
}
inline ::baikaldb::pb::BaikalHeartBeatTable* BaikalHeartBeatRequest::add_heartbeat_tables() {
  ::baikaldb::pb::BaikalHeartBeatTable* _add = _internal_add_heartbeat_tables();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalHeartBeatRequest.heartbeat_tables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalHeartBeatTable >&
BaikalHeartBeatRequest::heartbeat_tables() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalHeartBeatRequest.heartbeat_tables)
  return heartbeat_tables_;
}

// optional bool need_global_index_heartbeat = 12;
inline bool BaikalHeartBeatRequest::_internal_has_need_global_index_heartbeat() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BaikalHeartBeatRequest::has_need_global_index_heartbeat() const {
  return _internal_has_need_global_index_heartbeat();
}
inline void BaikalHeartBeatRequest::clear_need_global_index_heartbeat() {
  need_global_index_heartbeat_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool BaikalHeartBeatRequest::_internal_need_global_index_heartbeat() const {
  return need_global_index_heartbeat_;
}
inline bool BaikalHeartBeatRequest::need_global_index_heartbeat() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatRequest.need_global_index_heartbeat)
  return _internal_need_global_index_heartbeat();
}
inline void BaikalHeartBeatRequest::_internal_set_need_global_index_heartbeat(bool value) {
  _has_bits_[0] |= 0x00000040u;
  need_global_index_heartbeat_ = value;
}
inline void BaikalHeartBeatRequest::set_need_global_index_heartbeat(bool value) {
  _internal_set_need_global_index_heartbeat(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalHeartBeatRequest.need_global_index_heartbeat)
}

// optional .baikaldb.pb.BaikalStatus baikal_status = 13;
inline bool BaikalHeartBeatRequest::_internal_has_baikal_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || baikal_status_ != nullptr);
  return value;
}
inline bool BaikalHeartBeatRequest::has_baikal_status() const {
  return _internal_has_baikal_status();
}
inline void BaikalHeartBeatRequest::clear_baikal_status() {
  if (baikal_status_ != nullptr) baikal_status_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::baikaldb::pb::BaikalStatus& BaikalHeartBeatRequest::_internal_baikal_status() const {
  const ::baikaldb::pb::BaikalStatus* p = baikal_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::BaikalStatus&>(
      ::baikaldb::pb::_BaikalStatus_default_instance_);
}
inline const ::baikaldb::pb::BaikalStatus& BaikalHeartBeatRequest::baikal_status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatRequest.baikal_status)
  return _internal_baikal_status();
}
inline void BaikalHeartBeatRequest::unsafe_arena_set_allocated_baikal_status(
    ::baikaldb::pb::BaikalStatus* baikal_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(baikal_status_);
  }
  baikal_status_ = baikal_status;
  if (baikal_status) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.BaikalHeartBeatRequest.baikal_status)
}
inline ::baikaldb::pb::BaikalStatus* BaikalHeartBeatRequest::release_baikal_status() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::BaikalStatus* temp = baikal_status_;
  baikal_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::BaikalStatus* BaikalHeartBeatRequest::unsafe_arena_release_baikal_status() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BaikalHeartBeatRequest.baikal_status)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::BaikalStatus* temp = baikal_status_;
  baikal_status_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::BaikalStatus* BaikalHeartBeatRequest::_internal_mutable_baikal_status() {
  _has_bits_[0] |= 0x00000002u;
  if (baikal_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::BaikalStatus>(GetArenaForAllocation());
    baikal_status_ = p;
  }
  return baikal_status_;
}
inline ::baikaldb::pb::BaikalStatus* BaikalHeartBeatRequest::mutable_baikal_status() {
  ::baikaldb::pb::BaikalStatus* _msg = _internal_mutable_baikal_status();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatRequest.baikal_status)
  return _msg;
}
inline void BaikalHeartBeatRequest::set_allocated_baikal_status(::baikaldb::pb::BaikalStatus* baikal_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete baikal_status_;
  }
  if (baikal_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::BaikalStatus>::GetOwningArena(baikal_status);
    if (message_arena != submessage_arena) {
      baikal_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, baikal_status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  baikal_status_ = baikal_status;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BaikalHeartBeatRequest.baikal_status)
}

// -------------------------------------------------------------------

// BaikalOtherHeartBeat

// required int64 table_id = 1;
inline bool BaikalOtherHeartBeat::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BaikalOtherHeartBeat::has_table_id() const {
  return _internal_has_table_id();
}
inline void BaikalOtherHeartBeat::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalOtherHeartBeat::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalOtherHeartBeat::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalOtherHeartBeat.table_id)
  return _internal_table_id();
}
inline void BaikalOtherHeartBeat::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  table_id_ = value;
}
inline void BaikalOtherHeartBeat::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalOtherHeartBeat.table_id)
}

// optional int64 statis_version = 2;
inline bool BaikalOtherHeartBeat::_internal_has_statis_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BaikalOtherHeartBeat::has_statis_version() const {
  return _internal_has_statis_version();
}
inline void BaikalOtherHeartBeat::clear_statis_version() {
  statis_version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalOtherHeartBeat::_internal_statis_version() const {
  return statis_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalOtherHeartBeat::statis_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalOtherHeartBeat.statis_version)
  return _internal_statis_version();
}
inline void BaikalOtherHeartBeat::_internal_set_statis_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  statis_version_ = value;
}
inline void BaikalOtherHeartBeat::set_statis_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_statis_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalOtherHeartBeat.statis_version)
}

// -------------------------------------------------------------------

// BaikalOtherHeartBeatRequest

// repeated .baikaldb.pb.BaikalOtherHeartBeat schema_infos = 1;
inline int BaikalOtherHeartBeatRequest::_internal_schema_infos_size() const {
  return schema_infos_.size();
}
inline int BaikalOtherHeartBeatRequest::schema_infos_size() const {
  return _internal_schema_infos_size();
}
inline void BaikalOtherHeartBeatRequest::clear_schema_infos() {
  schema_infos_.Clear();
}
inline ::baikaldb::pb::BaikalOtherHeartBeat* BaikalOtherHeartBeatRequest::mutable_schema_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalOtherHeartBeatRequest.schema_infos)
  return schema_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalOtherHeartBeat >*
BaikalOtherHeartBeatRequest::mutable_schema_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalOtherHeartBeatRequest.schema_infos)
  return &schema_infos_;
}
inline const ::baikaldb::pb::BaikalOtherHeartBeat& BaikalOtherHeartBeatRequest::_internal_schema_infos(int index) const {
  return schema_infos_.Get(index);
}
inline const ::baikaldb::pb::BaikalOtherHeartBeat& BaikalOtherHeartBeatRequest::schema_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalOtherHeartBeatRequest.schema_infos)
  return _internal_schema_infos(index);
}
inline ::baikaldb::pb::BaikalOtherHeartBeat* BaikalOtherHeartBeatRequest::_internal_add_schema_infos() {
  return schema_infos_.Add();
}
inline ::baikaldb::pb::BaikalOtherHeartBeat* BaikalOtherHeartBeatRequest::add_schema_infos() {
  ::baikaldb::pb::BaikalOtherHeartBeat* _add = _internal_add_schema_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalOtherHeartBeatRequest.schema_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalOtherHeartBeat >&
BaikalOtherHeartBeatRequest::schema_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalOtherHeartBeatRequest.schema_infos)
  return schema_infos_;
}

// optional string baikaldb_resource_tag = 2;
inline bool BaikalOtherHeartBeatRequest::_internal_has_baikaldb_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BaikalOtherHeartBeatRequest::has_baikaldb_resource_tag() const {
  return _internal_has_baikaldb_resource_tag();
}
inline void BaikalOtherHeartBeatRequest::clear_baikaldb_resource_tag() {
  baikaldb_resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BaikalOtherHeartBeatRequest::baikaldb_resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalOtherHeartBeatRequest.baikaldb_resource_tag)
  return _internal_baikaldb_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaikalOtherHeartBeatRequest::set_baikaldb_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 baikaldb_resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalOtherHeartBeatRequest.baikaldb_resource_tag)
}
inline std::string* BaikalOtherHeartBeatRequest::mutable_baikaldb_resource_tag() {
  std::string* _s = _internal_mutable_baikaldb_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalOtherHeartBeatRequest.baikaldb_resource_tag)
  return _s;
}
inline const std::string& BaikalOtherHeartBeatRequest::_internal_baikaldb_resource_tag() const {
  return baikaldb_resource_tag_.Get();
}
inline void BaikalOtherHeartBeatRequest::_internal_set_baikaldb_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  baikaldb_resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BaikalOtherHeartBeatRequest::_internal_mutable_baikaldb_resource_tag() {
  _has_bits_[0] |= 0x00000001u;
  return baikaldb_resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BaikalOtherHeartBeatRequest::release_baikaldb_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BaikalOtherHeartBeatRequest.baikaldb_resource_tag)
  if (!_internal_has_baikaldb_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return baikaldb_resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BaikalOtherHeartBeatRequest::set_allocated_baikaldb_resource_tag(std::string* baikaldb_resource_tag) {
  if (baikaldb_resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  baikaldb_resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), baikaldb_resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BaikalOtherHeartBeatRequest.baikaldb_resource_tag)
}

// -------------------------------------------------------------------

// BaikalOtherHeartBeatResponse

// required .baikaldb.pb.ErrCode errcode = 1;
inline bool BaikalOtherHeartBeatResponse::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BaikalOtherHeartBeatResponse::has_errcode() const {
  return _internal_has_errcode();
}
inline void BaikalOtherHeartBeatResponse::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::baikaldb::pb::ErrCode BaikalOtherHeartBeatResponse::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::ErrCode >(errcode_);
}
inline ::baikaldb::pb::ErrCode BaikalOtherHeartBeatResponse::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalOtherHeartBeatResponse.errcode)
  return _internal_errcode();
}
inline void BaikalOtherHeartBeatResponse::_internal_set_errcode(::baikaldb::pb::ErrCode value) {
  assert(::baikaldb::pb::ErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  errcode_ = value;
}
inline void BaikalOtherHeartBeatResponse::set_errcode(::baikaldb::pb::ErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalOtherHeartBeatResponse.errcode)
}

// optional string errmsg = 2;
inline bool BaikalOtherHeartBeatResponse::_internal_has_errmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BaikalOtherHeartBeatResponse::has_errmsg() const {
  return _internal_has_errmsg();
}
inline void BaikalOtherHeartBeatResponse::clear_errmsg() {
  errmsg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BaikalOtherHeartBeatResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalOtherHeartBeatResponse.errmsg)
  return _internal_errmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaikalOtherHeartBeatResponse::set_errmsg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalOtherHeartBeatResponse.errmsg)
}
inline std::string* BaikalOtherHeartBeatResponse::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalOtherHeartBeatResponse.errmsg)
  return _s;
}
inline const std::string& BaikalOtherHeartBeatResponse::_internal_errmsg() const {
  return errmsg_.Get();
}
inline void BaikalOtherHeartBeatResponse::_internal_set_errmsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BaikalOtherHeartBeatResponse::_internal_mutable_errmsg() {
  _has_bits_[0] |= 0x00000001u;
  return errmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BaikalOtherHeartBeatResponse::release_errmsg() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BaikalOtherHeartBeatResponse.errmsg)
  if (!_internal_has_errmsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return errmsg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BaikalOtherHeartBeatResponse::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BaikalOtherHeartBeatResponse.errmsg)
}

// optional string leader = 3;
inline bool BaikalOtherHeartBeatResponse::_internal_has_leader() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BaikalOtherHeartBeatResponse::has_leader() const {
  return _internal_has_leader();
}
inline void BaikalOtherHeartBeatResponse::clear_leader() {
  leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BaikalOtherHeartBeatResponse::leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalOtherHeartBeatResponse.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaikalOtherHeartBeatResponse::set_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalOtherHeartBeatResponse.leader)
}
inline std::string* BaikalOtherHeartBeatResponse::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalOtherHeartBeatResponse.leader)
  return _s;
}
inline const std::string& BaikalOtherHeartBeatResponse::_internal_leader() const {
  return leader_.Get();
}
inline void BaikalOtherHeartBeatResponse::_internal_set_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BaikalOtherHeartBeatResponse::_internal_mutable_leader() {
  _has_bits_[0] |= 0x00000002u;
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BaikalOtherHeartBeatResponse::release_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BaikalOtherHeartBeatResponse.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BaikalOtherHeartBeatResponse::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BaikalOtherHeartBeatResponse.leader)
}

// repeated .baikaldb.pb.Statistics statistics = 4;
inline int BaikalOtherHeartBeatResponse::_internal_statistics_size() const {
  return statistics_.size();
}
inline int BaikalOtherHeartBeatResponse::statistics_size() const {
  return _internal_statistics_size();
}
inline ::baikaldb::pb::Statistics* BaikalOtherHeartBeatResponse::mutable_statistics(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalOtherHeartBeatResponse.statistics)
  return statistics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Statistics >*
BaikalOtherHeartBeatResponse::mutable_statistics() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalOtherHeartBeatResponse.statistics)
  return &statistics_;
}
inline const ::baikaldb::pb::Statistics& BaikalOtherHeartBeatResponse::_internal_statistics(int index) const {
  return statistics_.Get(index);
}
inline const ::baikaldb::pb::Statistics& BaikalOtherHeartBeatResponse::statistics(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalOtherHeartBeatResponse.statistics)
  return _internal_statistics(index);
}
inline ::baikaldb::pb::Statistics* BaikalOtherHeartBeatResponse::_internal_add_statistics() {
  return statistics_.Add();
}
inline ::baikaldb::pb::Statistics* BaikalOtherHeartBeatResponse::add_statistics() {
  ::baikaldb::pb::Statistics* _add = _internal_add_statistics();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalOtherHeartBeatResponse.statistics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Statistics >&
BaikalOtherHeartBeatResponse::statistics() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalOtherHeartBeatResponse.statistics)
  return statistics_;
}

// repeated .baikaldb.pb.InstanceParam instance_param = 5;
inline int BaikalOtherHeartBeatResponse::_internal_instance_param_size() const {
  return instance_param_.size();
}
inline int BaikalOtherHeartBeatResponse::instance_param_size() const {
  return _internal_instance_param_size();
}
inline void BaikalOtherHeartBeatResponse::clear_instance_param() {
  instance_param_.Clear();
}
inline ::baikaldb::pb::InstanceParam* BaikalOtherHeartBeatResponse::mutable_instance_param(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalOtherHeartBeatResponse.instance_param)
  return instance_param_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam >*
BaikalOtherHeartBeatResponse::mutable_instance_param() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalOtherHeartBeatResponse.instance_param)
  return &instance_param_;
}
inline const ::baikaldb::pb::InstanceParam& BaikalOtherHeartBeatResponse::_internal_instance_param(int index) const {
  return instance_param_.Get(index);
}
inline const ::baikaldb::pb::InstanceParam& BaikalOtherHeartBeatResponse::instance_param(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalOtherHeartBeatResponse.instance_param)
  return _internal_instance_param(index);
}
inline ::baikaldb::pb::InstanceParam* BaikalOtherHeartBeatResponse::_internal_add_instance_param() {
  return instance_param_.Add();
}
inline ::baikaldb::pb::InstanceParam* BaikalOtherHeartBeatResponse::add_instance_param() {
  ::baikaldb::pb::InstanceParam* _add = _internal_add_instance_param();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalOtherHeartBeatResponse.instance_param)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam >&
BaikalOtherHeartBeatResponse::instance_param() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalOtherHeartBeatResponse.instance_param)
  return instance_param_;
}

// -------------------------------------------------------------------

// IdcInfo

// repeated .baikaldb.pb.PhysicalRoom logical_physical_map = 1;
inline int IdcInfo::_internal_logical_physical_map_size() const {
  return logical_physical_map_.size();
}
inline int IdcInfo::logical_physical_map_size() const {
  return _internal_logical_physical_map_size();
}
inline void IdcInfo::clear_logical_physical_map() {
  logical_physical_map_.Clear();
}
inline ::baikaldb::pb::PhysicalRoom* IdcInfo::mutable_logical_physical_map(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.IdcInfo.logical_physical_map)
  return logical_physical_map_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PhysicalRoom >*
IdcInfo::mutable_logical_physical_map() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.IdcInfo.logical_physical_map)
  return &logical_physical_map_;
}
inline const ::baikaldb::pb::PhysicalRoom& IdcInfo::_internal_logical_physical_map(int index) const {
  return logical_physical_map_.Get(index);
}
inline const ::baikaldb::pb::PhysicalRoom& IdcInfo::logical_physical_map(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IdcInfo.logical_physical_map)
  return _internal_logical_physical_map(index);
}
inline ::baikaldb::pb::PhysicalRoom* IdcInfo::_internal_add_logical_physical_map() {
  return logical_physical_map_.Add();
}
inline ::baikaldb::pb::PhysicalRoom* IdcInfo::add_logical_physical_map() {
  ::baikaldb::pb::PhysicalRoom* _add = _internal_add_logical_physical_map();
  // @@protoc_insertion_point(field_add:baikaldb.pb.IdcInfo.logical_physical_map)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PhysicalRoom >&
IdcInfo::logical_physical_map() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.IdcInfo.logical_physical_map)
  return logical_physical_map_;
}

// repeated .baikaldb.pb.InstanceInfo instance_infos = 2;
inline int IdcInfo::_internal_instance_infos_size() const {
  return instance_infos_.size();
}
inline int IdcInfo::instance_infos_size() const {
  return _internal_instance_infos_size();
}
inline void IdcInfo::clear_instance_infos() {
  instance_infos_.Clear();
}
inline ::baikaldb::pb::InstanceInfo* IdcInfo::mutable_instance_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.IdcInfo.instance_infos)
  return instance_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceInfo >*
IdcInfo::mutable_instance_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.IdcInfo.instance_infos)
  return &instance_infos_;
}
inline const ::baikaldb::pb::InstanceInfo& IdcInfo::_internal_instance_infos(int index) const {
  return instance_infos_.Get(index);
}
inline const ::baikaldb::pb::InstanceInfo& IdcInfo::instance_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.IdcInfo.instance_infos)
  return _internal_instance_infos(index);
}
inline ::baikaldb::pb::InstanceInfo* IdcInfo::_internal_add_instance_infos() {
  return instance_infos_.Add();
}
inline ::baikaldb::pb::InstanceInfo* IdcInfo::add_instance_infos() {
  ::baikaldb::pb::InstanceInfo* _add = _internal_add_instance_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.IdcInfo.instance_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceInfo >&
IdcInfo::instance_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.IdcInfo.instance_infos)
  return instance_infos_;
}

// -------------------------------------------------------------------

// BaikalHeartBeatResponse

// required .baikaldb.pb.ErrCode errcode = 1;
inline bool BaikalHeartBeatResponse::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BaikalHeartBeatResponse::has_errcode() const {
  return _internal_has_errcode();
}
inline void BaikalHeartBeatResponse::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::baikaldb::pb::ErrCode BaikalHeartBeatResponse::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::ErrCode >(errcode_);
}
inline ::baikaldb::pb::ErrCode BaikalHeartBeatResponse::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatResponse.errcode)
  return _internal_errcode();
}
inline void BaikalHeartBeatResponse::_internal_set_errcode(::baikaldb::pb::ErrCode value) {
  assert(::baikaldb::pb::ErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  errcode_ = value;
}
inline void BaikalHeartBeatResponse::set_errcode(::baikaldb::pb::ErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalHeartBeatResponse.errcode)
}

// optional string errmsg = 2;
inline bool BaikalHeartBeatResponse::_internal_has_errmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BaikalHeartBeatResponse::has_errmsg() const {
  return _internal_has_errmsg();
}
inline void BaikalHeartBeatResponse::clear_errmsg() {
  errmsg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BaikalHeartBeatResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatResponse.errmsg)
  return _internal_errmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaikalHeartBeatResponse::set_errmsg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalHeartBeatResponse.errmsg)
}
inline std::string* BaikalHeartBeatResponse::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatResponse.errmsg)
  return _s;
}
inline const std::string& BaikalHeartBeatResponse::_internal_errmsg() const {
  return errmsg_.Get();
}
inline void BaikalHeartBeatResponse::_internal_set_errmsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BaikalHeartBeatResponse::_internal_mutable_errmsg() {
  _has_bits_[0] |= 0x00000001u;
  return errmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BaikalHeartBeatResponse::release_errmsg() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BaikalHeartBeatResponse.errmsg)
  if (!_internal_has_errmsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return errmsg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BaikalHeartBeatResponse::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BaikalHeartBeatResponse.errmsg)
}

// optional string leader = 3;
inline bool BaikalHeartBeatResponse::_internal_has_leader() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BaikalHeartBeatResponse::has_leader() const {
  return _internal_has_leader();
}
inline void BaikalHeartBeatResponse::clear_leader() {
  leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BaikalHeartBeatResponse::leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatResponse.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaikalHeartBeatResponse::set_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalHeartBeatResponse.leader)
}
inline std::string* BaikalHeartBeatResponse::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatResponse.leader)
  return _s;
}
inline const std::string& BaikalHeartBeatResponse::_internal_leader() const {
  return leader_.Get();
}
inline void BaikalHeartBeatResponse::_internal_set_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BaikalHeartBeatResponse::_internal_mutable_leader() {
  _has_bits_[0] |= 0x00000002u;
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BaikalHeartBeatResponse::release_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BaikalHeartBeatResponse.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BaikalHeartBeatResponse::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BaikalHeartBeatResponse.leader)
}

// repeated .baikaldb.pb.SchemaInfo schema_change_info = 4;
inline int BaikalHeartBeatResponse::_internal_schema_change_info_size() const {
  return schema_change_info_.size();
}
inline int BaikalHeartBeatResponse::schema_change_info_size() const {
  return _internal_schema_change_info_size();
}
inline void BaikalHeartBeatResponse::clear_schema_change_info() {
  schema_change_info_.Clear();
}
inline ::baikaldb::pb::SchemaInfo* BaikalHeartBeatResponse::mutable_schema_change_info(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatResponse.schema_change_info)
  return schema_change_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaInfo >*
BaikalHeartBeatResponse::mutable_schema_change_info() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalHeartBeatResponse.schema_change_info)
  return &schema_change_info_;
}
inline const ::baikaldb::pb::SchemaInfo& BaikalHeartBeatResponse::_internal_schema_change_info(int index) const {
  return schema_change_info_.Get(index);
}
inline const ::baikaldb::pb::SchemaInfo& BaikalHeartBeatResponse::schema_change_info(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatResponse.schema_change_info)
  return _internal_schema_change_info(index);
}
inline ::baikaldb::pb::SchemaInfo* BaikalHeartBeatResponse::_internal_add_schema_change_info() {
  return schema_change_info_.Add();
}
inline ::baikaldb::pb::SchemaInfo* BaikalHeartBeatResponse::add_schema_change_info() {
  ::baikaldb::pb::SchemaInfo* _add = _internal_add_schema_change_info();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalHeartBeatResponse.schema_change_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaInfo >&
BaikalHeartBeatResponse::schema_change_info() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalHeartBeatResponse.schema_change_info)
  return schema_change_info_;
}

// repeated .baikaldb.pb.RegionInfo region_change_info = 5;
inline int BaikalHeartBeatResponse::_internal_region_change_info_size() const {
  return region_change_info_.size();
}
inline int BaikalHeartBeatResponse::region_change_info_size() const {
  return _internal_region_change_info_size();
}
inline void BaikalHeartBeatResponse::clear_region_change_info() {
  region_change_info_.Clear();
}
inline ::baikaldb::pb::RegionInfo* BaikalHeartBeatResponse::mutable_region_change_info(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatResponse.region_change_info)
  return region_change_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >*
BaikalHeartBeatResponse::mutable_region_change_info() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalHeartBeatResponse.region_change_info)
  return &region_change_info_;
}
inline const ::baikaldb::pb::RegionInfo& BaikalHeartBeatResponse::_internal_region_change_info(int index) const {
  return region_change_info_.Get(index);
}
inline const ::baikaldb::pb::RegionInfo& BaikalHeartBeatResponse::region_change_info(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatResponse.region_change_info)
  return _internal_region_change_info(index);
}
inline ::baikaldb::pb::RegionInfo* BaikalHeartBeatResponse::_internal_add_region_change_info() {
  return region_change_info_.Add();
}
inline ::baikaldb::pb::RegionInfo* BaikalHeartBeatResponse::add_region_change_info() {
  ::baikaldb::pb::RegionInfo* _add = _internal_add_region_change_info();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalHeartBeatResponse.region_change_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >&
BaikalHeartBeatResponse::region_change_info() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalHeartBeatResponse.region_change_info)
  return region_change_info_;
}

// repeated .baikaldb.pb.UserPrivilege privilege_change_info = 6;
inline int BaikalHeartBeatResponse::_internal_privilege_change_info_size() const {
  return privilege_change_info_.size();
}
inline int BaikalHeartBeatResponse::privilege_change_info_size() const {
  return _internal_privilege_change_info_size();
}
inline void BaikalHeartBeatResponse::clear_privilege_change_info() {
  privilege_change_info_.Clear();
}
inline ::baikaldb::pb::UserPrivilege* BaikalHeartBeatResponse::mutable_privilege_change_info(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatResponse.privilege_change_info)
  return privilege_change_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::UserPrivilege >*
BaikalHeartBeatResponse::mutable_privilege_change_info() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalHeartBeatResponse.privilege_change_info)
  return &privilege_change_info_;
}
inline const ::baikaldb::pb::UserPrivilege& BaikalHeartBeatResponse::_internal_privilege_change_info(int index) const {
  return privilege_change_info_.Get(index);
}
inline const ::baikaldb::pb::UserPrivilege& BaikalHeartBeatResponse::privilege_change_info(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatResponse.privilege_change_info)
  return _internal_privilege_change_info(index);
}
inline ::baikaldb::pb::UserPrivilege* BaikalHeartBeatResponse::_internal_add_privilege_change_info() {
  return privilege_change_info_.Add();
}
inline ::baikaldb::pb::UserPrivilege* BaikalHeartBeatResponse::add_privilege_change_info() {
  ::baikaldb::pb::UserPrivilege* _add = _internal_add_privilege_change_info();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalHeartBeatResponse.privilege_change_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::UserPrivilege >&
BaikalHeartBeatResponse::privilege_change_info() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalHeartBeatResponse.privilege_change_info)
  return privilege_change_info_;
}

// optional .baikaldb.pb.IdcInfo idc_info = 7;
inline bool BaikalHeartBeatResponse::_internal_has_idc_info() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || idc_info_ != nullptr);
  return value;
}
inline bool BaikalHeartBeatResponse::has_idc_info() const {
  return _internal_has_idc_info();
}
inline void BaikalHeartBeatResponse::clear_idc_info() {
  if (idc_info_ != nullptr) idc_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::baikaldb::pb::IdcInfo& BaikalHeartBeatResponse::_internal_idc_info() const {
  const ::baikaldb::pb::IdcInfo* p = idc_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::IdcInfo&>(
      ::baikaldb::pb::_IdcInfo_default_instance_);
}
inline const ::baikaldb::pb::IdcInfo& BaikalHeartBeatResponse::idc_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatResponse.idc_info)
  return _internal_idc_info();
}
inline void BaikalHeartBeatResponse::unsafe_arena_set_allocated_idc_info(
    ::baikaldb::pb::IdcInfo* idc_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(idc_info_);
  }
  idc_info_ = idc_info;
  if (idc_info) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.BaikalHeartBeatResponse.idc_info)
}
inline ::baikaldb::pb::IdcInfo* BaikalHeartBeatResponse::release_idc_info() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::IdcInfo* temp = idc_info_;
  idc_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::IdcInfo* BaikalHeartBeatResponse::unsafe_arena_release_idc_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BaikalHeartBeatResponse.idc_info)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::IdcInfo* temp = idc_info_;
  idc_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::IdcInfo* BaikalHeartBeatResponse::_internal_mutable_idc_info() {
  _has_bits_[0] |= 0x00000004u;
  if (idc_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::IdcInfo>(GetArenaForAllocation());
    idc_info_ = p;
  }
  return idc_info_;
}
inline ::baikaldb::pb::IdcInfo* BaikalHeartBeatResponse::mutable_idc_info() {
  ::baikaldb::pb::IdcInfo* _msg = _internal_mutable_idc_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatResponse.idc_info)
  return _msg;
}
inline void BaikalHeartBeatResponse::set_allocated_idc_info(::baikaldb::pb::IdcInfo* idc_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete idc_info_;
  }
  if (idc_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::IdcInfo>::GetOwningArena(idc_info);
    if (message_arena != submessage_arena) {
      idc_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, idc_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  idc_info_ = idc_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BaikalHeartBeatResponse.idc_info)
}

// repeated .baikaldb.pb.DataBaseInfo db_info = 8;
inline int BaikalHeartBeatResponse::_internal_db_info_size() const {
  return db_info_.size();
}
inline int BaikalHeartBeatResponse::db_info_size() const {
  return _internal_db_info_size();
}
inline void BaikalHeartBeatResponse::clear_db_info() {
  db_info_.Clear();
}
inline ::baikaldb::pb::DataBaseInfo* BaikalHeartBeatResponse::mutable_db_info(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatResponse.db_info)
  return db_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DataBaseInfo >*
BaikalHeartBeatResponse::mutable_db_info() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalHeartBeatResponse.db_info)
  return &db_info_;
}
inline const ::baikaldb::pb::DataBaseInfo& BaikalHeartBeatResponse::_internal_db_info(int index) const {
  return db_info_.Get(index);
}
inline const ::baikaldb::pb::DataBaseInfo& BaikalHeartBeatResponse::db_info(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatResponse.db_info)
  return _internal_db_info(index);
}
inline ::baikaldb::pb::DataBaseInfo* BaikalHeartBeatResponse::_internal_add_db_info() {
  return db_info_.Add();
}
inline ::baikaldb::pb::DataBaseInfo* BaikalHeartBeatResponse::add_db_info() {
  ::baikaldb::pb::DataBaseInfo* _add = _internal_add_db_info();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalHeartBeatResponse.db_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DataBaseInfo >&
BaikalHeartBeatResponse::db_info() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalHeartBeatResponse.db_info)
  return db_info_;
}

// optional int64 last_updated_index = 9;
inline bool BaikalHeartBeatResponse::_internal_has_last_updated_index() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BaikalHeartBeatResponse::has_last_updated_index() const {
  return _internal_has_last_updated_index();
}
inline void BaikalHeartBeatResponse::clear_last_updated_index() {
  last_updated_index_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalHeartBeatResponse::_internal_last_updated_index() const {
  return last_updated_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BaikalHeartBeatResponse::last_updated_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatResponse.last_updated_index)
  return _internal_last_updated_index();
}
inline void BaikalHeartBeatResponse::_internal_set_last_updated_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  last_updated_index_ = value;
}
inline void BaikalHeartBeatResponse::set_last_updated_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_last_updated_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaikalHeartBeatResponse.last_updated_index)
}

// repeated .baikaldb.pb.Statistics statistics = 10;
inline int BaikalHeartBeatResponse::_internal_statistics_size() const {
  return statistics_.size();
}
inline int BaikalHeartBeatResponse::statistics_size() const {
  return _internal_statistics_size();
}
inline ::baikaldb::pb::Statistics* BaikalHeartBeatResponse::mutable_statistics(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatResponse.statistics)
  return statistics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Statistics >*
BaikalHeartBeatResponse::mutable_statistics() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalHeartBeatResponse.statistics)
  return &statistics_;
}
inline const ::baikaldb::pb::Statistics& BaikalHeartBeatResponse::_internal_statistics(int index) const {
  return statistics_.Get(index);
}
inline const ::baikaldb::pb::Statistics& BaikalHeartBeatResponse::statistics(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatResponse.statistics)
  return _internal_statistics(index);
}
inline ::baikaldb::pb::Statistics* BaikalHeartBeatResponse::_internal_add_statistics() {
  return statistics_.Add();
}
inline ::baikaldb::pb::Statistics* BaikalHeartBeatResponse::add_statistics() {
  ::baikaldb::pb::Statistics* _add = _internal_add_statistics();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalHeartBeatResponse.statistics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::Statistics >&
BaikalHeartBeatResponse::statistics() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalHeartBeatResponse.statistics)
  return statistics_;
}

// repeated .baikaldb.pb.RegionDdlWork region_ddl_works = 11;
inline int BaikalHeartBeatResponse::_internal_region_ddl_works_size() const {
  return region_ddl_works_.size();
}
inline int BaikalHeartBeatResponse::region_ddl_works_size() const {
  return _internal_region_ddl_works_size();
}
inline void BaikalHeartBeatResponse::clear_region_ddl_works() {
  region_ddl_works_.Clear();
}
inline ::baikaldb::pb::RegionDdlWork* BaikalHeartBeatResponse::mutable_region_ddl_works(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatResponse.region_ddl_works)
  return region_ddl_works_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionDdlWork >*
BaikalHeartBeatResponse::mutable_region_ddl_works() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalHeartBeatResponse.region_ddl_works)
  return &region_ddl_works_;
}
inline const ::baikaldb::pb::RegionDdlWork& BaikalHeartBeatResponse::_internal_region_ddl_works(int index) const {
  return region_ddl_works_.Get(index);
}
inline const ::baikaldb::pb::RegionDdlWork& BaikalHeartBeatResponse::region_ddl_works(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatResponse.region_ddl_works)
  return _internal_region_ddl_works(index);
}
inline ::baikaldb::pb::RegionDdlWork* BaikalHeartBeatResponse::_internal_add_region_ddl_works() {
  return region_ddl_works_.Add();
}
inline ::baikaldb::pb::RegionDdlWork* BaikalHeartBeatResponse::add_region_ddl_works() {
  ::baikaldb::pb::RegionDdlWork* _add = _internal_add_region_ddl_works();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalHeartBeatResponse.region_ddl_works)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionDdlWork >&
BaikalHeartBeatResponse::region_ddl_works() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalHeartBeatResponse.region_ddl_works)
  return region_ddl_works_;
}

// repeated .baikaldb.pb.DdlWorkInfo ddl_works = 12;
inline int BaikalHeartBeatResponse::_internal_ddl_works_size() const {
  return ddl_works_.size();
}
inline int BaikalHeartBeatResponse::ddl_works_size() const {
  return _internal_ddl_works_size();
}
inline void BaikalHeartBeatResponse::clear_ddl_works() {
  ddl_works_.Clear();
}
inline ::baikaldb::pb::DdlWorkInfo* BaikalHeartBeatResponse::mutable_ddl_works(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatResponse.ddl_works)
  return ddl_works_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >*
BaikalHeartBeatResponse::mutable_ddl_works() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalHeartBeatResponse.ddl_works)
  return &ddl_works_;
}
inline const ::baikaldb::pb::DdlWorkInfo& BaikalHeartBeatResponse::_internal_ddl_works(int index) const {
  return ddl_works_.Get(index);
}
inline const ::baikaldb::pb::DdlWorkInfo& BaikalHeartBeatResponse::ddl_works(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatResponse.ddl_works)
  return _internal_ddl_works(index);
}
inline ::baikaldb::pb::DdlWorkInfo* BaikalHeartBeatResponse::_internal_add_ddl_works() {
  return ddl_works_.Add();
}
inline ::baikaldb::pb::DdlWorkInfo* BaikalHeartBeatResponse::add_ddl_works() {
  ::baikaldb::pb::DdlWorkInfo* _add = _internal_add_ddl_works();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalHeartBeatResponse.ddl_works)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >&
BaikalHeartBeatResponse::ddl_works() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalHeartBeatResponse.ddl_works)
  return ddl_works_;
}

// repeated .baikaldb.pb.NameSpaceInfo ns_info = 13;
inline int BaikalHeartBeatResponse::_internal_ns_info_size() const {
  return ns_info_.size();
}
inline int BaikalHeartBeatResponse::ns_info_size() const {
  return _internal_ns_info_size();
}
inline void BaikalHeartBeatResponse::clear_ns_info() {
  ns_info_.Clear();
}
inline ::baikaldb::pb::NameSpaceInfo* BaikalHeartBeatResponse::mutable_ns_info(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatResponse.ns_info)
  return ns_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::NameSpaceInfo >*
BaikalHeartBeatResponse::mutable_ns_info() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalHeartBeatResponse.ns_info)
  return &ns_info_;
}
inline const ::baikaldb::pb::NameSpaceInfo& BaikalHeartBeatResponse::_internal_ns_info(int index) const {
  return ns_info_.Get(index);
}
inline const ::baikaldb::pb::NameSpaceInfo& BaikalHeartBeatResponse::ns_info(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatResponse.ns_info)
  return _internal_ns_info(index);
}
inline ::baikaldb::pb::NameSpaceInfo* BaikalHeartBeatResponse::_internal_add_ns_info() {
  return ns_info_.Add();
}
inline ::baikaldb::pb::NameSpaceInfo* BaikalHeartBeatResponse::add_ns_info() {
  ::baikaldb::pb::NameSpaceInfo* _add = _internal_add_ns_info();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalHeartBeatResponse.ns_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::NameSpaceInfo >&
BaikalHeartBeatResponse::ns_info() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalHeartBeatResponse.ns_info)
  return ns_info_;
}

// repeated .baikaldb.pb.BaikalStatus baikal_status = 14;
inline int BaikalHeartBeatResponse::_internal_baikal_status_size() const {
  return baikal_status_.size();
}
inline int BaikalHeartBeatResponse::baikal_status_size() const {
  return _internal_baikal_status_size();
}
inline void BaikalHeartBeatResponse::clear_baikal_status() {
  baikal_status_.Clear();
}
inline ::baikaldb::pb::BaikalStatus* BaikalHeartBeatResponse::mutable_baikal_status(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaikalHeartBeatResponse.baikal_status)
  return baikal_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalStatus >*
BaikalHeartBeatResponse::mutable_baikal_status() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BaikalHeartBeatResponse.baikal_status)
  return &baikal_status_;
}
inline const ::baikaldb::pb::BaikalStatus& BaikalHeartBeatResponse::_internal_baikal_status(int index) const {
  return baikal_status_.Get(index);
}
inline const ::baikaldb::pb::BaikalStatus& BaikalHeartBeatResponse::baikal_status(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaikalHeartBeatResponse.baikal_status)
  return _internal_baikal_status(index);
}
inline ::baikaldb::pb::BaikalStatus* BaikalHeartBeatResponse::_internal_add_baikal_status() {
  return baikal_status_.Add();
}
inline ::baikaldb::pb::BaikalStatus* BaikalHeartBeatResponse::add_baikal_status() {
  ::baikaldb::pb::BaikalStatus* _add = _internal_add_baikal_status();
  // @@protoc_insertion_point(field_add:baikaldb.pb.BaikalHeartBeatResponse.baikal_status)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BaikalStatus >&
BaikalHeartBeatResponse::baikal_status() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BaikalHeartBeatResponse.baikal_status)
  return baikal_status_;
}

// -------------------------------------------------------------------

// PhysicalInstance

// required string physical_room = 1;
inline bool PhysicalInstance::_internal_has_physical_room() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PhysicalInstance::has_physical_room() const {
  return _internal_has_physical_room();
}
inline void PhysicalInstance::clear_physical_room() {
  physical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PhysicalInstance::physical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PhysicalInstance.physical_room)
  return _internal_physical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhysicalInstance::set_physical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.PhysicalInstance.physical_room)
}
inline std::string* PhysicalInstance::mutable_physical_room() {
  std::string* _s = _internal_mutable_physical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PhysicalInstance.physical_room)
  return _s;
}
inline const std::string& PhysicalInstance::_internal_physical_room() const {
  return physical_room_.Get();
}
inline void PhysicalInstance::_internal_set_physical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PhysicalInstance::_internal_mutable_physical_room() {
  _has_bits_[0] |= 0x00000001u;
  return physical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PhysicalInstance::release_physical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PhysicalInstance.physical_room)
  if (!_internal_has_physical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return physical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PhysicalInstance::set_allocated_physical_room(std::string* physical_room) {
  if (physical_room != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  physical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), physical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PhysicalInstance.physical_room)
}

// required string logical_room = 2;
inline bool PhysicalInstance::_internal_has_logical_room() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PhysicalInstance::has_logical_room() const {
  return _internal_has_logical_room();
}
inline void PhysicalInstance::clear_logical_room() {
  logical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PhysicalInstance::logical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PhysicalInstance.logical_room)
  return _internal_logical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhysicalInstance::set_logical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.PhysicalInstance.logical_room)
}
inline std::string* PhysicalInstance::mutable_logical_room() {
  std::string* _s = _internal_mutable_logical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PhysicalInstance.logical_room)
  return _s;
}
inline const std::string& PhysicalInstance::_internal_logical_room() const {
  return logical_room_.Get();
}
inline void PhysicalInstance::_internal_set_logical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PhysicalInstance::_internal_mutable_logical_room() {
  _has_bits_[0] |= 0x00000002u;
  return logical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PhysicalInstance::release_logical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.PhysicalInstance.logical_room)
  if (!_internal_has_logical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return logical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PhysicalInstance::set_allocated_logical_room(std::string* logical_room) {
  if (logical_room != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  logical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.PhysicalInstance.logical_room)
}

// repeated string instances = 3;
inline int PhysicalInstance::_internal_instances_size() const {
  return instances_.size();
}
inline int PhysicalInstance::instances_size() const {
  return _internal_instances_size();
}
inline void PhysicalInstance::clear_instances() {
  instances_.Clear();
}
inline std::string* PhysicalInstance::add_instances() {
  std::string* _s = _internal_add_instances();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.PhysicalInstance.instances)
  return _s;
}
inline const std::string& PhysicalInstance::_internal_instances(int index) const {
  return instances_.Get(index);
}
inline const std::string& PhysicalInstance::instances(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PhysicalInstance.instances)
  return _internal_instances(index);
}
inline std::string* PhysicalInstance::mutable_instances(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.PhysicalInstance.instances)
  return instances_.Mutable(index);
}
inline void PhysicalInstance::set_instances(int index, const std::string& value) {
  instances_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PhysicalInstance.instances)
}
inline void PhysicalInstance::set_instances(int index, std::string&& value) {
  instances_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.PhysicalInstance.instances)
}
inline void PhysicalInstance::set_instances(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  instances_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.PhysicalInstance.instances)
}
inline void PhysicalInstance::set_instances(int index, const char* value, size_t size) {
  instances_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.PhysicalInstance.instances)
}
inline std::string* PhysicalInstance::_internal_add_instances() {
  return instances_.Add();
}
inline void PhysicalInstance::add_instances(const std::string& value) {
  instances_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.PhysicalInstance.instances)
}
inline void PhysicalInstance::add_instances(std::string&& value) {
  instances_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.PhysicalInstance.instances)
}
inline void PhysicalInstance::add_instances(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  instances_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.PhysicalInstance.instances)
}
inline void PhysicalInstance::add_instances(const char* value, size_t size) {
  instances_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.PhysicalInstance.instances)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PhysicalInstance::instances() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.PhysicalInstance.instances)
  return instances_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PhysicalInstance::mutable_instances() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.PhysicalInstance.instances)
  return &instances_;
}

// -------------------------------------------------------------------

// QueryRequest

// required .baikaldb.pb.QueryOpType op_type = 1;
inline bool QueryRequest::_internal_has_op_type() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool QueryRequest::has_op_type() const {
  return _internal_has_op_type();
}
inline void QueryRequest::clear_op_type() {
  op_type_ = 1;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::baikaldb::pb::QueryOpType QueryRequest::_internal_op_type() const {
  return static_cast< ::baikaldb::pb::QueryOpType >(op_type_);
}
inline ::baikaldb::pb::QueryOpType QueryRequest::op_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRequest.op_type)
  return _internal_op_type();
}
inline void QueryRequest::_internal_set_op_type(::baikaldb::pb::QueryOpType value) {
  assert(::baikaldb::pb::QueryOpType_IsValid(value));
  _has_bits_[0] |= 0x00004000u;
  op_type_ = value;
}
inline void QueryRequest::set_op_type(::baikaldb::pb::QueryOpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRequest.op_type)
}

// optional string logical_room = 2;
inline bool QueryRequest::_internal_has_logical_room() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryRequest::has_logical_room() const {
  return _internal_has_logical_room();
}
inline void QueryRequest::clear_logical_room() {
  logical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryRequest::logical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRequest.logical_room)
  return _internal_logical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRequest::set_logical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRequest.logical_room)
}
inline std::string* QueryRequest::mutable_logical_room() {
  std::string* _s = _internal_mutable_logical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRequest.logical_room)
  return _s;
}
inline const std::string& QueryRequest::_internal_logical_room() const {
  return logical_room_.Get();
}
inline void QueryRequest::_internal_set_logical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRequest::_internal_mutable_logical_room() {
  _has_bits_[0] |= 0x00000001u;
  return logical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRequest::release_logical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRequest.logical_room)
  if (!_internal_has_logical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return logical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRequest::set_allocated_logical_room(std::string* logical_room) {
  if (logical_room != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  logical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRequest.logical_room)
}

// optional string physical_room = 3;
inline bool QueryRequest::_internal_has_physical_room() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QueryRequest::has_physical_room() const {
  return _internal_has_physical_room();
}
inline void QueryRequest::clear_physical_room() {
  physical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryRequest::physical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRequest.physical_room)
  return _internal_physical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRequest::set_physical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRequest.physical_room)
}
inline std::string* QueryRequest::mutable_physical_room() {
  std::string* _s = _internal_mutable_physical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRequest.physical_room)
  return _s;
}
inline const std::string& QueryRequest::_internal_physical_room() const {
  return physical_room_.Get();
}
inline void QueryRequest::_internal_set_physical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRequest::_internal_mutable_physical_room() {
  _has_bits_[0] |= 0x00000002u;
  return physical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRequest::release_physical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRequest.physical_room)
  if (!_internal_has_physical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return physical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRequest::set_allocated_physical_room(std::string* physical_room) {
  if (physical_room != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  physical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), physical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRequest.physical_room)
}

// optional string instance_address = 4;
inline bool QueryRequest::_internal_has_instance_address() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QueryRequest::has_instance_address() const {
  return _internal_has_instance_address();
}
inline void QueryRequest::clear_instance_address() {
  instance_address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& QueryRequest::instance_address() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRequest.instance_address)
  return _internal_instance_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRequest::set_instance_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 instance_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRequest.instance_address)
}
inline std::string* QueryRequest::mutable_instance_address() {
  std::string* _s = _internal_mutable_instance_address();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRequest.instance_address)
  return _s;
}
inline const std::string& QueryRequest::_internal_instance_address() const {
  return instance_address_.Get();
}
inline void QueryRequest::_internal_set_instance_address(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  instance_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRequest::_internal_mutable_instance_address() {
  _has_bits_[0] |= 0x00000004u;
  return instance_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRequest::release_instance_address() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRequest.instance_address)
  if (!_internal_has_instance_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return instance_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRequest::set_allocated_instance_address(std::string* instance_address) {
  if (instance_address != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  instance_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), instance_address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRequest.instance_address)
}

// optional string user_name = 5;
inline bool QueryRequest::_internal_has_user_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QueryRequest::has_user_name() const {
  return _internal_has_user_name();
}
inline void QueryRequest::clear_user_name() {
  user_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& QueryRequest::user_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRequest.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRequest::set_user_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRequest.user_name)
}
inline std::string* QueryRequest::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRequest.user_name)
  return _s;
}
inline const std::string& QueryRequest::_internal_user_name() const {
  return user_name_.Get();
}
inline void QueryRequest::_internal_set_user_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRequest::_internal_mutable_user_name() {
  _has_bits_[0] |= 0x00000008u;
  return user_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRequest::release_user_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRequest.user_name)
  if (!_internal_has_user_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return user_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRequest::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  user_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRequest.user_name)
}

// optional string namespace_name = 6;
inline bool QueryRequest::_internal_has_namespace_name() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QueryRequest::has_namespace_name() const {
  return _internal_has_namespace_name();
}
inline void QueryRequest::clear_namespace_name() {
  namespace_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& QueryRequest::namespace_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRequest.namespace_name)
  return _internal_namespace_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRequest::set_namespace_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRequest.namespace_name)
}
inline std::string* QueryRequest::mutable_namespace_name() {
  std::string* _s = _internal_mutable_namespace_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRequest.namespace_name)
  return _s;
}
inline const std::string& QueryRequest::_internal_namespace_name() const {
  return namespace_name_.Get();
}
inline void QueryRequest::_internal_set_namespace_name(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRequest::_internal_mutable_namespace_name() {
  _has_bits_[0] |= 0x00000010u;
  return namespace_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRequest::release_namespace_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRequest.namespace_name)
  if (!_internal_has_namespace_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return namespace_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRequest::set_allocated_namespace_name(std::string* namespace_name) {
  if (namespace_name != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  namespace_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRequest.namespace_name)
}

// optional string database = 7;
inline bool QueryRequest::_internal_has_database() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool QueryRequest::has_database() const {
  return _internal_has_database();
}
inline void QueryRequest::clear_database() {
  database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& QueryRequest::database() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRequest.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRequest::set_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRequest.database)
}
inline std::string* QueryRequest::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRequest.database)
  return _s;
}
inline const std::string& QueryRequest::_internal_database() const {
  return database_.Get();
}
inline void QueryRequest::_internal_set_database(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRequest::_internal_mutable_database() {
  _has_bits_[0] |= 0x00000020u;
  return database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRequest::release_database() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRequest.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRequest::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRequest.database)
}

// optional string table_name = 8;
inline bool QueryRequest::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool QueryRequest::has_table_name() const {
  return _internal_has_table_name();
}
inline void QueryRequest::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& QueryRequest::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRequest.table_name)
}
inline std::string* QueryRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRequest.table_name)
  return _s;
}
inline const std::string& QueryRequest::_internal_table_name() const {
  return table_name_.Get();
}
inline void QueryRequest::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRequest::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000040u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRequest.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRequest.table_name)
}

// repeated int64 region_ids = 9;
inline int QueryRequest::_internal_region_ids_size() const {
  return region_ids_.size();
}
inline int QueryRequest::region_ids_size() const {
  return _internal_region_ids_size();
}
inline void QueryRequest::clear_region_ids() {
  region_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRequest::_internal_region_ids(int index) const {
  return region_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRequest::region_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRequest.region_ids)
  return _internal_region_ids(index);
}
inline void QueryRequest::set_region_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  region_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRequest.region_ids)
}
inline void QueryRequest::_internal_add_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  region_ids_.Add(value);
}
inline void QueryRequest::add_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_region_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryRequest.region_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
QueryRequest::_internal_region_ids() const {
  return region_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
QueryRequest::region_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryRequest.region_ids)
  return _internal_region_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
QueryRequest::_internal_mutable_region_ids() {
  return &region_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
QueryRequest::mutable_region_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryRequest.region_ids)
  return _internal_mutable_region_ids();
}

// optional string old_leader = 10;
inline bool QueryRequest::_internal_has_old_leader() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool QueryRequest::has_old_leader() const {
  return _internal_has_old_leader();
}
inline void QueryRequest::clear_old_leader() {
  old_leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& QueryRequest::old_leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRequest.old_leader)
  return _internal_old_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRequest::set_old_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 old_leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRequest.old_leader)
}
inline std::string* QueryRequest::mutable_old_leader() {
  std::string* _s = _internal_mutable_old_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRequest.old_leader)
  return _s;
}
inline const std::string& QueryRequest::_internal_old_leader() const {
  return old_leader_.Get();
}
inline void QueryRequest::_internal_set_old_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  old_leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRequest::_internal_mutable_old_leader() {
  _has_bits_[0] |= 0x00000080u;
  return old_leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRequest::release_old_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRequest.old_leader)
  if (!_internal_has_old_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return old_leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRequest::set_allocated_old_leader(std::string* old_leader) {
  if (old_leader != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  old_leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), old_leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRequest.old_leader)
}

// optional string new_leader = 11;
inline bool QueryRequest::_internal_has_new_leader() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool QueryRequest::has_new_leader() const {
  return _internal_has_new_leader();
}
inline void QueryRequest::clear_new_leader() {
  new_leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& QueryRequest::new_leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRequest.new_leader)
  return _internal_new_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRequest::set_new_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 new_leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRequest.new_leader)
}
inline std::string* QueryRequest::mutable_new_leader() {
  std::string* _s = _internal_mutable_new_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRequest.new_leader)
  return _s;
}
inline const std::string& QueryRequest::_internal_new_leader() const {
  return new_leader_.Get();
}
inline void QueryRequest::_internal_set_new_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  new_leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRequest::_internal_mutable_new_leader() {
  _has_bits_[0] |= 0x00000100u;
  return new_leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRequest::release_new_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRequest.new_leader)
  if (!_internal_has_new_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  return new_leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRequest::set_allocated_new_leader(std::string* new_leader) {
  if (new_leader != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  new_leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRequest.new_leader)
}

// optional string old_peers = 12;
inline bool QueryRequest::_internal_has_old_peers() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool QueryRequest::has_old_peers() const {
  return _internal_has_old_peers();
}
inline void QueryRequest::clear_old_peers() {
  old_peers_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& QueryRequest::old_peers() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRequest.old_peers)
  return _internal_old_peers();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRequest::set_old_peers(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 old_peers_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRequest.old_peers)
}
inline std::string* QueryRequest::mutable_old_peers() {
  std::string* _s = _internal_mutable_old_peers();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRequest.old_peers)
  return _s;
}
inline const std::string& QueryRequest::_internal_old_peers() const {
  return old_peers_.Get();
}
inline void QueryRequest::_internal_set_old_peers(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  old_peers_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRequest::_internal_mutable_old_peers() {
  _has_bits_[0] |= 0x00000200u;
  return old_peers_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRequest::release_old_peers() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRequest.old_peers)
  if (!_internal_has_old_peers()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  return old_peers_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRequest::set_allocated_old_peers(std::string* old_peers) {
  if (old_peers != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  old_peers_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), old_peers,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRequest.old_peers)
}

// optional string new_peers = 13;
inline bool QueryRequest::_internal_has_new_peers() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool QueryRequest::has_new_peers() const {
  return _internal_has_new_peers();
}
inline void QueryRequest::clear_new_peers() {
  new_peers_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& QueryRequest::new_peers() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRequest.new_peers)
  return _internal_new_peers();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRequest::set_new_peers(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 new_peers_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRequest.new_peers)
}
inline std::string* QueryRequest::mutable_new_peers() {
  std::string* _s = _internal_mutable_new_peers();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRequest.new_peers)
  return _s;
}
inline const std::string& QueryRequest::_internal_new_peers() const {
  return new_peers_.Get();
}
inline void QueryRequest::_internal_set_new_peers(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  new_peers_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRequest::_internal_mutable_new_peers() {
  _has_bits_[0] |= 0x00000400u;
  return new_peers_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRequest::release_new_peers() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRequest.new_peers)
  if (!_internal_has_new_peers()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  return new_peers_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRequest::set_allocated_new_peers(std::string* new_peers) {
  if (new_peers != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  new_peers_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_peers,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRequest.new_peers)
}

// optional string resource_tag = 14;
inline bool QueryRequest::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool QueryRequest::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void QueryRequest::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000800u;
}
inline const std::string& QueryRequest::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRequest.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRequest::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000800u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRequest.resource_tag)
}
inline std::string* QueryRequest::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRequest.resource_tag)
  return _s;
}
inline const std::string& QueryRequest::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void QueryRequest::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000800u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRequest::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000800u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRequest::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRequest.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000800u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRequest::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRequest.resource_tag)
}

// optional string str_region_id = 15;
inline bool QueryRequest::_internal_has_str_region_id() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool QueryRequest::has_str_region_id() const {
  return _internal_has_str_region_id();
}
inline void QueryRequest::clear_str_region_id() {
  str_region_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00001000u;
}
inline const std::string& QueryRequest::str_region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRequest.str_region_id)
  return _internal_str_region_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRequest::set_str_region_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00001000u;
 str_region_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRequest.str_region_id)
}
inline std::string* QueryRequest::mutable_str_region_id() {
  std::string* _s = _internal_mutable_str_region_id();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRequest.str_region_id)
  return _s;
}
inline const std::string& QueryRequest::_internal_str_region_id() const {
  return str_region_id_.Get();
}
inline void QueryRequest::_internal_set_str_region_id(const std::string& value) {
  _has_bits_[0] |= 0x00001000u;
  str_region_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRequest::_internal_mutable_str_region_id() {
  _has_bits_[0] |= 0x00001000u;
  return str_region_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRequest::release_str_region_id() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRequest.str_region_id)
  if (!_internal_has_str_region_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00001000u;
  return str_region_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRequest::set_allocated_str_region_id(std::string* str_region_id) {
  if (str_region_id != nullptr) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  str_region_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), str_region_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRequest.str_region_id)
}

// optional int64 table_id = 16;
inline bool QueryRequest::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool QueryRequest::has_table_id() const {
  return _internal_has_table_id();
}
inline void QueryRequest::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRequest::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRequest::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRequest.table_id)
  return _internal_table_id();
}
inline void QueryRequest::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00002000u;
  table_id_ = value;
}
inline void QueryRequest::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRequest.table_id)
}

// -------------------------------------------------------------------

// ResourceTagInfo

// required string resource_tag = 1;
inline bool ResourceTagInfo::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResourceTagInfo::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void ResourceTagInfo::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResourceTagInfo::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ResourceTagInfo.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceTagInfo::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ResourceTagInfo.resource_tag)
}
inline std::string* ResourceTagInfo::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ResourceTagInfo.resource_tag)
  return _s;
}
inline const std::string& ResourceTagInfo::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void ResourceTagInfo::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResourceTagInfo::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000001u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResourceTagInfo::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ResourceTagInfo.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResourceTagInfo::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ResourceTagInfo.resource_tag)
}

// optional bool peer_load_balance = 2;
inline bool ResourceTagInfo::_internal_has_peer_load_balance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResourceTagInfo::has_peer_load_balance() const {
  return _internal_has_peer_load_balance();
}
inline void ResourceTagInfo::clear_peer_load_balance() {
  peer_load_balance_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ResourceTagInfo::_internal_peer_load_balance() const {
  return peer_load_balance_;
}
inline bool ResourceTagInfo::peer_load_balance() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ResourceTagInfo.peer_load_balance)
  return _internal_peer_load_balance();
}
inline void ResourceTagInfo::_internal_set_peer_load_balance(bool value) {
  _has_bits_[0] |= 0x00000002u;
  peer_load_balance_ = value;
}
inline void ResourceTagInfo::set_peer_load_balance(bool value) {
  _internal_set_peer_load_balance(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ResourceTagInfo.peer_load_balance)
}

// optional bool migrate = 3;
inline bool ResourceTagInfo::_internal_has_migrate() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ResourceTagInfo::has_migrate() const {
  return _internal_has_migrate();
}
inline void ResourceTagInfo::clear_migrate() {
  migrate_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ResourceTagInfo::_internal_migrate() const {
  return migrate_;
}
inline bool ResourceTagInfo::migrate() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ResourceTagInfo.migrate)
  return _internal_migrate();
}
inline void ResourceTagInfo::_internal_set_migrate(bool value) {
  _has_bits_[0] |= 0x00000004u;
  migrate_ = value;
}
inline void ResourceTagInfo::set_migrate(bool value) {
  _internal_set_migrate(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ResourceTagInfo.migrate)
}

// optional bool network_segment_balance = 4;
inline bool ResourceTagInfo::_internal_has_network_segment_balance() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ResourceTagInfo::has_network_segment_balance() const {
  return _internal_has_network_segment_balance();
}
inline void ResourceTagInfo::clear_network_segment_balance() {
  network_segment_balance_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ResourceTagInfo::_internal_network_segment_balance() const {
  return network_segment_balance_;
}
inline bool ResourceTagInfo::network_segment_balance() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ResourceTagInfo.network_segment_balance)
  return _internal_network_segment_balance();
}
inline void ResourceTagInfo::_internal_set_network_segment_balance(bool value) {
  _has_bits_[0] |= 0x00000008u;
  network_segment_balance_ = value;
}
inline void ResourceTagInfo::set_network_segment_balance(bool value) {
  _internal_set_network_segment_balance(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ResourceTagInfo.network_segment_balance)
}

// -------------------------------------------------------------------

// VirtualInfoAndSqls

// optional string virtual_index_info = 1;
inline bool VirtualInfoAndSqls::_internal_has_virtual_index_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VirtualInfoAndSqls::has_virtual_index_info() const {
  return _internal_has_virtual_index_info();
}
inline void VirtualInfoAndSqls::clear_virtual_index_info() {
  virtual_index_info_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VirtualInfoAndSqls::virtual_index_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.VirtualInfoAndSqls.virtual_index_info)
  return _internal_virtual_index_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VirtualInfoAndSqls::set_virtual_index_info(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 virtual_index_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.VirtualInfoAndSqls.virtual_index_info)
}
inline std::string* VirtualInfoAndSqls::mutable_virtual_index_info() {
  std::string* _s = _internal_mutable_virtual_index_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.VirtualInfoAndSqls.virtual_index_info)
  return _s;
}
inline const std::string& VirtualInfoAndSqls::_internal_virtual_index_info() const {
  return virtual_index_info_.Get();
}
inline void VirtualInfoAndSqls::_internal_set_virtual_index_info(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  virtual_index_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VirtualInfoAndSqls::_internal_mutable_virtual_index_info() {
  _has_bits_[0] |= 0x00000001u;
  return virtual_index_info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VirtualInfoAndSqls::release_virtual_index_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.VirtualInfoAndSqls.virtual_index_info)
  if (!_internal_has_virtual_index_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return virtual_index_info_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VirtualInfoAndSqls::set_allocated_virtual_index_info(std::string* virtual_index_info) {
  if (virtual_index_info != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  virtual_index_info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), virtual_index_info,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.VirtualInfoAndSqls.virtual_index_info)
}

// optional string affected_sign = 2;
inline bool VirtualInfoAndSqls::_internal_has_affected_sign() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VirtualInfoAndSqls::has_affected_sign() const {
  return _internal_has_affected_sign();
}
inline void VirtualInfoAndSqls::clear_affected_sign() {
  affected_sign_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VirtualInfoAndSqls::affected_sign() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.VirtualInfoAndSqls.affected_sign)
  return _internal_affected_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VirtualInfoAndSqls::set_affected_sign(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 affected_sign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.VirtualInfoAndSqls.affected_sign)
}
inline std::string* VirtualInfoAndSqls::mutable_affected_sign() {
  std::string* _s = _internal_mutable_affected_sign();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.VirtualInfoAndSqls.affected_sign)
  return _s;
}
inline const std::string& VirtualInfoAndSqls::_internal_affected_sign() const {
  return affected_sign_.Get();
}
inline void VirtualInfoAndSqls::_internal_set_affected_sign(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  affected_sign_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VirtualInfoAndSqls::_internal_mutable_affected_sign() {
  _has_bits_[0] |= 0x00000002u;
  return affected_sign_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VirtualInfoAndSqls::release_affected_sign() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.VirtualInfoAndSqls.affected_sign)
  if (!_internal_has_affected_sign()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return affected_sign_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VirtualInfoAndSqls::set_allocated_affected_sign(std::string* affected_sign) {
  if (affected_sign != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  affected_sign_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), affected_sign,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.VirtualInfoAndSqls.affected_sign)
}

// optional string affected_sqls = 3;
inline bool VirtualInfoAndSqls::_internal_has_affected_sqls() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VirtualInfoAndSqls::has_affected_sqls() const {
  return _internal_has_affected_sqls();
}
inline void VirtualInfoAndSqls::clear_affected_sqls() {
  affected_sqls_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& VirtualInfoAndSqls::affected_sqls() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.VirtualInfoAndSqls.affected_sqls)
  return _internal_affected_sqls();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VirtualInfoAndSqls::set_affected_sqls(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 affected_sqls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.VirtualInfoAndSqls.affected_sqls)
}
inline std::string* VirtualInfoAndSqls::mutable_affected_sqls() {
  std::string* _s = _internal_mutable_affected_sqls();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.VirtualInfoAndSqls.affected_sqls)
  return _s;
}
inline const std::string& VirtualInfoAndSqls::_internal_affected_sqls() const {
  return affected_sqls_.Get();
}
inline void VirtualInfoAndSqls::_internal_set_affected_sqls(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  affected_sqls_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VirtualInfoAndSqls::_internal_mutable_affected_sqls() {
  _has_bits_[0] |= 0x00000004u;
  return affected_sqls_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VirtualInfoAndSqls::release_affected_sqls() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.VirtualInfoAndSqls.affected_sqls)
  if (!_internal_has_affected_sqls()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return affected_sqls_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VirtualInfoAndSqls::set_allocated_affected_sqls(std::string* affected_sqls) {
  if (affected_sqls != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  affected_sqls_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), affected_sqls,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.VirtualInfoAndSqls.affected_sqls)
}

// -------------------------------------------------------------------

// BinlogRegionInfo

// required int64 region_id = 1;
inline bool BinlogRegionInfo::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BinlogRegionInfo::has_region_id() const {
  return _internal_has_region_id();
}
inline void BinlogRegionInfo::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogRegionInfo::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BinlogRegionInfo::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogRegionInfo.region_id)
  return _internal_region_id();
}
inline void BinlogRegionInfo::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  region_id_ = value;
}
inline void BinlogRegionInfo::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogRegionInfo.region_id)
}

// repeated string peer_id = 2;
inline int BinlogRegionInfo::_internal_peer_id_size() const {
  return peer_id_.size();
}
inline int BinlogRegionInfo::peer_id_size() const {
  return _internal_peer_id_size();
}
inline void BinlogRegionInfo::clear_peer_id() {
  peer_id_.Clear();
}
inline std::string* BinlogRegionInfo::add_peer_id() {
  std::string* _s = _internal_add_peer_id();
  // @@protoc_insertion_point(field_add_mutable:baikaldb.pb.BinlogRegionInfo.peer_id)
  return _s;
}
inline const std::string& BinlogRegionInfo::_internal_peer_id(int index) const {
  return peer_id_.Get(index);
}
inline const std::string& BinlogRegionInfo::peer_id(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogRegionInfo.peer_id)
  return _internal_peer_id(index);
}
inline std::string* BinlogRegionInfo::mutable_peer_id(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BinlogRegionInfo.peer_id)
  return peer_id_.Mutable(index);
}
inline void BinlogRegionInfo::set_peer_id(int index, const std::string& value) {
  peer_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogRegionInfo.peer_id)
}
inline void BinlogRegionInfo::set_peer_id(int index, std::string&& value) {
  peer_id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogRegionInfo.peer_id)
}
inline void BinlogRegionInfo::set_peer_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  peer_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:baikaldb.pb.BinlogRegionInfo.peer_id)
}
inline void BinlogRegionInfo::set_peer_id(int index, const char* value, size_t size) {
  peer_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:baikaldb.pb.BinlogRegionInfo.peer_id)
}
inline std::string* BinlogRegionInfo::_internal_add_peer_id() {
  return peer_id_.Add();
}
inline void BinlogRegionInfo::add_peer_id(const std::string& value) {
  peer_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.BinlogRegionInfo.peer_id)
}
inline void BinlogRegionInfo::add_peer_id(std::string&& value) {
  peer_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:baikaldb.pb.BinlogRegionInfo.peer_id)
}
inline void BinlogRegionInfo::add_peer_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  peer_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:baikaldb.pb.BinlogRegionInfo.peer_id)
}
inline void BinlogRegionInfo::add_peer_id(const char* value, size_t size) {
  peer_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:baikaldb.pb.BinlogRegionInfo.peer_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BinlogRegionInfo::peer_id() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BinlogRegionInfo.peer_id)
  return peer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BinlogRegionInfo::mutable_peer_id() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BinlogRegionInfo.peer_id)
  return &peer_id_;
}

// repeated uint32 oldest_ts_to_now = 3;
inline int BinlogRegionInfo::_internal_oldest_ts_to_now_size() const {
  return oldest_ts_to_now_.size();
}
inline int BinlogRegionInfo::oldest_ts_to_now_size() const {
  return _internal_oldest_ts_to_now_size();
}
inline void BinlogRegionInfo::clear_oldest_ts_to_now() {
  oldest_ts_to_now_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BinlogRegionInfo::_internal_oldest_ts_to_now(int index) const {
  return oldest_ts_to_now_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BinlogRegionInfo::oldest_ts_to_now(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BinlogRegionInfo.oldest_ts_to_now)
  return _internal_oldest_ts_to_now(index);
}
inline void BinlogRegionInfo::set_oldest_ts_to_now(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  oldest_ts_to_now_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BinlogRegionInfo.oldest_ts_to_now)
}
inline void BinlogRegionInfo::_internal_add_oldest_ts_to_now(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  oldest_ts_to_now_.Add(value);
}
inline void BinlogRegionInfo::add_oldest_ts_to_now(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_oldest_ts_to_now(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.BinlogRegionInfo.oldest_ts_to_now)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
BinlogRegionInfo::_internal_oldest_ts_to_now() const {
  return oldest_ts_to_now_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
BinlogRegionInfo::oldest_ts_to_now() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.BinlogRegionInfo.oldest_ts_to_now)
  return _internal_oldest_ts_to_now();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
BinlogRegionInfo::_internal_mutable_oldest_ts_to_now() {
  return &oldest_ts_to_now_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
BinlogRegionInfo::mutable_oldest_ts_to_now() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.BinlogRegionInfo.oldest_ts_to_now)
  return _internal_mutable_oldest_ts_to_now();
}

// -------------------------------------------------------------------

// QueryResponse

// required .baikaldb.pb.ErrCode errcode = 1;
inline bool QueryResponse::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QueryResponse::has_errcode() const {
  return _internal_has_errcode();
}
inline void QueryResponse::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::baikaldb::pb::ErrCode QueryResponse::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::ErrCode >(errcode_);
}
inline ::baikaldb::pb::ErrCode QueryResponse::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.errcode)
  return _internal_errcode();
}
inline void QueryResponse::_internal_set_errcode(::baikaldb::pb::ErrCode value) {
  assert(::baikaldb::pb::ErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  errcode_ = value;
}
inline void QueryResponse::set_errcode(::baikaldb::pb::ErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryResponse.errcode)
}

// optional string errmsg = 2;
inline bool QueryResponse::_internal_has_errmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryResponse::has_errmsg() const {
  return _internal_has_errmsg();
}
inline void QueryResponse::clear_errmsg() {
  errmsg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.errmsg)
  return _internal_errmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryResponse::set_errmsg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryResponse.errmsg)
}
inline std::string* QueryResponse::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.errmsg)
  return _s;
}
inline const std::string& QueryResponse::_internal_errmsg() const {
  return errmsg_.Get();
}
inline void QueryResponse::_internal_set_errmsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryResponse::_internal_mutable_errmsg() {
  _has_bits_[0] |= 0x00000001u;
  return errmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryResponse::release_errmsg() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryResponse.errmsg)
  if (!_internal_has_errmsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return errmsg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryResponse::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryResponse.errmsg)
}

// optional string leader = 3;
inline bool QueryResponse::_internal_has_leader() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QueryResponse::has_leader() const {
  return _internal_has_leader();
}
inline void QueryResponse::clear_leader() {
  leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryResponse::leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryResponse::set_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryResponse.leader)
}
inline std::string* QueryResponse::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.leader)
  return _s;
}
inline const std::string& QueryResponse::_internal_leader() const {
  return leader_.Get();
}
inline void QueryResponse::_internal_set_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryResponse::_internal_mutable_leader() {
  _has_bits_[0] |= 0x00000002u;
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryResponse::release_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryResponse.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryResponse::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryResponse.leader)
}

// repeated .baikaldb.pb.PhysicalRoom physical_rooms = 4;
inline int QueryResponse::_internal_physical_rooms_size() const {
  return physical_rooms_.size();
}
inline int QueryResponse::physical_rooms_size() const {
  return _internal_physical_rooms_size();
}
inline void QueryResponse::clear_physical_rooms() {
  physical_rooms_.Clear();
}
inline ::baikaldb::pb::PhysicalRoom* QueryResponse::mutable_physical_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.physical_rooms)
  return physical_rooms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PhysicalRoom >*
QueryResponse::mutable_physical_rooms() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.physical_rooms)
  return &physical_rooms_;
}
inline const ::baikaldb::pb::PhysicalRoom& QueryResponse::_internal_physical_rooms(int index) const {
  return physical_rooms_.Get(index);
}
inline const ::baikaldb::pb::PhysicalRoom& QueryResponse::physical_rooms(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.physical_rooms)
  return _internal_physical_rooms(index);
}
inline ::baikaldb::pb::PhysicalRoom* QueryResponse::_internal_add_physical_rooms() {
  return physical_rooms_.Add();
}
inline ::baikaldb::pb::PhysicalRoom* QueryResponse::add_physical_rooms() {
  ::baikaldb::pb::PhysicalRoom* _add = _internal_add_physical_rooms();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.physical_rooms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PhysicalRoom >&
QueryResponse::physical_rooms() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.physical_rooms)
  return physical_rooms_;
}

// repeated .baikaldb.pb.PhysicalInstance physical_instances = 5;
inline int QueryResponse::_internal_physical_instances_size() const {
  return physical_instances_.size();
}
inline int QueryResponse::physical_instances_size() const {
  return _internal_physical_instances_size();
}
inline void QueryResponse::clear_physical_instances() {
  physical_instances_.Clear();
}
inline ::baikaldb::pb::PhysicalInstance* QueryResponse::mutable_physical_instances(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.physical_instances)
  return physical_instances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PhysicalInstance >*
QueryResponse::mutable_physical_instances() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.physical_instances)
  return &physical_instances_;
}
inline const ::baikaldb::pb::PhysicalInstance& QueryResponse::_internal_physical_instances(int index) const {
  return physical_instances_.Get(index);
}
inline const ::baikaldb::pb::PhysicalInstance& QueryResponse::physical_instances(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.physical_instances)
  return _internal_physical_instances(index);
}
inline ::baikaldb::pb::PhysicalInstance* QueryResponse::_internal_add_physical_instances() {
  return physical_instances_.Add();
}
inline ::baikaldb::pb::PhysicalInstance* QueryResponse::add_physical_instances() {
  ::baikaldb::pb::PhysicalInstance* _add = _internal_add_physical_instances();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.physical_instances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::PhysicalInstance >&
QueryResponse::physical_instances() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.physical_instances)
  return physical_instances_;
}

// repeated .baikaldb.pb.InstanceInfo instance_infos = 6;
inline int QueryResponse::_internal_instance_infos_size() const {
  return instance_infos_.size();
}
inline int QueryResponse::instance_infos_size() const {
  return _internal_instance_infos_size();
}
inline void QueryResponse::clear_instance_infos() {
  instance_infos_.Clear();
}
inline ::baikaldb::pb::InstanceInfo* QueryResponse::mutable_instance_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.instance_infos)
  return instance_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceInfo >*
QueryResponse::mutable_instance_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.instance_infos)
  return &instance_infos_;
}
inline const ::baikaldb::pb::InstanceInfo& QueryResponse::_internal_instance_infos(int index) const {
  return instance_infos_.Get(index);
}
inline const ::baikaldb::pb::InstanceInfo& QueryResponse::instance_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.instance_infos)
  return _internal_instance_infos(index);
}
inline ::baikaldb::pb::InstanceInfo* QueryResponse::_internal_add_instance_infos() {
  return instance_infos_.Add();
}
inline ::baikaldb::pb::InstanceInfo* QueryResponse::add_instance_infos() {
  ::baikaldb::pb::InstanceInfo* _add = _internal_add_instance_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.instance_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceInfo >&
QueryResponse::instance_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.instance_infos)
  return instance_infos_;
}

// repeated .baikaldb.pb.UserPrivilege user_privilege = 7;
inline int QueryResponse::_internal_user_privilege_size() const {
  return user_privilege_.size();
}
inline int QueryResponse::user_privilege_size() const {
  return _internal_user_privilege_size();
}
inline void QueryResponse::clear_user_privilege() {
  user_privilege_.Clear();
}
inline ::baikaldb::pb::UserPrivilege* QueryResponse::mutable_user_privilege(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.user_privilege)
  return user_privilege_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::UserPrivilege >*
QueryResponse::mutable_user_privilege() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.user_privilege)
  return &user_privilege_;
}
inline const ::baikaldb::pb::UserPrivilege& QueryResponse::_internal_user_privilege(int index) const {
  return user_privilege_.Get(index);
}
inline const ::baikaldb::pb::UserPrivilege& QueryResponse::user_privilege(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.user_privilege)
  return _internal_user_privilege(index);
}
inline ::baikaldb::pb::UserPrivilege* QueryResponse::_internal_add_user_privilege() {
  return user_privilege_.Add();
}
inline ::baikaldb::pb::UserPrivilege* QueryResponse::add_user_privilege() {
  ::baikaldb::pb::UserPrivilege* _add = _internal_add_user_privilege();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.user_privilege)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::UserPrivilege >&
QueryResponse::user_privilege() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.user_privilege)
  return user_privilege_;
}

// repeated .baikaldb.pb.NameSpaceInfo namespace_infos = 8;
inline int QueryResponse::_internal_namespace_infos_size() const {
  return namespace_infos_.size();
}
inline int QueryResponse::namespace_infos_size() const {
  return _internal_namespace_infos_size();
}
inline void QueryResponse::clear_namespace_infos() {
  namespace_infos_.Clear();
}
inline ::baikaldb::pb::NameSpaceInfo* QueryResponse::mutable_namespace_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.namespace_infos)
  return namespace_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::NameSpaceInfo >*
QueryResponse::mutable_namespace_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.namespace_infos)
  return &namespace_infos_;
}
inline const ::baikaldb::pb::NameSpaceInfo& QueryResponse::_internal_namespace_infos(int index) const {
  return namespace_infos_.Get(index);
}
inline const ::baikaldb::pb::NameSpaceInfo& QueryResponse::namespace_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.namespace_infos)
  return _internal_namespace_infos(index);
}
inline ::baikaldb::pb::NameSpaceInfo* QueryResponse::_internal_add_namespace_infos() {
  return namespace_infos_.Add();
}
inline ::baikaldb::pb::NameSpaceInfo* QueryResponse::add_namespace_infos() {
  ::baikaldb::pb::NameSpaceInfo* _add = _internal_add_namespace_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.namespace_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::NameSpaceInfo >&
QueryResponse::namespace_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.namespace_infos)
  return namespace_infos_;
}

// repeated .baikaldb.pb.DataBaseInfo database_infos = 9;
inline int QueryResponse::_internal_database_infos_size() const {
  return database_infos_.size();
}
inline int QueryResponse::database_infos_size() const {
  return _internal_database_infos_size();
}
inline void QueryResponse::clear_database_infos() {
  database_infos_.Clear();
}
inline ::baikaldb::pb::DataBaseInfo* QueryResponse::mutable_database_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.database_infos)
  return database_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DataBaseInfo >*
QueryResponse::mutable_database_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.database_infos)
  return &database_infos_;
}
inline const ::baikaldb::pb::DataBaseInfo& QueryResponse::_internal_database_infos(int index) const {
  return database_infos_.Get(index);
}
inline const ::baikaldb::pb::DataBaseInfo& QueryResponse::database_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.database_infos)
  return _internal_database_infos(index);
}
inline ::baikaldb::pb::DataBaseInfo* QueryResponse::_internal_add_database_infos() {
  return database_infos_.Add();
}
inline ::baikaldb::pb::DataBaseInfo* QueryResponse::add_database_infos() {
  ::baikaldb::pb::DataBaseInfo* _add = _internal_add_database_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.database_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DataBaseInfo >&
QueryResponse::database_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.database_infos)
  return database_infos_;
}

// repeated .baikaldb.pb.SchemaInfo schema_infos = 10;
inline int QueryResponse::_internal_schema_infos_size() const {
  return schema_infos_.size();
}
inline int QueryResponse::schema_infos_size() const {
  return _internal_schema_infos_size();
}
inline void QueryResponse::clear_schema_infos() {
  schema_infos_.Clear();
}
inline ::baikaldb::pb::SchemaInfo* QueryResponse::mutable_schema_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.schema_infos)
  return schema_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaInfo >*
QueryResponse::mutable_schema_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.schema_infos)
  return &schema_infos_;
}
inline const ::baikaldb::pb::SchemaInfo& QueryResponse::_internal_schema_infos(int index) const {
  return schema_infos_.Get(index);
}
inline const ::baikaldb::pb::SchemaInfo& QueryResponse::schema_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.schema_infos)
  return _internal_schema_infos(index);
}
inline ::baikaldb::pb::SchemaInfo* QueryResponse::_internal_add_schema_infos() {
  return schema_infos_.Add();
}
inline ::baikaldb::pb::SchemaInfo* QueryResponse::add_schema_infos() {
  ::baikaldb::pb::SchemaInfo* _add = _internal_add_schema_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.schema_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::SchemaInfo >&
QueryResponse::schema_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.schema_infos)
  return schema_infos_;
}

// repeated .baikaldb.pb.RegionInfo region_infos = 11;
inline int QueryResponse::_internal_region_infos_size() const {
  return region_infos_.size();
}
inline int QueryResponse::region_infos_size() const {
  return _internal_region_infos_size();
}
inline void QueryResponse::clear_region_infos() {
  region_infos_.Clear();
}
inline ::baikaldb::pb::RegionInfo* QueryResponse::mutable_region_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.region_infos)
  return region_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >*
QueryResponse::mutable_region_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.region_infos)
  return &region_infos_;
}
inline const ::baikaldb::pb::RegionInfo& QueryResponse::_internal_region_infos(int index) const {
  return region_infos_.Get(index);
}
inline const ::baikaldb::pb::RegionInfo& QueryResponse::region_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.region_infos)
  return _internal_region_infos(index);
}
inline ::baikaldb::pb::RegionInfo* QueryResponse::_internal_add_region_infos() {
  return region_infos_.Add();
}
inline ::baikaldb::pb::RegionInfo* QueryResponse::add_region_infos() {
  ::baikaldb::pb::RegionInfo* _add = _internal_add_region_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.region_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionInfo >&
QueryResponse::region_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.region_infos)
  return region_infos_;
}

// repeated .baikaldb.pb.QueryInstance flatten_instances = 12;
inline int QueryResponse::_internal_flatten_instances_size() const {
  return flatten_instances_.size();
}
inline int QueryResponse::flatten_instances_size() const {
  return _internal_flatten_instances_size();
}
inline void QueryResponse::clear_flatten_instances() {
  flatten_instances_.Clear();
}
inline ::baikaldb::pb::QueryInstance* QueryResponse::mutable_flatten_instances(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.flatten_instances)
  return flatten_instances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryInstance >*
QueryResponse::mutable_flatten_instances() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.flatten_instances)
  return &flatten_instances_;
}
inline const ::baikaldb::pb::QueryInstance& QueryResponse::_internal_flatten_instances(int index) const {
  return flatten_instances_.Get(index);
}
inline const ::baikaldb::pb::QueryInstance& QueryResponse::flatten_instances(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.flatten_instances)
  return _internal_flatten_instances(index);
}
inline ::baikaldb::pb::QueryInstance* QueryResponse::_internal_add_flatten_instances() {
  return flatten_instances_.Add();
}
inline ::baikaldb::pb::QueryInstance* QueryResponse::add_flatten_instances() {
  ::baikaldb::pb::QueryInstance* _add = _internal_add_flatten_instances();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.flatten_instances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryInstance >&
QueryResponse::flatten_instances() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.flatten_instances)
  return flatten_instances_;
}

// repeated .baikaldb.pb.QueryUserPrivilege flatten_privileges = 13;
inline int QueryResponse::_internal_flatten_privileges_size() const {
  return flatten_privileges_.size();
}
inline int QueryResponse::flatten_privileges_size() const {
  return _internal_flatten_privileges_size();
}
inline void QueryResponse::clear_flatten_privileges() {
  flatten_privileges_.Clear();
}
inline ::baikaldb::pb::QueryUserPrivilege* QueryResponse::mutable_flatten_privileges(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.flatten_privileges)
  return flatten_privileges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryUserPrivilege >*
QueryResponse::mutable_flatten_privileges() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.flatten_privileges)
  return &flatten_privileges_;
}
inline const ::baikaldb::pb::QueryUserPrivilege& QueryResponse::_internal_flatten_privileges(int index) const {
  return flatten_privileges_.Get(index);
}
inline const ::baikaldb::pb::QueryUserPrivilege& QueryResponse::flatten_privileges(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.flatten_privileges)
  return _internal_flatten_privileges(index);
}
inline ::baikaldb::pb::QueryUserPrivilege* QueryResponse::_internal_add_flatten_privileges() {
  return flatten_privileges_.Add();
}
inline ::baikaldb::pb::QueryUserPrivilege* QueryResponse::add_flatten_privileges() {
  ::baikaldb::pb::QueryUserPrivilege* _add = _internal_add_flatten_privileges();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.flatten_privileges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryUserPrivilege >&
QueryResponse::flatten_privileges() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.flatten_privileges)
  return flatten_privileges_;
}

// repeated .baikaldb.pb.QueryRegion flatten_regions = 14;
inline int QueryResponse::_internal_flatten_regions_size() const {
  return flatten_regions_.size();
}
inline int QueryResponse::flatten_regions_size() const {
  return _internal_flatten_regions_size();
}
inline void QueryResponse::clear_flatten_regions() {
  flatten_regions_.Clear();
}
inline ::baikaldb::pb::QueryRegion* QueryResponse::mutable_flatten_regions(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.flatten_regions)
  return flatten_regions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryRegion >*
QueryResponse::mutable_flatten_regions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.flatten_regions)
  return &flatten_regions_;
}
inline const ::baikaldb::pb::QueryRegion& QueryResponse::_internal_flatten_regions(int index) const {
  return flatten_regions_.Get(index);
}
inline const ::baikaldb::pb::QueryRegion& QueryResponse::flatten_regions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.flatten_regions)
  return _internal_flatten_regions(index);
}
inline ::baikaldb::pb::QueryRegion* QueryResponse::_internal_add_flatten_regions() {
  return flatten_regions_.Add();
}
inline ::baikaldb::pb::QueryRegion* QueryResponse::add_flatten_regions() {
  ::baikaldb::pb::QueryRegion* _add = _internal_add_flatten_regions();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.flatten_regions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryRegion >&
QueryResponse::flatten_regions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.flatten_regions)
  return flatten_regions_;
}

// repeated .baikaldb.pb.QueryTable flatten_tables = 15;
inline int QueryResponse::_internal_flatten_tables_size() const {
  return flatten_tables_.size();
}
inline int QueryResponse::flatten_tables_size() const {
  return _internal_flatten_tables_size();
}
inline void QueryResponse::clear_flatten_tables() {
  flatten_tables_.Clear();
}
inline ::baikaldb::pb::QueryTable* QueryResponse::mutable_flatten_tables(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.flatten_tables)
  return flatten_tables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryTable >*
QueryResponse::mutable_flatten_tables() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.flatten_tables)
  return &flatten_tables_;
}
inline const ::baikaldb::pb::QueryTable& QueryResponse::_internal_flatten_tables(int index) const {
  return flatten_tables_.Get(index);
}
inline const ::baikaldb::pb::QueryTable& QueryResponse::flatten_tables(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.flatten_tables)
  return _internal_flatten_tables(index);
}
inline ::baikaldb::pb::QueryTable* QueryResponse::_internal_add_flatten_tables() {
  return flatten_tables_.Add();
}
inline ::baikaldb::pb::QueryTable* QueryResponse::add_flatten_tables() {
  ::baikaldb::pb::QueryTable* _add = _internal_add_flatten_tables();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.flatten_tables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryTable >&
QueryResponse::flatten_tables() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.flatten_tables)
  return flatten_tables_;
}

// repeated .baikaldb.pb.QuerySchema flatten_schema_infos = 16;
inline int QueryResponse::_internal_flatten_schema_infos_size() const {
  return flatten_schema_infos_.size();
}
inline int QueryResponse::flatten_schema_infos_size() const {
  return _internal_flatten_schema_infos_size();
}
inline void QueryResponse::clear_flatten_schema_infos() {
  flatten_schema_infos_.Clear();
}
inline ::baikaldb::pb::QuerySchema* QueryResponse::mutable_flatten_schema_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.flatten_schema_infos)
  return flatten_schema_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QuerySchema >*
QueryResponse::mutable_flatten_schema_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.flatten_schema_infos)
  return &flatten_schema_infos_;
}
inline const ::baikaldb::pb::QuerySchema& QueryResponse::_internal_flatten_schema_infos(int index) const {
  return flatten_schema_infos_.Get(index);
}
inline const ::baikaldb::pb::QuerySchema& QueryResponse::flatten_schema_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.flatten_schema_infos)
  return _internal_flatten_schema_infos(index);
}
inline ::baikaldb::pb::QuerySchema* QueryResponse::_internal_add_flatten_schema_infos() {
  return flatten_schema_infos_.Add();
}
inline ::baikaldb::pb::QuerySchema* QueryResponse::add_flatten_schema_infos() {
  ::baikaldb::pb::QuerySchema* _add = _internal_add_flatten_schema_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.flatten_schema_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QuerySchema >&
QueryResponse::flatten_schema_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.flatten_schema_infos)
  return flatten_schema_infos_;
}

// repeated int64 peer_ids = 17;
inline int QueryResponse::_internal_peer_ids_size() const {
  return peer_ids_.size();
}
inline int QueryResponse::peer_ids_size() const {
  return _internal_peer_ids_size();
}
inline void QueryResponse::clear_peer_ids() {
  peer_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryResponse::_internal_peer_ids(int index) const {
  return peer_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryResponse::peer_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.peer_ids)
  return _internal_peer_ids(index);
}
inline void QueryResponse::set_peer_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  peer_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryResponse.peer_ids)
}
inline void QueryResponse::_internal_add_peer_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  peer_ids_.Add(value);
}
inline void QueryResponse::add_peer_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_peer_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.peer_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
QueryResponse::_internal_peer_ids() const {
  return peer_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
QueryResponse::peer_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.peer_ids)
  return _internal_peer_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
QueryResponse::_internal_mutable_peer_ids() {
  return &peer_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
QueryResponse::mutable_peer_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.peer_ids)
  return _internal_mutable_peer_ids();
}

// repeated int64 region_ids = 18;
inline int QueryResponse::_internal_region_ids_size() const {
  return region_ids_.size();
}
inline int QueryResponse::region_ids_size() const {
  return _internal_region_ids_size();
}
inline void QueryResponse::clear_region_ids() {
  region_ids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryResponse::_internal_region_ids(int index) const {
  return region_ids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryResponse::region_ids(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.region_ids)
  return _internal_region_ids(index);
}
inline void QueryResponse::set_region_ids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  region_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryResponse.region_ids)
}
inline void QueryResponse::_internal_add_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  region_ids_.Add(value);
}
inline void QueryResponse::add_region_ids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_region_ids(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.region_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
QueryResponse::_internal_region_ids() const {
  return region_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
QueryResponse::region_ids() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.region_ids)
  return _internal_region_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
QueryResponse::_internal_mutable_region_ids() {
  return &region_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
QueryResponse::mutable_region_ids() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.region_ids)
  return _internal_mutable_region_ids();
}

// repeated .baikaldb.pb.DdlWorkInfo ddlwork_infos = 19;
inline int QueryResponse::_internal_ddlwork_infos_size() const {
  return ddlwork_infos_.size();
}
inline int QueryResponse::ddlwork_infos_size() const {
  return _internal_ddlwork_infos_size();
}
inline void QueryResponse::clear_ddlwork_infos() {
  ddlwork_infos_.Clear();
}
inline ::baikaldb::pb::DdlWorkInfo* QueryResponse::mutable_ddlwork_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.ddlwork_infos)
  return ddlwork_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >*
QueryResponse::mutable_ddlwork_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.ddlwork_infos)
  return &ddlwork_infos_;
}
inline const ::baikaldb::pb::DdlWorkInfo& QueryResponse::_internal_ddlwork_infos(int index) const {
  return ddlwork_infos_.Get(index);
}
inline const ::baikaldb::pb::DdlWorkInfo& QueryResponse::ddlwork_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.ddlwork_infos)
  return _internal_ddlwork_infos(index);
}
inline ::baikaldb::pb::DdlWorkInfo* QueryResponse::_internal_add_ddlwork_infos() {
  return ddlwork_infos_.Add();
}
inline ::baikaldb::pb::DdlWorkInfo* QueryResponse::add_ddlwork_infos() {
  ::baikaldb::pb::DdlWorkInfo* _add = _internal_add_ddlwork_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.ddlwork_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlWorkInfo >&
QueryResponse::ddlwork_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.ddlwork_infos)
  return ddlwork_infos_;
}

// repeated .baikaldb.pb.QueryDdlInfo query_ddl_infos = 20;
inline int QueryResponse::_internal_query_ddl_infos_size() const {
  return query_ddl_infos_.size();
}
inline int QueryResponse::query_ddl_infos_size() const {
  return _internal_query_ddl_infos_size();
}
inline void QueryResponse::clear_query_ddl_infos() {
  query_ddl_infos_.Clear();
}
inline ::baikaldb::pb::QueryDdlInfo* QueryResponse::mutable_query_ddl_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.query_ddl_infos)
  return query_ddl_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryDdlInfo >*
QueryResponse::mutable_query_ddl_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.query_ddl_infos)
  return &query_ddl_infos_;
}
inline const ::baikaldb::pb::QueryDdlInfo& QueryResponse::_internal_query_ddl_infos(int index) const {
  return query_ddl_infos_.Get(index);
}
inline const ::baikaldb::pb::QueryDdlInfo& QueryResponse::query_ddl_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.query_ddl_infos)
  return _internal_query_ddl_infos(index);
}
inline ::baikaldb::pb::QueryDdlInfo* QueryResponse::_internal_add_query_ddl_infos() {
  return query_ddl_infos_.Add();
}
inline ::baikaldb::pb::QueryDdlInfo* QueryResponse::add_query_ddl_infos() {
  ::baikaldb::pb::QueryDdlInfo* _add = _internal_add_query_ddl_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.query_ddl_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryDdlInfo >&
QueryResponse::query_ddl_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.query_ddl_infos)
  return query_ddl_infos_;
}

// repeated .baikaldb.pb.RegionStateInfo region_status_infos = 21;
inline int QueryResponse::_internal_region_status_infos_size() const {
  return region_status_infos_.size();
}
inline int QueryResponse::region_status_infos_size() const {
  return _internal_region_status_infos_size();
}
inline void QueryResponse::clear_region_status_infos() {
  region_status_infos_.Clear();
}
inline ::baikaldb::pb::RegionStateInfo* QueryResponse::mutable_region_status_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.region_status_infos)
  return region_status_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionStateInfo >*
QueryResponse::mutable_region_status_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.region_status_infos)
  return &region_status_infos_;
}
inline const ::baikaldb::pb::RegionStateInfo& QueryResponse::_internal_region_status_infos(int index) const {
  return region_status_infos_.Get(index);
}
inline const ::baikaldb::pb::RegionStateInfo& QueryResponse::region_status_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.region_status_infos)
  return _internal_region_status_infos(index);
}
inline ::baikaldb::pb::RegionStateInfo* QueryResponse::_internal_add_region_status_infos() {
  return region_status_infos_.Add();
}
inline ::baikaldb::pb::RegionStateInfo* QueryResponse::add_region_status_infos() {
  ::baikaldb::pb::RegionStateInfo* _add = _internal_add_region_status_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.region_status_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionStateInfo >&
QueryResponse::region_status_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.region_status_infos)
  return region_status_infos_;
}

// repeated .baikaldb.pb.InstanceParam instance_params = 22;
inline int QueryResponse::_internal_instance_params_size() const {
  return instance_params_.size();
}
inline int QueryResponse::instance_params_size() const {
  return _internal_instance_params_size();
}
inline void QueryResponse::clear_instance_params() {
  instance_params_.Clear();
}
inline ::baikaldb::pb::InstanceParam* QueryResponse::mutable_instance_params(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.instance_params)
  return instance_params_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam >*
QueryResponse::mutable_instance_params() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.instance_params)
  return &instance_params_;
}
inline const ::baikaldb::pb::InstanceParam& QueryResponse::_internal_instance_params(int index) const {
  return instance_params_.Get(index);
}
inline const ::baikaldb::pb::InstanceParam& QueryResponse::instance_params(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.instance_params)
  return _internal_instance_params(index);
}
inline ::baikaldb::pb::InstanceParam* QueryResponse::_internal_add_instance_params() {
  return instance_params_.Add();
}
inline ::baikaldb::pb::InstanceParam* QueryResponse::add_instance_params() {
  ::baikaldb::pb::InstanceParam* _add = _internal_add_instance_params();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.instance_params)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::InstanceParam >&
QueryResponse::instance_params() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.instance_params)
  return instance_params_;
}

// repeated .baikaldb.pb.RegionDdlWork region_ddl_infos = 23;
inline int QueryResponse::_internal_region_ddl_infos_size() const {
  return region_ddl_infos_.size();
}
inline int QueryResponse::region_ddl_infos_size() const {
  return _internal_region_ddl_infos_size();
}
inline void QueryResponse::clear_region_ddl_infos() {
  region_ddl_infos_.Clear();
}
inline ::baikaldb::pb::RegionDdlWork* QueryResponse::mutable_region_ddl_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.region_ddl_infos)
  return region_ddl_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionDdlWork >*
QueryResponse::mutable_region_ddl_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.region_ddl_infos)
  return &region_ddl_infos_;
}
inline const ::baikaldb::pb::RegionDdlWork& QueryResponse::_internal_region_ddl_infos(int index) const {
  return region_ddl_infos_.Get(index);
}
inline const ::baikaldb::pb::RegionDdlWork& QueryResponse::region_ddl_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.region_ddl_infos)
  return _internal_region_ddl_infos(index);
}
inline ::baikaldb::pb::RegionDdlWork* QueryResponse::_internal_add_region_ddl_infos() {
  return region_ddl_infos_.Add();
}
inline ::baikaldb::pb::RegionDdlWork* QueryResponse::add_region_ddl_infos() {
  ::baikaldb::pb::RegionDdlWork* _add = _internal_add_region_ddl_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.region_ddl_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionDdlWork >&
QueryResponse::region_ddl_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.region_ddl_infos)
  return region_ddl_infos_;
}

// repeated .baikaldb.pb.ResourceTagInfo resource_tag_infos = 24;
inline int QueryResponse::_internal_resource_tag_infos_size() const {
  return resource_tag_infos_.size();
}
inline int QueryResponse::resource_tag_infos_size() const {
  return _internal_resource_tag_infos_size();
}
inline void QueryResponse::clear_resource_tag_infos() {
  resource_tag_infos_.Clear();
}
inline ::baikaldb::pb::ResourceTagInfo* QueryResponse::mutable_resource_tag_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.resource_tag_infos)
  return resource_tag_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ResourceTagInfo >*
QueryResponse::mutable_resource_tag_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.resource_tag_infos)
  return &resource_tag_infos_;
}
inline const ::baikaldb::pb::ResourceTagInfo& QueryResponse::_internal_resource_tag_infos(int index) const {
  return resource_tag_infos_.Get(index);
}
inline const ::baikaldb::pb::ResourceTagInfo& QueryResponse::resource_tag_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.resource_tag_infos)
  return _internal_resource_tag_infos(index);
}
inline ::baikaldb::pb::ResourceTagInfo* QueryResponse::_internal_add_resource_tag_infos() {
  return resource_tag_infos_.Add();
}
inline ::baikaldb::pb::ResourceTagInfo* QueryResponse::add_resource_tag_infos() {
  ::baikaldb::pb::ResourceTagInfo* _add = _internal_add_resource_tag_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.resource_tag_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ResourceTagInfo >&
QueryResponse::resource_tag_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.resource_tag_infos)
  return resource_tag_infos_;
}

// repeated .baikaldb.pb.VirtualInfoAndSqls virtual_index_influence_info = 25;
inline int QueryResponse::_internal_virtual_index_influence_info_size() const {
  return virtual_index_influence_info_.size();
}
inline int QueryResponse::virtual_index_influence_info_size() const {
  return _internal_virtual_index_influence_info_size();
}
inline void QueryResponse::clear_virtual_index_influence_info() {
  virtual_index_influence_info_.Clear();
}
inline ::baikaldb::pb::VirtualInfoAndSqls* QueryResponse::mutable_virtual_index_influence_info(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.virtual_index_influence_info)
  return virtual_index_influence_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::VirtualInfoAndSqls >*
QueryResponse::mutable_virtual_index_influence_info() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.virtual_index_influence_info)
  return &virtual_index_influence_info_;
}
inline const ::baikaldb::pb::VirtualInfoAndSqls& QueryResponse::_internal_virtual_index_influence_info(int index) const {
  return virtual_index_influence_info_.Get(index);
}
inline const ::baikaldb::pb::VirtualInfoAndSqls& QueryResponse::virtual_index_influence_info(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.virtual_index_influence_info)
  return _internal_virtual_index_influence_info(index);
}
inline ::baikaldb::pb::VirtualInfoAndSqls* QueryResponse::_internal_add_virtual_index_influence_info() {
  return virtual_index_influence_info_.Add();
}
inline ::baikaldb::pb::VirtualInfoAndSqls* QueryResponse::add_virtual_index_influence_info() {
  ::baikaldb::pb::VirtualInfoAndSqls* _add = _internal_add_virtual_index_influence_info();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.virtual_index_influence_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::VirtualInfoAndSqls >&
QueryResponse::virtual_index_influence_info() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.virtual_index_influence_info)
  return virtual_index_influence_info_;
}

// repeated .baikaldb.pb.BinlogRegionInfo binlog_region_state = 26;
inline int QueryResponse::_internal_binlog_region_state_size() const {
  return binlog_region_state_.size();
}
inline int QueryResponse::binlog_region_state_size() const {
  return _internal_binlog_region_state_size();
}
inline void QueryResponse::clear_binlog_region_state() {
  binlog_region_state_.Clear();
}
inline ::baikaldb::pb::BinlogRegionInfo* QueryResponse::mutable_binlog_region_state(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryResponse.binlog_region_state)
  return binlog_region_state_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogRegionInfo >*
QueryResponse::mutable_binlog_region_state() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryResponse.binlog_region_state)
  return &binlog_region_state_;
}
inline const ::baikaldb::pb::BinlogRegionInfo& QueryResponse::_internal_binlog_region_state(int index) const {
  return binlog_region_state_.Get(index);
}
inline const ::baikaldb::pb::BinlogRegionInfo& QueryResponse::binlog_region_state(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryResponse.binlog_region_state)
  return _internal_binlog_region_state(index);
}
inline ::baikaldb::pb::BinlogRegionInfo* QueryResponse::_internal_add_binlog_region_state() {
  return binlog_region_state_.Add();
}
inline ::baikaldb::pb::BinlogRegionInfo* QueryResponse::add_binlog_region_state() {
  ::baikaldb::pb::BinlogRegionInfo* _add = _internal_add_binlog_region_state();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryResponse.binlog_region_state)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::BinlogRegionInfo >&
QueryResponse::binlog_region_state() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryResponse.binlog_region_state)
  return binlog_region_state_;
}

// -------------------------------------------------------------------

// DdlPeerInfo

// optional string peer = 1;
inline bool DdlPeerInfo::_internal_has_peer() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DdlPeerInfo::has_peer() const {
  return _internal_has_peer();
}
inline void DdlPeerInfo::clear_peer() {
  peer_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DdlPeerInfo::peer() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlPeerInfo.peer)
  return _internal_peer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DdlPeerInfo::set_peer(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 peer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlPeerInfo.peer)
}
inline std::string* DdlPeerInfo::mutable_peer() {
  std::string* _s = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DdlPeerInfo.peer)
  return _s;
}
inline const std::string& DdlPeerInfo::_internal_peer() const {
  return peer_.Get();
}
inline void DdlPeerInfo::_internal_set_peer(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  peer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DdlPeerInfo::_internal_mutable_peer() {
  _has_bits_[0] |= 0x00000001u;
  return peer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DdlPeerInfo::release_peer() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DdlPeerInfo.peer)
  if (!_internal_has_peer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return peer_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DdlPeerInfo::set_allocated_peer(std::string* peer) {
  if (peer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  peer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peer,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DdlPeerInfo.peer)
}

// optional .baikaldb.pb.IndexState state = 2;
inline bool DdlPeerInfo::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DdlPeerInfo::has_state() const {
  return _internal_has_state();
}
inline void DdlPeerInfo::clear_state() {
  state_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::baikaldb::pb::IndexState DdlPeerInfo::_internal_state() const {
  return static_cast< ::baikaldb::pb::IndexState >(state_);
}
inline ::baikaldb::pb::IndexState DdlPeerInfo::state() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlPeerInfo.state)
  return _internal_state();
}
inline void DdlPeerInfo::_internal_set_state(::baikaldb::pb::IndexState value) {
  assert(::baikaldb::pb::IndexState_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  state_ = value;
}
inline void DdlPeerInfo::set_state(::baikaldb::pb::IndexState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlPeerInfo.state)
}

// -------------------------------------------------------------------

// DdlRegionInfo

// optional int64 region_id = 1;
inline bool DdlRegionInfo::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DdlRegionInfo::has_region_id() const {
  return _internal_has_region_id();
}
inline void DdlRegionInfo::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DdlRegionInfo::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DdlRegionInfo::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlRegionInfo.region_id)
  return _internal_region_id();
}
inline void DdlRegionInfo::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  region_id_ = value;
}
inline void DdlRegionInfo::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlRegionInfo.region_id)
}

// optional .baikaldb.pb.IndexState state = 2;
inline bool DdlRegionInfo::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DdlRegionInfo::has_state() const {
  return _internal_has_state();
}
inline void DdlRegionInfo::clear_state() {
  state_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::baikaldb::pb::IndexState DdlRegionInfo::_internal_state() const {
  return static_cast< ::baikaldb::pb::IndexState >(state_);
}
inline ::baikaldb::pb::IndexState DdlRegionInfo::state() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlRegionInfo.state)
  return _internal_state();
}
inline void DdlRegionInfo::_internal_set_state(::baikaldb::pb::IndexState value) {
  assert(::baikaldb::pb::IndexState_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  state_ = value;
}
inline void DdlRegionInfo::set_state(::baikaldb::pb::IndexState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlRegionInfo.state)
}

// repeated .baikaldb.pb.DdlPeerInfo ddl_peer_infos = 3;
inline int DdlRegionInfo::_internal_ddl_peer_infos_size() const {
  return ddl_peer_infos_.size();
}
inline int DdlRegionInfo::ddl_peer_infos_size() const {
  return _internal_ddl_peer_infos_size();
}
inline void DdlRegionInfo::clear_ddl_peer_infos() {
  ddl_peer_infos_.Clear();
}
inline ::baikaldb::pb::DdlPeerInfo* DdlRegionInfo::mutable_ddl_peer_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DdlRegionInfo.ddl_peer_infos)
  return ddl_peer_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlPeerInfo >*
DdlRegionInfo::mutable_ddl_peer_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.DdlRegionInfo.ddl_peer_infos)
  return &ddl_peer_infos_;
}
inline const ::baikaldb::pb::DdlPeerInfo& DdlRegionInfo::_internal_ddl_peer_infos(int index) const {
  return ddl_peer_infos_.Get(index);
}
inline const ::baikaldb::pb::DdlPeerInfo& DdlRegionInfo::ddl_peer_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlRegionInfo.ddl_peer_infos)
  return _internal_ddl_peer_infos(index);
}
inline ::baikaldb::pb::DdlPeerInfo* DdlRegionInfo::_internal_add_ddl_peer_infos() {
  return ddl_peer_infos_.Add();
}
inline ::baikaldb::pb::DdlPeerInfo* DdlRegionInfo::add_ddl_peer_infos() {
  ::baikaldb::pb::DdlPeerInfo* _add = _internal_add_ddl_peer_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.DdlRegionInfo.ddl_peer_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlPeerInfo >&
DdlRegionInfo::ddl_peer_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.DdlRegionInfo.ddl_peer_infos)
  return ddl_peer_infos_;
}

// -------------------------------------------------------------------

// QueryDdlInfo

// optional int64 table_id = 1;
inline bool QueryDdlInfo::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryDdlInfo::has_table_id() const {
  return _internal_has_table_id();
}
inline void QueryDdlInfo::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryDdlInfo::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryDdlInfo::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryDdlInfo.table_id)
  return _internal_table_id();
}
inline void QueryDdlInfo::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  table_id_ = value;
}
inline void QueryDdlInfo::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryDdlInfo.table_id)
}

// repeated .baikaldb.pb.DdlRegionInfo ddl_region_infos = 2;
inline int QueryDdlInfo::_internal_ddl_region_infos_size() const {
  return ddl_region_infos_.size();
}
inline int QueryDdlInfo::ddl_region_infos_size() const {
  return _internal_ddl_region_infos_size();
}
inline void QueryDdlInfo::clear_ddl_region_infos() {
  ddl_region_infos_.Clear();
}
inline ::baikaldb::pb::DdlRegionInfo* QueryDdlInfo::mutable_ddl_region_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryDdlInfo.ddl_region_infos)
  return ddl_region_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlRegionInfo >*
QueryDdlInfo::mutable_ddl_region_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.QueryDdlInfo.ddl_region_infos)
  return &ddl_region_infos_;
}
inline const ::baikaldb::pb::DdlRegionInfo& QueryDdlInfo::_internal_ddl_region_infos(int index) const {
  return ddl_region_infos_.Get(index);
}
inline const ::baikaldb::pb::DdlRegionInfo& QueryDdlInfo::ddl_region_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryDdlInfo.ddl_region_infos)
  return _internal_ddl_region_infos(index);
}
inline ::baikaldb::pb::DdlRegionInfo* QueryDdlInfo::_internal_add_ddl_region_infos() {
  return ddl_region_infos_.Add();
}
inline ::baikaldb::pb::DdlRegionInfo* QueryDdlInfo::add_ddl_region_infos() {
  ::baikaldb::pb::DdlRegionInfo* _add = _internal_add_ddl_region_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.QueryDdlInfo.ddl_region_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DdlRegionInfo >&
QueryDdlInfo::ddl_region_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.QueryDdlInfo.ddl_region_infos)
  return ddl_region_infos_;
}

// -------------------------------------------------------------------

// QueryUserPrivilege

// required string username = 1;
inline bool QueryUserPrivilege::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryUserPrivilege::has_username() const {
  return _internal_has_username();
}
inline void QueryUserPrivilege::clear_username() {
  username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryUserPrivilege::username() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryUserPrivilege.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryUserPrivilege::set_username(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryUserPrivilege.username)
}
inline std::string* QueryUserPrivilege::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryUserPrivilege.username)
  return _s;
}
inline const std::string& QueryUserPrivilege::_internal_username() const {
  return username_.Get();
}
inline void QueryUserPrivilege::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryUserPrivilege::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryUserPrivilege::release_username() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryUserPrivilege.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryUserPrivilege::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryUserPrivilege.username)
}

// required string namespace_name = 2;
inline bool QueryUserPrivilege::_internal_has_namespace_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QueryUserPrivilege::has_namespace_name() const {
  return _internal_has_namespace_name();
}
inline void QueryUserPrivilege::clear_namespace_name() {
  namespace_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryUserPrivilege::namespace_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryUserPrivilege.namespace_name)
  return _internal_namespace_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryUserPrivilege::set_namespace_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryUserPrivilege.namespace_name)
}
inline std::string* QueryUserPrivilege::mutable_namespace_name() {
  std::string* _s = _internal_mutable_namespace_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryUserPrivilege.namespace_name)
  return _s;
}
inline const std::string& QueryUserPrivilege::_internal_namespace_name() const {
  return namespace_name_.Get();
}
inline void QueryUserPrivilege::_internal_set_namespace_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryUserPrivilege::_internal_mutable_namespace_name() {
  _has_bits_[0] |= 0x00000002u;
  return namespace_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryUserPrivilege::release_namespace_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryUserPrivilege.namespace_name)
  if (!_internal_has_namespace_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return namespace_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryUserPrivilege::set_allocated_namespace_name(std::string* namespace_name) {
  if (namespace_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  namespace_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryUserPrivilege.namespace_name)
}

// required string privilege = 3;
inline bool QueryUserPrivilege::_internal_has_privilege() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QueryUserPrivilege::has_privilege() const {
  return _internal_has_privilege();
}
inline void QueryUserPrivilege::clear_privilege() {
  privilege_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& QueryUserPrivilege::privilege() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryUserPrivilege.privilege)
  return _internal_privilege();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryUserPrivilege::set_privilege(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 privilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryUserPrivilege.privilege)
}
inline std::string* QueryUserPrivilege::mutable_privilege() {
  std::string* _s = _internal_mutable_privilege();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryUserPrivilege.privilege)
  return _s;
}
inline const std::string& QueryUserPrivilege::_internal_privilege() const {
  return privilege_.Get();
}
inline void QueryUserPrivilege::_internal_set_privilege(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  privilege_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryUserPrivilege::_internal_mutable_privilege() {
  _has_bits_[0] |= 0x00000004u;
  return privilege_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryUserPrivilege::release_privilege() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryUserPrivilege.privilege)
  if (!_internal_has_privilege()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return privilege_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryUserPrivilege::set_allocated_privilege(std::string* privilege) {
  if (privilege != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  privilege_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), privilege,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryUserPrivilege.privilege)
}

// required .baikaldb.pb.RW table_rw = 4;
inline bool QueryUserPrivilege::_internal_has_table_rw() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QueryUserPrivilege::has_table_rw() const {
  return _internal_has_table_rw();
}
inline void QueryUserPrivilege::clear_table_rw() {
  table_rw_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::baikaldb::pb::RW QueryUserPrivilege::_internal_table_rw() const {
  return static_cast< ::baikaldb::pb::RW >(table_rw_);
}
inline ::baikaldb::pb::RW QueryUserPrivilege::table_rw() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryUserPrivilege.table_rw)
  return _internal_table_rw();
}
inline void QueryUserPrivilege::_internal_set_table_rw(::baikaldb::pb::RW value) {
  assert(::baikaldb::pb::RW_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  table_rw_ = value;
}
inline void QueryUserPrivilege::set_table_rw(::baikaldb::pb::RW value) {
  _internal_set_table_rw(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryUserPrivilege.table_rw)
}

// optional string password = 5;
inline bool QueryUserPrivilege::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QueryUserPrivilege::has_password() const {
  return _internal_has_password();
}
inline void QueryUserPrivilege::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& QueryUserPrivilege::password() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryUserPrivilege.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryUserPrivilege::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryUserPrivilege.password)
}
inline std::string* QueryUserPrivilege::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryUserPrivilege.password)
  return _s;
}
inline const std::string& QueryUserPrivilege::_internal_password() const {
  return password_.Get();
}
inline void QueryUserPrivilege::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryUserPrivilege::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000008u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryUserPrivilege::release_password() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryUserPrivilege.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryUserPrivilege::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryUserPrivilege.password)
}

// -------------------------------------------------------------------

// QueryInstance

// required string address = 1;
inline bool QueryInstance::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryInstance::has_address() const {
  return _internal_has_address();
}
inline void QueryInstance::clear_address() {
  address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryInstance::address() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryInstance.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryInstance::set_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryInstance.address)
}
inline std::string* QueryInstance::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryInstance.address)
  return _s;
}
inline const std::string& QueryInstance::_internal_address() const {
  return address_.Get();
}
inline void QueryInstance::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryInstance::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryInstance::release_address() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryInstance.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryInstance::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryInstance.address)
}

// optional int64 capacity = 2;
inline bool QueryInstance::_internal_has_capacity() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool QueryInstance::has_capacity() const {
  return _internal_has_capacity();
}
inline void QueryInstance::clear_capacity() {
  capacity_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryInstance::_internal_capacity() const {
  return capacity_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryInstance::capacity() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryInstance.capacity)
  return _internal_capacity();
}
inline void QueryInstance::_internal_set_capacity(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  capacity_ = value;
}
inline void QueryInstance::set_capacity(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryInstance.capacity)
}

// optional int64 used_size = 3;
inline bool QueryInstance::_internal_has_used_size() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool QueryInstance::has_used_size() const {
  return _internal_has_used_size();
}
inline void QueryInstance::clear_used_size() {
  used_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryInstance::_internal_used_size() const {
  return used_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryInstance::used_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryInstance.used_size)
  return _internal_used_size();
}
inline void QueryInstance::_internal_set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  used_size_ = value;
}
inline void QueryInstance::set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_used_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryInstance.used_size)
}

// optional string resource_tag = 4;
inline bool QueryInstance::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QueryInstance::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void QueryInstance::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryInstance::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryInstance.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryInstance::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryInstance.resource_tag)
}
inline std::string* QueryInstance::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryInstance.resource_tag)
  return _s;
}
inline const std::string& QueryInstance::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void QueryInstance::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryInstance::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000002u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryInstance::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryInstance.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryInstance::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryInstance.resource_tag)
}

// optional .baikaldb.pb.Status status = 5;
inline bool QueryInstance::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool QueryInstance::has_status() const {
  return _internal_has_status();
}
inline void QueryInstance::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::baikaldb::pb::Status QueryInstance::_internal_status() const {
  return static_cast< ::baikaldb::pb::Status >(status_);
}
inline ::baikaldb::pb::Status QueryInstance::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryInstance.status)
  return _internal_status();
}
inline void QueryInstance::_internal_set_status(::baikaldb::pb::Status value) {
  assert(::baikaldb::pb::Status_IsValid(value));
  _has_bits_[0] |= 0x00002000u;
  status_ = value;
}
inline void QueryInstance::set_status(::baikaldb::pb::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryInstance.status)
}

// optional string physical_room = 6;
inline bool QueryInstance::_internal_has_physical_room() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QueryInstance::has_physical_room() const {
  return _internal_has_physical_room();
}
inline void QueryInstance::clear_physical_room() {
  physical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& QueryInstance::physical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryInstance.physical_room)
  return _internal_physical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryInstance::set_physical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryInstance.physical_room)
}
inline std::string* QueryInstance::mutable_physical_room() {
  std::string* _s = _internal_mutable_physical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryInstance.physical_room)
  return _s;
}
inline const std::string& QueryInstance::_internal_physical_room() const {
  return physical_room_.Get();
}
inline void QueryInstance::_internal_set_physical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  physical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryInstance::_internal_mutable_physical_room() {
  _has_bits_[0] |= 0x00000004u;
  return physical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryInstance::release_physical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryInstance.physical_room)
  if (!_internal_has_physical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return physical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryInstance::set_allocated_physical_room(std::string* physical_room) {
  if (physical_room != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  physical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), physical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryInstance.physical_room)
}

// optional string logical_room = 7;
inline bool QueryInstance::_internal_has_logical_room() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QueryInstance::has_logical_room() const {
  return _internal_has_logical_room();
}
inline void QueryInstance::clear_logical_room() {
  logical_room_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& QueryInstance::logical_room() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryInstance.logical_room)
  return _internal_logical_room();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryInstance::set_logical_room(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryInstance.logical_room)
}
inline std::string* QueryInstance::mutable_logical_room() {
  std::string* _s = _internal_mutable_logical_room();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryInstance.logical_room)
  return _s;
}
inline const std::string& QueryInstance::_internal_logical_room() const {
  return logical_room_.Get();
}
inline void QueryInstance::_internal_set_logical_room(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  logical_room_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryInstance::_internal_mutable_logical_room() {
  _has_bits_[0] |= 0x00000008u;
  return logical_room_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryInstance::release_logical_room() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryInstance.logical_room)
  if (!_internal_has_logical_room()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return logical_room_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryInstance::set_allocated_logical_room(std::string* logical_room) {
  if (logical_room != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  logical_room_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logical_room,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryInstance.logical_room)
}

// optional int64 peer_count = 8;
inline bool QueryInstance::_internal_has_peer_count() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool QueryInstance::has_peer_count() const {
  return _internal_has_peer_count();
}
inline void QueryInstance::clear_peer_count() {
  peer_count_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryInstance::_internal_peer_count() const {
  return peer_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryInstance::peer_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryInstance.peer_count)
  return _internal_peer_count();
}
inline void QueryInstance::_internal_set_peer_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  peer_count_ = value;
}
inline void QueryInstance::set_peer_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_peer_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryInstance.peer_count)
}

// optional string peer_ids = 9;
inline bool QueryInstance::_internal_has_peer_ids() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QueryInstance::has_peer_ids() const {
  return _internal_has_peer_ids();
}
inline void QueryInstance::clear_peer_ids() {
  peer_ids_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& QueryInstance::peer_ids() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryInstance.peer_ids)
  return _internal_peer_ids();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryInstance::set_peer_ids(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 peer_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryInstance.peer_ids)
}
inline std::string* QueryInstance::mutable_peer_ids() {
  std::string* _s = _internal_mutable_peer_ids();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryInstance.peer_ids)
  return _s;
}
inline const std::string& QueryInstance::_internal_peer_ids() const {
  return peer_ids_.Get();
}
inline void QueryInstance::_internal_set_peer_ids(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  peer_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryInstance::_internal_mutable_peer_ids() {
  _has_bits_[0] |= 0x00000010u;
  return peer_ids_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryInstance::release_peer_ids() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryInstance.peer_ids)
  if (!_internal_has_peer_ids()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return peer_ids_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryInstance::set_allocated_peer_ids(std::string* peer_ids) {
  if (peer_ids != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  peer_ids_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peer_ids,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryInstance.peer_ids)
}

// optional int64 region_leader_count = 10;
inline bool QueryInstance::_internal_has_region_leader_count() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool QueryInstance::has_region_leader_count() const {
  return _internal_has_region_leader_count();
}
inline void QueryInstance::clear_region_leader_count() {
  region_leader_count_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryInstance::_internal_region_leader_count() const {
  return region_leader_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryInstance::region_leader_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryInstance.region_leader_count)
  return _internal_region_leader_count();
}
inline void QueryInstance::_internal_set_region_leader_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  region_leader_count_ = value;
}
inline void QueryInstance::set_region_leader_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_leader_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryInstance.region_leader_count)
}

// optional string region_leader_ids = 11;
inline bool QueryInstance::_internal_has_region_leader_ids() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool QueryInstance::has_region_leader_ids() const {
  return _internal_has_region_leader_ids();
}
inline void QueryInstance::clear_region_leader_ids() {
  region_leader_ids_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& QueryInstance::region_leader_ids() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryInstance.region_leader_ids)
  return _internal_region_leader_ids();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryInstance::set_region_leader_ids(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 region_leader_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryInstance.region_leader_ids)
}
inline std::string* QueryInstance::mutable_region_leader_ids() {
  std::string* _s = _internal_mutable_region_leader_ids();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryInstance.region_leader_ids)
  return _s;
}
inline const std::string& QueryInstance::_internal_region_leader_ids() const {
  return region_leader_ids_.Get();
}
inline void QueryInstance::_internal_set_region_leader_ids(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  region_leader_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryInstance::_internal_mutable_region_leader_ids() {
  _has_bits_[0] |= 0x00000020u;
  return region_leader_ids_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryInstance::release_region_leader_ids() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryInstance.region_leader_ids)
  if (!_internal_has_region_leader_ids()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return region_leader_ids_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryInstance::set_allocated_region_leader_ids(std::string* region_leader_ids) {
  if (region_leader_ids != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  region_leader_ids_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region_leader_ids,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryInstance.region_leader_ids)
}

// optional int64 region_count = 12;
inline bool QueryInstance::_internal_has_region_count() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool QueryInstance::has_region_count() const {
  return _internal_has_region_count();
}
inline void QueryInstance::clear_region_count() {
  region_count_ = int64_t{0};
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryInstance::_internal_region_count() const {
  return region_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryInstance::region_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryInstance.region_count)
  return _internal_region_count();
}
inline void QueryInstance::_internal_set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00001000u;
  region_count_ = value;
}
inline void QueryInstance::set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryInstance.region_count)
}

// optional string region_ids = 13;
inline bool QueryInstance::_internal_has_region_ids() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool QueryInstance::has_region_ids() const {
  return _internal_has_region_ids();
}
inline void QueryInstance::clear_region_ids() {
  region_ids_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& QueryInstance::region_ids() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryInstance.region_ids)
  return _internal_region_ids();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryInstance::set_region_ids(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 region_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryInstance.region_ids)
}
inline std::string* QueryInstance::mutable_region_ids() {
  std::string* _s = _internal_mutable_region_ids();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryInstance.region_ids)
  return _s;
}
inline const std::string& QueryInstance::_internal_region_ids() const {
  return region_ids_.Get();
}
inline void QueryInstance::_internal_set_region_ids(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  region_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryInstance::_internal_mutable_region_ids() {
  _has_bits_[0] |= 0x00000040u;
  return region_ids_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryInstance::release_region_ids() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryInstance.region_ids)
  if (!_internal_has_region_ids()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return region_ids_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryInstance::set_allocated_region_ids(std::string* region_ids) {
  if (region_ids != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  region_ids_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region_ids,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryInstance.region_ids)
}

// optional string version = 14;
inline bool QueryInstance::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool QueryInstance::has_version() const {
  return _internal_has_version();
}
inline void QueryInstance::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& QueryInstance::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryInstance.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryInstance::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryInstance.version)
}
inline std::string* QueryInstance::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryInstance.version)
  return _s;
}
inline const std::string& QueryInstance::_internal_version() const {
  return version_.Get();
}
inline void QueryInstance::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryInstance::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000080u;
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryInstance::release_version() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryInstance.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryInstance::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryInstance.version)
}

// -------------------------------------------------------------------

// QueryRegion

// required int64 region_id = 1;
inline bool QueryRegion::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool QueryRegion::has_region_id() const {
  return _internal_has_region_id();
}
inline void QueryRegion::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.region_id)
  return _internal_region_id();
}
inline void QueryRegion::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  region_id_ = value;
}
inline void QueryRegion::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.region_id)
}

// optional string table_name = 2;
inline bool QueryRegion::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryRegion::has_table_name() const {
  return _internal_has_table_name();
}
inline void QueryRegion::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryRegion::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRegion::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.table_name)
}
inline std::string* QueryRegion::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRegion.table_name)
  return _s;
}
inline const std::string& QueryRegion::_internal_table_name() const {
  return table_name_.Get();
}
inline void QueryRegion::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRegion::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000001u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRegion::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRegion.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRegion::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRegion.table_name)
}

// optional int64 partition_id = 3;
inline bool QueryRegion::_internal_has_partition_id() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool QueryRegion::has_partition_id() const {
  return _internal_has_partition_id();
}
inline void QueryRegion::clear_partition_id() {
  partition_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::_internal_partition_id() const {
  return partition_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::partition_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.partition_id)
  return _internal_partition_id();
}
inline void QueryRegion::_internal_set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  partition_id_ = value;
}
inline void QueryRegion::set_partition_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_partition_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.partition_id)
}

// optional int64 replica_num = 4;
inline bool QueryRegion::_internal_has_replica_num() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool QueryRegion::has_replica_num() const {
  return _internal_has_replica_num();
}
inline void QueryRegion::clear_replica_num() {
  replica_num_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::_internal_replica_num() const {
  return replica_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::replica_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.replica_num)
  return _internal_replica_num();
}
inline void QueryRegion::_internal_set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  replica_num_ = value;
}
inline void QueryRegion::set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_replica_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.replica_num)
}

// optional int64 version = 5;
inline bool QueryRegion::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool QueryRegion::has_version() const {
  return _internal_has_version();
}
inline void QueryRegion::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.version)
  return _internal_version();
}
inline void QueryRegion::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00001000u;
  version_ = value;
}
inline void QueryRegion::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.version)
}

// optional int64 conf_version = 6;
inline bool QueryRegion::_internal_has_conf_version() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool QueryRegion::has_conf_version() const {
  return _internal_has_conf_version();
}
inline void QueryRegion::clear_conf_version() {
  conf_version_ = int64_t{0};
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::_internal_conf_version() const {
  return conf_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::conf_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.conf_version)
  return _internal_conf_version();
}
inline void QueryRegion::_internal_set_conf_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00002000u;
  conf_version_ = value;
}
inline void QueryRegion::set_conf_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_conf_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.conf_version)
}

// optional bytes start_key = 7;
inline bool QueryRegion::_internal_has_start_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QueryRegion::has_start_key() const {
  return _internal_has_start_key();
}
inline void QueryRegion::clear_start_key() {
  start_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryRegion::start_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.start_key)
  return _internal_start_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRegion::set_start_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 start_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.start_key)
}
inline std::string* QueryRegion::mutable_start_key() {
  std::string* _s = _internal_mutable_start_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRegion.start_key)
  return _s;
}
inline const std::string& QueryRegion::_internal_start_key() const {
  return start_key_.Get();
}
inline void QueryRegion::_internal_set_start_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  start_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRegion::_internal_mutable_start_key() {
  _has_bits_[0] |= 0x00000002u;
  return start_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRegion::release_start_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRegion.start_key)
  if (!_internal_has_start_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return start_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRegion::set_allocated_start_key(std::string* start_key) {
  if (start_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  start_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRegion.start_key)
}

// optional bytes end_key = 8;
inline bool QueryRegion::_internal_has_end_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QueryRegion::has_end_key() const {
  return _internal_has_end_key();
}
inline void QueryRegion::clear_end_key() {
  end_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& QueryRegion::end_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.end_key)
  return _internal_end_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRegion::set_end_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 end_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.end_key)
}
inline std::string* QueryRegion::mutable_end_key() {
  std::string* _s = _internal_mutable_end_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRegion.end_key)
  return _s;
}
inline const std::string& QueryRegion::_internal_end_key() const {
  return end_key_.Get();
}
inline void QueryRegion::_internal_set_end_key(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  end_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRegion::_internal_mutable_end_key() {
  _has_bits_[0] |= 0x00000004u;
  return end_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRegion::release_end_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRegion.end_key)
  if (!_internal_has_end_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return end_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRegion::set_allocated_end_key(std::string* end_key) {
  if (end_key != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  end_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), end_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRegion.end_key)
}

// optional string peers = 9;
inline bool QueryRegion::_internal_has_peers() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QueryRegion::has_peers() const {
  return _internal_has_peers();
}
inline void QueryRegion::clear_peers() {
  peers_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& QueryRegion::peers() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.peers)
  return _internal_peers();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRegion::set_peers(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 peers_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.peers)
}
inline std::string* QueryRegion::mutable_peers() {
  std::string* _s = _internal_mutable_peers();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRegion.peers)
  return _s;
}
inline const std::string& QueryRegion::_internal_peers() const {
  return peers_.Get();
}
inline void QueryRegion::_internal_set_peers(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  peers_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRegion::_internal_mutable_peers() {
  _has_bits_[0] |= 0x00000008u;
  return peers_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRegion::release_peers() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRegion.peers)
  if (!_internal_has_peers()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return peers_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRegion::set_allocated_peers(std::string* peers) {
  if (peers != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  peers_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peers,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRegion.peers)
}

// optional string leader = 10;
inline bool QueryRegion::_internal_has_leader() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QueryRegion::has_leader() const {
  return _internal_has_leader();
}
inline void QueryRegion::clear_leader() {
  leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& QueryRegion::leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRegion::set_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.leader)
}
inline std::string* QueryRegion::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRegion.leader)
  return _s;
}
inline const std::string& QueryRegion::_internal_leader() const {
  return leader_.Get();
}
inline void QueryRegion::_internal_set_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRegion::_internal_mutable_leader() {
  _has_bits_[0] |= 0x00000010u;
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRegion::release_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRegion.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRegion::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRegion.leader)
}

// optional .baikaldb.pb.RegionStatus status = 11;
inline bool QueryRegion::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool QueryRegion::has_status() const {
  return _internal_has_status();
}
inline void QueryRegion::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00400000u;
}
inline ::baikaldb::pb::RegionStatus QueryRegion::_internal_status() const {
  return static_cast< ::baikaldb::pb::RegionStatus >(status_);
}
inline ::baikaldb::pb::RegionStatus QueryRegion::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.status)
  return _internal_status();
}
inline void QueryRegion::_internal_set_status(::baikaldb::pb::RegionStatus value) {
  assert(::baikaldb::pb::RegionStatus_IsValid(value));
  _has_bits_[0] |= 0x00400000u;
  status_ = value;
}
inline void QueryRegion::set_status(::baikaldb::pb::RegionStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.status)
}

// optional int64 used_size = 12;
inline bool QueryRegion::_internal_has_used_size() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool QueryRegion::has_used_size() const {
  return _internal_has_used_size();
}
inline void QueryRegion::clear_used_size() {
  used_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::_internal_used_size() const {
  return used_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::used_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.used_size)
  return _internal_used_size();
}
inline void QueryRegion::_internal_set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00004000u;
  used_size_ = value;
}
inline void QueryRegion::set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_used_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.used_size)
}

// optional int64 log_index = 13;
inline bool QueryRegion::_internal_has_log_index() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool QueryRegion::has_log_index() const {
  return _internal_has_log_index();
}
inline void QueryRegion::clear_log_index() {
  log_index_ = int64_t{0};
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::_internal_log_index() const {
  return log_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::log_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.log_index)
  return _internal_log_index();
}
inline void QueryRegion::_internal_set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00008000u;
  log_index_ = value;
}
inline void QueryRegion::set_log_index(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_log_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.log_index)
}

// optional bool deleted = 14;
inline bool QueryRegion::_internal_has_deleted() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool QueryRegion::has_deleted() const {
  return _internal_has_deleted();
}
inline void QueryRegion::clear_deleted() {
  deleted_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool QueryRegion::_internal_deleted() const {
  return deleted_;
}
inline bool QueryRegion::deleted() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.deleted)
  return _internal_deleted();
}
inline void QueryRegion::_internal_set_deleted(bool value) {
  _has_bits_[0] |= 0x00100000u;
  deleted_ = value;
}
inline void QueryRegion::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.deleted)
}

// optional bool can_add_peer = 15;
inline bool QueryRegion::_internal_has_can_add_peer() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool QueryRegion::has_can_add_peer() const {
  return _internal_has_can_add_peer();
}
inline void QueryRegion::clear_can_add_peer() {
  can_add_peer_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool QueryRegion::_internal_can_add_peer() const {
  return can_add_peer_;
}
inline bool QueryRegion::can_add_peer() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.can_add_peer)
  return _internal_can_add_peer();
}
inline void QueryRegion::_internal_set_can_add_peer(bool value) {
  _has_bits_[0] |= 0x00200000u;
  can_add_peer_ = value;
}
inline void QueryRegion::set_can_add_peer(bool value) {
  _internal_set_can_add_peer(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.can_add_peer)
}

// optional string primary_key = 16;
inline bool QueryRegion::_internal_has_primary_key() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool QueryRegion::has_primary_key() const {
  return _internal_has_primary_key();
}
inline void QueryRegion::clear_primary_key() {
  primary_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& QueryRegion::primary_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.primary_key)
  return _internal_primary_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRegion::set_primary_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 primary_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.primary_key)
}
inline std::string* QueryRegion::mutable_primary_key() {
  std::string* _s = _internal_mutable_primary_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRegion.primary_key)
  return _s;
}
inline const std::string& QueryRegion::_internal_primary_key() const {
  return primary_key_.Get();
}
inline void QueryRegion::_internal_set_primary_key(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  primary_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRegion::_internal_mutable_primary_key() {
  _has_bits_[0] |= 0x00000020u;
  return primary_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRegion::release_primary_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRegion.primary_key)
  if (!_internal_has_primary_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return primary_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRegion::set_allocated_primary_key(std::string* primary_key) {
  if (primary_key != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  primary_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), primary_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRegion.primary_key)
}

// optional string resource_tag = 17;
inline bool QueryRegion::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool QueryRegion::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void QueryRegion::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& QueryRegion::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRegion::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.resource_tag)
}
inline std::string* QueryRegion::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRegion.resource_tag)
  return _s;
}
inline const std::string& QueryRegion::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void QueryRegion::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRegion::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000040u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRegion::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRegion.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRegion::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRegion.resource_tag)
}

// optional int64 parent = 18;
inline bool QueryRegion::_internal_has_parent() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool QueryRegion::has_parent() const {
  return _internal_has_parent();
}
inline void QueryRegion::clear_parent() {
  parent_ = int64_t{0};
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::_internal_parent() const {
  return parent_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::parent() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.parent)
  return _internal_parent();
}
inline void QueryRegion::_internal_set_parent(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00010000u;
  parent_ = value;
}
inline void QueryRegion::set_parent(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_parent(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.parent)
}

// optional string create_time = 19;
inline bool QueryRegion::_internal_has_create_time() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool QueryRegion::has_create_time() const {
  return _internal_has_create_time();
}
inline void QueryRegion::clear_create_time() {
  create_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& QueryRegion::create_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.create_time)
  return _internal_create_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRegion::set_create_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 create_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.create_time)
}
inline std::string* QueryRegion::mutable_create_time() {
  std::string* _s = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRegion.create_time)
  return _s;
}
inline const std::string& QueryRegion::_internal_create_time() const {
  return create_time_.Get();
}
inline void QueryRegion::_internal_set_create_time(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  create_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRegion::_internal_mutable_create_time() {
  _has_bits_[0] |= 0x00000080u;
  return create_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRegion::release_create_time() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRegion.create_time)
  if (!_internal_has_create_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return create_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRegion::set_allocated_create_time(std::string* create_time) {
  if (create_time != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  create_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), create_time,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRegion.create_time)
}

// optional int64 table_id = 20;
inline bool QueryRegion::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool QueryRegion::has_table_id() const {
  return _internal_has_table_id();
}
inline void QueryRegion::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.table_id)
  return _internal_table_id();
}
inline void QueryRegion::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00020000u;
  table_id_ = value;
}
inline void QueryRegion::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.table_id)
}

// optional int64 num_table_lines = 21;
inline bool QueryRegion::_internal_has_num_table_lines() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool QueryRegion::has_num_table_lines() const {
  return _internal_has_num_table_lines();
}
inline void QueryRegion::clear_num_table_lines() {
  num_table_lines_ = int64_t{0};
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::_internal_num_table_lines() const {
  return num_table_lines_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::num_table_lines() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.num_table_lines)
  return _internal_num_table_lines();
}
inline void QueryRegion::_internal_set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00040000u;
  num_table_lines_ = value;
}
inline void QueryRegion::set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_num_table_lines(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.num_table_lines)
}

// optional string raw_start_key = 22;
inline bool QueryRegion::_internal_has_raw_start_key() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool QueryRegion::has_raw_start_key() const {
  return _internal_has_raw_start_key();
}
inline void QueryRegion::clear_raw_start_key() {
  raw_start_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& QueryRegion::raw_start_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.raw_start_key)
  return _internal_raw_start_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryRegion::set_raw_start_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 raw_start_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.raw_start_key)
}
inline std::string* QueryRegion::mutable_raw_start_key() {
  std::string* _s = _internal_mutable_raw_start_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryRegion.raw_start_key)
  return _s;
}
inline const std::string& QueryRegion::_internal_raw_start_key() const {
  return raw_start_key_.Get();
}
inline void QueryRegion::_internal_set_raw_start_key(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  raw_start_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryRegion::_internal_mutable_raw_start_key() {
  _has_bits_[0] |= 0x00000100u;
  return raw_start_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryRegion::release_raw_start_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryRegion.raw_start_key)
  if (!_internal_has_raw_start_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  return raw_start_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryRegion::set_allocated_raw_start_key(std::string* raw_start_key) {
  if (raw_start_key != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  raw_start_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), raw_start_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryRegion.raw_start_key)
}

// optional int64 main_table_id = 23;
inline bool QueryRegion::_internal_has_main_table_id() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool QueryRegion::has_main_table_id() const {
  return _internal_has_main_table_id();
}
inline void QueryRegion::clear_main_table_id() {
  main_table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::_internal_main_table_id() const {
  return main_table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryRegion::main_table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryRegion.main_table_id)
  return _internal_main_table_id();
}
inline void QueryRegion::_internal_set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00080000u;
  main_table_id_ = value;
}
inline void QueryRegion::set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_main_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryRegion.main_table_id)
}

// -------------------------------------------------------------------

// QueryTable

// required string namespace_name = 1;
inline bool QueryTable::_internal_has_namespace_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QueryTable::has_namespace_name() const {
  return _internal_has_namespace_name();
}
inline void QueryTable::clear_namespace_name() {
  namespace_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryTable::namespace_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.namespace_name)
  return _internal_namespace_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryTable::set_namespace_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.namespace_name)
}
inline std::string* QueryTable::mutable_namespace_name() {
  std::string* _s = _internal_mutable_namespace_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryTable.namespace_name)
  return _s;
}
inline const std::string& QueryTable::_internal_namespace_name() const {
  return namespace_name_.Get();
}
inline void QueryTable::_internal_set_namespace_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  namespace_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryTable::_internal_mutable_namespace_name() {
  _has_bits_[0] |= 0x00000001u;
  return namespace_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryTable::release_namespace_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryTable.namespace_name)
  if (!_internal_has_namespace_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return namespace_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryTable::set_allocated_namespace_name(std::string* namespace_name) {
  if (namespace_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  namespace_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryTable.namespace_name)
}

// required string database = 2;
inline bool QueryTable::_internal_has_database() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QueryTable::has_database() const {
  return _internal_has_database();
}
inline void QueryTable::clear_database() {
  database_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryTable::database() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.database)
  return _internal_database();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryTable::set_database(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.database)
}
inline std::string* QueryTable::mutable_database() {
  std::string* _s = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryTable.database)
  return _s;
}
inline const std::string& QueryTable::_internal_database() const {
  return database_.Get();
}
inline void QueryTable::_internal_set_database(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  database_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryTable::_internal_mutable_database() {
  _has_bits_[0] |= 0x00000002u;
  return database_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryTable::release_database() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryTable.database)
  if (!_internal_has_database()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return database_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryTable::set_allocated_database(std::string* database) {
  if (database != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  database_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), database,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryTable.database)
}

// required string table_name = 3;
inline bool QueryTable::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QueryTable::has_table_name() const {
  return _internal_has_table_name();
}
inline void QueryTable::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& QueryTable::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryTable::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.table_name)
}
inline std::string* QueryTable::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryTable.table_name)
  return _s;
}
inline const std::string& QueryTable::_internal_table_name() const {
  return table_name_.Get();
}
inline void QueryTable::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryTable::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000004u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryTable::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryTable.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryTable::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryTable.table_name)
}

// optional string upper_table_name = 4;
inline bool QueryTable::_internal_has_upper_table_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QueryTable::has_upper_table_name() const {
  return _internal_has_upper_table_name();
}
inline void QueryTable::clear_upper_table_name() {
  upper_table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& QueryTable::upper_table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.upper_table_name)
  return _internal_upper_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryTable::set_upper_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 upper_table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.upper_table_name)
}
inline std::string* QueryTable::mutable_upper_table_name() {
  std::string* _s = _internal_mutable_upper_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryTable.upper_table_name)
  return _s;
}
inline const std::string& QueryTable::_internal_upper_table_name() const {
  return upper_table_name_.Get();
}
inline void QueryTable::_internal_set_upper_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  upper_table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryTable::_internal_mutable_upper_table_name() {
  _has_bits_[0] |= 0x00000008u;
  return upper_table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryTable::release_upper_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryTable.upper_table_name)
  if (!_internal_has_upper_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return upper_table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryTable::set_allocated_upper_table_name(std::string* upper_table_name) {
  if (upper_table_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  upper_table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), upper_table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryTable.upper_table_name)
}

// required int64 region_size = 5;
inline bool QueryTable::_internal_has_region_size() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool QueryTable::has_region_size() const {
  return _internal_has_region_size();
}
inline void QueryTable::clear_region_size() {
  region_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::_internal_region_size() const {
  return region_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::region_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.region_size)
  return _internal_region_size();
}
inline void QueryTable::_internal_set_region_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  region_size_ = value;
}
inline void QueryTable::set_region_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.region_size)
}

// required int64 replica_num = 6;
inline bool QueryTable::_internal_has_replica_num() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool QueryTable::has_replica_num() const {
  return _internal_has_replica_num();
}
inline void QueryTable::clear_replica_num() {
  replica_num_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::_internal_replica_num() const {
  return replica_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::replica_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.replica_num)
  return _internal_replica_num();
}
inline void QueryTable::_internal_set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  replica_num_ = value;
}
inline void QueryTable::set_replica_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_replica_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.replica_num)
}

// required string resource_tag = 7;
inline bool QueryTable::_internal_has_resource_tag() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QueryTable::has_resource_tag() const {
  return _internal_has_resource_tag();
}
inline void QueryTable::clear_resource_tag() {
  resource_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& QueryTable::resource_tag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.resource_tag)
  return _internal_resource_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryTable::set_resource_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.resource_tag)
}
inline std::string* QueryTable::mutable_resource_tag() {
  std::string* _s = _internal_mutable_resource_tag();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryTable.resource_tag)
  return _s;
}
inline const std::string& QueryTable::_internal_resource_tag() const {
  return resource_tag_.Get();
}
inline void QueryTable::_internal_set_resource_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  resource_tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryTable::_internal_mutable_resource_tag() {
  _has_bits_[0] |= 0x00000010u;
  return resource_tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryTable::release_resource_tag() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryTable.resource_tag)
  if (!_internal_has_resource_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return resource_tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryTable::set_allocated_resource_tag(std::string* resource_tag) {
  if (resource_tag != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  resource_tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), resource_tag,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryTable.resource_tag)
}

// required int64 max_field_id = 8;
inline bool QueryTable::_internal_has_max_field_id() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool QueryTable::has_max_field_id() const {
  return _internal_has_max_field_id();
}
inline void QueryTable::clear_max_field_id() {
  max_field_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::_internal_max_field_id() const {
  return max_field_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::max_field_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.max_field_id)
  return _internal_max_field_id();
}
inline void QueryTable::_internal_set_max_field_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  max_field_id_ = value;
}
inline void QueryTable::set_max_field_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_max_field_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.max_field_id)
}

// required int64 version = 10;
inline bool QueryTable::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool QueryTable::has_version() const {
  return _internal_has_version();
}
inline void QueryTable::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.version)
  return _internal_version();
}
inline void QueryTable::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  version_ = value;
}
inline void QueryTable::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.version)
}

// required .baikaldb.pb.Status status = 11;
inline bool QueryTable::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool QueryTable::has_status() const {
  return _internal_has_status();
}
inline void QueryTable::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::baikaldb::pb::Status QueryTable::_internal_status() const {
  return static_cast< ::baikaldb::pb::Status >(status_);
}
inline ::baikaldb::pb::Status QueryTable::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.status)
  return _internal_status();
}
inline void QueryTable::_internal_set_status(::baikaldb::pb::Status value) {
  assert(::baikaldb::pb::Status_IsValid(value));
  _has_bits_[0] |= 0x00200000u;
  status_ = value;
}
inline void QueryTable::set_status(::baikaldb::pb::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.status)
}

// optional string split_keys = 12;
inline bool QueryTable::_internal_has_split_keys() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool QueryTable::has_split_keys() const {
  return _internal_has_split_keys();
}
inline void QueryTable::clear_split_keys() {
  split_keys_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& QueryTable::split_keys() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.split_keys)
  return _internal_split_keys();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryTable::set_split_keys(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 split_keys_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.split_keys)
}
inline std::string* QueryTable::mutable_split_keys() {
  std::string* _s = _internal_mutable_split_keys();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryTable.split_keys)
  return _s;
}
inline const std::string& QueryTable::_internal_split_keys() const {
  return split_keys_.Get();
}
inline void QueryTable::_internal_set_split_keys(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  split_keys_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryTable::_internal_mutable_split_keys() {
  _has_bits_[0] |= 0x00000020u;
  return split_keys_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryTable::release_split_keys() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryTable.split_keys)
  if (!_internal_has_split_keys()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return split_keys_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryTable::set_allocated_split_keys(std::string* split_keys) {
  if (split_keys != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  split_keys_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), split_keys,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryTable.split_keys)
}

// required bool deleted = 13;
inline bool QueryTable::_internal_has_deleted() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool QueryTable::has_deleted() const {
  return _internal_has_deleted();
}
inline void QueryTable::clear_deleted() {
  deleted_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool QueryTable::_internal_deleted() const {
  return deleted_;
}
inline bool QueryTable::deleted() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.deleted)
  return _internal_deleted();
}
inline void QueryTable::_internal_set_deleted(bool value) {
  _has_bits_[0] |= 0x00100000u;
  deleted_ = value;
}
inline void QueryTable::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.deleted)
}

// required int64 byte_size_per_record = 14;
inline bool QueryTable::_internal_has_byte_size_per_record() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool QueryTable::has_byte_size_per_record() const {
  return _internal_has_byte_size_per_record();
}
inline void QueryTable::clear_byte_size_per_record() {
  byte_size_per_record_ = int64_t{0};
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::_internal_byte_size_per_record() const {
  return byte_size_per_record_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::byte_size_per_record() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.byte_size_per_record)
  return _internal_byte_size_per_record();
}
inline void QueryTable::_internal_set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00001000u;
  byte_size_per_record_ = value;
}
inline void QueryTable::set_byte_size_per_record(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_byte_size_per_record(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.byte_size_per_record)
}

// optional int64 table_id = 15;
inline bool QueryTable::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool QueryTable::has_table_id() const {
  return _internal_has_table_id();
}
inline void QueryTable::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.table_id)
  return _internal_table_id();
}
inline void QueryTable::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00002000u;
  table_id_ = value;
}
inline void QueryTable::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.table_id)
}

// optional string create_time = 16;
inline bool QueryTable::_internal_has_create_time() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool QueryTable::has_create_time() const {
  return _internal_has_create_time();
}
inline void QueryTable::clear_create_time() {
  create_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& QueryTable::create_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.create_time)
  return _internal_create_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryTable::set_create_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 create_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.create_time)
}
inline std::string* QueryTable::mutable_create_time() {
  std::string* _s = _internal_mutable_create_time();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryTable.create_time)
  return _s;
}
inline const std::string& QueryTable::_internal_create_time() const {
  return create_time_.Get();
}
inline void QueryTable::_internal_set_create_time(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  create_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryTable::_internal_mutable_create_time() {
  _has_bits_[0] |= 0x00000040u;
  return create_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryTable::release_create_time() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryTable.create_time)
  if (!_internal_has_create_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return create_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryTable::set_allocated_create_time(std::string* create_time) {
  if (create_time != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  create_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), create_time,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryTable.create_time)
}

// optional int64 region_count = 17;
inline bool QueryTable::_internal_has_region_count() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool QueryTable::has_region_count() const {
  return _internal_has_region_count();
}
inline void QueryTable::clear_region_count() {
  region_count_ = int64_t{0};
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::_internal_region_count() const {
  return region_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::region_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.region_count)
  return _internal_region_count();
}
inline void QueryTable::_internal_set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00004000u;
  region_count_ = value;
}
inline void QueryTable::set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.region_count)
}

// optional int64 row_count = 18;
inline bool QueryTable::_internal_has_row_count() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool QueryTable::has_row_count() const {
  return _internal_has_row_count();
}
inline void QueryTable::clear_row_count() {
  row_count_ = int64_t{0};
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::_internal_row_count() const {
  return row_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::row_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.row_count)
  return _internal_row_count();
}
inline void QueryTable::_internal_set_row_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00008000u;
  row_count_ = value;
}
inline void QueryTable::set_row_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_row_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.row_count)
}

// optional int64 main_table_id = 19;
inline bool QueryTable::_internal_has_main_table_id() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool QueryTable::has_main_table_id() const {
  return _internal_has_main_table_id();
}
inline void QueryTable::clear_main_table_id() {
  main_table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::_internal_main_table_id() const {
  return main_table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::main_table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.main_table_id)
  return _internal_main_table_id();
}
inline void QueryTable::_internal_set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00010000u;
  main_table_id_ = value;
}
inline void QueryTable::set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_main_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.main_table_id)
}

// optional int64 region_split_lines = 20;
inline bool QueryTable::_internal_has_region_split_lines() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool QueryTable::has_region_split_lines() const {
  return _internal_has_region_split_lines();
}
inline void QueryTable::clear_region_split_lines() {
  region_split_lines_ = int64_t{0};
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::_internal_region_split_lines() const {
  return region_split_lines_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::region_split_lines() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.region_split_lines)
  return _internal_region_split_lines();
}
inline void QueryTable::_internal_set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00020000u;
  region_split_lines_ = value;
}
inline void QueryTable::set_region_split_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_split_lines(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.region_split_lines)
}

// optional int64 partition_num = 21;
inline bool QueryTable::_internal_has_partition_num() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool QueryTable::has_partition_num() const {
  return _internal_has_partition_num();
}
inline void QueryTable::clear_partition_num() {
  partition_num_ = int64_t{0};
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::_internal_partition_num() const {
  return partition_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::partition_num() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.partition_num)
  return _internal_partition_num();
}
inline void QueryTable::_internal_set_partition_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00040000u;
  partition_num_ = value;
}
inline void QueryTable::set_partition_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_partition_num(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.partition_num)
}

// optional int64 fast_importer_ts = 22;
inline bool QueryTable::_internal_has_fast_importer_ts() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool QueryTable::has_fast_importer_ts() const {
  return _internal_has_fast_importer_ts();
}
inline void QueryTable::clear_fast_importer_ts() {
  fast_importer_ts_ = int64_t{0};
  _has_bits_[0] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::_internal_fast_importer_ts() const {
  return fast_importer_ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QueryTable::fast_importer_ts() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.fast_importer_ts)
  return _internal_fast_importer_ts();
}
inline void QueryTable::_internal_set_fast_importer_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00080000u;
  fast_importer_ts_ = value;
}
inline void QueryTable::set_fast_importer_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_fast_importer_ts(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.fast_importer_ts)
}

// optional string binlog = 23;
inline bool QueryTable::_internal_has_binlog() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool QueryTable::has_binlog() const {
  return _internal_has_binlog();
}
inline void QueryTable::clear_binlog() {
  binlog_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& QueryTable::binlog() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QueryTable.binlog)
  return _internal_binlog();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueryTable::set_binlog(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 binlog_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QueryTable.binlog)
}
inline std::string* QueryTable::mutable_binlog() {
  std::string* _s = _internal_mutable_binlog();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QueryTable.binlog)
  return _s;
}
inline const std::string& QueryTable::_internal_binlog() const {
  return binlog_.Get();
}
inline void QueryTable::_internal_set_binlog(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  binlog_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QueryTable::_internal_mutable_binlog() {
  _has_bits_[0] |= 0x00000080u;
  return binlog_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QueryTable::release_binlog() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QueryTable.binlog)
  if (!_internal_has_binlog()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return binlog_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QueryTable::set_allocated_binlog(std::string* binlog) {
  if (binlog != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  binlog_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), binlog,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QueryTable.binlog)
}

// -------------------------------------------------------------------

// QuerySchema

// required string field_or_index = 1;
inline bool QuerySchema::_internal_has_field_or_index() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QuerySchema::has_field_or_index() const {
  return _internal_has_field_or_index();
}
inline void QuerySchema::clear_field_or_index() {
  field_or_index_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QuerySchema::field_or_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QuerySchema.field_or_index)
  return _internal_field_or_index();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QuerySchema::set_field_or_index(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 field_or_index_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QuerySchema.field_or_index)
}
inline std::string* QuerySchema::mutable_field_or_index() {
  std::string* _s = _internal_mutable_field_or_index();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QuerySchema.field_or_index)
  return _s;
}
inline const std::string& QuerySchema::_internal_field_or_index() const {
  return field_or_index_.Get();
}
inline void QuerySchema::_internal_set_field_or_index(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  field_or_index_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QuerySchema::_internal_mutable_field_or_index() {
  _has_bits_[0] |= 0x00000001u;
  return field_or_index_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QuerySchema::release_field_or_index() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QuerySchema.field_or_index)
  if (!_internal_has_field_or_index()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return field_or_index_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QuerySchema::set_allocated_field_or_index(std::string* field_or_index) {
  if (field_or_index != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  field_or_index_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), field_or_index,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QuerySchema.field_or_index)
}

// required string column_name = 2;
inline bool QuerySchema::_internal_has_column_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QuerySchema::has_column_name() const {
  return _internal_has_column_name();
}
inline void QuerySchema::clear_column_name() {
  column_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QuerySchema::column_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QuerySchema.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QuerySchema::set_column_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 column_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QuerySchema.column_name)
}
inline std::string* QuerySchema::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QuerySchema.column_name)
  return _s;
}
inline const std::string& QuerySchema::_internal_column_name() const {
  return column_name_.Get();
}
inline void QuerySchema::_internal_set_column_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  column_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QuerySchema::_internal_mutable_column_name() {
  _has_bits_[0] |= 0x00000002u;
  return column_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QuerySchema::release_column_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QuerySchema.column_name)
  if (!_internal_has_column_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return column_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QuerySchema::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  column_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), column_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QuerySchema.column_name)
}

// required int64 column_id = 3;
inline bool QuerySchema::_internal_has_column_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool QuerySchema::has_column_id() const {
  return _internal_has_column_id();
}
inline void QuerySchema::clear_column_id() {
  column_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QuerySchema::_internal_column_id() const {
  return column_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QuerySchema::column_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QuerySchema.column_id)
  return _internal_column_id();
}
inline void QuerySchema::_internal_set_column_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  column_id_ = value;
}
inline void QuerySchema::set_column_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_column_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QuerySchema.column_id)
}

// required string column_type = 4;
inline bool QuerySchema::_internal_has_column_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QuerySchema::has_column_type() const {
  return _internal_has_column_type();
}
inline void QuerySchema::clear_column_type() {
  column_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& QuerySchema::column_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QuerySchema.column_type)
  return _internal_column_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QuerySchema::set_column_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 column_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QuerySchema.column_type)
}
inline std::string* QuerySchema::mutable_column_type() {
  std::string* _s = _internal_mutable_column_type();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QuerySchema.column_type)
  return _s;
}
inline const std::string& QuerySchema::_internal_column_type() const {
  return column_type_.Get();
}
inline void QuerySchema::_internal_set_column_type(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  column_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QuerySchema::_internal_mutable_column_type() {
  _has_bits_[0] |= 0x00000004u;
  return column_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QuerySchema::release_column_type() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QuerySchema.column_type)
  if (!_internal_has_column_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return column_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QuerySchema::set_allocated_column_type(std::string* column_type) {
  if (column_type != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  column_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), column_type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QuerySchema.column_type)
}

// optional bool can_null = 5;
inline bool QuerySchema::_internal_has_can_null() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool QuerySchema::has_can_null() const {
  return _internal_has_can_null();
}
inline void QuerySchema::clear_can_null() {
  can_null_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool QuerySchema::_internal_can_null() const {
  return can_null_;
}
inline bool QuerySchema::can_null() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QuerySchema.can_null)
  return _internal_can_null();
}
inline void QuerySchema::_internal_set_can_null(bool value) {
  _has_bits_[0] |= 0x00000080u;
  can_null_ = value;
}
inline void QuerySchema::set_can_null(bool value) {
  _internal_set_can_null(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QuerySchema.can_null)
}

// optional string extra = 6;
inline bool QuerySchema::_internal_has_extra() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QuerySchema::has_extra() const {
  return _internal_has_extra();
}
inline void QuerySchema::clear_extra() {
  extra_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& QuerySchema::extra() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QuerySchema.extra)
  return _internal_extra();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QuerySchema::set_extra(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 extra_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QuerySchema.extra)
}
inline std::string* QuerySchema::mutable_extra() {
  std::string* _s = _internal_mutable_extra();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QuerySchema.extra)
  return _s;
}
inline const std::string& QuerySchema::_internal_extra() const {
  return extra_.Get();
}
inline void QuerySchema::_internal_set_extra(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  extra_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QuerySchema::_internal_mutable_extra() {
  _has_bits_[0] |= 0x00000008u;
  return extra_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QuerySchema::release_extra() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QuerySchema.extra)
  if (!_internal_has_extra()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return extra_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QuerySchema::set_allocated_extra(std::string* extra) {
  if (extra != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  extra_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extra,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QuerySchema.extra)
}

// optional bool deleted = 7;
inline bool QuerySchema::_internal_has_deleted() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool QuerySchema::has_deleted() const {
  return _internal_has_deleted();
}
inline void QuerySchema::clear_deleted() {
  deleted_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool QuerySchema::_internal_deleted() const {
  return deleted_;
}
inline bool QuerySchema::deleted() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QuerySchema.deleted)
  return _internal_deleted();
}
inline void QuerySchema::_internal_set_deleted(bool value) {
  _has_bits_[0] |= 0x00000100u;
  deleted_ = value;
}
inline void QuerySchema::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.QuerySchema.deleted)
}

// optional string default_value = 8;
inline bool QuerySchema::_internal_has_default_value() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QuerySchema::has_default_value() const {
  return _internal_has_default_value();
}
inline void QuerySchema::clear_default_value() {
  default_value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& QuerySchema::default_value() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QuerySchema.default_value)
  return _internal_default_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QuerySchema::set_default_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 default_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QuerySchema.default_value)
}
inline std::string* QuerySchema::mutable_default_value() {
  std::string* _s = _internal_mutable_default_value();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QuerySchema.default_value)
  return _s;
}
inline const std::string& QuerySchema::_internal_default_value() const {
  return default_value_.Get();
}
inline void QuerySchema::_internal_set_default_value(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  default_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QuerySchema::_internal_mutable_default_value() {
  _has_bits_[0] |= 0x00000010u;
  return default_value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QuerySchema::release_default_value() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QuerySchema.default_value)
  if (!_internal_has_default_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return default_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QuerySchema::set_allocated_default_value(std::string* default_value) {
  if (default_value != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  default_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), default_value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QuerySchema.default_value)
}

// optional string comment = 9;
inline bool QuerySchema::_internal_has_comment() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool QuerySchema::has_comment() const {
  return _internal_has_comment();
}
inline void QuerySchema::clear_comment() {
  comment_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& QuerySchema::comment() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.QuerySchema.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QuerySchema::set_comment(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 comment_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.QuerySchema.comment)
}
inline std::string* QuerySchema::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.QuerySchema.comment)
  return _s;
}
inline const std::string& QuerySchema::_internal_comment() const {
  return comment_.Get();
}
inline void QuerySchema::_internal_set_comment(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  comment_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* QuerySchema::_internal_mutable_comment() {
  _has_bits_[0] |= 0x00000020u;
  return comment_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* QuerySchema::release_comment() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.QuerySchema.comment)
  if (!_internal_has_comment()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return comment_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void QuerySchema::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  comment_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comment,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.QuerySchema.comment)
}

// -------------------------------------------------------------------

// MigrateInstance

// optional string name = 1;
inline bool MigrateInstance::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MigrateInstance::has_name() const {
  return _internal_has_name();
}
inline void MigrateInstance::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MigrateInstance::name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MigrateInstance.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MigrateInstance::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MigrateInstance.name)
}
inline std::string* MigrateInstance::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MigrateInstance.name)
  return _s;
}
inline const std::string& MigrateInstance::_internal_name() const {
  return name_.Get();
}
inline void MigrateInstance::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MigrateInstance::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MigrateInstance::release_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MigrateInstance.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MigrateInstance::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MigrateInstance.name)
}

// optional string event = 2;
inline bool MigrateInstance::_internal_has_event() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MigrateInstance::has_event() const {
  return _internal_has_event();
}
inline void MigrateInstance::clear_event() {
  event_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MigrateInstance::event() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MigrateInstance.event)
  return _internal_event();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MigrateInstance::set_event(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 event_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MigrateInstance.event)
}
inline std::string* MigrateInstance::mutable_event() {
  std::string* _s = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MigrateInstance.event)
  return _s;
}
inline const std::string& MigrateInstance::_internal_event() const {
  return event_.Get();
}
inline void MigrateInstance::_internal_set_event(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  event_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MigrateInstance::_internal_mutable_event() {
  _has_bits_[0] |= 0x00000002u;
  return event_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MigrateInstance::release_event() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MigrateInstance.event)
  if (!_internal_has_event()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return event_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MigrateInstance::set_allocated_event(std::string* event) {
  if (event != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  event_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), event,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MigrateInstance.event)
}

// optional string pre_host = 3;
inline bool MigrateInstance::_internal_has_pre_host() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MigrateInstance::has_pre_host() const {
  return _internal_has_pre_host();
}
inline void MigrateInstance::clear_pre_host() {
  pre_host_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MigrateInstance::pre_host() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MigrateInstance.pre_host)
  return _internal_pre_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MigrateInstance::set_pre_host(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 pre_host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MigrateInstance.pre_host)
}
inline std::string* MigrateInstance::mutable_pre_host() {
  std::string* _s = _internal_mutable_pre_host();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MigrateInstance.pre_host)
  return _s;
}
inline const std::string& MigrateInstance::_internal_pre_host() const {
  return pre_host_.Get();
}
inline void MigrateInstance::_internal_set_pre_host(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  pre_host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MigrateInstance::_internal_mutable_pre_host() {
  _has_bits_[0] |= 0x00000004u;
  return pre_host_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MigrateInstance::release_pre_host() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MigrateInstance.pre_host)
  if (!_internal_has_pre_host()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return pre_host_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MigrateInstance::set_allocated_pre_host(std::string* pre_host) {
  if (pre_host != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  pre_host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pre_host,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MigrateInstance.pre_host)
}

// optional string pre_port = 4;
inline bool MigrateInstance::_internal_has_pre_port() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MigrateInstance::has_pre_port() const {
  return _internal_has_pre_port();
}
inline void MigrateInstance::clear_pre_port() {
  pre_port_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MigrateInstance::pre_port() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MigrateInstance.pre_port)
  return _internal_pre_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MigrateInstance::set_pre_port(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 pre_port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MigrateInstance.pre_port)
}
inline std::string* MigrateInstance::mutable_pre_port() {
  std::string* _s = _internal_mutable_pre_port();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MigrateInstance.pre_port)
  return _s;
}
inline const std::string& MigrateInstance::_internal_pre_port() const {
  return pre_port_.Get();
}
inline void MigrateInstance::_internal_set_pre_port(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  pre_port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MigrateInstance::_internal_mutable_pre_port() {
  _has_bits_[0] |= 0x00000008u;
  return pre_port_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MigrateInstance::release_pre_port() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MigrateInstance.pre_port)
  if (!_internal_has_pre_port()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return pre_port_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MigrateInstance::set_allocated_pre_port(std::string* pre_port) {
  if (pre_port != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  pre_port_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pre_port,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MigrateInstance.pre_port)
}

// optional string post_host = 5;
inline bool MigrateInstance::_internal_has_post_host() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MigrateInstance::has_post_host() const {
  return _internal_has_post_host();
}
inline void MigrateInstance::clear_post_host() {
  post_host_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MigrateInstance::post_host() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MigrateInstance.post_host)
  return _internal_post_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MigrateInstance::set_post_host(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 post_host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MigrateInstance.post_host)
}
inline std::string* MigrateInstance::mutable_post_host() {
  std::string* _s = _internal_mutable_post_host();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MigrateInstance.post_host)
  return _s;
}
inline const std::string& MigrateInstance::_internal_post_host() const {
  return post_host_.Get();
}
inline void MigrateInstance::_internal_set_post_host(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  post_host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MigrateInstance::_internal_mutable_post_host() {
  _has_bits_[0] |= 0x00000010u;
  return post_host_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MigrateInstance::release_post_host() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MigrateInstance.post_host)
  if (!_internal_has_post_host()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return post_host_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MigrateInstance::set_allocated_post_host(std::string* post_host) {
  if (post_host != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  post_host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), post_host,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MigrateInstance.post_host)
}

// optional string post_port = 6;
inline bool MigrateInstance::_internal_has_post_port() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MigrateInstance::has_post_port() const {
  return _internal_has_post_port();
}
inline void MigrateInstance::clear_post_port() {
  post_port_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& MigrateInstance::post_port() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MigrateInstance.post_port)
  return _internal_post_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MigrateInstance::set_post_port(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 post_port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MigrateInstance.post_port)
}
inline std::string* MigrateInstance::mutable_post_port() {
  std::string* _s = _internal_mutable_post_port();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MigrateInstance.post_port)
  return _s;
}
inline const std::string& MigrateInstance::_internal_post_port() const {
  return post_port_.Get();
}
inline void MigrateInstance::_internal_set_post_port(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  post_port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MigrateInstance::_internal_mutable_post_port() {
  _has_bits_[0] |= 0x00000020u;
  return post_port_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MigrateInstance::release_post_port() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MigrateInstance.post_port)
  if (!_internal_has_post_port()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return post_port_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MigrateInstance::set_allocated_post_port(std::string* post_port) {
  if (post_port != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  post_port_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), post_port,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MigrateInstance.post_port)
}

// optional string status = 7;
inline bool MigrateInstance::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MigrateInstance::has_status() const {
  return _internal_has_status();
}
inline void MigrateInstance::clear_status() {
  status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& MigrateInstance::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MigrateInstance.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MigrateInstance::set_status(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MigrateInstance.status)
}
inline std::string* MigrateInstance::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MigrateInstance.status)
  return _s;
}
inline const std::string& MigrateInstance::_internal_status() const {
  return status_.Get();
}
inline void MigrateInstance::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MigrateInstance::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000040u;
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MigrateInstance::release_status() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MigrateInstance.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MigrateInstance::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MigrateInstance.status)
}

// -------------------------------------------------------------------

// TargetsList

// repeated .baikaldb.pb.MigrateInstance instances = 1;
inline int TargetsList::_internal_instances_size() const {
  return instances_.size();
}
inline int TargetsList::instances_size() const {
  return _internal_instances_size();
}
inline void TargetsList::clear_instances() {
  instances_.Clear();
}
inline ::baikaldb::pb::MigrateInstance* TargetsList::mutable_instances(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TargetsList.instances)
  return instances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::MigrateInstance >*
TargetsList::mutable_instances() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.TargetsList.instances)
  return &instances_;
}
inline const ::baikaldb::pb::MigrateInstance& TargetsList::_internal_instances(int index) const {
  return instances_.Get(index);
}
inline const ::baikaldb::pb::MigrateInstance& TargetsList::instances(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TargetsList.instances)
  return _internal_instances(index);
}
inline ::baikaldb::pb::MigrateInstance* TargetsList::_internal_add_instances() {
  return instances_.Add();
}
inline ::baikaldb::pb::MigrateInstance* TargetsList::add_instances() {
  ::baikaldb::pb::MigrateInstance* _add = _internal_add_instances();
  // @@protoc_insertion_point(field_add:baikaldb.pb.TargetsList.instances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::MigrateInstance >&
TargetsList::instances() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.TargetsList.instances)
  return instances_;
}

// -------------------------------------------------------------------

// MigrateRequest

// optional string opera_action = 1;
inline bool MigrateRequest::_internal_has_opera_action() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MigrateRequest::has_opera_action() const {
  return _internal_has_opera_action();
}
inline void MigrateRequest::clear_opera_action() {
  opera_action_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MigrateRequest::opera_action() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MigrateRequest.opera_action)
  return _internal_opera_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MigrateRequest::set_opera_action(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 opera_action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.MigrateRequest.opera_action)
}
inline std::string* MigrateRequest::mutable_opera_action() {
  std::string* _s = _internal_mutable_opera_action();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MigrateRequest.opera_action)
  return _s;
}
inline const std::string& MigrateRequest::_internal_opera_action() const {
  return opera_action_.Get();
}
inline void MigrateRequest::_internal_set_opera_action(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  opera_action_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MigrateRequest::_internal_mutable_opera_action() {
  _has_bits_[0] |= 0x00000001u;
  return opera_action_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MigrateRequest::release_opera_action() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MigrateRequest.opera_action)
  if (!_internal_has_opera_action()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return opera_action_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MigrateRequest::set_allocated_opera_action(std::string* opera_action) {
  if (opera_action != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  opera_action_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), opera_action,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MigrateRequest.opera_action)
}

// optional .baikaldb.pb.TargetsList targets_list = 2;
inline bool MigrateRequest::_internal_has_targets_list() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || targets_list_ != nullptr);
  return value;
}
inline bool MigrateRequest::has_targets_list() const {
  return _internal_has_targets_list();
}
inline void MigrateRequest::clear_targets_list() {
  if (targets_list_ != nullptr) targets_list_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::baikaldb::pb::TargetsList& MigrateRequest::_internal_targets_list() const {
  const ::baikaldb::pb::TargetsList* p = targets_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::TargetsList&>(
      ::baikaldb::pb::_TargetsList_default_instance_);
}
inline const ::baikaldb::pb::TargetsList& MigrateRequest::targets_list() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MigrateRequest.targets_list)
  return _internal_targets_list();
}
inline void MigrateRequest::unsafe_arena_set_allocated_targets_list(
    ::baikaldb::pb::TargetsList* targets_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(targets_list_);
  }
  targets_list_ = targets_list;
  if (targets_list) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MigrateRequest.targets_list)
}
inline ::baikaldb::pb::TargetsList* MigrateRequest::release_targets_list() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::TargetsList* temp = targets_list_;
  targets_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::TargetsList* MigrateRequest::unsafe_arena_release_targets_list() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MigrateRequest.targets_list)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::TargetsList* temp = targets_list_;
  targets_list_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::TargetsList* MigrateRequest::_internal_mutable_targets_list() {
  _has_bits_[0] |= 0x00000002u;
  if (targets_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::TargetsList>(GetArenaForAllocation());
    targets_list_ = p;
  }
  return targets_list_;
}
inline ::baikaldb::pb::TargetsList* MigrateRequest::mutable_targets_list() {
  ::baikaldb::pb::TargetsList* _msg = _internal_mutable_targets_list();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MigrateRequest.targets_list)
  return _msg;
}
inline void MigrateRequest::set_allocated_targets_list(::baikaldb::pb::TargetsList* targets_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete targets_list_;
  }
  if (targets_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::TargetsList>::GetOwningArena(targets_list);
    if (message_arena != submessage_arena) {
      targets_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, targets_list, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  targets_list_ = targets_list;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MigrateRequest.targets_list)
}

// -------------------------------------------------------------------

// MigrateData

// optional .baikaldb.pb.TargetsList targets_list = 1;
inline bool MigrateData::_internal_has_targets_list() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || targets_list_ != nullptr);
  return value;
}
inline bool MigrateData::has_targets_list() const {
  return _internal_has_targets_list();
}
inline void MigrateData::clear_targets_list() {
  if (targets_list_ != nullptr) targets_list_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::TargetsList& MigrateData::_internal_targets_list() const {
  const ::baikaldb::pb::TargetsList* p = targets_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::TargetsList&>(
      ::baikaldb::pb::_TargetsList_default_instance_);
}
inline const ::baikaldb::pb::TargetsList& MigrateData::targets_list() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MigrateData.targets_list)
  return _internal_targets_list();
}
inline void MigrateData::unsafe_arena_set_allocated_targets_list(
    ::baikaldb::pb::TargetsList* targets_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(targets_list_);
  }
  targets_list_ = targets_list;
  if (targets_list) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MigrateData.targets_list)
}
inline ::baikaldb::pb::TargetsList* MigrateData::release_targets_list() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::TargetsList* temp = targets_list_;
  targets_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::TargetsList* MigrateData::unsafe_arena_release_targets_list() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MigrateData.targets_list)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::TargetsList* temp = targets_list_;
  targets_list_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::TargetsList* MigrateData::_internal_mutable_targets_list() {
  _has_bits_[0] |= 0x00000001u;
  if (targets_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::TargetsList>(GetArenaForAllocation());
    targets_list_ = p;
  }
  return targets_list_;
}
inline ::baikaldb::pb::TargetsList* MigrateData::mutable_targets_list() {
  ::baikaldb::pb::TargetsList* _msg = _internal_mutable_targets_list();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MigrateData.targets_list)
  return _msg;
}
inline void MigrateData::set_allocated_targets_list(::baikaldb::pb::TargetsList* targets_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete targets_list_;
  }
  if (targets_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::TargetsList>::GetOwningArena(targets_list);
    if (message_arena != submessage_arena) {
      targets_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, targets_list, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  targets_list_ = targets_list;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MigrateData.targets_list)
}

// -------------------------------------------------------------------

// MigrateResponse

// optional .baikaldb.pb.MigrateData data = 1;
inline bool MigrateResponse::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || data_ != nullptr);
  return value;
}
inline bool MigrateResponse::has_data() const {
  return _internal_has_data();
}
inline void MigrateResponse::clear_data() {
  if (data_ != nullptr) data_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::MigrateData& MigrateResponse::_internal_data() const {
  const ::baikaldb::pb::MigrateData* p = data_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::MigrateData&>(
      ::baikaldb::pb::_MigrateData_default_instance_);
}
inline const ::baikaldb::pb::MigrateData& MigrateResponse::data() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.MigrateResponse.data)
  return _internal_data();
}
inline void MigrateResponse::unsafe_arena_set_allocated_data(
    ::baikaldb::pb::MigrateData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_);
  }
  data_ = data;
  if (data) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.MigrateResponse.data)
}
inline ::baikaldb::pb::MigrateData* MigrateResponse::release_data() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::MigrateData* temp = data_;
  data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::MigrateData* MigrateResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.MigrateResponse.data)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::MigrateData* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::MigrateData* MigrateResponse::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::MigrateData>(GetArenaForAllocation());
    data_ = p;
  }
  return data_;
}
inline ::baikaldb::pb::MigrateData* MigrateResponse::mutable_data() {
  ::baikaldb::pb::MigrateData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.MigrateResponse.data)
  return _msg;
}
inline void MigrateResponse::set_allocated_data(::baikaldb::pb::MigrateData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::MigrateData>::GetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.MigrateResponse.data)
}

// -------------------------------------------------------------------

// TableInfo

// optional .baikaldb.pb.SchemaInfo schema_info = 1;
inline bool TableInfo::_internal_has_schema_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || schema_info_ != nullptr);
  return value;
}
inline bool TableInfo::has_schema_info() const {
  return _internal_has_schema_info();
}
inline void TableInfo::clear_schema_info() {
  if (schema_info_ != nullptr) schema_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::SchemaInfo& TableInfo::_internal_schema_info() const {
  const ::baikaldb::pb::SchemaInfo* p = schema_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::SchemaInfo&>(
      ::baikaldb::pb::_SchemaInfo_default_instance_);
}
inline const ::baikaldb::pb::SchemaInfo& TableInfo::schema_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TableInfo.schema_info)
  return _internal_schema_info();
}
inline void TableInfo::unsafe_arena_set_allocated_schema_info(
    ::baikaldb::pb::SchemaInfo* schema_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_info_);
  }
  schema_info_ = schema_info;
  if (schema_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.TableInfo.schema_info)
}
inline ::baikaldb::pb::SchemaInfo* TableInfo::release_schema_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::SchemaInfo* temp = schema_info_;
  schema_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::SchemaInfo* TableInfo::unsafe_arena_release_schema_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TableInfo.schema_info)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::SchemaInfo* temp = schema_info_;
  schema_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::SchemaInfo* TableInfo::_internal_mutable_schema_info() {
  _has_bits_[0] |= 0x00000001u;
  if (schema_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::SchemaInfo>(GetArenaForAllocation());
    schema_info_ = p;
  }
  return schema_info_;
}
inline ::baikaldb::pb::SchemaInfo* TableInfo::mutable_schema_info() {
  ::baikaldb::pb::SchemaInfo* _msg = _internal_mutable_schema_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TableInfo.schema_info)
  return _msg;
}
inline void TableInfo::set_allocated_schema_info(::baikaldb::pb::SchemaInfo* schema_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete schema_info_;
  }
  if (schema_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::SchemaInfo>::GetOwningArena(schema_info);
    if (message_arena != submessage_arena) {
      schema_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  schema_info_ = schema_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TableInfo.schema_info)
}

// optional int64 row_count = 2;
inline bool TableInfo::_internal_has_row_count() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TableInfo::has_row_count() const {
  return _internal_has_row_count();
}
inline void TableInfo::clear_row_count() {
  row_count_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableInfo::_internal_row_count() const {
  return row_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableInfo::row_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TableInfo.row_count)
  return _internal_row_count();
}
inline void TableInfo::_internal_set_row_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  row_count_ = value;
}
inline void TableInfo::set_row_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_row_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TableInfo.row_count)
}

// optional int64 region_count = 3;
inline bool TableInfo::_internal_has_region_count() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TableInfo::has_region_count() const {
  return _internal_has_region_count();
}
inline void TableInfo::clear_region_count() {
  region_count_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableInfo::_internal_region_count() const {
  return region_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableInfo::region_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TableInfo.region_count)
  return _internal_region_count();
}
inline void TableInfo::_internal_set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  region_count_ = value;
}
inline void TableInfo::set_region_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TableInfo.region_count)
}

// optional int64 table_id = 4;
inline bool TableInfo::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TableInfo::has_table_id() const {
  return _internal_has_table_id();
}
inline void TableInfo::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableInfo::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableInfo::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TableInfo.table_id)
  return _internal_table_id();
}
inline void TableInfo::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  table_id_ = value;
}
inline void TableInfo::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TableInfo.table_id)
}

// optional bool deleted = 5;
inline bool TableInfo::_internal_has_deleted() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TableInfo::has_deleted() const {
  return _internal_has_deleted();
}
inline void TableInfo::clear_deleted() {
  deleted_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool TableInfo::_internal_deleted() const {
  return deleted_;
}
inline bool TableInfo::deleted() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TableInfo.deleted)
  return _internal_deleted();
}
inline void TableInfo::_internal_set_deleted(bool value) {
  _has_bits_[0] |= 0x00000020u;
  deleted_ = value;
}
inline void TableInfo::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TableInfo.deleted)
}

// optional int64 main_table_id = 6;
inline bool TableInfo::_internal_has_main_table_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TableInfo::has_main_table_id() const {
  return _internal_has_main_table_id();
}
inline void TableInfo::clear_main_table_id() {
  main_table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableInfo::_internal_main_table_id() const {
  return main_table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableInfo::main_table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TableInfo.main_table_id)
  return _internal_main_table_id();
}
inline void TableInfo::_internal_set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  main_table_id_ = value;
}
inline void TableInfo::set_main_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_main_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TableInfo.main_table_id)
}

// -------------------------------------------------------------------

// RegionChangeInfo

// optional .baikaldb.pb.RegionInfo region_info = 1;
inline bool RegionChangeInfo::_internal_has_region_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || region_info_ != nullptr);
  return value;
}
inline bool RegionChangeInfo::has_region_info() const {
  return _internal_has_region_info();
}
inline void RegionChangeInfo::clear_region_info() {
  if (region_info_ != nullptr) region_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::RegionInfo& RegionChangeInfo::_internal_region_info() const {
  const ::baikaldb::pb::RegionInfo* p = region_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::RegionInfo&>(
      ::baikaldb::pb::_RegionInfo_default_instance_);
}
inline const ::baikaldb::pb::RegionInfo& RegionChangeInfo::region_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionChangeInfo.region_info)
  return _internal_region_info();
}
inline void RegionChangeInfo::unsafe_arena_set_allocated_region_info(
    ::baikaldb::pb::RegionInfo* region_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_info_);
  }
  region_info_ = region_info;
  if (region_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.RegionChangeInfo.region_info)
}
inline ::baikaldb::pb::RegionInfo* RegionChangeInfo::release_region_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::RegionInfo* temp = region_info_;
  region_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::RegionInfo* RegionChangeInfo::unsafe_arena_release_region_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionChangeInfo.region_info)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::RegionInfo* temp = region_info_;
  region_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::RegionInfo* RegionChangeInfo::_internal_mutable_region_info() {
  _has_bits_[0] |= 0x00000001u;
  if (region_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::RegionInfo>(GetArenaForAllocation());
    region_info_ = p;
  }
  return region_info_;
}
inline ::baikaldb::pb::RegionInfo* RegionChangeInfo::mutable_region_info() {
  ::baikaldb::pb::RegionInfo* _msg = _internal_mutable_region_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionChangeInfo.region_info)
  return _msg;
}
inline void RegionChangeInfo::set_allocated_region_info(::baikaldb::pb::RegionInfo* region_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete region_info_;
  }
  if (region_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::RegionInfo>::GetOwningArena(region_info);
    if (message_arena != submessage_arena) {
      region_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_info_ = region_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionChangeInfo.region_info)
}

// optional int64 region_id = 2;
inline bool RegionChangeInfo::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionChangeInfo::has_region_id() const {
  return _internal_has_region_id();
}
inline void RegionChangeInfo::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionChangeInfo::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionChangeInfo::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionChangeInfo.region_id)
  return _internal_region_id();
}
inline void RegionChangeInfo::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  region_id_ = value;
}
inline void RegionChangeInfo::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionChangeInfo.region_id)
}

// optional int64 used_size = 3;
inline bool RegionChangeInfo::_internal_has_used_size() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegionChangeInfo::has_used_size() const {
  return _internal_has_used_size();
}
inline void RegionChangeInfo::clear_used_size() {
  used_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionChangeInfo::_internal_used_size() const {
  return used_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionChangeInfo::used_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionChangeInfo.used_size)
  return _internal_used_size();
}
inline void RegionChangeInfo::_internal_set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  used_size_ = value;
}
inline void RegionChangeInfo::set_used_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_used_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionChangeInfo.used_size)
}

// optional int64 num_table_lines = 4;
inline bool RegionChangeInfo::_internal_has_num_table_lines() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RegionChangeInfo::has_num_table_lines() const {
  return _internal_has_num_table_lines();
}
inline void RegionChangeInfo::clear_num_table_lines() {
  num_table_lines_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionChangeInfo::_internal_num_table_lines() const {
  return num_table_lines_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionChangeInfo::num_table_lines() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionChangeInfo.num_table_lines)
  return _internal_num_table_lines();
}
inline void RegionChangeInfo::_internal_set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  num_table_lines_ = value;
}
inline void RegionChangeInfo::set_num_table_lines(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_num_table_lines(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionChangeInfo.num_table_lines)
}

// -------------------------------------------------------------------

// DdlWorkInfoHeartBeat

// optional int64 table_id = 1;
inline bool DdlWorkInfoHeartBeat::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DdlWorkInfoHeartBeat::has_table_id() const {
  return _internal_has_table_id();
}
inline void DdlWorkInfoHeartBeat::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DdlWorkInfoHeartBeat::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DdlWorkInfoHeartBeat::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfoHeartBeat.table_id)
  return _internal_table_id();
}
inline void DdlWorkInfoHeartBeat::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  table_id_ = value;
}
inline void DdlWorkInfoHeartBeat::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfoHeartBeat.table_id)
}

// optional .baikaldb.pb.OpType op_type = 2;
inline bool DdlWorkInfoHeartBeat::_internal_has_op_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DdlWorkInfoHeartBeat::has_op_type() const {
  return _internal_has_op_type();
}
inline void DdlWorkInfoHeartBeat::clear_op_type() {
  op_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::baikaldb::pb::OpType DdlWorkInfoHeartBeat::_internal_op_type() const {
  return static_cast< ::baikaldb::pb::OpType >(op_type_);
}
inline ::baikaldb::pb::OpType DdlWorkInfoHeartBeat::op_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfoHeartBeat.op_type)
  return _internal_op_type();
}
inline void DdlWorkInfoHeartBeat::_internal_set_op_type(::baikaldb::pb::OpType value) {
  assert(::baikaldb::pb::OpType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  op_type_ = value;
}
inline void DdlWorkInfoHeartBeat::set_op_type(::baikaldb::pb::OpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfoHeartBeat.op_type)
}

// optional .baikaldb.pb.IndexState job_state = 3;
inline bool DdlWorkInfoHeartBeat::_internal_has_job_state() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DdlWorkInfoHeartBeat::has_job_state() const {
  return _internal_has_job_state();
}
inline void DdlWorkInfoHeartBeat::clear_job_state() {
  job_state_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::baikaldb::pb::IndexState DdlWorkInfoHeartBeat::_internal_job_state() const {
  return static_cast< ::baikaldb::pb::IndexState >(job_state_);
}
inline ::baikaldb::pb::IndexState DdlWorkInfoHeartBeat::job_state() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfoHeartBeat.job_state)
  return _internal_job_state();
}
inline void DdlWorkInfoHeartBeat::_internal_set_job_state(::baikaldb::pb::IndexState value) {
  assert(::baikaldb::pb::IndexState_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  job_state_ = value;
}
inline void DdlWorkInfoHeartBeat::set_job_state(::baikaldb::pb::IndexState value) {
  _internal_set_job_state(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfoHeartBeat.job_state)
}

// optional int64 region_id = 4;
inline bool DdlWorkInfoHeartBeat::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DdlWorkInfoHeartBeat::has_region_id() const {
  return _internal_has_region_id();
}
inline void DdlWorkInfoHeartBeat::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DdlWorkInfoHeartBeat::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DdlWorkInfoHeartBeat::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfoHeartBeat.region_id)
  return _internal_region_id();
}
inline void DdlWorkInfoHeartBeat::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  region_id_ = value;
}
inline void DdlWorkInfoHeartBeat::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfoHeartBeat.region_id)
}

// optional bool rollback = 5 [default = false];
inline bool DdlWorkInfoHeartBeat::_internal_has_rollback() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DdlWorkInfoHeartBeat::has_rollback() const {
  return _internal_has_rollback();
}
inline void DdlWorkInfoHeartBeat::clear_rollback() {
  rollback_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool DdlWorkInfoHeartBeat::_internal_rollback() const {
  return rollback_;
}
inline bool DdlWorkInfoHeartBeat::rollback() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfoHeartBeat.rollback)
  return _internal_rollback();
}
inline void DdlWorkInfoHeartBeat::_internal_set_rollback(bool value) {
  _has_bits_[0] |= 0x00000004u;
  rollback_ = value;
}
inline void DdlWorkInfoHeartBeat::set_rollback(bool value) {
  _internal_set_rollback(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfoHeartBeat.rollback)
}

// optional uint32 begin_timestamp = 6;
inline bool DdlWorkInfoHeartBeat::_internal_has_begin_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DdlWorkInfoHeartBeat::has_begin_timestamp() const {
  return _internal_has_begin_timestamp();
}
inline void DdlWorkInfoHeartBeat::clear_begin_timestamp() {
  begin_timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DdlWorkInfoHeartBeat::_internal_begin_timestamp() const {
  return begin_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DdlWorkInfoHeartBeat::begin_timestamp() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfoHeartBeat.begin_timestamp)
  return _internal_begin_timestamp();
}
inline void DdlWorkInfoHeartBeat::_internal_set_begin_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  begin_timestamp_ = value;
}
inline void DdlWorkInfoHeartBeat::set_begin_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_begin_timestamp(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfoHeartBeat.begin_timestamp)
}

// optional .baikaldb.pb.ErrCode errcode = 7;
inline bool DdlWorkInfoHeartBeat::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DdlWorkInfoHeartBeat::has_errcode() const {
  return _internal_has_errcode();
}
inline void DdlWorkInfoHeartBeat::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::baikaldb::pb::ErrCode DdlWorkInfoHeartBeat::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::ErrCode >(errcode_);
}
inline ::baikaldb::pb::ErrCode DdlWorkInfoHeartBeat::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfoHeartBeat.errcode)
  return _internal_errcode();
}
inline void DdlWorkInfoHeartBeat::_internal_set_errcode(::baikaldb::pb::ErrCode value) {
  assert(::baikaldb::pb::ErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  errcode_ = value;
}
inline void DdlWorkInfoHeartBeat::set_errcode(::baikaldb::pb::ErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfoHeartBeat.errcode)
}

// -------------------------------------------------------------------

// DdlWorkInfo

// optional int64 table_id = 1;
inline bool DdlWorkInfo::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DdlWorkInfo::has_table_id() const {
  return _internal_has_table_id();
}
inline void DdlWorkInfo::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DdlWorkInfo::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DdlWorkInfo::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.table_id)
  return _internal_table_id();
}
inline void DdlWorkInfo::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  table_id_ = value;
}
inline void DdlWorkInfo::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfo.table_id)
}

// optional .baikaldb.pb.OpType op_type = 2;
inline bool DdlWorkInfo::_internal_has_op_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DdlWorkInfo::has_op_type() const {
  return _internal_has_op_type();
}
inline void DdlWorkInfo::clear_op_type() {
  op_type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::baikaldb::pb::OpType DdlWorkInfo::_internal_op_type() const {
  return static_cast< ::baikaldb::pb::OpType >(op_type_);
}
inline ::baikaldb::pb::OpType DdlWorkInfo::op_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.op_type)
  return _internal_op_type();
}
inline void DdlWorkInfo::_internal_set_op_type(::baikaldb::pb::OpType value) {
  assert(::baikaldb::pb::OpType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  op_type_ = value;
}
inline void DdlWorkInfo::set_op_type(::baikaldb::pb::OpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfo.op_type)
}

// optional .baikaldb.pb.IndexState job_state = 3;
inline bool DdlWorkInfo::_internal_has_job_state() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool DdlWorkInfo::has_job_state() const {
  return _internal_has_job_state();
}
inline void DdlWorkInfo::clear_job_state() {
  job_state_ = 1;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::baikaldb::pb::IndexState DdlWorkInfo::_internal_job_state() const {
  return static_cast< ::baikaldb::pb::IndexState >(job_state_);
}
inline ::baikaldb::pb::IndexState DdlWorkInfo::job_state() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.job_state)
  return _internal_job_state();
}
inline void DdlWorkInfo::_internal_set_job_state(::baikaldb::pb::IndexState value) {
  assert(::baikaldb::pb::IndexState_IsValid(value));
  _has_bits_[0] |= 0x00008000u;
  job_state_ = value;
}
inline void DdlWorkInfo::set_job_state(::baikaldb::pb::IndexState value) {
  _internal_set_job_state(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfo.job_state)
}

// optional int64 index_id = 4;
inline bool DdlWorkInfo::_internal_has_index_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DdlWorkInfo::has_index_id() const {
  return _internal_has_index_id();
}
inline void DdlWorkInfo::clear_index_id() {
  index_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DdlWorkInfo::_internal_index_id() const {
  return index_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DdlWorkInfo::index_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.index_id)
  return _internal_index_id();
}
inline void DdlWorkInfo::_internal_set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  index_id_ = value;
}
inline void DdlWorkInfo::set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_index_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfo.index_id)
}

// optional int64 begin_timestamp = 5;
inline bool DdlWorkInfo::_internal_has_begin_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DdlWorkInfo::has_begin_timestamp() const {
  return _internal_has_begin_timestamp();
}
inline void DdlWorkInfo::clear_begin_timestamp() {
  begin_timestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DdlWorkInfo::_internal_begin_timestamp() const {
  return begin_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DdlWorkInfo::begin_timestamp() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.begin_timestamp)
  return _internal_begin_timestamp();
}
inline void DdlWorkInfo::_internal_set_begin_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  begin_timestamp_ = value;
}
inline void DdlWorkInfo::set_begin_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_begin_timestamp(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfo.begin_timestamp)
}

// optional int64 end_timestamp = 6;
inline bool DdlWorkInfo::_internal_has_end_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool DdlWorkInfo::has_end_timestamp() const {
  return _internal_has_end_timestamp();
}
inline void DdlWorkInfo::clear_end_timestamp() {
  end_timestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DdlWorkInfo::_internal_end_timestamp() const {
  return end_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DdlWorkInfo::end_timestamp() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.end_timestamp)
  return _internal_end_timestamp();
}
inline void DdlWorkInfo::_internal_set_end_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  end_timestamp_ = value;
}
inline void DdlWorkInfo::set_end_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_end_timestamp(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfo.end_timestamp)
}

// optional bool rollback = 7 [default = false];
inline bool DdlWorkInfo::_internal_has_rollback() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool DdlWorkInfo::has_rollback() const {
  return _internal_has_rollback();
}
inline void DdlWorkInfo::clear_rollback() {
  rollback_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool DdlWorkInfo::_internal_rollback() const {
  return rollback_;
}
inline bool DdlWorkInfo::rollback() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.rollback)
  return _internal_rollback();
}
inline void DdlWorkInfo::_internal_set_rollback(bool value) {
  _has_bits_[0] |= 0x00000100u;
  rollback_ = value;
}
inline void DdlWorkInfo::set_rollback(bool value) {
  _internal_set_rollback(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfo.rollback)
}

// optional .baikaldb.pb.ErrCode errcode = 8;
inline bool DdlWorkInfo::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DdlWorkInfo::has_errcode() const {
  return _internal_has_errcode();
}
inline void DdlWorkInfo::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::baikaldb::pb::ErrCode DdlWorkInfo::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::ErrCode >(errcode_);
}
inline ::baikaldb::pb::ErrCode DdlWorkInfo::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.errcode)
  return _internal_errcode();
}
inline void DdlWorkInfo::_internal_set_errcode(::baikaldb::pb::ErrCode value) {
  assert(::baikaldb::pb::ErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  errcode_ = value;
}
inline void DdlWorkInfo::set_errcode(::baikaldb::pb::ErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfo.errcode)
}

// optional bool deleted = 9 [default = false];
inline bool DdlWorkInfo::_internal_has_deleted() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool DdlWorkInfo::has_deleted() const {
  return _internal_has_deleted();
}
inline void DdlWorkInfo::clear_deleted() {
  deleted_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool DdlWorkInfo::_internal_deleted() const {
  return deleted_;
}
inline bool DdlWorkInfo::deleted() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.deleted)
  return _internal_deleted();
}
inline void DdlWorkInfo::_internal_set_deleted(bool value) {
  _has_bits_[0] |= 0x00000200u;
  deleted_ = value;
}
inline void DdlWorkInfo::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfo.deleted)
}

// optional .baikaldb.pb.DdlWorkStatus status = 10;
inline bool DdlWorkInfo::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool DdlWorkInfo::has_status() const {
  return _internal_has_status();
}
inline void DdlWorkInfo::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::baikaldb::pb::DdlWorkStatus DdlWorkInfo::_internal_status() const {
  return static_cast< ::baikaldb::pb::DdlWorkStatus >(status_);
}
inline ::baikaldb::pb::DdlWorkStatus DdlWorkInfo::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.status)
  return _internal_status();
}
inline void DdlWorkInfo::_internal_set_status(::baikaldb::pb::DdlWorkStatus value) {
  assert(::baikaldb::pb::DdlWorkStatus_IsValid(value));
  _has_bits_[0] |= 0x00010000u;
  status_ = value;
}
inline void DdlWorkInfo::set_status(::baikaldb::pb::DdlWorkStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfo.status)
}

// optional bool suspend = 11;
inline bool DdlWorkInfo::_internal_has_suspend() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool DdlWorkInfo::has_suspend() const {
  return _internal_has_suspend();
}
inline void DdlWorkInfo::clear_suspend() {
  suspend_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool DdlWorkInfo::_internal_suspend() const {
  return suspend_;
}
inline bool DdlWorkInfo::suspend() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.suspend)
  return _internal_suspend();
}
inline void DdlWorkInfo::_internal_set_suspend(bool value) {
  _has_bits_[0] |= 0x00000400u;
  suspend_ = value;
}
inline void DdlWorkInfo::set_suspend(bool value) {
  _internal_set_suspend(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfo.suspend)
}

// optional int64 update_timestamp = 12;
inline bool DdlWorkInfo::_internal_has_update_timestamp() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool DdlWorkInfo::has_update_timestamp() const {
  return _internal_has_update_timestamp();
}
inline void DdlWorkInfo::clear_update_timestamp() {
  update_timestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DdlWorkInfo::_internal_update_timestamp() const {
  return update_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DdlWorkInfo::update_timestamp() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.update_timestamp)
  return _internal_update_timestamp();
}
inline void DdlWorkInfo::_internal_set_update_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00004000u;
  update_timestamp_ = value;
}
inline void DdlWorkInfo::set_update_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_update_timestamp(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfo.update_timestamp)
}

// optional bool global = 13;
inline bool DdlWorkInfo::_internal_has_global() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool DdlWorkInfo::has_global() const {
  return _internal_has_global();
}
inline void DdlWorkInfo::clear_global() {
  global_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool DdlWorkInfo::_internal_global() const {
  return global_;
}
inline bool DdlWorkInfo::global() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.global)
  return _internal_global();
}
inline void DdlWorkInfo::_internal_set_global(bool value) {
  _has_bits_[0] |= 0x00000800u;
  global_ = value;
}
inline void DdlWorkInfo::set_global(bool value) {
  _internal_set_global(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfo.global)
}

// optional bool drop_index = 14;
inline bool DdlWorkInfo::_internal_has_drop_index() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool DdlWorkInfo::has_drop_index() const {
  return _internal_has_drop_index();
}
inline void DdlWorkInfo::clear_drop_index() {
  drop_index_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool DdlWorkInfo::_internal_drop_index() const {
  return drop_index_;
}
inline bool DdlWorkInfo::drop_index() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.drop_index)
  return _internal_drop_index();
}
inline void DdlWorkInfo::_internal_set_drop_index(bool value) {
  _has_bits_[0] |= 0x00001000u;
  drop_index_ = value;
}
inline void DdlWorkInfo::set_drop_index(bool value) {
  _internal_set_drop_index(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfo.drop_index)
}

// optional .baikaldb.pb.ColumnDdlInfo column_ddl_info = 15;
inline bool DdlWorkInfo::_internal_has_column_ddl_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || column_ddl_info_ != nullptr);
  return value;
}
inline bool DdlWorkInfo::has_column_ddl_info() const {
  return _internal_has_column_ddl_info();
}
inline const ::baikaldb::pb::ColumnDdlInfo& DdlWorkInfo::_internal_column_ddl_info() const {
  const ::baikaldb::pb::ColumnDdlInfo* p = column_ddl_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::ColumnDdlInfo&>(
      ::baikaldb::pb::_ColumnDdlInfo_default_instance_);
}
inline const ::baikaldb::pb::ColumnDdlInfo& DdlWorkInfo::column_ddl_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.column_ddl_info)
  return _internal_column_ddl_info();
}
inline void DdlWorkInfo::unsafe_arena_set_allocated_column_ddl_info(
    ::baikaldb::pb::ColumnDdlInfo* column_ddl_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(column_ddl_info_);
  }
  column_ddl_info_ = column_ddl_info;
  if (column_ddl_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DdlWorkInfo.column_ddl_info)
}
inline ::baikaldb::pb::ColumnDdlInfo* DdlWorkInfo::release_column_ddl_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::ColumnDdlInfo* temp = column_ddl_info_;
  column_ddl_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::ColumnDdlInfo* DdlWorkInfo::unsafe_arena_release_column_ddl_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DdlWorkInfo.column_ddl_info)
  _has_bits_[0] &= ~0x00000002u;
  ::baikaldb::pb::ColumnDdlInfo* temp = column_ddl_info_;
  column_ddl_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::ColumnDdlInfo* DdlWorkInfo::_internal_mutable_column_ddl_info() {
  _has_bits_[0] |= 0x00000002u;
  if (column_ddl_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::ColumnDdlInfo>(GetArenaForAllocation());
    column_ddl_info_ = p;
  }
  return column_ddl_info_;
}
inline ::baikaldb::pb::ColumnDdlInfo* DdlWorkInfo::mutable_column_ddl_info() {
  ::baikaldb::pb::ColumnDdlInfo* _msg = _internal_mutable_column_ddl_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DdlWorkInfo.column_ddl_info)
  return _msg;
}
inline void DdlWorkInfo::set_allocated_column_ddl_info(::baikaldb::pb::ColumnDdlInfo* column_ddl_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(column_ddl_info_);
  }
  if (column_ddl_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(column_ddl_info));
    if (message_arena != submessage_arena) {
      column_ddl_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_ddl_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  column_ddl_info_ = column_ddl_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DdlWorkInfo.column_ddl_info)
}

// optional string opt_sql = 16;
inline bool DdlWorkInfo::_internal_has_opt_sql() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DdlWorkInfo::has_opt_sql() const {
  return _internal_has_opt_sql();
}
inline void DdlWorkInfo::clear_opt_sql() {
  opt_sql_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DdlWorkInfo::opt_sql() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.opt_sql)
  return _internal_opt_sql();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DdlWorkInfo::set_opt_sql(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 opt_sql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfo.opt_sql)
}
inline std::string* DdlWorkInfo::mutable_opt_sql() {
  std::string* _s = _internal_mutable_opt_sql();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DdlWorkInfo.opt_sql)
  return _s;
}
inline const std::string& DdlWorkInfo::_internal_opt_sql() const {
  return opt_sql_.Get();
}
inline void DdlWorkInfo::_internal_set_opt_sql(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  opt_sql_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DdlWorkInfo::_internal_mutable_opt_sql() {
  _has_bits_[0] |= 0x00000001u;
  return opt_sql_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DdlWorkInfo::release_opt_sql() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DdlWorkInfo.opt_sql)
  if (!_internal_has_opt_sql()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return opt_sql_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DdlWorkInfo::set_allocated_opt_sql(std::string* opt_sql) {
  if (opt_sql != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  opt_sql_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), opt_sql,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DdlWorkInfo.opt_sql)
}

// optional bool is_rollup = 17;
inline bool DdlWorkInfo::_internal_has_is_rollup() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool DdlWorkInfo::has_is_rollup() const {
  return _internal_has_is_rollup();
}
inline void DdlWorkInfo::clear_is_rollup() {
  is_rollup_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool DdlWorkInfo::_internal_is_rollup() const {
  return is_rollup_;
}
inline bool DdlWorkInfo::is_rollup() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DdlWorkInfo.is_rollup)
  return _internal_is_rollup();
}
inline void DdlWorkInfo::_internal_set_is_rollup(bool value) {
  _has_bits_[0] |= 0x00002000u;
  is_rollup_ = value;
}
inline void DdlWorkInfo::set_is_rollup(bool value) {
  _internal_set_is_rollup(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DdlWorkInfo.is_rollup)
}

// -------------------------------------------------------------------

// RegionDdlWork

// optional int64 table_id = 1;
inline bool RegionDdlWork::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RegionDdlWork::has_table_id() const {
  return _internal_has_table_id();
}
inline void RegionDdlWork::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionDdlWork::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionDdlWork::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionDdlWork.table_id)
  return _internal_table_id();
}
inline void RegionDdlWork::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  table_id_ = value;
}
inline void RegionDdlWork::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionDdlWork.table_id)
}

// optional int64 region_id = 2;
inline bool RegionDdlWork::_internal_has_region_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RegionDdlWork::has_region_id() const {
  return _internal_has_region_id();
}
inline void RegionDdlWork::clear_region_id() {
  region_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionDdlWork::_internal_region_id() const {
  return region_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionDdlWork::region_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionDdlWork.region_id)
  return _internal_region_id();
}
inline void RegionDdlWork::_internal_set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  region_id_ = value;
}
inline void RegionDdlWork::set_region_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_region_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionDdlWork.region_id)
}

// optional bytes start_key = 3;
inline bool RegionDdlWork::_internal_has_start_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegionDdlWork::has_start_key() const {
  return _internal_has_start_key();
}
inline void RegionDdlWork::clear_start_key() {
  start_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionDdlWork::start_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionDdlWork.start_key)
  return _internal_start_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionDdlWork::set_start_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 start_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionDdlWork.start_key)
}
inline std::string* RegionDdlWork::mutable_start_key() {
  std::string* _s = _internal_mutable_start_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionDdlWork.start_key)
  return _s;
}
inline const std::string& RegionDdlWork::_internal_start_key() const {
  return start_key_.Get();
}
inline void RegionDdlWork::_internal_set_start_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  start_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionDdlWork::_internal_mutable_start_key() {
  _has_bits_[0] |= 0x00000001u;
  return start_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionDdlWork::release_start_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionDdlWork.start_key)
  if (!_internal_has_start_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return start_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionDdlWork::set_allocated_start_key(std::string* start_key) {
  if (start_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  start_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionDdlWork.start_key)
}

// optional bytes end_key = 4;
inline bool RegionDdlWork::_internal_has_end_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionDdlWork::has_end_key() const {
  return _internal_has_end_key();
}
inline void RegionDdlWork::clear_end_key() {
  end_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RegionDdlWork::end_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionDdlWork.end_key)
  return _internal_end_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionDdlWork::set_end_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 end_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionDdlWork.end_key)
}
inline std::string* RegionDdlWork::mutable_end_key() {
  std::string* _s = _internal_mutable_end_key();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionDdlWork.end_key)
  return _s;
}
inline const std::string& RegionDdlWork::_internal_end_key() const {
  return end_key_.Get();
}
inline void RegionDdlWork::_internal_set_end_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  end_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionDdlWork::_internal_mutable_end_key() {
  _has_bits_[0] |= 0x00000002u;
  return end_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionDdlWork::release_end_key() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionDdlWork.end_key)
  if (!_internal_has_end_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return end_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionDdlWork::set_allocated_end_key(std::string* end_key) {
  if (end_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  end_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), end_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionDdlWork.end_key)
}

// optional .baikaldb.pb.DdlWorkStatus status = 5;
inline bool RegionDdlWork::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool RegionDdlWork::has_status() const {
  return _internal_has_status();
}
inline void RegionDdlWork::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::baikaldb::pb::DdlWorkStatus RegionDdlWork::_internal_status() const {
  return static_cast< ::baikaldb::pb::DdlWorkStatus >(status_);
}
inline ::baikaldb::pb::DdlWorkStatus RegionDdlWork::status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionDdlWork.status)
  return _internal_status();
}
inline void RegionDdlWork::_internal_set_status(::baikaldb::pb::DdlWorkStatus value) {
  assert(::baikaldb::pb::DdlWorkStatus_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  status_ = value;
}
inline void RegionDdlWork::set_status(::baikaldb::pb::DdlWorkStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionDdlWork.status)
}

// optional .baikaldb.pb.OpType op_type = 6;
inline bool RegionDdlWork::_internal_has_op_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool RegionDdlWork::has_op_type() const {
  return _internal_has_op_type();
}
inline void RegionDdlWork::clear_op_type() {
  op_type_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::baikaldb::pb::OpType RegionDdlWork::_internal_op_type() const {
  return static_cast< ::baikaldb::pb::OpType >(op_type_);
}
inline ::baikaldb::pb::OpType RegionDdlWork::op_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionDdlWork.op_type)
  return _internal_op_type();
}
inline void RegionDdlWork::_internal_set_op_type(::baikaldb::pb::OpType value) {
  assert(::baikaldb::pb::OpType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  op_type_ = value;
}
inline void RegionDdlWork::set_op_type(::baikaldb::pb::OpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionDdlWork.op_type)
}

// optional int64 index_id = 7;
inline bool RegionDdlWork::_internal_has_index_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RegionDdlWork::has_index_id() const {
  return _internal_has_index_id();
}
inline void RegionDdlWork::clear_index_id() {
  index_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionDdlWork::_internal_index_id() const {
  return index_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionDdlWork::index_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionDdlWork.index_id)
  return _internal_index_id();
}
inline void RegionDdlWork::_internal_set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  index_id_ = value;
}
inline void RegionDdlWork::set_index_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_index_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionDdlWork.index_id)
}

// optional string address = 8;
inline bool RegionDdlWork::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegionDdlWork::has_address() const {
  return _internal_has_address();
}
inline void RegionDdlWork::clear_address() {
  address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RegionDdlWork::address() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionDdlWork.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegionDdlWork::set_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionDdlWork.address)
}
inline std::string* RegionDdlWork::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionDdlWork.address)
  return _s;
}
inline const std::string& RegionDdlWork::_internal_address() const {
  return address_.Get();
}
inline void RegionDdlWork::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegionDdlWork::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000004u;
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegionDdlWork::release_address() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionDdlWork.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegionDdlWork::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionDdlWork.address)
}

// optional uint32 retry_time = 9;
inline bool RegionDdlWork::_internal_has_retry_time() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool RegionDdlWork::has_retry_time() const {
  return _internal_has_retry_time();
}
inline void RegionDdlWork::clear_retry_time() {
  retry_time_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RegionDdlWork::_internal_retry_time() const {
  return retry_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RegionDdlWork::retry_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionDdlWork.retry_time)
  return _internal_retry_time();
}
inline void RegionDdlWork::_internal_set_retry_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  retry_time_ = value;
}
inline void RegionDdlWork::set_retry_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_retry_time(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionDdlWork.retry_time)
}

// optional int64 update_timestamp = 10;
inline bool RegionDdlWork::_internal_has_update_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool RegionDdlWork::has_update_timestamp() const {
  return _internal_has_update_timestamp();
}
inline void RegionDdlWork::clear_update_timestamp() {
  update_timestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionDdlWork::_internal_update_timestamp() const {
  return update_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionDdlWork::update_timestamp() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionDdlWork.update_timestamp)
  return _internal_update_timestamp();
}
inline void RegionDdlWork::_internal_set_update_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  update_timestamp_ = value;
}
inline void RegionDdlWork::set_update_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_update_timestamp(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionDdlWork.update_timestamp)
}

// optional int64 partition = 11;
inline bool RegionDdlWork::_internal_has_partition() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool RegionDdlWork::has_partition() const {
  return _internal_has_partition();
}
inline void RegionDdlWork::clear_partition() {
  partition_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionDdlWork::_internal_partition() const {
  return partition_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RegionDdlWork::partition() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionDdlWork.partition)
  return _internal_partition();
}
inline void RegionDdlWork::_internal_set_partition(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000400u;
  partition_ = value;
}
inline void RegionDdlWork::set_partition(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_partition(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionDdlWork.partition)
}

// optional bool is_global = 12;
inline bool RegionDdlWork::_internal_has_is_global() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool RegionDdlWork::has_is_global() const {
  return _internal_has_is_global();
}
inline void RegionDdlWork::clear_is_global() {
  is_global_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool RegionDdlWork::_internal_is_global() const {
  return is_global_;
}
inline bool RegionDdlWork::is_global() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionDdlWork.is_global)
  return _internal_is_global();
}
inline void RegionDdlWork::_internal_set_is_global(bool value) {
  _has_bits_[0] |= 0x00000800u;
  is_global_ = value;
}
inline void RegionDdlWork::set_is_global(bool value) {
  _internal_set_is_global(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.RegionDdlWork.is_global)
}

// optional .baikaldb.pb.ColumnDdlInfo column_ddl_info = 13;
inline bool RegionDdlWork::_internal_has_column_ddl_info() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || column_ddl_info_ != nullptr);
  return value;
}
inline bool RegionDdlWork::has_column_ddl_info() const {
  return _internal_has_column_ddl_info();
}
inline const ::baikaldb::pb::ColumnDdlInfo& RegionDdlWork::_internal_column_ddl_info() const {
  const ::baikaldb::pb::ColumnDdlInfo* p = column_ddl_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::ColumnDdlInfo&>(
      ::baikaldb::pb::_ColumnDdlInfo_default_instance_);
}
inline const ::baikaldb::pb::ColumnDdlInfo& RegionDdlWork::column_ddl_info() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.RegionDdlWork.column_ddl_info)
  return _internal_column_ddl_info();
}
inline void RegionDdlWork::unsafe_arena_set_allocated_column_ddl_info(
    ::baikaldb::pb::ColumnDdlInfo* column_ddl_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(column_ddl_info_);
  }
  column_ddl_info_ = column_ddl_info;
  if (column_ddl_info) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.RegionDdlWork.column_ddl_info)
}
inline ::baikaldb::pb::ColumnDdlInfo* RegionDdlWork::release_column_ddl_info() {
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::ColumnDdlInfo* temp = column_ddl_info_;
  column_ddl_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::ColumnDdlInfo* RegionDdlWork::unsafe_arena_release_column_ddl_info() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.RegionDdlWork.column_ddl_info)
  _has_bits_[0] &= ~0x00000008u;
  ::baikaldb::pb::ColumnDdlInfo* temp = column_ddl_info_;
  column_ddl_info_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::ColumnDdlInfo* RegionDdlWork::_internal_mutable_column_ddl_info() {
  _has_bits_[0] |= 0x00000008u;
  if (column_ddl_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::ColumnDdlInfo>(GetArenaForAllocation());
    column_ddl_info_ = p;
  }
  return column_ddl_info_;
}
inline ::baikaldb::pb::ColumnDdlInfo* RegionDdlWork::mutable_column_ddl_info() {
  ::baikaldb::pb::ColumnDdlInfo* _msg = _internal_mutable_column_ddl_info();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.RegionDdlWork.column_ddl_info)
  return _msg;
}
inline void RegionDdlWork::set_allocated_column_ddl_info(::baikaldb::pb::ColumnDdlInfo* column_ddl_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(column_ddl_info_);
  }
  if (column_ddl_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(column_ddl_info));
    if (message_arena != submessage_arena) {
      column_ddl_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_ddl_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  column_ddl_info_ = column_ddl_info;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.RegionDdlWork.column_ddl_info)
}

// -------------------------------------------------------------------

// TableHeartBeat

// optional int64 table_id = 1;
inline bool TableHeartBeat::_internal_has_table_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TableHeartBeat::has_table_id() const {
  return _internal_has_table_id();
}
inline void TableHeartBeat::clear_table_id() {
  table_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableHeartBeat::_internal_table_id() const {
  return table_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableHeartBeat::table_id() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TableHeartBeat.table_id)
  return _internal_table_id();
}
inline void TableHeartBeat::_internal_set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  table_id_ = value;
}
inline void TableHeartBeat::set_table_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TableHeartBeat.table_id)
}

// optional int64 version = 2;
inline bool TableHeartBeat::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TableHeartBeat::has_version() const {
  return _internal_has_version();
}
inline void TableHeartBeat::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableHeartBeat::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TableHeartBeat::version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TableHeartBeat.version)
  return _internal_version();
}
inline void TableHeartBeat::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
}
inline void TableHeartBeat::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TableHeartBeat.version)
}

// optional bool need_update = 3;
inline bool TableHeartBeat::_internal_has_need_update() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TableHeartBeat::has_need_update() const {
  return _internal_has_need_update();
}
inline void TableHeartBeat::clear_need_update() {
  need_update_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool TableHeartBeat::_internal_need_update() const {
  return need_update_;
}
inline bool TableHeartBeat::need_update() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TableHeartBeat.need_update)
  return _internal_need_update();
}
inline void TableHeartBeat::_internal_set_need_update(bool value) {
  _has_bits_[0] |= 0x00000004u;
  need_update_ = value;
}
inline void TableHeartBeat::set_need_update(bool value) {
  _internal_set_need_update(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TableHeartBeat.need_update)
}

// -------------------------------------------------------------------

// ConsoleHeartBeatRequest

// repeated .baikaldb.pb.TableHeartBeat table_versions = 1;
inline int ConsoleHeartBeatRequest::_internal_table_versions_size() const {
  return table_versions_.size();
}
inline int ConsoleHeartBeatRequest::table_versions_size() const {
  return _internal_table_versions_size();
}
inline void ConsoleHeartBeatRequest::clear_table_versions() {
  table_versions_.Clear();
}
inline ::baikaldb::pb::TableHeartBeat* ConsoleHeartBeatRequest::mutable_table_versions(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleHeartBeatRequest.table_versions)
  return table_versions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TableHeartBeat >*
ConsoleHeartBeatRequest::mutable_table_versions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ConsoleHeartBeatRequest.table_versions)
  return &table_versions_;
}
inline const ::baikaldb::pb::TableHeartBeat& ConsoleHeartBeatRequest::_internal_table_versions(int index) const {
  return table_versions_.Get(index);
}
inline const ::baikaldb::pb::TableHeartBeat& ConsoleHeartBeatRequest::table_versions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleHeartBeatRequest.table_versions)
  return _internal_table_versions(index);
}
inline ::baikaldb::pb::TableHeartBeat* ConsoleHeartBeatRequest::_internal_add_table_versions() {
  return table_versions_.Add();
}
inline ::baikaldb::pb::TableHeartBeat* ConsoleHeartBeatRequest::add_table_versions() {
  ::baikaldb::pb::TableHeartBeat* _add = _internal_add_table_versions();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ConsoleHeartBeatRequest.table_versions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TableHeartBeat >&
ConsoleHeartBeatRequest::table_versions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ConsoleHeartBeatRequest.table_versions)
  return table_versions_;
}

// repeated .baikaldb.pb.RegionHeartBeat region_versions = 2;
inline int ConsoleHeartBeatRequest::_internal_region_versions_size() const {
  return region_versions_.size();
}
inline int ConsoleHeartBeatRequest::region_versions_size() const {
  return _internal_region_versions_size();
}
inline void ConsoleHeartBeatRequest::clear_region_versions() {
  region_versions_.Clear();
}
inline ::baikaldb::pb::RegionHeartBeat* ConsoleHeartBeatRequest::mutable_region_versions(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleHeartBeatRequest.region_versions)
  return region_versions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionHeartBeat >*
ConsoleHeartBeatRequest::mutable_region_versions() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ConsoleHeartBeatRequest.region_versions)
  return &region_versions_;
}
inline const ::baikaldb::pb::RegionHeartBeat& ConsoleHeartBeatRequest::_internal_region_versions(int index) const {
  return region_versions_.Get(index);
}
inline const ::baikaldb::pb::RegionHeartBeat& ConsoleHeartBeatRequest::region_versions(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleHeartBeatRequest.region_versions)
  return _internal_region_versions(index);
}
inline ::baikaldb::pb::RegionHeartBeat* ConsoleHeartBeatRequest::_internal_add_region_versions() {
  return region_versions_.Add();
}
inline ::baikaldb::pb::RegionHeartBeat* ConsoleHeartBeatRequest::add_region_versions() {
  ::baikaldb::pb::RegionHeartBeat* _add = _internal_add_region_versions();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ConsoleHeartBeatRequest.region_versions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionHeartBeat >&
ConsoleHeartBeatRequest::region_versions() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ConsoleHeartBeatRequest.region_versions)
  return region_versions_;
}

// -------------------------------------------------------------------

// ConsoleHeartBeatResponse

// required .baikaldb.pb.ErrCode errcode = 1;
inline bool ConsoleHeartBeatResponse::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConsoleHeartBeatResponse::has_errcode() const {
  return _internal_has_errcode();
}
inline void ConsoleHeartBeatResponse::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::baikaldb::pb::ErrCode ConsoleHeartBeatResponse::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::ErrCode >(errcode_);
}
inline ::baikaldb::pb::ErrCode ConsoleHeartBeatResponse::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleHeartBeatResponse.errcode)
  return _internal_errcode();
}
inline void ConsoleHeartBeatResponse::_internal_set_errcode(::baikaldb::pb::ErrCode value) {
  assert(::baikaldb::pb::ErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  errcode_ = value;
}
inline void ConsoleHeartBeatResponse::set_errcode(::baikaldb::pb::ErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleHeartBeatResponse.errcode)
}

// optional string errmsg = 2;
inline bool ConsoleHeartBeatResponse::_internal_has_errmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConsoleHeartBeatResponse::has_errmsg() const {
  return _internal_has_errmsg();
}
inline void ConsoleHeartBeatResponse::clear_errmsg() {
  errmsg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConsoleHeartBeatResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleHeartBeatResponse.errmsg)
  return _internal_errmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsoleHeartBeatResponse::set_errmsg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleHeartBeatResponse.errmsg)
}
inline std::string* ConsoleHeartBeatResponse::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleHeartBeatResponse.errmsg)
  return _s;
}
inline const std::string& ConsoleHeartBeatResponse::_internal_errmsg() const {
  return errmsg_.Get();
}
inline void ConsoleHeartBeatResponse::_internal_set_errmsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConsoleHeartBeatResponse::_internal_mutable_errmsg() {
  _has_bits_[0] |= 0x00000001u;
  return errmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConsoleHeartBeatResponse::release_errmsg() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ConsoleHeartBeatResponse.errmsg)
  if (!_internal_has_errmsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return errmsg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConsoleHeartBeatResponse::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ConsoleHeartBeatResponse.errmsg)
}

// optional string leader = 3;
inline bool ConsoleHeartBeatResponse::_internal_has_leader() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConsoleHeartBeatResponse::has_leader() const {
  return _internal_has_leader();
}
inline void ConsoleHeartBeatResponse::clear_leader() {
  leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConsoleHeartBeatResponse::leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleHeartBeatResponse.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConsoleHeartBeatResponse::set_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ConsoleHeartBeatResponse.leader)
}
inline std::string* ConsoleHeartBeatResponse::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleHeartBeatResponse.leader)
  return _s;
}
inline const std::string& ConsoleHeartBeatResponse::_internal_leader() const {
  return leader_.Get();
}
inline void ConsoleHeartBeatResponse::_internal_set_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConsoleHeartBeatResponse::_internal_mutable_leader() {
  _has_bits_[0] |= 0x00000002u;
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConsoleHeartBeatResponse::release_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ConsoleHeartBeatResponse.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConsoleHeartBeatResponse::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ConsoleHeartBeatResponse.leader)
}

// repeated .baikaldb.pb.QueryInstance flatten_instances = 4;
inline int ConsoleHeartBeatResponse::_internal_flatten_instances_size() const {
  return flatten_instances_.size();
}
inline int ConsoleHeartBeatResponse::flatten_instances_size() const {
  return _internal_flatten_instances_size();
}
inline void ConsoleHeartBeatResponse::clear_flatten_instances() {
  flatten_instances_.Clear();
}
inline ::baikaldb::pb::QueryInstance* ConsoleHeartBeatResponse::mutable_flatten_instances(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleHeartBeatResponse.flatten_instances)
  return flatten_instances_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryInstance >*
ConsoleHeartBeatResponse::mutable_flatten_instances() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ConsoleHeartBeatResponse.flatten_instances)
  return &flatten_instances_;
}
inline const ::baikaldb::pb::QueryInstance& ConsoleHeartBeatResponse::_internal_flatten_instances(int index) const {
  return flatten_instances_.Get(index);
}
inline const ::baikaldb::pb::QueryInstance& ConsoleHeartBeatResponse::flatten_instances(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleHeartBeatResponse.flatten_instances)
  return _internal_flatten_instances(index);
}
inline ::baikaldb::pb::QueryInstance* ConsoleHeartBeatResponse::_internal_add_flatten_instances() {
  return flatten_instances_.Add();
}
inline ::baikaldb::pb::QueryInstance* ConsoleHeartBeatResponse::add_flatten_instances() {
  ::baikaldb::pb::QueryInstance* _add = _internal_add_flatten_instances();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ConsoleHeartBeatResponse.flatten_instances)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryInstance >&
ConsoleHeartBeatResponse::flatten_instances() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ConsoleHeartBeatResponse.flatten_instances)
  return flatten_instances_;
}

// repeated .baikaldb.pb.QueryUserPrivilege flatten_privileges = 5;
inline int ConsoleHeartBeatResponse::_internal_flatten_privileges_size() const {
  return flatten_privileges_.size();
}
inline int ConsoleHeartBeatResponse::flatten_privileges_size() const {
  return _internal_flatten_privileges_size();
}
inline void ConsoleHeartBeatResponse::clear_flatten_privileges() {
  flatten_privileges_.Clear();
}
inline ::baikaldb::pb::QueryUserPrivilege* ConsoleHeartBeatResponse::mutable_flatten_privileges(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleHeartBeatResponse.flatten_privileges)
  return flatten_privileges_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryUserPrivilege >*
ConsoleHeartBeatResponse::mutable_flatten_privileges() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ConsoleHeartBeatResponse.flatten_privileges)
  return &flatten_privileges_;
}
inline const ::baikaldb::pb::QueryUserPrivilege& ConsoleHeartBeatResponse::_internal_flatten_privileges(int index) const {
  return flatten_privileges_.Get(index);
}
inline const ::baikaldb::pb::QueryUserPrivilege& ConsoleHeartBeatResponse::flatten_privileges(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleHeartBeatResponse.flatten_privileges)
  return _internal_flatten_privileges(index);
}
inline ::baikaldb::pb::QueryUserPrivilege* ConsoleHeartBeatResponse::_internal_add_flatten_privileges() {
  return flatten_privileges_.Add();
}
inline ::baikaldb::pb::QueryUserPrivilege* ConsoleHeartBeatResponse::add_flatten_privileges() {
  ::baikaldb::pb::QueryUserPrivilege* _add = _internal_add_flatten_privileges();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ConsoleHeartBeatResponse.flatten_privileges)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::QueryUserPrivilege >&
ConsoleHeartBeatResponse::flatten_privileges() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ConsoleHeartBeatResponse.flatten_privileges)
  return flatten_privileges_;
}

// repeated .baikaldb.pb.RegionChangeInfo region_change_infos = 6;
inline int ConsoleHeartBeatResponse::_internal_region_change_infos_size() const {
  return region_change_infos_.size();
}
inline int ConsoleHeartBeatResponse::region_change_infos_size() const {
  return _internal_region_change_infos_size();
}
inline void ConsoleHeartBeatResponse::clear_region_change_infos() {
  region_change_infos_.Clear();
}
inline ::baikaldb::pb::RegionChangeInfo* ConsoleHeartBeatResponse::mutable_region_change_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleHeartBeatResponse.region_change_infos)
  return region_change_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionChangeInfo >*
ConsoleHeartBeatResponse::mutable_region_change_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ConsoleHeartBeatResponse.region_change_infos)
  return &region_change_infos_;
}
inline const ::baikaldb::pb::RegionChangeInfo& ConsoleHeartBeatResponse::_internal_region_change_infos(int index) const {
  return region_change_infos_.Get(index);
}
inline const ::baikaldb::pb::RegionChangeInfo& ConsoleHeartBeatResponse::region_change_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleHeartBeatResponse.region_change_infos)
  return _internal_region_change_infos(index);
}
inline ::baikaldb::pb::RegionChangeInfo* ConsoleHeartBeatResponse::_internal_add_region_change_infos() {
  return region_change_infos_.Add();
}
inline ::baikaldb::pb::RegionChangeInfo* ConsoleHeartBeatResponse::add_region_change_infos() {
  ::baikaldb::pb::RegionChangeInfo* _add = _internal_add_region_change_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ConsoleHeartBeatResponse.region_change_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::RegionChangeInfo >&
ConsoleHeartBeatResponse::region_change_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ConsoleHeartBeatResponse.region_change_infos)
  return region_change_infos_;
}

// repeated .baikaldb.pb.TableInfo table_change_infos = 7;
inline int ConsoleHeartBeatResponse::_internal_table_change_infos_size() const {
  return table_change_infos_.size();
}
inline int ConsoleHeartBeatResponse::table_change_infos_size() const {
  return _internal_table_change_infos_size();
}
inline void ConsoleHeartBeatResponse::clear_table_change_infos() {
  table_change_infos_.Clear();
}
inline ::baikaldb::pb::TableInfo* ConsoleHeartBeatResponse::mutable_table_change_infos(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ConsoleHeartBeatResponse.table_change_infos)
  return table_change_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TableInfo >*
ConsoleHeartBeatResponse::mutable_table_change_infos() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.ConsoleHeartBeatResponse.table_change_infos)
  return &table_change_infos_;
}
inline const ::baikaldb::pb::TableInfo& ConsoleHeartBeatResponse::_internal_table_change_infos(int index) const {
  return table_change_infos_.Get(index);
}
inline const ::baikaldb::pb::TableInfo& ConsoleHeartBeatResponse::table_change_infos(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ConsoleHeartBeatResponse.table_change_infos)
  return _internal_table_change_infos(index);
}
inline ::baikaldb::pb::TableInfo* ConsoleHeartBeatResponse::_internal_add_table_change_infos() {
  return table_change_infos_.Add();
}
inline ::baikaldb::pb::TableInfo* ConsoleHeartBeatResponse::add_table_change_infos() {
  ::baikaldb::pb::TableInfo* _add = _internal_add_table_change_infos();
  // @@protoc_insertion_point(field_add:baikaldb.pb.ConsoleHeartBeatResponse.table_change_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::TableInfo >&
ConsoleHeartBeatResponse::table_change_infos() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.ConsoleHeartBeatResponse.table_change_infos)
  return table_change_infos_;
}

// -------------------------------------------------------------------

// TsoTimestamp

// optional int64 physical = 1;
inline bool TsoTimestamp::_internal_has_physical() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TsoTimestamp::has_physical() const {
  return _internal_has_physical();
}
inline void TsoTimestamp::clear_physical() {
  physical_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TsoTimestamp::_internal_physical() const {
  return physical_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TsoTimestamp::physical() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TsoTimestamp.physical)
  return _internal_physical();
}
inline void TsoTimestamp::_internal_set_physical(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  physical_ = value;
}
inline void TsoTimestamp::set_physical(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_physical(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TsoTimestamp.physical)
}

// optional int64 logical = 2;
inline bool TsoTimestamp::_internal_has_logical() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TsoTimestamp::has_logical() const {
  return _internal_has_logical();
}
inline void TsoTimestamp::clear_logical() {
  logical_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TsoTimestamp::_internal_logical() const {
  return logical_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TsoTimestamp::logical() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TsoTimestamp.logical)
  return _internal_logical();
}
inline void TsoTimestamp::_internal_set_logical(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  logical_ = value;
}
inline void TsoTimestamp::set_logical(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_logical(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TsoTimestamp.logical)
}

// -------------------------------------------------------------------

// TsoRequest

// required .baikaldb.pb.OpType op_type = 1;
inline bool TsoRequest::_internal_has_op_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TsoRequest::has_op_type() const {
  return _internal_has_op_type();
}
inline void TsoRequest::clear_op_type() {
  op_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::baikaldb::pb::OpType TsoRequest::_internal_op_type() const {
  return static_cast< ::baikaldb::pb::OpType >(op_type_);
}
inline ::baikaldb::pb::OpType TsoRequest::op_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TsoRequest.op_type)
  return _internal_op_type();
}
inline void TsoRequest::_internal_set_op_type(::baikaldb::pb::OpType value) {
  assert(::baikaldb::pb::OpType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  op_type_ = value;
}
inline void TsoRequest::set_op_type(::baikaldb::pb::OpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TsoRequest.op_type)
}

// optional int64 count = 2;
inline bool TsoRequest::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TsoRequest::has_count() const {
  return _internal_has_count();
}
inline void TsoRequest::clear_count() {
  count_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TsoRequest::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TsoRequest::count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TsoRequest.count)
  return _internal_count();
}
inline void TsoRequest::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  count_ = value;
}
inline void TsoRequest::set_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TsoRequest.count)
}

// optional .baikaldb.pb.TsoTimestamp current_timestamp = 3;
inline bool TsoRequest::_internal_has_current_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || current_timestamp_ != nullptr);
  return value;
}
inline bool TsoRequest::has_current_timestamp() const {
  return _internal_has_current_timestamp();
}
inline void TsoRequest::clear_current_timestamp() {
  if (current_timestamp_ != nullptr) current_timestamp_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::TsoTimestamp& TsoRequest::_internal_current_timestamp() const {
  const ::baikaldb::pb::TsoTimestamp* p = current_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::TsoTimestamp&>(
      ::baikaldb::pb::_TsoTimestamp_default_instance_);
}
inline const ::baikaldb::pb::TsoTimestamp& TsoRequest::current_timestamp() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TsoRequest.current_timestamp)
  return _internal_current_timestamp();
}
inline void TsoRequest::unsafe_arena_set_allocated_current_timestamp(
    ::baikaldb::pb::TsoTimestamp* current_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(current_timestamp_);
  }
  current_timestamp_ = current_timestamp;
  if (current_timestamp) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.TsoRequest.current_timestamp)
}
inline ::baikaldb::pb::TsoTimestamp* TsoRequest::release_current_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::TsoTimestamp* temp = current_timestamp_;
  current_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::TsoTimestamp* TsoRequest::unsafe_arena_release_current_timestamp() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TsoRequest.current_timestamp)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::TsoTimestamp* temp = current_timestamp_;
  current_timestamp_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::TsoTimestamp* TsoRequest::_internal_mutable_current_timestamp() {
  _has_bits_[0] |= 0x00000001u;
  if (current_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::TsoTimestamp>(GetArenaForAllocation());
    current_timestamp_ = p;
  }
  return current_timestamp_;
}
inline ::baikaldb::pb::TsoTimestamp* TsoRequest::mutable_current_timestamp() {
  ::baikaldb::pb::TsoTimestamp* _msg = _internal_mutable_current_timestamp();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TsoRequest.current_timestamp)
  return _msg;
}
inline void TsoRequest::set_allocated_current_timestamp(::baikaldb::pb::TsoTimestamp* current_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete current_timestamp_;
  }
  if (current_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::TsoTimestamp>::GetOwningArena(current_timestamp);
    if (message_arena != submessage_arena) {
      current_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, current_timestamp, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  current_timestamp_ = current_timestamp;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TsoRequest.current_timestamp)
}

// optional int64 save_physical = 4;
inline bool TsoRequest::_internal_has_save_physical() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TsoRequest::has_save_physical() const {
  return _internal_has_save_physical();
}
inline void TsoRequest::clear_save_physical() {
  save_physical_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TsoRequest::_internal_save_physical() const {
  return save_physical_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TsoRequest::save_physical() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TsoRequest.save_physical)
  return _internal_save_physical();
}
inline void TsoRequest::_internal_set_save_physical(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  save_physical_ = value;
}
inline void TsoRequest::set_save_physical(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_save_physical(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TsoRequest.save_physical)
}

// optional bool force = 5;
inline bool TsoRequest::_internal_has_force() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TsoRequest::has_force() const {
  return _internal_has_force();
}
inline void TsoRequest::clear_force() {
  force_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool TsoRequest::_internal_force() const {
  return force_;
}
inline bool TsoRequest::force() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TsoRequest.force)
  return _internal_force();
}
inline void TsoRequest::_internal_set_force(bool value) {
  _has_bits_[0] |= 0x00000008u;
  force_ = value;
}
inline void TsoRequest::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TsoRequest.force)
}

// -------------------------------------------------------------------

// TsoResponse

// required .baikaldb.pb.OpType op_type = 1;
inline bool TsoResponse::_internal_has_op_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TsoResponse::has_op_type() const {
  return _internal_has_op_type();
}
inline void TsoResponse::clear_op_type() {
  op_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::baikaldb::pb::OpType TsoResponse::_internal_op_type() const {
  return static_cast< ::baikaldb::pb::OpType >(op_type_);
}
inline ::baikaldb::pb::OpType TsoResponse::op_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TsoResponse.op_type)
  return _internal_op_type();
}
inline void TsoResponse::_internal_set_op_type(::baikaldb::pb::OpType value) {
  assert(::baikaldb::pb::OpType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  op_type_ = value;
}
inline void TsoResponse::set_op_type(::baikaldb::pb::OpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TsoResponse.op_type)
}

// optional .baikaldb.pb.ErrCode errcode = 2;
inline bool TsoResponse::_internal_has_errcode() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TsoResponse::has_errcode() const {
  return _internal_has_errcode();
}
inline void TsoResponse::clear_errcode() {
  errcode_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::baikaldb::pb::ErrCode TsoResponse::_internal_errcode() const {
  return static_cast< ::baikaldb::pb::ErrCode >(errcode_);
}
inline ::baikaldb::pb::ErrCode TsoResponse::errcode() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TsoResponse.errcode)
  return _internal_errcode();
}
inline void TsoResponse::_internal_set_errcode(::baikaldb::pb::ErrCode value) {
  assert(::baikaldb::pb::ErrCode_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  errcode_ = value;
}
inline void TsoResponse::set_errcode(::baikaldb::pb::ErrCode value) {
  _internal_set_errcode(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TsoResponse.errcode)
}

// optional .baikaldb.pb.TsoTimestamp start_timestamp = 3;
inline bool TsoResponse::_internal_has_start_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || start_timestamp_ != nullptr);
  return value;
}
inline bool TsoResponse::has_start_timestamp() const {
  return _internal_has_start_timestamp();
}
inline void TsoResponse::clear_start_timestamp() {
  if (start_timestamp_ != nullptr) start_timestamp_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::baikaldb::pb::TsoTimestamp& TsoResponse::_internal_start_timestamp() const {
  const ::baikaldb::pb::TsoTimestamp* p = start_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::TsoTimestamp&>(
      ::baikaldb::pb::_TsoTimestamp_default_instance_);
}
inline const ::baikaldb::pb::TsoTimestamp& TsoResponse::start_timestamp() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TsoResponse.start_timestamp)
  return _internal_start_timestamp();
}
inline void TsoResponse::unsafe_arena_set_allocated_start_timestamp(
    ::baikaldb::pb::TsoTimestamp* start_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_timestamp_);
  }
  start_timestamp_ = start_timestamp;
  if (start_timestamp) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.TsoResponse.start_timestamp)
}
inline ::baikaldb::pb::TsoTimestamp* TsoResponse::release_start_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::TsoTimestamp* temp = start_timestamp_;
  start_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::TsoTimestamp* TsoResponse::unsafe_arena_release_start_timestamp() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TsoResponse.start_timestamp)
  _has_bits_[0] &= ~0x00000004u;
  ::baikaldb::pb::TsoTimestamp* temp = start_timestamp_;
  start_timestamp_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::TsoTimestamp* TsoResponse::_internal_mutable_start_timestamp() {
  _has_bits_[0] |= 0x00000004u;
  if (start_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::TsoTimestamp>(GetArenaForAllocation());
    start_timestamp_ = p;
  }
  return start_timestamp_;
}
inline ::baikaldb::pb::TsoTimestamp* TsoResponse::mutable_start_timestamp() {
  ::baikaldb::pb::TsoTimestamp* _msg = _internal_mutable_start_timestamp();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TsoResponse.start_timestamp)
  return _msg;
}
inline void TsoResponse::set_allocated_start_timestamp(::baikaldb::pb::TsoTimestamp* start_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete start_timestamp_;
  }
  if (start_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::TsoTimestamp>::GetOwningArena(start_timestamp);
    if (message_arena != submessage_arena) {
      start_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_timestamp, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  start_timestamp_ = start_timestamp;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TsoResponse.start_timestamp)
}

// optional int64 count = 4;
inline bool TsoResponse::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TsoResponse::has_count() const {
  return _internal_has_count();
}
inline void TsoResponse::clear_count() {
  count_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TsoResponse::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TsoResponse::count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TsoResponse.count)
  return _internal_count();
}
inline void TsoResponse::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  count_ = value;
}
inline void TsoResponse::set_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TsoResponse.count)
}

// optional string errmsg = 5;
inline bool TsoResponse::_internal_has_errmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TsoResponse::has_errmsg() const {
  return _internal_has_errmsg();
}
inline void TsoResponse::clear_errmsg() {
  errmsg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TsoResponse::errmsg() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TsoResponse.errmsg)
  return _internal_errmsg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TsoResponse::set_errmsg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.TsoResponse.errmsg)
}
inline std::string* TsoResponse::mutable_errmsg() {
  std::string* _s = _internal_mutable_errmsg();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TsoResponse.errmsg)
  return _s;
}
inline const std::string& TsoResponse::_internal_errmsg() const {
  return errmsg_.Get();
}
inline void TsoResponse::_internal_set_errmsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TsoResponse::_internal_mutable_errmsg() {
  _has_bits_[0] |= 0x00000001u;
  return errmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TsoResponse::release_errmsg() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TsoResponse.errmsg)
  if (!_internal_has_errmsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return errmsg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TsoResponse::set_allocated_errmsg(std::string* errmsg) {
  if (errmsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errmsg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TsoResponse.errmsg)
}

// optional int64 save_physical = 6;
inline bool TsoResponse::_internal_has_save_physical() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TsoResponse::has_save_physical() const {
  return _internal_has_save_physical();
}
inline void TsoResponse::clear_save_physical() {
  save_physical_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TsoResponse::_internal_save_physical() const {
  return save_physical_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TsoResponse::save_physical() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TsoResponse.save_physical)
  return _internal_save_physical();
}
inline void TsoResponse::_internal_set_save_physical(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  save_physical_ = value;
}
inline void TsoResponse::set_save_physical(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_save_physical(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TsoResponse.save_physical)
}

// optional int64 system_time = 7;
inline bool TsoResponse::_internal_has_system_time() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TsoResponse::has_system_time() const {
  return _internal_has_system_time();
}
inline void TsoResponse::clear_system_time() {
  system_time_ = int64_t{0};
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TsoResponse::_internal_system_time() const {
  return system_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TsoResponse::system_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TsoResponse.system_time)
  return _internal_system_time();
}
inline void TsoResponse::_internal_set_system_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  system_time_ = value;
}
inline void TsoResponse::set_system_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_system_time(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TsoResponse.system_time)
}

// optional string leader = 8;
inline bool TsoResponse::_internal_has_leader() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TsoResponse::has_leader() const {
  return _internal_has_leader();
}
inline void TsoResponse::clear_leader() {
  leader_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TsoResponse::leader() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TsoResponse.leader)
  return _internal_leader();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TsoResponse::set_leader(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.TsoResponse.leader)
}
inline std::string* TsoResponse::mutable_leader() {
  std::string* _s = _internal_mutable_leader();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.TsoResponse.leader)
  return _s;
}
inline const std::string& TsoResponse::_internal_leader() const {
  return leader_.Get();
}
inline void TsoResponse::_internal_set_leader(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  leader_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TsoResponse::_internal_mutable_leader() {
  _has_bits_[0] |= 0x00000002u;
  return leader_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TsoResponse::release_leader() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.TsoResponse.leader)
  if (!_internal_has_leader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return leader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TsoResponse::set_allocated_leader(std::string* leader) {
  if (leader != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  leader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), leader,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.TsoResponse.leader)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace baikaldb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::baikaldb::pb::Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::Status>() {
  return ::baikaldb::pb::Status_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::RegionStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::RegionStatus>() {
  return ::baikaldb::pb::RegionStatus_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::IndexState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::IndexState>() {
  return ::baikaldb::pb::IndexState_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::IndexHintStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::IndexHintStatus>() {
  return ::baikaldb::pb::IndexHintStatus_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::RollupType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::RollupType>() {
  return ::baikaldb::pb::RollupType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::PartitionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::PartitionType>() {
  return ::baikaldb::pb::PartitionType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::RangePartitionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::RangePartitionType>() {
  return ::baikaldb::pb::RangePartitionType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::DBLinkType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::DBLinkType>() {
  return ::baikaldb::pb::DBLinkType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::IndexType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::IndexType>() {
  return ::baikaldb::pb::IndexType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::SegmentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::SegmentType>() {
  return ::baikaldb::pb::SegmentType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::StorageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::StorageType>() {
  return ::baikaldb::pb::StorageType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::MetricType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::MetricType>() {
  return ::baikaldb::pb::MetricType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::RW> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::RW>() {
  return ::baikaldb::pb::RW_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::RecoverOpt> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::RecoverOpt>() {
  return ::baikaldb::pb::RecoverOpt_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::PeerStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::PeerStatus>() {
  return ::baikaldb::pb::PeerStatus_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::QueryOpType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::QueryOpType>() {
  return ::baikaldb::pb::QueryOpType_descriptor();
}
template <> struct is_proto_enum< ::baikaldb::pb::DdlWorkStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::DdlWorkStatus>() {
  return ::baikaldb::pb::DdlWorkStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_meta_2einterface_2eproto
