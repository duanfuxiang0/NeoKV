// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: plan.proto

#include "plan.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace baikaldb {
namespace pb {
constexpr SelectManagerNode::SelectManagerNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : slot_order_exprs_()
  , is_asc_()
  , is_null_first_()
  , schema_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , is_return_empty_(false){}
struct SelectManagerNodeDefaultTypeInternal {
  constexpr SelectManagerNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SelectManagerNodeDefaultTypeInternal() {}
  union {
    SelectManagerNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SelectManagerNodeDefaultTypeInternal _SelectManagerNode_default_instance_;
constexpr PossibleIndex_Range::PossibleIndex_Range(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : partition_ids_()
  , left_pb_record_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , right_pb_record_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , left_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , right_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , left_field_cnt_(0)
  , right_field_cnt_(0)
  , left_open_(false)
  , right_open_(false)
  , like_prefix_(false)
  , left_full_(false)
  , match_mode_(0)

  , right_full_(false)
  , topk_(0)
  , separate_value_(uint64_t{0u})
  , efsearch_(0){}
struct PossibleIndex_RangeDefaultTypeInternal {
  constexpr PossibleIndex_RangeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PossibleIndex_RangeDefaultTypeInternal() {}
  union {
    PossibleIndex_Range _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PossibleIndex_RangeDefaultTypeInternal _PossibleIndex_Range_default_instance_;
constexpr PossibleIndex_SortIndex::PossibleIndex_SortIndex(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sort_limit_(int64_t{0})
  , is_asc_(false){}
struct PossibleIndex_SortIndexDefaultTypeInternal {
  constexpr PossibleIndex_SortIndexDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PossibleIndex_SortIndexDefaultTypeInternal() {}
  union {
    PossibleIndex_SortIndex _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PossibleIndex_SortIndexDefaultTypeInternal _PossibleIndex_SortIndex_default_instance_;
constexpr PossibleIndex::PossibleIndex(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ranges_()
  , index_conjuncts_()
  , sort_index_(nullptr)
  , index_id_(int64_t{0})
  , bool_and_(false)
  , is_covering_index_(false)
  , use_for_learner_(false)
  , range_key_sorted_(false)
  , left_field_cnt_(0)
  , right_field_cnt_(0)
  , is_eq_(false)
  , left_open_(false)
  , right_open_(false)
  , like_prefix_(false){}
struct PossibleIndexDefaultTypeInternal {
  constexpr PossibleIndexDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PossibleIndexDefaultTypeInternal() {}
  union {
    PossibleIndex _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PossibleIndexDefaultTypeInternal _PossibleIndex_default_instance_;
constexpr FulltextIndex::FulltextIndex(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nested_fulltext_indexes_()
  , possible_index_(nullptr)
  , fulltext_node_type_(1)
{}
struct FulltextIndexDefaultTypeInternal {
  constexpr FulltextIndexDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FulltextIndexDefaultTypeInternal() {}
  union {
    FulltextIndex _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FulltextIndexDefaultTypeInternal _FulltextIndex_default_instance_;
constexpr ScanNode::ScanNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : indexes_()
  , use_indexes_()
  , ignore_indexes_()
  , force_indexes_()
  , learner_index_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , fulltext_index_(nullptr)
  , column_ddl_info_(nullptr)
  , table_id_(int64_t{0})
  , tuple_id_(0)
  , lock_(0)

  , ddl_index_id_(int64_t{0})
  , ddl_work_type_(0)

  , is_ddl_work_(false)
  , use_column_storage_(false)
  , watt_stats_version_(uint64_t{0u})
  , union_tuple_id_(0)
  , engine_(1)
{}
struct ScanNodeDefaultTypeInternal {
  constexpr ScanNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ScanNodeDefaultTypeInternal() {}
  union {
    ScanNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ScanNodeDefaultTypeInternal _ScanNode_default_instance_;
constexpr LimitNode::LimitNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : offset_expr_(nullptr)
  , count_expr_(nullptr)
  , offset_(int64_t{0}){}
struct LimitNodeDefaultTypeInternal {
  constexpr LimitNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LimitNodeDefaultTypeInternal() {}
  union {
    LimitNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LimitNodeDefaultTypeInternal _LimitNode_default_instance_;
constexpr SortNode::SortNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : order_exprs_()
  , is_asc_()
  , is_null_first_()
  , slot_order_exprs_()
  , tuple_id_(0){}
struct SortNodeDefaultTypeInternal {
  constexpr SortNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SortNodeDefaultTypeInternal() {}
  union {
    SortNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SortNodeDefaultTypeInternal _SortNode_default_instance_;
constexpr AggNode::AggNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : group_exprs_()
  , agg_funcs_()
  , agg_tuple_id_(0)
  , arrow_ignore_tuple_id_(0)
  , is_pushdown_(false){}
struct AggNodeDefaultTypeInternal {
  constexpr AggNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AggNodeDefaultTypeInternal() {}
  union {
    AggNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AggNodeDefaultTypeInternal _AggNode_default_instance_;
constexpr FilterNode::FilterNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : conjuncts_()
  , conjuncts_learner_(){}
struct FilterNodeDefaultTypeInternal {
  constexpr FilterNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FilterNodeDefaultTypeInternal() {}
  union {
    FilterNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FilterNodeDefaultTypeInternal _FilterNode_default_instance_;
constexpr DualScanNode::DualScanNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : derived_table_projections_()
  , slot_column_()
  , derived_table_projections_agg_or_window_vec_()
  , agg_tuple_id_pair_()
  , agg_slot_ids_()
  , multi_distinct_agg_slot_ids_()
  , sub_query_node_(nullptr)
  , runtime_state_(nullptr){}
struct DualScanNodeDefaultTypeInternal {
  constexpr DualScanNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DualScanNodeDefaultTypeInternal() {}
  union {
    DualScanNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DualScanNodeDefaultTypeInternal _DualScanNode_default_instance_;
constexpr JoinNode::JoinNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : conditions_()
  , using_clos_()
  , left_tuple_ids_()
  , left_table_ids_()
  , right_tuple_ids_()
  , right_table_ids_()
  , join_type_(0)

  , use_index_join_(false){}
struct JoinNodeDefaultTypeInternal {
  constexpr JoinNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~JoinNodeDefaultTypeInternal() {}
  union {
    JoinNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT JoinNodeDefaultTypeInternal _JoinNode_default_instance_;
constexpr ApplyNode::ApplyNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : conditions_()
  , left_tuple_ids_()
  , left_table_ids_()
  , right_tuple_ids_()
  , right_table_ids_()
  , join_type_(0)

  , compare_type_(0)

  , max_one_row_(false)
  , is_select_field_(false){}
struct ApplyNodeDefaultTypeInternal {
  constexpr ApplyNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ApplyNodeDefaultTypeInternal() {}
  union {
    ApplyNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ApplyNodeDefaultTypeInternal _ApplyNode_default_instance_;
constexpr FetcherNode::FetcherNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : slot_order_exprs_()
  , is_asc_()
  , is_null_first_()
  , op_type_(0)
{}
struct FetcherNodeDefaultTypeInternal {
  constexpr FetcherNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FetcherNodeDefaultTypeInternal() {}
  union {
    FetcherNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FetcherNodeDefaultTypeInternal _FetcherNode_default_instance_;
constexpr InsertNode::InsertNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : records_()
  , update_slots_()
  , update_exprs_()
  , field_ids_()
  , insert_values_()
  , table_id_(int64_t{0})
  , tuple_id_(0)
  , values_tuple_id_(0)
  , row_ttl_duration_(int64_t{0})
  , ddl_index_id_(int64_t{0})
  , watt_stats_version_(uint64_t{0u})
  , need_ignore_(false)
  , is_replace_(false)
  , ddl_need_write_(false)
  , is_merge_(false){}
struct InsertNodeDefaultTypeInternal {
  constexpr InsertNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~InsertNodeDefaultTypeInternal() {}
  union {
    InsertNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT InsertNodeDefaultTypeInternal _InsertNode_default_instance_;
constexpr LockPrimaryNode::LockPrimaryNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : put_records_()
  , delete_records_()
  , affect_index_ids_()
  , conjuncts_()
  , table_id_(int64_t{0})
  , row_ttl_duration_s_(int64_t{0})
  , lock_type_(0)

  , affect_primary_(true){}
struct LockPrimaryNodeDefaultTypeInternal {
  constexpr LockPrimaryNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LockPrimaryNodeDefaultTypeInternal() {}
  union {
    LockPrimaryNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LockPrimaryNodeDefaultTypeInternal _LockPrimaryNode_default_instance_;
constexpr LockSecondaryNode::LockSecondaryNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : put_records_()
  , delete_records_()
  , global_ddl_ttl_timestamp_us_()
  , table_id_(int64_t{0})
  , global_index_id_(int64_t{0})
  , lock_type_(0)

  , lock_secondary_type_(0)

  , row_ttl_duration_s_(int64_t{0}){}
struct LockSecondaryNodeDefaultTypeInternal {
  constexpr LockSecondaryNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LockSecondaryNodeDefaultTypeInternal() {}
  union {
    LockSecondaryNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LockSecondaryNodeDefaultTypeInternal _LockSecondaryNode_default_instance_;
constexpr DeleteNode::DeleteNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : primary_slots_()
  , table_id_(int64_t{0}){}
struct DeleteNodeDefaultTypeInternal {
  constexpr DeleteNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DeleteNodeDefaultTypeInternal() {}
  union {
    DeleteNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DeleteNodeDefaultTypeInternal _DeleteNode_default_instance_;
constexpr TruncateNode::TruncateNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : table_id_(int64_t{0}){}
struct TruncateNodeDefaultTypeInternal {
  constexpr TruncateNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TruncateNodeDefaultTypeInternal() {}
  union {
    TruncateNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TruncateNodeDefaultTypeInternal _TruncateNode_default_instance_;
constexpr UpdateNode::UpdateNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : primary_slots_()
  , update_slots_()
  , update_exprs_()
  , table_id_(int64_t{0})
  , row_ttl_duration_(int64_t{0}){}
struct UpdateNodeDefaultTypeInternal {
  constexpr UpdateNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UpdateNodeDefaultTypeInternal() {}
  union {
    UpdateNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UpdateNodeDefaultTypeInternal _UpdateNode_default_instance_;
constexpr PacketNode::PacketNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : projections_()
  , col_names_()
  , op_type_(0)
{}
struct PacketNodeDefaultTypeInternal {
  constexpr PacketNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PacketNodeDefaultTypeInternal() {}
  union {
    PacketNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PacketNodeDefaultTypeInternal _PacketNode_default_instance_;
constexpr TransactionNode::TransactionNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : txn_timeout_(int64_t{0})
  , txn_lock_timeout_(int64_t{0})
  , txn_cmd_(0)
{}
struct TransactionNodeDefaultTypeInternal {
  constexpr TransactionNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TransactionNodeDefaultTypeInternal() {}
  union {
    TransactionNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TransactionNodeDefaultTypeInternal _TransactionNode_default_instance_;
constexpr KillNode::KillNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : db_conn_id_(uint64_t{0u})
  , is_query_(false){}
struct KillNodeDefaultTypeInternal {
  constexpr KillNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KillNodeDefaultTypeInternal() {}
  union {
    KillNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KillNodeDefaultTypeInternal _KillNode_default_instance_;
constexpr UnionNode::UnionNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : slot_order_exprs_()
  , is_asc_()
  , is_null_first_()
  , union_tuple_id_(0){}
struct UnionNodeDefaultTypeInternal {
  constexpr UnionNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UnionNodeDefaultTypeInternal() {}
  union {
    UnionNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UnionNodeDefaultTypeInternal _UnionNode_default_instance_;
constexpr LoadNode::LoadNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : set_slots_()
  , set_exprs_()
  , field_ids_()
  , default_field_ids_()
  , ingore_field_indexes_()
  , data_path_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , terminated_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , enclosed_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , escaped_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , line_starting_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , line_terminated_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , table_id_(int64_t{0})
  , ignore_lines_(0)
  , opt_enclosed_(false)
  , file_size_(int64_t{0})
  , char_set_(0)
{}
struct LoadNodeDefaultTypeInternal {
  constexpr LoadNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LoadNodeDefaultTypeInternal() {}
  union {
    LoadNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LoadNodeDefaultTypeInternal _LoadNode_default_instance_;
constexpr PartitionProperty::PartitionProperty(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : hash_cols_()
  , need_cast_string_cols_()
  , need_project_hash_cols_()
  , need_project_hash_exprs_()
  , type_(1)
{}
struct PartitionPropertyDefaultTypeInternal {
  constexpr PartitionPropertyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PartitionPropertyDefaultTypeInternal() {}
  union {
    PartitionProperty _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PartitionPropertyDefaultTypeInternal _PartitionProperty_default_instance_;
constexpr ExchangeDestination::ExchangeDestination(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , fragment_instance_id_(uint64_t{0u})
  , node_id_(0){}
struct ExchangeDestinationDefaultTypeInternal {
  constexpr ExchangeDestinationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ExchangeDestinationDefaultTypeInternal() {}
  union {
    ExchangeDestination _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ExchangeDestinationDefaultTypeInternal _ExchangeDestination_default_instance_;
constexpr ExchangeSenderNode::ExchangeSenderNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : receiver_destinations_()
  , fragment_addresses_()
  , schema_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , partition_property_(nullptr)
  , log_id_(uint64_t{0u})
  , fragment_id_(0)
  , receiver_fragment_id_(0)
  , fragment_instance_id_(uint64_t{0u})
  , node_id_(0){}
struct ExchangeSenderNodeDefaultTypeInternal {
  constexpr ExchangeSenderNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ExchangeSenderNodeDefaultTypeInternal() {}
  union {
    ExchangeSenderNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ExchangeSenderNodeDefaultTypeInternal _ExchangeSenderNode_default_instance_;
constexpr ExchangeReceiverNode::ExchangeReceiverNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sender_destinations_()
  , regions_()
  , slot_order_exprs_()
  , is_asc_()
  , is_null_first_()
  , schema_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , partition_property_(nullptr)
  , log_id_(uint64_t{0u})
  , fragment_id_(0)
  , sender_fragment_id_(0)
  , fragment_instance_id_(uint64_t{0u})
  , node_id_(0){}
struct ExchangeReceiverNodeDefaultTypeInternal {
  constexpr ExchangeReceiverNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ExchangeReceiverNodeDefaultTypeInternal() {}
  union {
    ExchangeReceiverNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ExchangeReceiverNodeDefaultTypeInternal _ExchangeReceiverNode_default_instance_;
constexpr FrameBound::FrameBound(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : expr_(nullptr)
  , bound_type_(0)

  , is_unbounded_(false){}
struct FrameBoundDefaultTypeInternal {
  constexpr FrameBoundDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FrameBoundDefaultTypeInternal() {}
  union {
    FrameBound _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FrameBoundDefaultTypeInternal _FrameBound_default_instance_;
constexpr FrameExtent::FrameExtent(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : frame_start_(nullptr)
  , frame_end_(nullptr){}
struct FrameExtentDefaultTypeInternal {
  constexpr FrameExtentDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FrameExtentDefaultTypeInternal() {}
  union {
    FrameExtent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FrameExtentDefaultTypeInternal _FrameExtent_default_instance_;
constexpr WindowFrame::WindowFrame(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : frame_extent_(nullptr)
  , frame_type_(0)
{}
struct WindowFrameDefaultTypeInternal {
  constexpr WindowFrameDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WindowFrameDefaultTypeInternal() {}
  union {
    WindowFrame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WindowFrameDefaultTypeInternal _WindowFrame_default_instance_;
constexpr WindowSpec::WindowSpec(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : partition_exprs_()
  , order_exprs_()
  , is_asc_()
  , window_frame_(nullptr)
  , tuple_id_(0){}
struct WindowSpecDefaultTypeInternal {
  constexpr WindowSpecDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WindowSpecDefaultTypeInternal() {}
  union {
    WindowSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WindowSpecDefaultTypeInternal _WindowSpec_default_instance_;
constexpr WindowNode::WindowNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : func_exprs_()
  , window_spec_(nullptr){}
struct WindowNodeDefaultTypeInternal {
  constexpr WindowNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~WindowNodeDefaultTypeInternal() {}
  union {
    WindowNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT WindowNodeDefaultTypeInternal _WindowNode_default_instance_;
constexpr DerivePlanNode::DerivePlanNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : filter_node_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , scan_node_(nullptr)
  , sort_node_(nullptr)
  , agg_node_(nullptr)
  , join_node_(nullptr)
  , insert_node_(nullptr)
  , delete_node_(nullptr)
  , update_node_(nullptr)
  , fetcher_node_(nullptr)
  , limit_node_(nullptr)
  , packet_node_(nullptr)
  , truncate_node_(nullptr)
  , transaction_node_(nullptr)
  , kill_node_(nullptr)
  , lock_primary_node_(nullptr)
  , lock_secondary_node_(nullptr)
  , union_node_(nullptr)
  , apply_node_(nullptr)
  , load_node_(nullptr)
  , raw_filter_node_(nullptr)
  , exchange_sender_node_(nullptr)
  , exchange_receiver_node_(nullptr)
  , select_manager_node_(nullptr)
  , dual_scan_node_(nullptr)
  , window_node_(nullptr){}
struct DerivePlanNodeDefaultTypeInternal {
  constexpr DerivePlanNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DerivePlanNodeDefaultTypeInternal() {}
  union {
    DerivePlanNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DerivePlanNodeDefaultTypeInternal _DerivePlanNode_default_instance_;
constexpr PlanNode::PlanNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : partitions_()
  , derive_node_(nullptr)
  , limit_(int64_t{0})
  , num_children_(0)
  , is_explain_(false)
  , local_index_binlog_(false)
  , is_get_keypoint_(false)
  , node_type_(1)
{}
struct PlanNodeDefaultTypeInternal {
  constexpr PlanNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PlanNodeDefaultTypeInternal() {}
  union {
    PlanNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PlanNodeDefaultTypeInternal _PlanNode_default_instance_;
constexpr Plan::Plan(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nodes_(){}
struct PlanDefaultTypeInternal {
  constexpr PlanDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PlanDefaultTypeInternal() {}
  union {
    Plan _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PlanDefaultTypeInternal _Plan_default_instance_;
constexpr LocalTraceNode::LocalTraceNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : arrow_plan_()
  , description_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , index_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , mpp_property_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , time_cost_us_(int64_t{0})
  , sort_time_(int64_t{0})
  , affect_rows_(int64_t{0})
  , scan_rows_(int64_t{0})
  , index_filter_rows_(int64_t{0})
  , get_primary_rows_(int64_t{0})
  , where_filter_rows_(int64_t{0}){}
struct LocalTraceNodeDefaultTypeInternal {
  constexpr LocalTraceNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~LocalTraceNodeDefaultTypeInternal() {}
  union {
    LocalTraceNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT LocalTraceNodeDefaultTypeInternal _LocalTraceNode_default_instance_;
constexpr TraceNode::TraceNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : child_nodes_()
  , description_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , instance_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , open_trace_(nullptr)
  , get_next_trace_(nullptr)
  , txn_get_trace_(nullptr)
  , txn_put_trace_(nullptr)
  , txn_delete_trace_(nullptr)
  , txn_commit_trace_(nullptr)
  , store_agg_(nullptr)
  , region_id_(int64_t{0})
  , total_time_(int64_t{0})
  , affect_rows_(int64_t{0})
  , partition_id_(int64_t{0})
  , node_type_(1)
{}
struct TraceNodeDefaultTypeInternal {
  constexpr TraceNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~TraceNodeDefaultTypeInternal() {}
  union {
    TraceNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT TraceNodeDefaultTypeInternal _TraceNode_default_instance_;
constexpr FragmentInfo::FragmentInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : plan_(nullptr)
  , runtime_state_(nullptr)
  , fragment_id_(0){}
struct FragmentInfoDefaultTypeInternal {
  constexpr FragmentInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FragmentInfoDefaultTypeInternal() {}
  union {
    FragmentInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FragmentInfoDefaultTypeInternal _FragmentInfo_default_instance_;
}  // namespace pb
}  // namespace baikaldb
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_plan_2eproto[40];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_plan_2eproto[12];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_plan_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_plan_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::SelectManagerNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::SelectManagerNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::SelectManagerNode, schema_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::SelectManagerNode, slot_order_exprs_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::SelectManagerNode, is_asc_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::SelectManagerNode, is_null_first_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::SelectManagerNode, is_return_empty_),
  0,
  ~0u,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, left_pb_record_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, right_pb_record_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, left_field_cnt_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, right_field_cnt_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, left_open_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, right_open_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, like_prefix_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, match_mode_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, left_key_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, right_key_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, left_full_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, right_full_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, partition_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, topk_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, separate_value_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_Range, efsearch_),
  0,
  1,
  4,
  5,
  6,
  7,
  8,
  10,
  2,
  3,
  9,
  11,
  ~0u,
  12,
  13,
  14,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_SortIndex, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_SortIndex, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_SortIndex, is_asc_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex_SortIndex, sort_limit_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex, index_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex, ranges_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex, index_conjuncts_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex, sort_index_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex, bool_and_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex, is_covering_index_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex, use_for_learner_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex, range_key_sorted_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex, is_eq_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex, left_field_cnt_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex, right_field_cnt_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex, left_open_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex, right_open_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PossibleIndex, like_prefix_),
  1,
  ~0u,
  ~0u,
  0,
  2,
  3,
  4,
  5,
  8,
  6,
  7,
  9,
  10,
  11,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FulltextIndex, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FulltextIndex, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FulltextIndex, fulltext_node_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FulltextIndex, possible_index_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FulltextIndex, nested_fulltext_indexes_),
  1,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, tuple_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, table_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, indexes_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, use_indexes_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, engine_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, ignore_indexes_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, fulltext_index_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, lock_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, is_ddl_work_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, ddl_index_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, force_indexes_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, learner_index_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, ddl_work_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, column_ddl_info_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, watt_stats_version_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, union_tuple_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ScanNode, use_column_storage_),
  4,
  3,
  ~0u,
  ~0u,
  12,
  ~0u,
  1,
  5,
  8,
  6,
  ~0u,
  0,
  7,
  2,
  10,
  11,
  9,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LimitNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LimitNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LimitNode, offset_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LimitNode, offset_expr_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LimitNode, count_expr_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::SortNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::SortNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::SortNode, order_exprs_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::SortNode, is_asc_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::SortNode, is_null_first_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::SortNode, tuple_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::SortNode, slot_order_exprs_),
  ~0u,
  ~0u,
  ~0u,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::AggNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::AggNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::AggNode, group_exprs_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::AggNode, agg_funcs_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::AggNode, agg_tuple_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::AggNode, arrow_ignore_tuple_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::AggNode, is_pushdown_),
  ~0u,
  ~0u,
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FilterNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FilterNode, conjuncts_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FilterNode, conjuncts_learner_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DualScanNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DualScanNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DualScanNode, sub_query_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DualScanNode, derived_table_projections_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DualScanNode, runtime_state_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DualScanNode, slot_column_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DualScanNode, derived_table_projections_agg_or_window_vec_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DualScanNode, agg_tuple_id_pair_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DualScanNode, agg_slot_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DualScanNode, multi_distinct_agg_slot_ids_),
  0,
  ~0u,
  1,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::JoinNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::JoinNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::JoinNode, join_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::JoinNode, conditions_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::JoinNode, using_clos_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::JoinNode, left_tuple_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::JoinNode, left_table_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::JoinNode, right_tuple_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::JoinNode, right_table_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::JoinNode, use_index_join_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ApplyNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ApplyNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ApplyNode, join_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ApplyNode, conditions_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ApplyNode, left_tuple_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ApplyNode, left_table_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ApplyNode, right_tuple_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ApplyNode, right_table_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ApplyNode, max_one_row_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ApplyNode, compare_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ApplyNode, is_select_field_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  2,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FetcherNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FetcherNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FetcherNode, op_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FetcherNode, slot_order_exprs_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FetcherNode, is_asc_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FetcherNode, is_null_first_),
  0,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, table_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, records_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, need_ignore_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, update_slots_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, update_exprs_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, tuple_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, values_tuple_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, is_replace_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, field_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, insert_values_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, row_ttl_duration_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, ddl_need_write_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, ddl_index_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, is_merge_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::InsertNode, watt_stats_version_),
  0,
  ~0u,
  6,
  ~0u,
  ~0u,
  1,
  2,
  7,
  ~0u,
  ~0u,
  3,
  8,
  4,
  9,
  5,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockPrimaryNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockPrimaryNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockPrimaryNode, table_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockPrimaryNode, lock_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockPrimaryNode, put_records_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockPrimaryNode, delete_records_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockPrimaryNode, affect_primary_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockPrimaryNode, affect_index_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockPrimaryNode, row_ttl_duration_s_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockPrimaryNode, conjuncts_),
  0,
  2,
  ~0u,
  ~0u,
  3,
  ~0u,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockSecondaryNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockSecondaryNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockSecondaryNode, table_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockSecondaryNode, global_index_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockSecondaryNode, lock_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockSecondaryNode, put_records_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockSecondaryNode, delete_records_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockSecondaryNode, lock_secondary_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockSecondaryNode, row_ttl_duration_s_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LockSecondaryNode, global_ddl_ttl_timestamp_us_),
  0,
  1,
  2,
  ~0u,
  ~0u,
  3,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DeleteNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DeleteNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DeleteNode, table_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DeleteNode, primary_slots_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TruncateNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TruncateNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TruncateNode, table_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UpdateNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UpdateNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UpdateNode, table_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UpdateNode, primary_slots_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UpdateNode, update_slots_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UpdateNode, update_exprs_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UpdateNode, row_ttl_duration_),
  0,
  ~0u,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PacketNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PacketNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PacketNode, op_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PacketNode, projections_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PacketNode, col_names_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionNode, txn_cmd_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionNode, txn_timeout_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TransactionNode, txn_lock_timeout_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::KillNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::KillNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::KillNode, db_conn_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::KillNode, is_query_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UnionNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UnionNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UnionNode, union_tuple_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UnionNode, slot_order_exprs_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UnionNode, is_asc_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::UnionNode, is_null_first_),
  0,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, table_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, data_path_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, set_slots_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, set_exprs_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, field_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, default_field_ids_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, ingore_field_indexes_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, ignore_lines_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, terminated_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, enclosed_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, escaped_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, line_starting_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, line_terminated_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, opt_enclosed_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, file_size_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LoadNode, char_set_),
  6,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  7,
  1,
  2,
  3,
  4,
  5,
  8,
  9,
  10,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PartitionProperty, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PartitionProperty, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PartitionProperty, type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PartitionProperty, hash_cols_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PartitionProperty, need_cast_string_cols_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PartitionProperty, need_project_hash_cols_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PartitionProperty, need_project_hash_exprs_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeDestination, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeDestination, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeDestination, fragment_instance_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeDestination, node_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeDestination, address_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeSenderNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeSenderNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeSenderNode, log_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeSenderNode, fragment_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeSenderNode, receiver_fragment_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeSenderNode, fragment_instance_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeSenderNode, node_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeSenderNode, receiver_destinations_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeSenderNode, fragment_addresses_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeSenderNode, partition_property_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeSenderNode, schema_),
  2,
  3,
  4,
  5,
  6,
  ~0u,
  ~0u,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeReceiverNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeReceiverNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeReceiverNode, log_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeReceiverNode, fragment_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeReceiverNode, sender_fragment_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeReceiverNode, fragment_instance_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeReceiverNode, node_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeReceiverNode, sender_destinations_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeReceiverNode, regions_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeReceiverNode, partition_property_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeReceiverNode, schema_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeReceiverNode, slot_order_exprs_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeReceiverNode, is_asc_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::ExchangeReceiverNode, is_null_first_),
  2,
  3,
  4,
  5,
  6,
  ~0u,
  ~0u,
  1,
  0,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FrameBound, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FrameBound, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FrameBound, bound_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FrameBound, is_unbounded_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FrameBound, expr_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FrameExtent, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FrameExtent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FrameExtent, frame_start_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FrameExtent, frame_end_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::WindowFrame, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::WindowFrame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::WindowFrame, frame_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::WindowFrame, frame_extent_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::WindowSpec, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::WindowSpec, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::WindowSpec, partition_exprs_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::WindowSpec, order_exprs_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::WindowSpec, is_asc_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::WindowSpec, tuple_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::WindowSpec, window_frame_),
  ~0u,
  ~0u,
  ~0u,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::WindowNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::WindowNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::WindowNode, func_exprs_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::WindowNode, window_spec_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, scan_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, sort_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, agg_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, filter_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, join_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, insert_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, delete_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, update_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, fetcher_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, limit_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, packet_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, truncate_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, transaction_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, kill_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, lock_primary_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, lock_secondary_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, union_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, apply_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, load_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, raw_filter_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, exchange_sender_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, exchange_receiver_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, select_manager_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, dual_scan_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::DerivePlanNode, window_node_),
  1,
  2,
  3,
  0,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PlanNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PlanNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PlanNode, node_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PlanNode, num_children_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PlanNode, limit_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PlanNode, derive_node_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PlanNode, is_explain_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PlanNode, local_index_binlog_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PlanNode, partitions_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::PlanNode, is_get_keypoint_),
  6,
  2,
  1,
  0,
  3,
  4,
  ~0u,
  5,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::Plan, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::Plan, nodes_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LocalTraceNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LocalTraceNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LocalTraceNode, time_cost_us_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LocalTraceNode, sort_time_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LocalTraceNode, affect_rows_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LocalTraceNode, scan_rows_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LocalTraceNode, index_filter_rows_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LocalTraceNode, get_primary_rows_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LocalTraceNode, description_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LocalTraceNode, where_filter_rows_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LocalTraceNode, index_name_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LocalTraceNode, arrow_plan_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::LocalTraceNode, mpp_property_),
  3,
  4,
  5,
  6,
  7,
  8,
  0,
  9,
  1,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, node_type_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, description_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, instance_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, region_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, total_time_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, affect_rows_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, open_trace_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, get_next_trace_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, txn_get_trace_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, txn_put_trace_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, txn_delete_trace_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, txn_commit_trace_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, store_agg_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, child_nodes_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::TraceNode, partition_id_),
  13,
  0,
  1,
  9,
  10,
  11,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  ~0u,
  12,
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FragmentInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FragmentInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FragmentInfo, fragment_id_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FragmentInfo, plan_),
  PROTOBUF_FIELD_OFFSET(::baikaldb::pb::FragmentInfo, runtime_state_),
  2,
  0,
  1,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, -1, sizeof(::baikaldb::pb::SelectManagerNode)},
  { 16, 38, -1, sizeof(::baikaldb::pb::PossibleIndex_Range)},
  { 54, 62, -1, sizeof(::baikaldb::pb::PossibleIndex_SortIndex)},
  { 64, 84, -1, sizeof(::baikaldb::pb::PossibleIndex)},
  { 98, 107, -1, sizeof(::baikaldb::pb::FulltextIndex)},
  { 110, 133, -1, sizeof(::baikaldb::pb::ScanNode)},
  { 150, 159, -1, sizeof(::baikaldb::pb::LimitNode)},
  { 162, 173, -1, sizeof(::baikaldb::pb::SortNode)},
  { 178, 189, -1, sizeof(::baikaldb::pb::AggNode)},
  { 194, -1, -1, sizeof(::baikaldb::pb::FilterNode)},
  { 202, 216, -1, sizeof(::baikaldb::pb::DualScanNode)},
  { 224, 238, -1, sizeof(::baikaldb::pb::JoinNode)},
  { 246, 261, -1, sizeof(::baikaldb::pb::ApplyNode)},
  { 270, 280, -1, sizeof(::baikaldb::pb::FetcherNode)},
  { 284, 305, -1, sizeof(::baikaldb::pb::InsertNode)},
  { 320, 334, -1, sizeof(::baikaldb::pb::LockPrimaryNode)},
  { 342, 356, -1, sizeof(::baikaldb::pb::LockSecondaryNode)},
  { 364, 372, -1, sizeof(::baikaldb::pb::DeleteNode)},
  { 374, 381, -1, sizeof(::baikaldb::pb::TruncateNode)},
  { 382, 393, -1, sizeof(::baikaldb::pb::UpdateNode)},
  { 398, 407, -1, sizeof(::baikaldb::pb::PacketNode)},
  { 410, 419, -1, sizeof(::baikaldb::pb::TransactionNode)},
  { 422, 430, -1, sizeof(::baikaldb::pb::KillNode)},
  { 432, 442, -1, sizeof(::baikaldb::pb::UnionNode)},
  { 446, 468, -1, sizeof(::baikaldb::pb::LoadNode)},
  { 484, 495, -1, sizeof(::baikaldb::pb::PartitionProperty)},
  { 500, 509, -1, sizeof(::baikaldb::pb::ExchangeDestination)},
  { 512, 527, -1, sizeof(::baikaldb::pb::ExchangeSenderNode)},
  { 536, 554, -1, sizeof(::baikaldb::pb::ExchangeReceiverNode)},
  { 566, 575, -1, sizeof(::baikaldb::pb::FrameBound)},
  { 578, 586, -1, sizeof(::baikaldb::pb::FrameExtent)},
  { 588, 596, -1, sizeof(::baikaldb::pb::WindowFrame)},
  { 598, 609, -1, sizeof(::baikaldb::pb::WindowSpec)},
  { 614, 622, -1, sizeof(::baikaldb::pb::WindowNode)},
  { 624, 655, -1, sizeof(::baikaldb::pb::DerivePlanNode)},
  { 680, 694, -1, sizeof(::baikaldb::pb::PlanNode)},
  { 702, -1, -1, sizeof(::baikaldb::pb::Plan)},
  { 709, 726, -1, sizeof(::baikaldb::pb::LocalTraceNode)},
  { 737, 758, -1, sizeof(::baikaldb::pb::TraceNode)},
  { 773, 782, -1, sizeof(::baikaldb::pb::FragmentInfo)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_SelectManagerNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_PossibleIndex_Range_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_PossibleIndex_SortIndex_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_PossibleIndex_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_FulltextIndex_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_ScanNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_LimitNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_SortNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_AggNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_FilterNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_DualScanNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_JoinNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_ApplyNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_FetcherNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_InsertNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_LockPrimaryNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_LockSecondaryNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_DeleteNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_TruncateNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_UpdateNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_PacketNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_TransactionNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_KillNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_UnionNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_LoadNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_PartitionProperty_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_ExchangeDestination_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_ExchangeSenderNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_ExchangeReceiverNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_FrameBound_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_FrameExtent_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_WindowFrame_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_WindowSpec_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_WindowNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_DerivePlanNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_PlanNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_Plan_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_LocalTraceNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_TraceNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::baikaldb::pb::_FragmentInfo_default_instance_),
};

const char descriptor_table_protodef_plan_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\nplan.proto\022\013baikaldb.pb\032\014common.proto\032"
  "\014optype.proto\032\nexpr.proto\032\024meta.interfac"
  "e.proto\"\220\001\n\021SelectManagerNode\022\016\n\006schema\030"
  "\001 \001(\014\022+\n\020slot_order_exprs\030\002 \003(\0132\021.baikal"
  "db.pb.Expr\022\016\n\006is_asc\030\003 \003(\010\022\025\n\ris_null_fi"
  "rst\030\004 \003(\010\022\027\n\017is_return_empty\030\005 \001(\010\"\265\006\n\rP"
  "ossibleIndex\022\020\n\010index_id\030\001 \002(\003\0220\n\006ranges"
  "\030\002 \003(\0132 .baikaldb.pb.PossibleIndex.Range"
  "\022*\n\017index_conjuncts\030\003 \003(\0132\021.baikaldb.pb."
  "Expr\0228\n\nsort_index\030\004 \001(\0132$.baikaldb.pb.P"
  "ossibleIndex.SortIndex\022\020\n\010bool_and\030\005 \001(\010"
  "\022\031\n\021is_covering_index\030\006 \001(\010\022\027\n\017use_for_l"
  "earner\030\007 \001(\010\022\030\n\020range_key_sorted\030\010 \001(\010\022\r"
  "\n\005is_eq\030\t \001(\010\022\026\n\016left_field_cnt\030\n \001(\005\022\027\n"
  "\017right_field_cnt\030\013 \001(\005\022\021\n\tleft_open\030\014 \001("
  "\010\022\022\n\nright_open\030\r \001(\010\022\023\n\013like_prefix\030\016 \001"
  "(\010\032\354\002\n\005Range\022\026\n\016left_pb_record\030\003 \001(\014\022\027\n\017"
  "right_pb_record\030\004 \001(\014\022\026\n\016left_field_cnt\030"
  "\005 \001(\005\022\027\n\017right_field_cnt\030\006 \001(\005\022\021\n\tleft_o"
  "pen\030\007 \001(\010\022\022\n\nright_open\030\010 \001(\010\022\023\n\013like_pr"
  "efix\030\t \001(\010\022*\n\nmatch_mode\030\n \001(\0162\026.baikald"
  "b.pb.MatchMode\022\020\n\010left_key\030\013 \001(\014\022\021\n\trigh"
  "t_key\030\014 \001(\014\022\021\n\tleft_full\030\r \001(\010\022\022\n\nright_"
  "full\030\016 \001(\010\022\025\n\rpartition_ids\030\017 \003(\005\022\014\n\004top"
  "k\030\020 \001(\005\022\026\n\016separate_value\030\021 \001(\004\022\020\n\010efsea"
  "rch\030\022 \001(\005\032/\n\tSortIndex\022\016\n\006is_asc\030\001 \001(\010\022\022"
  "\n\nsort_limit\030\002 \001(\003\"\273\001\n\rFulltextIndex\0229\n\022"
  "fulltext_node_type\030\001 \001(\0162\035.baikaldb.pb.F"
  "ulltextNodeType\0222\n\016possible_index\030\002 \001(\0132"
  "\032.baikaldb.pb.PossibleIndex\022;\n\027nested_fu"
  "lltext_indexes\030\003 \003(\0132\032.baikaldb.pb.Fullt"
  "extIndex\"\370\003\n\010ScanNode\022\020\n\010tuple_id\030\001 \002(\005\022"
  "\020\n\010table_id\030\002 \002(\003\022\017\n\007indexes\030\003 \003(\014\022\023\n\013us"
  "e_indexes\030\004 \003(\003\022#\n\006engine\030\005 \001(\0162\023.baikal"
  "db.pb.Engine\022\026\n\016ignore_indexes\030\006 \003(\003\0222\n\016"
  "fulltext_index\030\007 \001(\0132\032.baikaldb.pb.Fullt"
  "extIndex\022&\n\004lock\030\010 \001(\0162\030.baikaldb.pb.Loc"
  "kCmdType\022\023\n\013is_ddl_work\030\t \001(\010\022\024\n\014ddl_ind"
  "ex_id\030\n \001(\003\022\025\n\rforce_indexes\030\013 \003(\003\022\025\n\rle"
  "arner_index\030\014 \001(\014\022+\n\rddl_work_type\030\r \001(\016"
  "2\024.baikaldb.pb.DDLType\0223\n\017column_ddl_inf"
  "o\030\016 \001(\0132\032.baikaldb.pb.ColumnDdlInfo\022\032\n\022w"
  "att_stats_version\030\017 \001(\004\022\026\n\016union_tuple_i"
  "d\030\020 \001(\005\022\032\n\022use_column_storage\030\021 \001(\010\"j\n\tL"
  "imitNode\022\016\n\006offset\030\001 \001(\003\022&\n\013offset_expr\030"
  "\002 \001(\0132\021.baikaldb.pb.Expr\022%\n\ncount_expr\030\003"
  " \001(\0132\021.baikaldb.pb.Expr\"\230\001\n\010SortNode\022&\n\013"
  "order_exprs\030\001 \003(\0132\021.baikaldb.pb.Expr\022\016\n\006"
  "is_asc\030\002 \003(\010\022\025\n\ris_null_first\030\003 \003(\010\022\020\n\010t"
  "uple_id\030\005 \001(\005\022+\n\020slot_order_exprs\030\006 \003(\0132"
  "\021.baikaldb.pb.Expr\"\241\001\n\007AggNode\022&\n\013group_"
  "exprs\030\001 \003(\0132\021.baikaldb.pb.Expr\022$\n\tagg_fu"
  "ncs\030\002 \003(\0132\021.baikaldb.pb.Expr\022\024\n\014agg_tupl"
  "e_id\030\003 \001(\005\022\035\n\025arrow_ignore_tuple_id\030\004 \001("
  "\005\022\023\n\013is_pushdown\030\005 \001(\010\"`\n\nFilterNode\022$\n\t"
  "conjuncts\030\001 \003(\0132\021.baikaldb.pb.Expr\022,\n\021co"
  "njuncts_learner\030\002 \003(\0132\021.baikaldb.pb.Expr"
  "\"\332\002\n\014DualScanNode\022)\n\016sub_query_node\030\001 \001("
  "\0132\021.baikaldb.pb.Plan\0224\n\031derived_table_pr"
  "ojections\030\002 \003(\0132\021.baikaldb.pb.Expr\0220\n\rru"
  "ntime_state\030\003 \001(\0132\031.baikaldb.pb.RuntimeS"
  "tate\022,\n\013slot_column\030\004 \003(\0132\027.baikaldb.pb."
  "SlotColumn\0223\n+derived_table_projections_"
  "agg_or_window_vec\030\005 \003(\010\022\031\n\021agg_tuple_id_"
  "pair\030\006 \003(\005\022\024\n\014agg_slot_ids\030\007 \003(\005\022#\n\033mult"
  "i_distinct_agg_slot_ids\030\010 \003(\005\"\351\001\n\010JoinNo"
  "de\022(\n\tjoin_type\030\001 \002(\0162\025.baikaldb.pb.Join"
  "Type\022%\n\nconditions\030\002 \003(\0132\021.baikaldb.pb.E"
  "xpr\022\022\n\nusing_clos\030\003 \003(\t\022\026\n\016left_tuple_id"
  "s\030\004 \003(\005\022\026\n\016left_table_ids\030\005 \003(\003\022\027\n\017right"
  "_tuple_ids\030\006 \003(\005\022\027\n\017right_table_ids\030\007 \003("
  "\003\022\026\n\016use_index_join\030\010 \001(\010\"\234\002\n\tApplyNode\022"
  "(\n\tjoin_type\030\001 \002(\0162\025.baikaldb.pb.JoinTyp"
  "e\022%\n\nconditions\030\002 \003(\0132\021.baikaldb.pb.Expr"
  "\022\026\n\016left_tuple_ids\030\004 \003(\005\022\026\n\016left_table_i"
  "ds\030\005 \003(\003\022\027\n\017right_tuple_ids\030\006 \003(\005\022\027\n\017rig"
  "ht_table_ids\030\007 \003(\003\022\023\n\013max_one_row\030\010 \001(\010\022"
  ".\n\014compare_type\030\t \001(\0162\030.baikaldb.pb.Comp"
  "areType\022\027\n\017is_select_field\030\n \001(\010\"\207\001\n\013Fet"
  "cherNode\022$\n\007op_type\030\001 \002(\0162\023.baikaldb.pb."
  "OpType\022+\n\020slot_order_exprs\030\003 \003(\0132\021.baika"
  "ldb.pb.Expr\022\016\n\006is_asc\030\004 \003(\010\022\025\n\ris_null_f"
  "irst\030\005 \003(\010\"\222\003\n\nInsertNode\022\020\n\010table_id\030\001 "
  "\002(\003\022\017\n\007records\030\002 \003(\014\022\023\n\013need_ignore\030\003 \001("
  "\010\0221\n\014update_slots\030\004 \003(\0132\033.baikaldb.pb.Sl"
  "otDescriptor\022\'\n\014update_exprs\030\005 \003(\0132\021.bai"
  "kaldb.pb.Expr\022\020\n\010tuple_id\030\006 \001(\005\022\027\n\017value"
  "s_tuple_id\030\007 \001(\005\022\022\n\nis_replace\030\010 \001(\010\022\021\n\t"
  "field_ids\030\t \003(\005\022(\n\rinsert_values\030\n \003(\0132\021"
  ".baikaldb.pb.Expr\022\030\n\020row_ttl_duration\030\013 "
  "\001(\003\022\026\n\016ddl_need_write\030\014 \001(\010\022\024\n\014ddl_index"
  "_id\030\r \001(\003\022\020\n\010is_merge\030\016 \001(\010\022\032\n\022watt_stat"
  "s_version\030\017 \001(\004\"\367\001\n\017LockPrimaryNode\022\020\n\010t"
  "able_id\030\001 \002(\003\022+\n\tlock_type\030\002 \002(\0162\030.baika"
  "ldb.pb.LockCmdType\022\023\n\013put_records\030\003 \003(\014\022"
  "\026\n\016delete_records\030\004 \003(\014\022\034\n\016affect_primar"
  "y\030\005 \001(\010:\004true\022\030\n\020affect_index_ids\030\006 \003(\003\022"
  "\032\n\022row_ttl_duration_s\030\007 \001(\003\022$\n\tconjuncts"
  "\030\010 \003(\0132\021.baikaldb.pb.Expr\"\226\002\n\021LockSecond"
  "aryNode\022\020\n\010table_id\030\001 \002(\003\022\027\n\017global_inde"
  "x_id\030\002 \002(\003\022+\n\tlock_type\030\003 \002(\0162\030.baikaldb"
  ".pb.LockCmdType\022\023\n\013put_records\030\004 \003(\014\022\026\n\016"
  "delete_records\030\005 \003(\014\022;\n\023lock_secondary_t"
  "ype\030\006 \001(\0162\036.baikaldb.pb.LockSecondaryTyp"
  "e\022\032\n\022row_ttl_duration_s\030\007 \001(\003\022#\n\033global_"
  "ddl_ttl_timestamp_us\030\010 \003(\003\"R\n\nDeleteNode"
  "\022\020\n\010table_id\030\001 \002(\003\0222\n\rprimary_slots\030\002 \003("
  "\0132\033.baikaldb.pb.SlotDescriptor\" \n\014Trunca"
  "teNode\022\020\n\010table_id\030\001 \002(\003\"\310\001\n\nUpdateNode\022"
  "\020\n\010table_id\030\001 \002(\003\0222\n\rprimary_slots\030\002 \003(\013"
  "2\033.baikaldb.pb.SlotDescriptor\0221\n\014update_"
  "slots\030\003 \003(\0132\033.baikaldb.pb.SlotDescriptor"
  "\022\'\n\014update_exprs\030\004 \003(\0132\021.baikaldb.pb.Exp"
  "r\022\030\n\020row_ttl_duration\030\006 \001(\003\"m\n\nPacketNod"
  "e\022$\n\007op_type\030\001 \002(\0162\023.baikaldb.pb.OpType\022"
  "&\n\013projections\030\002 \003(\0132\021.baikaldb.pb.Expr\022"
  "\021\n\tcol_names\030\003 \003(\t\"j\n\017TransactionNode\022(\n"
  "\007txn_cmd\030\001 \002(\0162\027.baikaldb.pb.TxnCmdType\022"
  "\023\n\013txn_timeout\030\002 \001(\003\022\030\n\020txn_lock_timeout"
  "\030\003 \001(\003\"0\n\010KillNode\022\022\n\ndb_conn_id\030\001 \002(\004\022\020"
  "\n\010is_query\030\002 \001(\010\"w\n\tUnionNode\022\026\n\016union_t"
  "uple_id\030\001 \001(\005\022+\n\020slot_order_exprs\030\002 \003(\0132"
  "\021.baikaldb.pb.Expr\022\016\n\006is_asc\030\003 \003(\010\022\025\n\ris"
  "_null_first\030\004 \003(\010\"\237\003\n\010LoadNode\022\020\n\010table_"
  "id\030\001 \002(\003\022\021\n\tdata_path\030\003 \001(\t\022.\n\tset_slots"
  "\030\004 \003(\0132\033.baikaldb.pb.SlotDescriptor\022$\n\ts"
  "et_exprs\030\005 \003(\0132\021.baikaldb.pb.Expr\022\021\n\tfie"
  "ld_ids\030\006 \003(\005\022\031\n\021default_field_ids\030\007 \003(\005\022"
  "\034\n\024ingore_field_indexes\030\010 \003(\005\022\024\n\014ignore_"
  "lines\030\t \001(\005\022\022\n\nterminated\030\n \001(\014\022\020\n\010enclo"
  "sed\030\013 \001(\014\022\017\n\007escaped\030\014 \001(\014\022\025\n\rline_start"
  "ing\030\r \001(\014\022\027\n\017line_terminated\030\016 \001(\014\022\024\n\014op"
  "t_enclosed\030\017 \001(\010\022\021\n\tfile_size\030\020 \001(\003\022&\n\010c"
  "har_set\030\021 \001(\0162\024.baikaldb.pb.Charset\"\313\001\n\021"
  "PartitionProperty\0220\n\004type\030\001 \002(\0162\".baikal"
  "db.pb.PartitionPropertyType\022\021\n\thash_cols"
  "\030\002 \003(\014\022\035\n\025need_cast_string_cols\030\003 \003(\014\022\036\n"
  "\026need_project_hash_cols\030\004 \003(\014\0222\n\027need_pr"
  "oject_hash_exprs\030\005 \003(\0132\021.baikaldb.pb.Exp"
  "r\"U\n\023ExchangeDestination\022\034\n\024fragment_ins"
  "tance_id\030\001 \002(\004\022\017\n\007node_id\030\002 \002(\005\022\017\n\007addre"
  "ss\030\003 \001(\014\"\321\002\n\022ExchangeSenderNode\022\016\n\006log_i"
  "d\030\001 \002(\004\022\023\n\013fragment_id\030\002 \002(\005\022\034\n\024receiver"
  "_fragment_id\030\003 \002(\005\022\034\n\024fragment_instance_"
  "id\030\004 \002(\004\022\017\n\007node_id\030\005 \002(\005\022\?\n\025receiver_de"
  "stinations\030\006 \003(\0132 .baikaldb.pb.ExchangeD"
  "estination\022<\n\022fragment_addresses\030\007 \003(\0132 "
  ".baikaldb.pb.ExchangeDestination\022:\n\022part"
  "ition_property\030\010 \001(\0132\036.baikaldb.pb.Parti"
  "tionProperty\022\016\n\006schema\030\t \001(\014\"\217\003\n\024Exchang"
  "eReceiverNode\022\016\n\006log_id\030\001 \002(\004\022\023\n\013fragmen"
  "t_id\030\002 \002(\005\022\032\n\022sender_fragment_id\030\003 \002(\005\022\034"
  "\n\024fragment_instance_id\030\004 \002(\004\022\017\n\007node_id\030"
  "\005 \002(\005\022=\n\023sender_destinations\030\006 \003(\0132 .bai"
  "kaldb.pb.ExchangeDestination\022(\n\007regions\030"
  "\007 \003(\0132\027.baikaldb.pb.RegionInfo\022:\n\022partit"
  "ion_property\030\010 \001(\0132\036.baikaldb.pb.Partiti"
  "onProperty\022\016\n\006schema\030\t \002(\014\022+\n\020slot_order"
  "_exprs\030\n \003(\0132\021.baikaldb.pb.Expr\022\016\n\006is_as"
  "c\030\013 \003(\010\022\025\n\ris_null_first\030\014 \003(\010\"o\n\nFrameB"
  "ound\022*\n\nbound_type\030\001 \001(\0162\026.baikaldb.pb.B"
  "oundType\022\024\n\014is_unbounded\030\002 \001(\010\022\037\n\004expr\030\003"
  " \001(\0132\021.baikaldb.pb.Expr\"g\n\013FrameExtent\022,"
  "\n\013frame_start\030\001 \001(\0132\027.baikaldb.pb.FrameB"
  "ound\022*\n\tframe_end\030\002 \001(\0132\027.baikaldb.pb.Fr"
  "ameBound\"i\n\013WindowFrame\022*\n\nframe_type\030\001 "
  "\001(\0162\026.baikaldb.pb.FrameType\022.\n\014frame_ext"
  "ent\030\002 \001(\0132\030.baikaldb.pb.FrameExtent\"\262\001\n\n"
  "WindowSpec\022*\n\017partition_exprs\030\001 \003(\0132\021.ba"
  "ikaldb.pb.Expr\022&\n\013order_exprs\030\002 \003(\0132\021.ba"
  "ikaldb.pb.Expr\022\016\n\006is_asc\030\003 \003(\010\022\020\n\010tuple_"
  "id\030\004 \001(\005\022.\n\014window_frame\030\005 \001(\0132\030.baikald"
  "b.pb.WindowFrame\"a\n\nWindowNode\022%\n\nfunc_e"
  "xprs\030\001 \003(\0132\021.baikaldb.pb.Expr\022,\n\013window_"
  "spec\030\002 \001(\0132\027.baikaldb.pb.WindowSpec\"\275\t\n\016"
  "DerivePlanNode\022(\n\tscan_node\030\001 \001(\0132\025.baik"
  "aldb.pb.ScanNode\022(\n\tsort_node\030\002 \001(\0132\025.ba"
  "ikaldb.pb.SortNode\022&\n\010agg_node\030\003 \001(\0132\024.b"
  "aikaldb.pb.AggNode\022\023\n\013filter_node\030\004 \001(\014\022"
  "(\n\tjoin_node\030\005 \001(\0132\025.baikaldb.pb.JoinNod"
  "e\022,\n\013insert_node\030\006 \001(\0132\027.baikaldb.pb.Ins"
  "ertNode\022,\n\013delete_node\030\007 \001(\0132\027.baikaldb."
  "pb.DeleteNode\022,\n\013update_node\030\010 \001(\0132\027.bai"
  "kaldb.pb.UpdateNode\022.\n\014fetcher_node\030\t \001("
  "\0132\030.baikaldb.pb.FetcherNode\022*\n\nlimit_nod"
  "e\030\n \001(\0132\026.baikaldb.pb.LimitNode\022,\n\013packe"
  "t_node\030\013 \001(\0132\027.baikaldb.pb.PacketNode\0220\n"
  "\rtruncate_node\030\014 \001(\0132\031.baikaldb.pb.Trunc"
  "ateNode\0226\n\020transaction_node\030\r \001(\0132\034.baik"
  "aldb.pb.TransactionNode\022(\n\tkill_node\030\016 \001"
  "(\0132\025.baikaldb.pb.KillNode\0227\n\021lock_primar"
  "y_node\030\017 \001(\0132\034.baikaldb.pb.LockPrimaryNo"
  "de\022;\n\023lock_secondary_node\030\020 \001(\0132\036.baikal"
  "db.pb.LockSecondaryNode\022*\n\nunion_node\030\021 "
  "\001(\0132\026.baikaldb.pb.UnionNode\022*\n\napply_nod"
  "e\030\022 \001(\0132\026.baikaldb.pb.ApplyNode\022(\n\tload_"
  "node\030\023 \001(\0132\025.baikaldb.pb.LoadNode\0220\n\017raw"
  "_filter_node\030\024 \001(\0132\027.baikaldb.pb.FilterN"
  "ode\022=\n\024exchange_sender_node\030\025 \001(\0132\037.baik"
  "aldb.pb.ExchangeSenderNode\022A\n\026exchange_r"
  "eceiver_node\030\026 \001(\0132!.baikaldb.pb.Exchang"
  "eReceiverNode\022;\n\023select_manager_node\030\027 \001"
  "(\0132\036.baikaldb.pb.SelectManagerNode\0221\n\016du"
  "al_scan_node\030\030 \001(\0132\031.baikaldb.pb.DualSca"
  "nNode\022,\n\013window_node\030\031 \001(\0132\027.baikaldb.pb"
  ".WindowNode\"\354\001\n\010PlanNode\022,\n\tnode_type\030\002 "
  "\002(\0162\031.baikaldb.pb.PlanNodeType\022\024\n\014num_ch"
  "ildren\030\003 \002(\005\022\r\n\005limit\030\005 \001(\003\0220\n\013derive_no"
  "de\030\006 \001(\0132\033.baikaldb.pb.DerivePlanNode\022\022\n"
  "\nis_explain\030\007 \001(\010\022\032\n\022local_index_binlog\030"
  "\010 \001(\010\022\022\n\npartitions\030\t \003(\003\022\027\n\017is_get_keyp"
  "oint\030\n \001(\010\",\n\004Plan\022$\n\005nodes\030\001 \003(\0132\025.baik"
  "aldb.pb.PlanNode\"\204\002\n\016LocalTraceNode\022\024\n\014t"
  "ime_cost_us\030\001 \001(\003\022\021\n\tsort_time\030\002 \001(\003\022\023\n\013"
  "affect_rows\030\003 \001(\003\022\021\n\tscan_rows\030\004 \001(\003\022\031\n\021"
  "index_filter_rows\030\005 \001(\003\022\030\n\020get_primary_r"
  "ows\030\006 \001(\003\022\023\n\013description\030\010 \001(\t\022\031\n\021where_"
  "filter_rows\030\t \001(\003\022\022\n\nindex_name\030\n \001(\t\022\022\n"
  "\narrow_plan\030\013 \003(\t\022\024\n\014mpp_property\030\014 \001(\t\""
  "\313\004\n\tTraceNode\022,\n\tnode_type\030\001 \001(\0162\031.baika"
  "ldb.pb.PlanNodeType\022\023\n\013description\030\002 \001(\t"
  "\022\020\n\010instance\030\003 \001(\t\022\021\n\tregion_id\030\004 \001(\003\022\022\n"
  "\ntotal_time\030\005 \001(\003\022\023\n\013affect_rows\030\006 \001(\003\022/"
  "\n\nopen_trace\030\007 \001(\0132\033.baikaldb.pb.LocalTr"
  "aceNode\0223\n\016get_next_trace\030\010 \001(\0132\033.baikal"
  "db.pb.LocalTraceNode\0222\n\rtxn_get_trace\030\t "
  "\001(\0132\033.baikaldb.pb.LocalTraceNode\0222\n\rtxn_"
  "put_trace\030\n \001(\0132\033.baikaldb.pb.LocalTrace"
  "Node\0225\n\020txn_delete_trace\030\013 \001(\0132\033.baikald"
  "b.pb.LocalTraceNode\0225\n\020txn_commit_trace\030"
  "\014 \001(\0132\033.baikaldb.pb.LocalTraceNode\022.\n\tst"
  "ore_agg\030\r \001(\0132\033.baikaldb.pb.LocalTraceNo"
  "de\022+\n\013child_nodes\030\016 \003(\0132\026.baikaldb.pb.Tr"
  "aceNode\022\024\n\014partition_id\030\017 \001(\003\"v\n\014Fragmen"
  "tInfo\022\023\n\013fragment_id\030\001 \002(\005\022\037\n\004plan\030\002 \002(\013"
  "2\021.baikaldb.pb.Plan\0220\n\rruntime_state\030\003 \001"
  "(\0132\031.baikaldb.pb.RuntimeState*\354\006\n\014PlanNo"
  "deType\022\r\n\tSCAN_NODE\020\001\022\r\n\tSORT_NODE\020\002\022\014\n\010"
  "AGG_NODE\020\004\022\022\n\016MERGE_AGG_NODE\020\005\022\025\n\021TABLE_"
  "FILTER_NODE\020\006\022\r\n\tJOIN_NODE\020\007\022\020\n\014FETCHER_"
  "NODE\020\010\022\017\n\013INSERT_NODE\020\t\022\017\n\013DELETE_NODE\020\n"
  "\022\016\n\nLIMIT_NODE\020\013\022\025\n\021WHERE_FILTER_NODE\020\014\022"
  "\026\n\022HAVING_FILTER_NODE\020\r\022\017\n\013PACKET_NODE\020\016"
  "\022\017\n\013UPDATE_NODE\020\017\022\021\n\rTRUNCATE_NODE\020\021\022\024\n\020"
  "TRANSACTION_NODE\020\022\022\r\n\tKILL_NODE\020\023\022\026\n\022BEG"
  "IN_MANAGER_NODE\020\024\022\027\n\023COMMIT_MANAGER_NODE"
  "\020\025\022\031\n\025ROLLBACK_MANAGER_NODE\020\026\022\035\n\031TXN_ROL"
  "LBACK_MANAGER_NODE\020\027\022\033\n\027SIGNEL_TXN_MANAG"
  "ER_NODE\020\030\022\027\n\023SELECT_MANAGER_NODE\020\031\022\027\n\023IN"
  "SERT_MANAGER_NODE\020\032\022\027\n\023UPDATE_MANAGER_NO"
  "DE\020\033\022\027\n\023DELETE_MANAGER_NODE\020\034\022\031\n\025TRUNCAT"
  "E_MANAGER_NODE\020\035\022\025\n\021KILL_MANAGER_NODE\020\036\022"
  "\025\n\021LOCK_PRIMARY_NODE\020\037\022\027\n\023LOCK_SECONDARY"
  "_NODE\020 \022\024\n\020FULL_EXPORT_NODE\020!\022\022\n\016DUAL_SC"
  "AN_NODE\020\"\022\016\n\nUNION_NODE\020#\022\032\n\026INDEX_DDL_M"
  "ANAGER_NODE\020$\022\016\n\nAPPLY_NODE\020%\022\r\n\tLOAD_NO"
  "DE\020&\022\037\n\033BASE_SUBSCRIBE_MANAGER_NODE\020\'\022\030\n"
  "\024EXCHANGE_SENDER_NODE\020(\022\032\n\026EXCHANGE_RECE"
  "IVER_NODE\020)\022\017\n\013WINDOW_NODE\020**\320\001\n\nTxnCmdT"
  "ype\022\017\n\013TXN_INVALID\020\000\022\r\n\tTXN_BEGIN\020\001\022\023\n\017T"
  "XN_BEGIN_STORE\020\002\022\016\n\nTXN_COMMIT\020\003\022\024\n\020TXN_"
  "COMMIT_STORE\020\004\022\024\n\020TXN_COMMIT_BEGIN\020\005\022\020\n\014"
  "TXN_ROLLBACK\020\006\022\026\n\022TXN_ROLLBACK_STORE\020\007\022\026"
  "\n\022TXN_ROLLBACK_BEGIN\020\010\022\017\n\013TXN_PREPARE\020\t*"
  "\242\001\n\013LockCmdType\022\020\n\014LOCK_INVALID\020\000\022\014\n\010LOC"
  "K_GET\020\001\022\031\n\025LOCK_GET_ONLY_PRIMARY\020\002\022\014\n\010LO"
  "CK_DML\020\003\022\020\n\014LOCK_GET_DML\020\004\022\013\n\007LOCK_NO\020\005\022"
  "\023\n\017LOCK_GLOBAL_DDL\020\006\022\026\n\022LOCK_NO_GLOBAL_D"
  "DL\020\007*>\n\tMatchMode\022\n\n\006M_NONE\020\000\022\026\n\022M_NARUT"
  "AL_LANGUAGE\020\001\022\r\n\tM_BOOLEAN\020\002*9\n\020Fulltext"
  "NodeType\022\n\n\006FNT_OR\020\001\022\013\n\007FNT_AND\020\002\022\014\n\010FNT"
  "_TERM\020\003*R\n\007DDLType\022\014\n\010DDL_NONE\020\000\022\023\n\017DDL_"
  "LOCAL_INDEX\020\001\022\024\n\020DDL_GLOBAL_INDEX\020\002\022\016\n\nD"
  "DL_COLUMN\020\003*z\n\010JoinType\022\r\n\tNULL_JOIN\020\000\022\r"
  "\n\tLEFT_JOIN\020\001\022\016\n\nRIGHT_JOIN\020\002\022\016\n\nINNER_J"
  "OIN\020\003\022\r\n\tSEMI_JOIN\020\004\022\022\n\016ANTI_SEMI_JOIN\020\005"
  "\022\r\n\tFULL_JOIN\020\006*C\n\013CompareType\022\014\n\010CMP_NU"
  "LL\020\000\022\013\n\007CMP_ANY\020\001\022\013\n\007CMP_ALL\020\002\022\014\n\010CMP_SO"
  "ME\020\003*7\n\021LockSecondaryType\022\016\n\nLST_COMMON\020"
  "\000\022\022\n\016LST_GLOBAL_DDL\020\001*\211\001\n\025PartitionPrope"
  "rtyType\022\013\n\007AnyType\020\001\022\027\n\023SinglePartitionT"
  "ype\020\002\022\025\n\021HashPartitionType\020\003\022\032\n\026Broadcas"
  "tPartitionType\020\004\022\027\n\023RandomPartitionType\020"
  "\005*&\n\tFrameType\022\013\n\007FT_ROWS\020\000\022\014\n\010FT_RANGE\020"
  "\001*C\n\tBoundType\022\020\n\014BT_PRECEDING\020\000\022\020\n\014BT_F"
  "OLLOWING\020\001\022\022\n\016BT_CURRENT_ROW\020\002"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_plan_2eproto_deps[4] = {
  &::descriptor_table_common_2eproto,
  &::descriptor_table_expr_2eproto,
  &::descriptor_table_meta_2einterface_2eproto,
  &::descriptor_table_optype_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_plan_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_plan_2eproto = {
  false, false, 11430, descriptor_table_protodef_plan_2eproto, "plan.proto", 
  &descriptor_table_plan_2eproto_once, descriptor_table_plan_2eproto_deps, 4, 40,
  schemas, file_default_instances, TableStruct_plan_2eproto::offsets,
  file_level_metadata_plan_2eproto, file_level_enum_descriptors_plan_2eproto, file_level_service_descriptors_plan_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_plan_2eproto_getter() {
  return &descriptor_table_plan_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_plan_2eproto(&descriptor_table_plan_2eproto);
namespace baikaldb {
namespace pb {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlanNodeType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_plan_2eproto);
  return file_level_enum_descriptors_plan_2eproto[0];
}
bool PlanNodeType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TxnCmdType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_plan_2eproto);
  return file_level_enum_descriptors_plan_2eproto[1];
}
bool TxnCmdType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LockCmdType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_plan_2eproto);
  return file_level_enum_descriptors_plan_2eproto[2];
}
bool LockCmdType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_plan_2eproto);
  return file_level_enum_descriptors_plan_2eproto[3];
}
bool MatchMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FulltextNodeType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_plan_2eproto);
  return file_level_enum_descriptors_plan_2eproto[4];
}
bool FulltextNodeType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DDLType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_plan_2eproto);
  return file_level_enum_descriptors_plan_2eproto[5];
}
bool DDLType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* JoinType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_plan_2eproto);
  return file_level_enum_descriptors_plan_2eproto[6];
}
bool JoinType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompareType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_plan_2eproto);
  return file_level_enum_descriptors_plan_2eproto[7];
}
bool CompareType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LockSecondaryType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_plan_2eproto);
  return file_level_enum_descriptors_plan_2eproto[8];
}
bool LockSecondaryType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PartitionPropertyType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_plan_2eproto);
  return file_level_enum_descriptors_plan_2eproto[9];
}
bool PartitionPropertyType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FrameType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_plan_2eproto);
  return file_level_enum_descriptors_plan_2eproto[10];
}
bool FrameType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BoundType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_plan_2eproto);
  return file_level_enum_descriptors_plan_2eproto[11];
}
bool BoundType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class SelectManagerNode::_Internal {
 public:
  using HasBits = decltype(std::declval<SelectManagerNode>()._has_bits_);
  static void set_has_schema(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_return_empty(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

void SelectManagerNode::clear_slot_order_exprs() {
  slot_order_exprs_.Clear();
}
SelectManagerNode::SelectManagerNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  slot_order_exprs_(arena),
  is_asc_(arena),
  is_null_first_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.SelectManagerNode)
}
SelectManagerNode::SelectManagerNode(const SelectManagerNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      slot_order_exprs_(from.slot_order_exprs_),
      is_asc_(from.is_asc_),
      is_null_first_(from.is_null_first_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  schema_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_schema()) {
    schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_schema(), 
      GetArenaForAllocation());
  }
  is_return_empty_ = from.is_return_empty_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.SelectManagerNode)
}

void SelectManagerNode::SharedCtor() {
schema_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
is_return_empty_ = false;
}

SelectManagerNode::~SelectManagerNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.SelectManagerNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SelectManagerNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  schema_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SelectManagerNode::ArenaDtor(void* object) {
  SelectManagerNode* _this = reinterpret_cast< SelectManagerNode* >(object);
  (void)_this;
}
void SelectManagerNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SelectManagerNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SelectManagerNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.SelectManagerNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  slot_order_exprs_.Clear();
  is_asc_.Clear();
  is_null_first_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    schema_.ClearNonDefaultToEmpty();
  }
  is_return_empty_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SelectManagerNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes schema = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_schema();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr slot_order_exprs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_slot_order_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bool is_asc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_is_asc(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_is_asc(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool is_null_first = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_is_null_first(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_is_null_first(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_return_empty = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_is_return_empty(&has_bits);
          is_return_empty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SelectManagerNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.SelectManagerNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes schema = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_schema(), target);
  }

  // repeated .baikaldb.pb.Expr slot_order_exprs = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_slot_order_exprs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_slot_order_exprs(i), target, stream);
  }

  // repeated bool is_asc = 3;
  for (int i = 0, n = this->_internal_is_asc_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_is_asc(i), target);
  }

  // repeated bool is_null_first = 4;
  for (int i = 0, n = this->_internal_is_null_first_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_null_first(i), target);
  }

  // optional bool is_return_empty = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_is_return_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.SelectManagerNode)
  return target;
}

size_t SelectManagerNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.SelectManagerNode)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr slot_order_exprs = 2;
  total_size += 1UL * this->_internal_slot_order_exprs_size();
  for (const auto& msg : this->slot_order_exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated bool is_asc = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_is_asc_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_is_asc_size());
    total_size += data_size;
  }

  // repeated bool is_null_first = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_is_null_first_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_is_null_first_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes schema = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_schema());
    }

    // optional bool is_return_empty = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SelectManagerNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SelectManagerNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SelectManagerNode::GetClassData() const { return &_class_data_; }

void SelectManagerNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SelectManagerNode *>(to)->MergeFrom(
      static_cast<const SelectManagerNode &>(from));
}


void SelectManagerNode::MergeFrom(const SelectManagerNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.SelectManagerNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  slot_order_exprs_.MergeFrom(from.slot_order_exprs_);
  is_asc_.MergeFrom(from.is_asc_);
  is_null_first_.MergeFrom(from.is_null_first_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_schema(from._internal_schema());
    }
    if (cached_has_bits & 0x00000002u) {
      is_return_empty_ = from.is_return_empty_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SelectManagerNode::CopyFrom(const SelectManagerNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.SelectManagerNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SelectManagerNode::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(slot_order_exprs_)) return false;
  return true;
}

void SelectManagerNode::InternalSwap(SelectManagerNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  slot_order_exprs_.InternalSwap(&other->slot_order_exprs_);
  is_asc_.InternalSwap(&other->is_asc_);
  is_null_first_.InternalSwap(&other->is_null_first_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &schema_, lhs_arena,
      &other->schema_, rhs_arena
  );
  swap(is_return_empty_, other->is_return_empty_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SelectManagerNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[0]);
}

// ===================================================================

class PossibleIndex_Range::_Internal {
 public:
  using HasBits = decltype(std::declval<PossibleIndex_Range>()._has_bits_);
  static void set_has_left_pb_record(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_right_pb_record(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_left_field_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_right_field_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_left_open(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_right_open(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_like_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_match_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_left_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_right_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_left_full(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_right_full(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_topk(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_separate_value(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_efsearch(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
};

PossibleIndex_Range::PossibleIndex_Range(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  partition_ids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.PossibleIndex.Range)
}
PossibleIndex_Range::PossibleIndex_Range(const PossibleIndex_Range& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      partition_ids_(from.partition_ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  left_pb_record_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_left_pb_record()) {
    left_pb_record_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_left_pb_record(), 
      GetArenaForAllocation());
  }
  right_pb_record_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_right_pb_record()) {
    right_pb_record_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_right_pb_record(), 
      GetArenaForAllocation());
  }
  left_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_left_key()) {
    left_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_left_key(), 
      GetArenaForAllocation());
  }
  right_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_right_key()) {
    right_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_right_key(), 
      GetArenaForAllocation());
  }
  ::memcpy(&left_field_cnt_, &from.left_field_cnt_,
    static_cast<size_t>(reinterpret_cast<char*>(&efsearch_) -
    reinterpret_cast<char*>(&left_field_cnt_)) + sizeof(efsearch_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.PossibleIndex.Range)
}

void PossibleIndex_Range::SharedCtor() {
left_pb_record_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
right_pb_record_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
left_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
right_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&left_field_cnt_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&efsearch_) -
    reinterpret_cast<char*>(&left_field_cnt_)) + sizeof(efsearch_));
}

PossibleIndex_Range::~PossibleIndex_Range() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.PossibleIndex.Range)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PossibleIndex_Range::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  left_pb_record_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  right_pb_record_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  left_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  right_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PossibleIndex_Range::ArenaDtor(void* object) {
  PossibleIndex_Range* _this = reinterpret_cast< PossibleIndex_Range* >(object);
  (void)_this;
}
void PossibleIndex_Range::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PossibleIndex_Range::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PossibleIndex_Range::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.PossibleIndex.Range)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  partition_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      left_pb_record_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      right_pb_record_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      left_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      right_key_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&left_field_cnt_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&right_open_) -
        reinterpret_cast<char*>(&left_field_cnt_)) + sizeof(right_open_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&like_prefix_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&efsearch_) -
        reinterpret_cast<char*>(&like_prefix_)) + sizeof(efsearch_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PossibleIndex_Range::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes left_pb_record = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_left_pb_record();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes right_pb_record = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_right_pb_record();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 left_field_cnt = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_left_field_cnt(&has_bits);
          left_field_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 right_field_cnt = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_right_field_cnt(&has_bits);
          right_field_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool left_open = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_left_open(&has_bits);
          left_open_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool right_open = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_right_open(&has_bits);
          right_open_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool like_prefix = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_like_prefix(&has_bits);
          like_prefix_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.MatchMode match_mode = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::MatchMode_IsValid(val))) {
            _internal_set_match_mode(static_cast<::baikaldb::pb::MatchMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes left_key = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          auto str = _internal_mutable_left_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes right_key = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          auto str = _internal_mutable_right_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool left_full = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_left_full(&has_bits);
          left_full_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool right_full = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_right_full(&has_bits);
          right_full_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 partition_ids = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_partition_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<120>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_partition_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 topk = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_topk(&has_bits);
          topk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 separate_value = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_separate_value(&has_bits);
          separate_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 efsearch = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          _Internal::set_has_efsearch(&has_bits);
          efsearch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PossibleIndex_Range::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.PossibleIndex.Range)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes left_pb_record = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_left_pb_record(), target);
  }

  // optional bytes right_pb_record = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_right_pb_record(), target);
  }

  // optional int32 left_field_cnt = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_left_field_cnt(), target);
  }

  // optional int32 right_field_cnt = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_right_field_cnt(), target);
  }

  // optional bool left_open = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_left_open(), target);
  }

  // optional bool right_open = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_right_open(), target);
  }

  // optional bool like_prefix = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_like_prefix(), target);
  }

  // optional .baikaldb.pb.MatchMode match_mode = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      10, this->_internal_match_mode(), target);
  }

  // optional bytes left_key = 11;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        11, this->_internal_left_key(), target);
  }

  // optional bytes right_key = 12;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        12, this->_internal_right_key(), target);
  }

  // optional bool left_full = 13;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_left_full(), target);
  }

  // optional bool right_full = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_right_full(), target);
  }

  // repeated int32 partition_ids = 15;
  for (int i = 0, n = this->_internal_partition_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(15, this->_internal_partition_ids(i), target);
  }

  // optional int32 topk = 16;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(16, this->_internal_topk(), target);
  }

  // optional uint64 separate_value = 17;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(17, this->_internal_separate_value(), target);
  }

  // optional int32 efsearch = 18;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(18, this->_internal_efsearch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.PossibleIndex.Range)
  return target;
}

size_t PossibleIndex_Range::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.PossibleIndex.Range)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 partition_ids = 15;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->partition_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_partition_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes left_pb_record = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_left_pb_record());
    }

    // optional bytes right_pb_record = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_right_pb_record());
    }

    // optional bytes left_key = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_left_key());
    }

    // optional bytes right_key = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_right_key());
    }

    // optional int32 left_field_cnt = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_left_field_cnt());
    }

    // optional int32 right_field_cnt = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_right_field_cnt());
    }

    // optional bool left_open = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool right_open = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional bool like_prefix = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool left_full = 13;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional .baikaldb.pb.MatchMode match_mode = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_match_mode());
    }

    // optional bool right_full = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional int32 topk = 16;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_topk());
    }

    // optional uint64 separate_value = 17;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_separate_value());
    }

    // optional int32 efsearch = 18;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_efsearch());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PossibleIndex_Range::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PossibleIndex_Range::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PossibleIndex_Range::GetClassData() const { return &_class_data_; }

void PossibleIndex_Range::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PossibleIndex_Range *>(to)->MergeFrom(
      static_cast<const PossibleIndex_Range &>(from));
}


void PossibleIndex_Range::MergeFrom(const PossibleIndex_Range& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.PossibleIndex.Range)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  partition_ids_.MergeFrom(from.partition_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_left_pb_record(from._internal_left_pb_record());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_right_pb_record(from._internal_right_pb_record());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_left_key(from._internal_left_key());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_right_key(from._internal_right_key());
    }
    if (cached_has_bits & 0x00000010u) {
      left_field_cnt_ = from.left_field_cnt_;
    }
    if (cached_has_bits & 0x00000020u) {
      right_field_cnt_ = from.right_field_cnt_;
    }
    if (cached_has_bits & 0x00000040u) {
      left_open_ = from.left_open_;
    }
    if (cached_has_bits & 0x00000080u) {
      right_open_ = from.right_open_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      like_prefix_ = from.like_prefix_;
    }
    if (cached_has_bits & 0x00000200u) {
      left_full_ = from.left_full_;
    }
    if (cached_has_bits & 0x00000400u) {
      match_mode_ = from.match_mode_;
    }
    if (cached_has_bits & 0x00000800u) {
      right_full_ = from.right_full_;
    }
    if (cached_has_bits & 0x00001000u) {
      topk_ = from.topk_;
    }
    if (cached_has_bits & 0x00002000u) {
      separate_value_ = from.separate_value_;
    }
    if (cached_has_bits & 0x00004000u) {
      efsearch_ = from.efsearch_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PossibleIndex_Range::CopyFrom(const PossibleIndex_Range& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.PossibleIndex.Range)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PossibleIndex_Range::IsInitialized() const {
  return true;
}

void PossibleIndex_Range::InternalSwap(PossibleIndex_Range* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  partition_ids_.InternalSwap(&other->partition_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &left_pb_record_, lhs_arena,
      &other->left_pb_record_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &right_pb_record_, lhs_arena,
      &other->right_pb_record_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &left_key_, lhs_arena,
      &other->left_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &right_key_, lhs_arena,
      &other->right_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PossibleIndex_Range, efsearch_)
      + sizeof(PossibleIndex_Range::efsearch_)
      - PROTOBUF_FIELD_OFFSET(PossibleIndex_Range, left_field_cnt_)>(
          reinterpret_cast<char*>(&left_field_cnt_),
          reinterpret_cast<char*>(&other->left_field_cnt_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PossibleIndex_Range::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[1]);
}

// ===================================================================

class PossibleIndex_SortIndex::_Internal {
 public:
  using HasBits = decltype(std::declval<PossibleIndex_SortIndex>()._has_bits_);
  static void set_has_is_asc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sort_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PossibleIndex_SortIndex::PossibleIndex_SortIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.PossibleIndex.SortIndex)
}
PossibleIndex_SortIndex::PossibleIndex_SortIndex(const PossibleIndex_SortIndex& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&sort_limit_, &from.sort_limit_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_asc_) -
    reinterpret_cast<char*>(&sort_limit_)) + sizeof(is_asc_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.PossibleIndex.SortIndex)
}

void PossibleIndex_SortIndex::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sort_limit_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_asc_) -
    reinterpret_cast<char*>(&sort_limit_)) + sizeof(is_asc_));
}

PossibleIndex_SortIndex::~PossibleIndex_SortIndex() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.PossibleIndex.SortIndex)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PossibleIndex_SortIndex::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PossibleIndex_SortIndex::ArenaDtor(void* object) {
  PossibleIndex_SortIndex* _this = reinterpret_cast< PossibleIndex_SortIndex* >(object);
  (void)_this;
}
void PossibleIndex_SortIndex::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PossibleIndex_SortIndex::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PossibleIndex_SortIndex::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.PossibleIndex.SortIndex)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&sort_limit_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_asc_) -
        reinterpret_cast<char*>(&sort_limit_)) + sizeof(is_asc_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PossibleIndex_SortIndex::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool is_asc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_is_asc(&has_bits);
          is_asc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 sort_limit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_sort_limit(&has_bits);
          sort_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PossibleIndex_SortIndex::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.PossibleIndex.SortIndex)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool is_asc = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_is_asc(), target);
  }

  // optional int64 sort_limit = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_sort_limit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.PossibleIndex.SortIndex)
  return target;
}

size_t PossibleIndex_SortIndex::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.PossibleIndex.SortIndex)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 sort_limit = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_sort_limit());
    }

    // optional bool is_asc = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PossibleIndex_SortIndex::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PossibleIndex_SortIndex::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PossibleIndex_SortIndex::GetClassData() const { return &_class_data_; }

void PossibleIndex_SortIndex::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PossibleIndex_SortIndex *>(to)->MergeFrom(
      static_cast<const PossibleIndex_SortIndex &>(from));
}


void PossibleIndex_SortIndex::MergeFrom(const PossibleIndex_SortIndex& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.PossibleIndex.SortIndex)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sort_limit_ = from.sort_limit_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_asc_ = from.is_asc_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PossibleIndex_SortIndex::CopyFrom(const PossibleIndex_SortIndex& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.PossibleIndex.SortIndex)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PossibleIndex_SortIndex::IsInitialized() const {
  return true;
}

void PossibleIndex_SortIndex::InternalSwap(PossibleIndex_SortIndex* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PossibleIndex_SortIndex, is_asc_)
      + sizeof(PossibleIndex_SortIndex::is_asc_)
      - PROTOBUF_FIELD_OFFSET(PossibleIndex_SortIndex, sort_limit_)>(
          reinterpret_cast<char*>(&sort_limit_),
          reinterpret_cast<char*>(&other->sort_limit_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PossibleIndex_SortIndex::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[2]);
}

// ===================================================================

class PossibleIndex::_Internal {
 public:
  using HasBits = decltype(std::declval<PossibleIndex>()._has_bits_);
  static void set_has_index_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::baikaldb::pb::PossibleIndex_SortIndex& sort_index(const PossibleIndex* msg);
  static void set_has_sort_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bool_and(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_covering_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_use_for_learner(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_range_key_sorted(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_eq(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_left_field_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_right_field_cnt(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_left_open(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_right_open(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_like_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::baikaldb::pb::PossibleIndex_SortIndex&
PossibleIndex::_Internal::sort_index(const PossibleIndex* msg) {
  return *msg->sort_index_;
}
void PossibleIndex::clear_index_conjuncts() {
  index_conjuncts_.Clear();
}
PossibleIndex::PossibleIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  ranges_(arena),
  index_conjuncts_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.PossibleIndex)
}
PossibleIndex::PossibleIndex(const PossibleIndex& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      ranges_(from.ranges_),
      index_conjuncts_(from.index_conjuncts_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_sort_index()) {
    sort_index_ = new ::baikaldb::pb::PossibleIndex_SortIndex(*from.sort_index_);
  } else {
    sort_index_ = nullptr;
  }
  ::memcpy(&index_id_, &from.index_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&like_prefix_) -
    reinterpret_cast<char*>(&index_id_)) + sizeof(like_prefix_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.PossibleIndex)
}

void PossibleIndex::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sort_index_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&like_prefix_) -
    reinterpret_cast<char*>(&sort_index_)) + sizeof(like_prefix_));
}

PossibleIndex::~PossibleIndex() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.PossibleIndex)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PossibleIndex::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sort_index_;
}

void PossibleIndex::ArenaDtor(void* object) {
  PossibleIndex* _this = reinterpret_cast< PossibleIndex* >(object);
  (void)_this;
}
void PossibleIndex::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PossibleIndex::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PossibleIndex::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.PossibleIndex)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ranges_.Clear();
  index_conjuncts_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(sort_index_ != nullptr);
    sort_index_->Clear();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&index_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&right_field_cnt_) -
        reinterpret_cast<char*>(&index_id_)) + sizeof(right_field_cnt_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&is_eq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&like_prefix_) -
        reinterpret_cast<char*>(&is_eq_)) + sizeof(like_prefix_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PossibleIndex::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 index_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_index_id(&has_bits);
          index_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.PossibleIndex.Range ranges = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ranges(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr index_conjuncts = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_index_conjuncts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.PossibleIndex.SortIndex sort_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_sort_index(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bool_and = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_bool_and(&has_bits);
          bool_and_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_covering_index = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_is_covering_index(&has_bits);
          is_covering_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_for_learner = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_use_for_learner(&has_bits);
          use_for_learner_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool range_key_sorted = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_range_key_sorted(&has_bits);
          range_key_sorted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_eq = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_is_eq(&has_bits);
          is_eq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 left_field_cnt = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_left_field_cnt(&has_bits);
          left_field_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 right_field_cnt = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_right_field_cnt(&has_bits);
          right_field_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool left_open = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_left_open(&has_bits);
          left_open_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool right_open = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_right_open(&has_bits);
          right_open_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool like_prefix = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_like_prefix(&has_bits);
          like_prefix_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PossibleIndex::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.PossibleIndex)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 index_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_index_id(), target);
  }

  // repeated .baikaldb.pb.PossibleIndex.Range ranges = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_ranges_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_ranges(i), target, stream);
  }

  // repeated .baikaldb.pb.Expr index_conjuncts = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_index_conjuncts_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_index_conjuncts(i), target, stream);
  }

  // optional .baikaldb.pb.PossibleIndex.SortIndex sort_index = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::sort_index(this), target, stream);
  }

  // optional bool bool_and = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_bool_and(), target);
  }

  // optional bool is_covering_index = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_is_covering_index(), target);
  }

  // optional bool use_for_learner = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_use_for_learner(), target);
  }

  // optional bool range_key_sorted = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_range_key_sorted(), target);
  }

  // optional bool is_eq = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_is_eq(), target);
  }

  // optional int32 left_field_cnt = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->_internal_left_field_cnt(), target);
  }

  // optional int32 right_field_cnt = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_right_field_cnt(), target);
  }

  // optional bool left_open = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_left_open(), target);
  }

  // optional bool right_open = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_right_open(), target);
  }

  // optional bool like_prefix = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_like_prefix(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.PossibleIndex)
  return target;
}

size_t PossibleIndex::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.PossibleIndex)
  size_t total_size = 0;

  // required int64 index_id = 1;
  if (_internal_has_index_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_index_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.PossibleIndex.Range ranges = 2;
  total_size += 1UL * this->_internal_ranges_size();
  for (const auto& msg : this->ranges_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.Expr index_conjuncts = 3;
  total_size += 1UL * this->_internal_index_conjuncts_size();
  for (const auto& msg : this->index_conjuncts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .baikaldb.pb.PossibleIndex.SortIndex sort_index = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sort_index_);
  }

  if (cached_has_bits & 0x000000fcu) {
    // optional bool bool_and = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool is_covering_index = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool use_for_learner = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool range_key_sorted = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional int32 left_field_cnt = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_left_field_cnt());
    }

    // optional int32 right_field_cnt = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_right_field_cnt());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional bool is_eq = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool left_open = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool right_open = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool like_prefix = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PossibleIndex::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PossibleIndex::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PossibleIndex::GetClassData() const { return &_class_data_; }

void PossibleIndex::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PossibleIndex *>(to)->MergeFrom(
      static_cast<const PossibleIndex &>(from));
}


void PossibleIndex::MergeFrom(const PossibleIndex& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.PossibleIndex)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  ranges_.MergeFrom(from.ranges_);
  index_conjuncts_.MergeFrom(from.index_conjuncts_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_sort_index()->::baikaldb::pb::PossibleIndex_SortIndex::MergeFrom(from._internal_sort_index());
    }
    if (cached_has_bits & 0x00000002u) {
      index_id_ = from.index_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      bool_and_ = from.bool_and_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_covering_index_ = from.is_covering_index_;
    }
    if (cached_has_bits & 0x00000010u) {
      use_for_learner_ = from.use_for_learner_;
    }
    if (cached_has_bits & 0x00000020u) {
      range_key_sorted_ = from.range_key_sorted_;
    }
    if (cached_has_bits & 0x00000040u) {
      left_field_cnt_ = from.left_field_cnt_;
    }
    if (cached_has_bits & 0x00000080u) {
      right_field_cnt_ = from.right_field_cnt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      is_eq_ = from.is_eq_;
    }
    if (cached_has_bits & 0x00000200u) {
      left_open_ = from.left_open_;
    }
    if (cached_has_bits & 0x00000400u) {
      right_open_ = from.right_open_;
    }
    if (cached_has_bits & 0x00000800u) {
      like_prefix_ = from.like_prefix_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PossibleIndex::CopyFrom(const PossibleIndex& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.PossibleIndex)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PossibleIndex::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(index_conjuncts_)) return false;
  return true;
}

void PossibleIndex::InternalSwap(PossibleIndex* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ranges_.InternalSwap(&other->ranges_);
  index_conjuncts_.InternalSwap(&other->index_conjuncts_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PossibleIndex, like_prefix_)
      + sizeof(PossibleIndex::like_prefix_)
      - PROTOBUF_FIELD_OFFSET(PossibleIndex, sort_index_)>(
          reinterpret_cast<char*>(&sort_index_),
          reinterpret_cast<char*>(&other->sort_index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PossibleIndex::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[3]);
}

// ===================================================================

class FulltextIndex::_Internal {
 public:
  using HasBits = decltype(std::declval<FulltextIndex>()._has_bits_);
  static void set_has_fulltext_node_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::baikaldb::pb::PossibleIndex& possible_index(const FulltextIndex* msg);
  static void set_has_possible_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::baikaldb::pb::PossibleIndex&
FulltextIndex::_Internal::possible_index(const FulltextIndex* msg) {
  return *msg->possible_index_;
}
FulltextIndex::FulltextIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  nested_fulltext_indexes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.FulltextIndex)
}
FulltextIndex::FulltextIndex(const FulltextIndex& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      nested_fulltext_indexes_(from.nested_fulltext_indexes_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_possible_index()) {
    possible_index_ = new ::baikaldb::pb::PossibleIndex(*from.possible_index_);
  } else {
    possible_index_ = nullptr;
  }
  fulltext_node_type_ = from.fulltext_node_type_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.FulltextIndex)
}

void FulltextIndex::SharedCtor() {
possible_index_ = nullptr;
fulltext_node_type_ = 1;
}

FulltextIndex::~FulltextIndex() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.FulltextIndex)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FulltextIndex::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete possible_index_;
}

void FulltextIndex::ArenaDtor(void* object) {
  FulltextIndex* _this = reinterpret_cast< FulltextIndex* >(object);
  (void)_this;
}
void FulltextIndex::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FulltextIndex::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FulltextIndex::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.FulltextIndex)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nested_fulltext_indexes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(possible_index_ != nullptr);
      possible_index_->Clear();
    }
    fulltext_node_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FulltextIndex::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .baikaldb.pb.FulltextNodeType fulltext_node_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::FulltextNodeType_IsValid(val))) {
            _internal_set_fulltext_node_type(static_cast<::baikaldb::pb::FulltextNodeType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.PossibleIndex possible_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_possible_index(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.FulltextIndex nested_fulltext_indexes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nested_fulltext_indexes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FulltextIndex::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.FulltextIndex)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .baikaldb.pb.FulltextNodeType fulltext_node_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_fulltext_node_type(), target);
  }

  // optional .baikaldb.pb.PossibleIndex possible_index = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::possible_index(this), target, stream);
  }

  // repeated .baikaldb.pb.FulltextIndex nested_fulltext_indexes = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_nested_fulltext_indexes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_nested_fulltext_indexes(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.FulltextIndex)
  return target;
}

size_t FulltextIndex::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.FulltextIndex)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.FulltextIndex nested_fulltext_indexes = 3;
  total_size += 1UL * this->_internal_nested_fulltext_indexes_size();
  for (const auto& msg : this->nested_fulltext_indexes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .baikaldb.pb.PossibleIndex possible_index = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *possible_index_);
    }

    // optional .baikaldb.pb.FulltextNodeType fulltext_node_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_fulltext_node_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FulltextIndex::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FulltextIndex::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FulltextIndex::GetClassData() const { return &_class_data_; }

void FulltextIndex::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FulltextIndex *>(to)->MergeFrom(
      static_cast<const FulltextIndex &>(from));
}


void FulltextIndex::MergeFrom(const FulltextIndex& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.FulltextIndex)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  nested_fulltext_indexes_.MergeFrom(from.nested_fulltext_indexes_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_possible_index()->::baikaldb::pb::PossibleIndex::MergeFrom(from._internal_possible_index());
    }
    if (cached_has_bits & 0x00000002u) {
      fulltext_node_type_ = from.fulltext_node_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FulltextIndex::CopyFrom(const FulltextIndex& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.FulltextIndex)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FulltextIndex::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(nested_fulltext_indexes_)) return false;
  if (_internal_has_possible_index()) {
    if (!possible_index_->IsInitialized()) return false;
  }
  return true;
}

void FulltextIndex::InternalSwap(FulltextIndex* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  nested_fulltext_indexes_.InternalSwap(&other->nested_fulltext_indexes_);
  swap(possible_index_, other->possible_index_);
  swap(fulltext_node_type_, other->fulltext_node_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FulltextIndex::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[4]);
}

// ===================================================================

class ScanNode::_Internal {
 public:
  using HasBits = decltype(std::declval<ScanNode>()._has_bits_);
  static void set_has_tuple_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_engine(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::baikaldb::pb::FulltextIndex& fulltext_index(const ScanNode* msg);
  static void set_has_fulltext_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lock(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_ddl_work(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_ddl_index_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_learner_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ddl_work_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::baikaldb::pb::ColumnDdlInfo& column_ddl_info(const ScanNode* msg);
  static void set_has_column_ddl_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_watt_stats_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_union_tuple_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_use_column_storage(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000018) ^ 0x00000018) != 0;
  }
};

const ::baikaldb::pb::FulltextIndex&
ScanNode::_Internal::fulltext_index(const ScanNode* msg) {
  return *msg->fulltext_index_;
}
const ::baikaldb::pb::ColumnDdlInfo&
ScanNode::_Internal::column_ddl_info(const ScanNode* msg) {
  return *msg->column_ddl_info_;
}
void ScanNode::clear_column_ddl_info() {
  if (column_ddl_info_ != nullptr) column_ddl_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
ScanNode::ScanNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  indexes_(arena),
  use_indexes_(arena),
  ignore_indexes_(arena),
  force_indexes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.ScanNode)
}
ScanNode::ScanNode(const ScanNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      indexes_(from.indexes_),
      use_indexes_(from.use_indexes_),
      ignore_indexes_(from.ignore_indexes_),
      force_indexes_(from.force_indexes_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  learner_index_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_learner_index()) {
    learner_index_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_learner_index(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_fulltext_index()) {
    fulltext_index_ = new ::baikaldb::pb::FulltextIndex(*from.fulltext_index_);
  } else {
    fulltext_index_ = nullptr;
  }
  if (from._internal_has_column_ddl_info()) {
    column_ddl_info_ = new ::baikaldb::pb::ColumnDdlInfo(*from.column_ddl_info_);
  } else {
    column_ddl_info_ = nullptr;
  }
  ::memcpy(&table_id_, &from.table_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&engine_) -
    reinterpret_cast<char*>(&table_id_)) + sizeof(engine_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.ScanNode)
}

void ScanNode::SharedCtor() {
learner_index_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&fulltext_index_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&union_tuple_id_) -
    reinterpret_cast<char*>(&fulltext_index_)) + sizeof(union_tuple_id_));
engine_ = 1;
}

ScanNode::~ScanNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.ScanNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ScanNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  learner_index_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete fulltext_index_;
  if (this != internal_default_instance()) delete column_ddl_info_;
}

void ScanNode::ArenaDtor(void* object) {
  ScanNode* _this = reinterpret_cast< ScanNode* >(object);
  (void)_this;
}
void ScanNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ScanNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ScanNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.ScanNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  indexes_.Clear();
  use_indexes_.Clear();
  ignore_indexes_.Clear();
  force_indexes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      learner_index_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(fulltext_index_ != nullptr);
      fulltext_index_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(column_ddl_info_ != nullptr);
      column_ddl_info_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&table_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ddl_work_type_) -
        reinterpret_cast<char*>(&table_id_)) + sizeof(ddl_work_type_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&is_ddl_work_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&union_tuple_id_) -
        reinterpret_cast<char*>(&is_ddl_work_)) + sizeof(union_tuple_id_));
    engine_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ScanNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 tuple_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_tuple_id(&has_bits);
          tuple_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 table_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_table_id(&has_bits);
          table_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes indexes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_indexes();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int64 use_indexes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_use_indexes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_use_indexes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.Engine engine = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::Engine_IsValid(val))) {
            _internal_set_engine(static_cast<::baikaldb::pb::Engine>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated int64 ignore_indexes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_ignore_indexes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_ignore_indexes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.FulltextIndex fulltext_index = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_fulltext_index(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.LockCmdType lock = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::LockCmdType_IsValid(val))) {
            _internal_set_lock(static_cast<::baikaldb::pb::LockCmdType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_ddl_work = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_is_ddl_work(&has_bits);
          is_ddl_work_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 ddl_index_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_ddl_index_id(&has_bits);
          ddl_index_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 force_indexes = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_force_indexes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<88>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_force_indexes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes learner_index = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          auto str = _internal_mutable_learner_index();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.DDLType ddl_work_type = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::DDLType_IsValid(val))) {
            _internal_set_ddl_work_type(static_cast<::baikaldb::pb::DDLType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(13, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.ColumnDdlInfo column_ddl_info = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_column_ddl_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 watt_stats_version = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_watt_stats_version(&has_bits);
          watt_stats_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 union_tuple_id = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_union_tuple_id(&has_bits);
          union_tuple_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_column_storage = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          _Internal::set_has_use_column_storage(&has_bits);
          use_column_storage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ScanNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.ScanNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 tuple_id = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_tuple_id(), target);
  }

  // required int64 table_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_table_id(), target);
  }

  // repeated bytes indexes = 3;
  for (int i = 0, n = this->_internal_indexes_size(); i < n; i++) {
    const auto& s = this->_internal_indexes(i);
    target = stream->WriteBytes(3, s, target);
  }

  // repeated int64 use_indexes = 4;
  for (int i = 0, n = this->_internal_use_indexes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_use_indexes(i), target);
  }

  // optional .baikaldb.pb.Engine engine = 5;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_engine(), target);
  }

  // repeated int64 ignore_indexes = 6;
  for (int i = 0, n = this->_internal_ignore_indexes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_ignore_indexes(i), target);
  }

  // optional .baikaldb.pb.FulltextIndex fulltext_index = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::fulltext_index(this), target, stream);
  }

  // optional .baikaldb.pb.LockCmdType lock = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      8, this->_internal_lock(), target);
  }

  // optional bool is_ddl_work = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_is_ddl_work(), target);
  }

  // optional int64 ddl_index_id = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(10, this->_internal_ddl_index_id(), target);
  }

  // repeated int64 force_indexes = 11;
  for (int i = 0, n = this->_internal_force_indexes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(11, this->_internal_force_indexes(i), target);
  }

  // optional bytes learner_index = 12;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        12, this->_internal_learner_index(), target);
  }

  // optional .baikaldb.pb.DDLType ddl_work_type = 13;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      13, this->_internal_ddl_work_type(), target);
  }

  // optional .baikaldb.pb.ColumnDdlInfo column_ddl_info = 14;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        14, _Internal::column_ddl_info(this), target, stream);
  }

  // optional uint64 watt_stats_version = 15;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(15, this->_internal_watt_stats_version(), target);
  }

  // optional int32 union_tuple_id = 16;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(16, this->_internal_union_tuple_id(), target);
  }

  // optional bool use_column_storage = 17;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_use_column_storage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.ScanNode)
  return target;
}

size_t ScanNode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.ScanNode)
  size_t total_size = 0;

  if (_internal_has_table_id()) {
    // required int64 table_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_table_id());
  }

  if (_internal_has_tuple_id()) {
    // required int32 tuple_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_tuple_id());
  }

  return total_size;
}
size_t ScanNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.ScanNode)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000018) ^ 0x00000018) == 0) {  // All required fields are present.
    // required int64 table_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_table_id());

    // required int32 tuple_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_tuple_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes indexes = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(indexes_.size());
  for (int i = 0, n = indexes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      indexes_.Get(i));
  }

  // repeated int64 use_indexes = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->use_indexes_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_use_indexes_size());
    total_size += data_size;
  }

  // repeated int64 ignore_indexes = 6;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->ignore_indexes_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_ignore_indexes_size());
    total_size += data_size;
  }

  // repeated int64 force_indexes = 11;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->force_indexes_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_force_indexes_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes learner_index = 12;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_learner_index());
    }

    // optional .baikaldb.pb.FulltextIndex fulltext_index = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *fulltext_index_);
    }

    // optional .baikaldb.pb.ColumnDdlInfo column_ddl_info = 14;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *column_ddl_info_);
    }

  }
  if (cached_has_bits & 0x000000e0u) {
    // optional .baikaldb.pb.LockCmdType lock = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_lock());
    }

    // optional int64 ddl_index_id = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_ddl_index_id());
    }

    // optional .baikaldb.pb.DDLType ddl_work_type = 13;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_ddl_work_type());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional bool is_ddl_work = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool use_column_storage = 17;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 1;
    }

    // optional uint64 watt_stats_version = 15;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_watt_stats_version());
    }

    // optional int32 union_tuple_id = 16;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_union_tuple_id());
    }

    // optional .baikaldb.pb.Engine engine = 5;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_engine());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ScanNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ScanNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ScanNode::GetClassData() const { return &_class_data_; }

void ScanNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ScanNode *>(to)->MergeFrom(
      static_cast<const ScanNode &>(from));
}


void ScanNode::MergeFrom(const ScanNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.ScanNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  indexes_.MergeFrom(from.indexes_);
  use_indexes_.MergeFrom(from.use_indexes_);
  ignore_indexes_.MergeFrom(from.ignore_indexes_);
  force_indexes_.MergeFrom(from.force_indexes_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_learner_index(from._internal_learner_index());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_fulltext_index()->::baikaldb::pb::FulltextIndex::MergeFrom(from._internal_fulltext_index());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_column_ddl_info()->::baikaldb::pb::ColumnDdlInfo::MergeFrom(from._internal_column_ddl_info());
    }
    if (cached_has_bits & 0x00000008u) {
      table_id_ = from.table_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      tuple_id_ = from.tuple_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      lock_ = from.lock_;
    }
    if (cached_has_bits & 0x00000040u) {
      ddl_index_id_ = from.ddl_index_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      ddl_work_type_ = from.ddl_work_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      is_ddl_work_ = from.is_ddl_work_;
    }
    if (cached_has_bits & 0x00000200u) {
      use_column_storage_ = from.use_column_storage_;
    }
    if (cached_has_bits & 0x00000400u) {
      watt_stats_version_ = from.watt_stats_version_;
    }
    if (cached_has_bits & 0x00000800u) {
      union_tuple_id_ = from.union_tuple_id_;
    }
    if (cached_has_bits & 0x00001000u) {
      engine_ = from.engine_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ScanNode::CopyFrom(const ScanNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.ScanNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScanNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_fulltext_index()) {
    if (!fulltext_index_->IsInitialized()) return false;
  }
  if (_internal_has_column_ddl_info()) {
    if (!column_ddl_info_->IsInitialized()) return false;
  }
  return true;
}

void ScanNode::InternalSwap(ScanNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  indexes_.InternalSwap(&other->indexes_);
  use_indexes_.InternalSwap(&other->use_indexes_);
  ignore_indexes_.InternalSwap(&other->ignore_indexes_);
  force_indexes_.InternalSwap(&other->force_indexes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &learner_index_, lhs_arena,
      &other->learner_index_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScanNode, union_tuple_id_)
      + sizeof(ScanNode::union_tuple_id_)
      - PROTOBUF_FIELD_OFFSET(ScanNode, fulltext_index_)>(
          reinterpret_cast<char*>(&fulltext_index_),
          reinterpret_cast<char*>(&other->fulltext_index_));
  swap(engine_, other->engine_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ScanNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[5]);
}

// ===================================================================

class LimitNode::_Internal {
 public:
  using HasBits = decltype(std::declval<LimitNode>()._has_bits_);
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::baikaldb::pb::Expr& offset_expr(const LimitNode* msg);
  static void set_has_offset_expr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::baikaldb::pb::Expr& count_expr(const LimitNode* msg);
  static void set_has_count_expr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::baikaldb::pb::Expr&
LimitNode::_Internal::offset_expr(const LimitNode* msg) {
  return *msg->offset_expr_;
}
const ::baikaldb::pb::Expr&
LimitNode::_Internal::count_expr(const LimitNode* msg) {
  return *msg->count_expr_;
}
void LimitNode::clear_offset_expr() {
  if (offset_expr_ != nullptr) offset_expr_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void LimitNode::clear_count_expr() {
  if (count_expr_ != nullptr) count_expr_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
LimitNode::LimitNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.LimitNode)
}
LimitNode::LimitNode(const LimitNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_offset_expr()) {
    offset_expr_ = new ::baikaldb::pb::Expr(*from.offset_expr_);
  } else {
    offset_expr_ = nullptr;
  }
  if (from._internal_has_count_expr()) {
    count_expr_ = new ::baikaldb::pb::Expr(*from.count_expr_);
  } else {
    count_expr_ = nullptr;
  }
  offset_ = from.offset_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.LimitNode)
}

void LimitNode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&offset_expr_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&offset_) -
    reinterpret_cast<char*>(&offset_expr_)) + sizeof(offset_));
}

LimitNode::~LimitNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.LimitNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LimitNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete offset_expr_;
  if (this != internal_default_instance()) delete count_expr_;
}

void LimitNode::ArenaDtor(void* object) {
  LimitNode* _this = reinterpret_cast< LimitNode* >(object);
  (void)_this;
}
void LimitNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LimitNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LimitNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.LimitNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(offset_expr_ != nullptr);
      offset_expr_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(count_expr_ != nullptr);
      count_expr_->Clear();
    }
  }
  offset_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LimitNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 offset = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.Expr offset_expr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_offset_expr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.Expr count_expr = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_count_expr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LimitNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.LimitNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 offset = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_offset(), target);
  }

  // optional .baikaldb.pb.Expr offset_expr = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::offset_expr(this), target, stream);
  }

  // optional .baikaldb.pb.Expr count_expr = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::count_expr(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.LimitNode)
  return target;
}

size_t LimitNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.LimitNode)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .baikaldb.pb.Expr offset_expr = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *offset_expr_);
    }

    // optional .baikaldb.pb.Expr count_expr = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *count_expr_);
    }

    // optional int64 offset = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LimitNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LimitNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LimitNode::GetClassData() const { return &_class_data_; }

void LimitNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LimitNode *>(to)->MergeFrom(
      static_cast<const LimitNode &>(from));
}


void LimitNode::MergeFrom(const LimitNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.LimitNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_offset_expr()->::baikaldb::pb::Expr::MergeFrom(from._internal_offset_expr());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_count_expr()->::baikaldb::pb::Expr::MergeFrom(from._internal_count_expr());
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LimitNode::CopyFrom(const LimitNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.LimitNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LimitNode::IsInitialized() const {
  if (_internal_has_offset_expr()) {
    if (!offset_expr_->IsInitialized()) return false;
  }
  if (_internal_has_count_expr()) {
    if (!count_expr_->IsInitialized()) return false;
  }
  return true;
}

void LimitNode::InternalSwap(LimitNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LimitNode, offset_)
      + sizeof(LimitNode::offset_)
      - PROTOBUF_FIELD_OFFSET(LimitNode, offset_expr_)>(
          reinterpret_cast<char*>(&offset_expr_),
          reinterpret_cast<char*>(&other->offset_expr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LimitNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[6]);
}

// ===================================================================

class SortNode::_Internal {
 public:
  using HasBits = decltype(std::declval<SortNode>()._has_bits_);
  static void set_has_tuple_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

void SortNode::clear_order_exprs() {
  order_exprs_.Clear();
}
void SortNode::clear_slot_order_exprs() {
  slot_order_exprs_.Clear();
}
SortNode::SortNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  order_exprs_(arena),
  is_asc_(arena),
  is_null_first_(arena),
  slot_order_exprs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.SortNode)
}
SortNode::SortNode(const SortNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      order_exprs_(from.order_exprs_),
      is_asc_(from.is_asc_),
      is_null_first_(from.is_null_first_),
      slot_order_exprs_(from.slot_order_exprs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  tuple_id_ = from.tuple_id_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.SortNode)
}

void SortNode::SharedCtor() {
tuple_id_ = 0;
}

SortNode::~SortNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.SortNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SortNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SortNode::ArenaDtor(void* object) {
  SortNode* _this = reinterpret_cast< SortNode* >(object);
  (void)_this;
}
void SortNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SortNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SortNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.SortNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  order_exprs_.Clear();
  is_asc_.Clear();
  is_null_first_.Clear();
  slot_order_exprs_.Clear();
  tuple_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SortNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .baikaldb.pb.Expr order_exprs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_order_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bool is_asc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_is_asc(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_is_asc(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool is_null_first = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_is_null_first(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_is_null_first(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tuple_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_tuple_id(&has_bits);
          tuple_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr slot_order_exprs = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_slot_order_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SortNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.SortNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr order_exprs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_order_exprs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_order_exprs(i), target, stream);
  }

  // repeated bool is_asc = 2;
  for (int i = 0, n = this->_internal_is_asc_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_is_asc(i), target);
  }

  // repeated bool is_null_first = 3;
  for (int i = 0, n = this->_internal_is_null_first_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_is_null_first(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 tuple_id = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_tuple_id(), target);
  }

  // repeated .baikaldb.pb.Expr slot_order_exprs = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_slot_order_exprs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_slot_order_exprs(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.SortNode)
  return target;
}

size_t SortNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.SortNode)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr order_exprs = 1;
  total_size += 1UL * this->_internal_order_exprs_size();
  for (const auto& msg : this->order_exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated bool is_asc = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_is_asc_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_is_asc_size());
    total_size += data_size;
  }

  // repeated bool is_null_first = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_is_null_first_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_is_null_first_size());
    total_size += data_size;
  }

  // repeated .baikaldb.pb.Expr slot_order_exprs = 6;
  total_size += 1UL * this->_internal_slot_order_exprs_size();
  for (const auto& msg : this->slot_order_exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int32 tuple_id = 5;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_tuple_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SortNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SortNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SortNode::GetClassData() const { return &_class_data_; }

void SortNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SortNode *>(to)->MergeFrom(
      static_cast<const SortNode &>(from));
}


void SortNode::MergeFrom(const SortNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.SortNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  order_exprs_.MergeFrom(from.order_exprs_);
  is_asc_.MergeFrom(from.is_asc_);
  is_null_first_.MergeFrom(from.is_null_first_);
  slot_order_exprs_.MergeFrom(from.slot_order_exprs_);
  if (from._internal_has_tuple_id()) {
    _internal_set_tuple_id(from._internal_tuple_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SortNode::CopyFrom(const SortNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.SortNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SortNode::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(order_exprs_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(slot_order_exprs_)) return false;
  return true;
}

void SortNode::InternalSwap(SortNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  order_exprs_.InternalSwap(&other->order_exprs_);
  is_asc_.InternalSwap(&other->is_asc_);
  is_null_first_.InternalSwap(&other->is_null_first_);
  slot_order_exprs_.InternalSwap(&other->slot_order_exprs_);
  swap(tuple_id_, other->tuple_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SortNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[7]);
}

// ===================================================================

class AggNode::_Internal {
 public:
  using HasBits = decltype(std::declval<AggNode>()._has_bits_);
  static void set_has_agg_tuple_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_arrow_ignore_tuple_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_pushdown(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

void AggNode::clear_group_exprs() {
  group_exprs_.Clear();
}
void AggNode::clear_agg_funcs() {
  agg_funcs_.Clear();
}
AggNode::AggNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  group_exprs_(arena),
  agg_funcs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.AggNode)
}
AggNode::AggNode(const AggNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      group_exprs_(from.group_exprs_),
      agg_funcs_(from.agg_funcs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&agg_tuple_id_, &from.agg_tuple_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_pushdown_) -
    reinterpret_cast<char*>(&agg_tuple_id_)) + sizeof(is_pushdown_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.AggNode)
}

void AggNode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&agg_tuple_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_pushdown_) -
    reinterpret_cast<char*>(&agg_tuple_id_)) + sizeof(is_pushdown_));
}

AggNode::~AggNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.AggNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AggNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AggNode::ArenaDtor(void* object) {
  AggNode* _this = reinterpret_cast< AggNode* >(object);
  (void)_this;
}
void AggNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AggNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AggNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.AggNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  group_exprs_.Clear();
  agg_funcs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&agg_tuple_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_pushdown_) -
        reinterpret_cast<char*>(&agg_tuple_id_)) + sizeof(is_pushdown_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AggNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .baikaldb.pb.Expr group_exprs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_group_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr agg_funcs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_agg_funcs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 agg_tuple_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_agg_tuple_id(&has_bits);
          agg_tuple_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 arrow_ignore_tuple_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_arrow_ignore_tuple_id(&has_bits);
          arrow_ignore_tuple_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_pushdown = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_is_pushdown(&has_bits);
          is_pushdown_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AggNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.AggNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr group_exprs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_group_exprs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_group_exprs(i), target, stream);
  }

  // repeated .baikaldb.pb.Expr agg_funcs = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_agg_funcs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_agg_funcs(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 agg_tuple_id = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_agg_tuple_id(), target);
  }

  // optional int32 arrow_ignore_tuple_id = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_arrow_ignore_tuple_id(), target);
  }

  // optional bool is_pushdown = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_is_pushdown(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.AggNode)
  return target;
}

size_t AggNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.AggNode)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr group_exprs = 1;
  total_size += 1UL * this->_internal_group_exprs_size();
  for (const auto& msg : this->group_exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.Expr agg_funcs = 2;
  total_size += 1UL * this->_internal_agg_funcs_size();
  for (const auto& msg : this->agg_funcs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 agg_tuple_id = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_agg_tuple_id());
    }

    // optional int32 arrow_ignore_tuple_id = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_arrow_ignore_tuple_id());
    }

    // optional bool is_pushdown = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AggNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AggNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AggNode::GetClassData() const { return &_class_data_; }

void AggNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AggNode *>(to)->MergeFrom(
      static_cast<const AggNode &>(from));
}


void AggNode::MergeFrom(const AggNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.AggNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  group_exprs_.MergeFrom(from.group_exprs_);
  agg_funcs_.MergeFrom(from.agg_funcs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      agg_tuple_id_ = from.agg_tuple_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      arrow_ignore_tuple_id_ = from.arrow_ignore_tuple_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      is_pushdown_ = from.is_pushdown_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AggNode::CopyFrom(const AggNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.AggNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AggNode::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(group_exprs_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(agg_funcs_)) return false;
  return true;
}

void AggNode::InternalSwap(AggNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  group_exprs_.InternalSwap(&other->group_exprs_);
  agg_funcs_.InternalSwap(&other->agg_funcs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AggNode, is_pushdown_)
      + sizeof(AggNode::is_pushdown_)
      - PROTOBUF_FIELD_OFFSET(AggNode, agg_tuple_id_)>(
          reinterpret_cast<char*>(&agg_tuple_id_),
          reinterpret_cast<char*>(&other->agg_tuple_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AggNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[8]);
}

// ===================================================================

class FilterNode::_Internal {
 public:
};

void FilterNode::clear_conjuncts() {
  conjuncts_.Clear();
}
void FilterNode::clear_conjuncts_learner() {
  conjuncts_learner_.Clear();
}
FilterNode::FilterNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  conjuncts_(arena),
  conjuncts_learner_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.FilterNode)
}
FilterNode::FilterNode(const FilterNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      conjuncts_(from.conjuncts_),
      conjuncts_learner_(from.conjuncts_learner_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.FilterNode)
}

void FilterNode::SharedCtor() {
}

FilterNode::~FilterNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.FilterNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FilterNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FilterNode::ArenaDtor(void* object) {
  FilterNode* _this = reinterpret_cast< FilterNode* >(object);
  (void)_this;
}
void FilterNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FilterNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FilterNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.FilterNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  conjuncts_.Clear();
  conjuncts_learner_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FilterNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .baikaldb.pb.Expr conjuncts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conjuncts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr conjuncts_learner = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conjuncts_learner(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FilterNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.FilterNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr conjuncts = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_conjuncts_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_conjuncts(i), target, stream);
  }

  // repeated .baikaldb.pb.Expr conjuncts_learner = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_conjuncts_learner_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_conjuncts_learner(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.FilterNode)
  return target;
}

size_t FilterNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.FilterNode)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr conjuncts = 1;
  total_size += 1UL * this->_internal_conjuncts_size();
  for (const auto& msg : this->conjuncts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.Expr conjuncts_learner = 2;
  total_size += 1UL * this->_internal_conjuncts_learner_size();
  for (const auto& msg : this->conjuncts_learner_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FilterNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FilterNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FilterNode::GetClassData() const { return &_class_data_; }

void FilterNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FilterNode *>(to)->MergeFrom(
      static_cast<const FilterNode &>(from));
}


void FilterNode::MergeFrom(const FilterNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.FilterNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  conjuncts_.MergeFrom(from.conjuncts_);
  conjuncts_learner_.MergeFrom(from.conjuncts_learner_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FilterNode::CopyFrom(const FilterNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.FilterNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FilterNode::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(conjuncts_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(conjuncts_learner_)) return false;
  return true;
}

void FilterNode::InternalSwap(FilterNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  conjuncts_.InternalSwap(&other->conjuncts_);
  conjuncts_learner_.InternalSwap(&other->conjuncts_learner_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FilterNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[9]);
}

// ===================================================================

class DualScanNode::_Internal {
 public:
  using HasBits = decltype(std::declval<DualScanNode>()._has_bits_);
  static const ::baikaldb::pb::Plan& sub_query_node(const DualScanNode* msg);
  static void set_has_sub_query_node(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::baikaldb::pb::RuntimeState& runtime_state(const DualScanNode* msg);
  static void set_has_runtime_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::baikaldb::pb::Plan&
DualScanNode::_Internal::sub_query_node(const DualScanNode* msg) {
  return *msg->sub_query_node_;
}
const ::baikaldb::pb::RuntimeState&
DualScanNode::_Internal::runtime_state(const DualScanNode* msg) {
  return *msg->runtime_state_;
}
void DualScanNode::clear_derived_table_projections() {
  derived_table_projections_.Clear();
}
void DualScanNode::clear_runtime_state() {
  if (runtime_state_ != nullptr) runtime_state_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void DualScanNode::clear_slot_column() {
  slot_column_.Clear();
}
DualScanNode::DualScanNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  derived_table_projections_(arena),
  slot_column_(arena),
  derived_table_projections_agg_or_window_vec_(arena),
  agg_tuple_id_pair_(arena),
  agg_slot_ids_(arena),
  multi_distinct_agg_slot_ids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.DualScanNode)
}
DualScanNode::DualScanNode(const DualScanNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      derived_table_projections_(from.derived_table_projections_),
      slot_column_(from.slot_column_),
      derived_table_projections_agg_or_window_vec_(from.derived_table_projections_agg_or_window_vec_),
      agg_tuple_id_pair_(from.agg_tuple_id_pair_),
      agg_slot_ids_(from.agg_slot_ids_),
      multi_distinct_agg_slot_ids_(from.multi_distinct_agg_slot_ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_sub_query_node()) {
    sub_query_node_ = new ::baikaldb::pb::Plan(*from.sub_query_node_);
  } else {
    sub_query_node_ = nullptr;
  }
  if (from._internal_has_runtime_state()) {
    runtime_state_ = new ::baikaldb::pb::RuntimeState(*from.runtime_state_);
  } else {
    runtime_state_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.DualScanNode)
}

void DualScanNode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sub_query_node_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&runtime_state_) -
    reinterpret_cast<char*>(&sub_query_node_)) + sizeof(runtime_state_));
}

DualScanNode::~DualScanNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.DualScanNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DualScanNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sub_query_node_;
  if (this != internal_default_instance()) delete runtime_state_;
}

void DualScanNode::ArenaDtor(void* object) {
  DualScanNode* _this = reinterpret_cast< DualScanNode* >(object);
  (void)_this;
}
void DualScanNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DualScanNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DualScanNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.DualScanNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  derived_table_projections_.Clear();
  slot_column_.Clear();
  derived_table_projections_agg_or_window_vec_.Clear();
  agg_tuple_id_pair_.Clear();
  agg_slot_ids_.Clear();
  multi_distinct_agg_slot_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(sub_query_node_ != nullptr);
      sub_query_node_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(runtime_state_ != nullptr);
      runtime_state_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DualScanNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .baikaldb.pb.Plan sub_query_node = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sub_query_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr derived_table_projections = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_derived_table_projections(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.RuntimeState runtime_state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_runtime_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.SlotColumn slot_column = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_slot_column(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bool derived_table_projections_agg_or_window_vec = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_derived_table_projections_agg_or_window_vec(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_derived_table_projections_agg_or_window_vec(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 agg_tuple_id_pair = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_agg_tuple_id_pair(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_agg_tuple_id_pair(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 agg_slot_ids = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_agg_slot_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_agg_slot_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 multi_distinct_agg_slot_ids = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_multi_distinct_agg_slot_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_multi_distinct_agg_slot_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DualScanNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.DualScanNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .baikaldb.pb.Plan sub_query_node = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::sub_query_node(this), target, stream);
  }

  // repeated .baikaldb.pb.Expr derived_table_projections = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_derived_table_projections_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_derived_table_projections(i), target, stream);
  }

  // optional .baikaldb.pb.RuntimeState runtime_state = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::runtime_state(this), target, stream);
  }

  // repeated .baikaldb.pb.SlotColumn slot_column = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_slot_column_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_slot_column(i), target, stream);
  }

  // repeated bool derived_table_projections_agg_or_window_vec = 5;
  for (int i = 0, n = this->_internal_derived_table_projections_agg_or_window_vec_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_derived_table_projections_agg_or_window_vec(i), target);
  }

  // repeated int32 agg_tuple_id_pair = 6;
  for (int i = 0, n = this->_internal_agg_tuple_id_pair_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_agg_tuple_id_pair(i), target);
  }

  // repeated int32 agg_slot_ids = 7;
  for (int i = 0, n = this->_internal_agg_slot_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_agg_slot_ids(i), target);
  }

  // repeated int32 multi_distinct_agg_slot_ids = 8;
  for (int i = 0, n = this->_internal_multi_distinct_agg_slot_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_multi_distinct_agg_slot_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.DualScanNode)
  return target;
}

size_t DualScanNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.DualScanNode)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr derived_table_projections = 2;
  total_size += 1UL * this->_internal_derived_table_projections_size();
  for (const auto& msg : this->derived_table_projections_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.SlotColumn slot_column = 4;
  total_size += 1UL * this->_internal_slot_column_size();
  for (const auto& msg : this->slot_column_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated bool derived_table_projections_agg_or_window_vec = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_derived_table_projections_agg_or_window_vec_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_derived_table_projections_agg_or_window_vec_size());
    total_size += data_size;
  }

  // repeated int32 agg_tuple_id_pair = 6;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->agg_tuple_id_pair_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_agg_tuple_id_pair_size());
    total_size += data_size;
  }

  // repeated int32 agg_slot_ids = 7;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->agg_slot_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_agg_slot_ids_size());
    total_size += data_size;
  }

  // repeated int32 multi_distinct_agg_slot_ids = 8;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->multi_distinct_agg_slot_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_multi_distinct_agg_slot_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .baikaldb.pb.Plan sub_query_node = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *sub_query_node_);
    }

    // optional .baikaldb.pb.RuntimeState runtime_state = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *runtime_state_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DualScanNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DualScanNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DualScanNode::GetClassData() const { return &_class_data_; }

void DualScanNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DualScanNode *>(to)->MergeFrom(
      static_cast<const DualScanNode &>(from));
}


void DualScanNode::MergeFrom(const DualScanNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.DualScanNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  derived_table_projections_.MergeFrom(from.derived_table_projections_);
  slot_column_.MergeFrom(from.slot_column_);
  derived_table_projections_agg_or_window_vec_.MergeFrom(from.derived_table_projections_agg_or_window_vec_);
  agg_tuple_id_pair_.MergeFrom(from.agg_tuple_id_pair_);
  agg_slot_ids_.MergeFrom(from.agg_slot_ids_);
  multi_distinct_agg_slot_ids_.MergeFrom(from.multi_distinct_agg_slot_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_sub_query_node()->::baikaldb::pb::Plan::MergeFrom(from._internal_sub_query_node());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_runtime_state()->::baikaldb::pb::RuntimeState::MergeFrom(from._internal_runtime_state());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DualScanNode::CopyFrom(const DualScanNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.DualScanNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DualScanNode::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(derived_table_projections_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(slot_column_)) return false;
  if (_internal_has_sub_query_node()) {
    if (!sub_query_node_->IsInitialized()) return false;
  }
  if (_internal_has_runtime_state()) {
    if (!runtime_state_->IsInitialized()) return false;
  }
  return true;
}

void DualScanNode::InternalSwap(DualScanNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  derived_table_projections_.InternalSwap(&other->derived_table_projections_);
  slot_column_.InternalSwap(&other->slot_column_);
  derived_table_projections_agg_or_window_vec_.InternalSwap(&other->derived_table_projections_agg_or_window_vec_);
  agg_tuple_id_pair_.InternalSwap(&other->agg_tuple_id_pair_);
  agg_slot_ids_.InternalSwap(&other->agg_slot_ids_);
  multi_distinct_agg_slot_ids_.InternalSwap(&other->multi_distinct_agg_slot_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DualScanNode, runtime_state_)
      + sizeof(DualScanNode::runtime_state_)
      - PROTOBUF_FIELD_OFFSET(DualScanNode, sub_query_node_)>(
          reinterpret_cast<char*>(&sub_query_node_),
          reinterpret_cast<char*>(&other->sub_query_node_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DualScanNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[10]);
}

// ===================================================================

class JoinNode::_Internal {
 public:
  using HasBits = decltype(std::declval<JoinNode>()._has_bits_);
  static void set_has_join_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_use_index_join(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

void JoinNode::clear_conditions() {
  conditions_.Clear();
}
JoinNode::JoinNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  conditions_(arena),
  using_clos_(arena),
  left_tuple_ids_(arena),
  left_table_ids_(arena),
  right_tuple_ids_(arena),
  right_table_ids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.JoinNode)
}
JoinNode::JoinNode(const JoinNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      conditions_(from.conditions_),
      using_clos_(from.using_clos_),
      left_tuple_ids_(from.left_tuple_ids_),
      left_table_ids_(from.left_table_ids_),
      right_tuple_ids_(from.right_tuple_ids_),
      right_table_ids_(from.right_table_ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&join_type_, &from.join_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&use_index_join_) -
    reinterpret_cast<char*>(&join_type_)) + sizeof(use_index_join_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.JoinNode)
}

void JoinNode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&join_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&use_index_join_) -
    reinterpret_cast<char*>(&join_type_)) + sizeof(use_index_join_));
}

JoinNode::~JoinNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.JoinNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void JoinNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void JoinNode::ArenaDtor(void* object) {
  JoinNode* _this = reinterpret_cast< JoinNode* >(object);
  (void)_this;
}
void JoinNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void JoinNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void JoinNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.JoinNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  conditions_.Clear();
  using_clos_.Clear();
  left_tuple_ids_.Clear();
  left_table_ids_.Clear();
  right_tuple_ids_.Clear();
  right_table_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&join_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&use_index_join_) -
        reinterpret_cast<char*>(&join_type_)) + sizeof(use_index_join_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* JoinNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.JoinType join_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::JoinType_IsValid(val))) {
            _internal_set_join_type(static_cast<::baikaldb::pb::JoinType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr conditions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conditions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string using_clos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_using_clos();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.JoinNode.using_clos");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 left_tuple_ids = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_left_tuple_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_left_tuple_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 left_table_ids = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_left_table_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_left_table_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 right_tuple_ids = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_right_tuple_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_right_tuple_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 right_table_ids = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_right_table_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_right_table_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_index_join = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_use_index_join(&has_bits);
          use_index_join_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* JoinNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.JoinNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.JoinType join_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_join_type(), target);
  }

  // repeated .baikaldb.pb.Expr conditions = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_conditions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_conditions(i), target, stream);
  }

  // repeated string using_clos = 3;
  for (int i = 0, n = this->_internal_using_clos_size(); i < n; i++) {
    const auto& s = this->_internal_using_clos(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.JoinNode.using_clos");
    target = stream->WriteString(3, s, target);
  }

  // repeated int32 left_tuple_ids = 4;
  for (int i = 0, n = this->_internal_left_tuple_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_left_tuple_ids(i), target);
  }

  // repeated int64 left_table_ids = 5;
  for (int i = 0, n = this->_internal_left_table_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_left_table_ids(i), target);
  }

  // repeated int32 right_tuple_ids = 6;
  for (int i = 0, n = this->_internal_right_tuple_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_right_tuple_ids(i), target);
  }

  // repeated int64 right_table_ids = 7;
  for (int i = 0, n = this->_internal_right_table_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(7, this->_internal_right_table_ids(i), target);
  }

  // optional bool use_index_join = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_use_index_join(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.JoinNode)
  return target;
}

size_t JoinNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.JoinNode)
  size_t total_size = 0;

  // required .baikaldb.pb.JoinType join_type = 1;
  if (_internal_has_join_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_join_type());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr conditions = 2;
  total_size += 1UL * this->_internal_conditions_size();
  for (const auto& msg : this->conditions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string using_clos = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(using_clos_.size());
  for (int i = 0, n = using_clos_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      using_clos_.Get(i));
  }

  // repeated int32 left_tuple_ids = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->left_tuple_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_left_tuple_ids_size());
    total_size += data_size;
  }

  // repeated int64 left_table_ids = 5;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->left_table_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_left_table_ids_size());
    total_size += data_size;
  }

  // repeated int32 right_tuple_ids = 6;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->right_tuple_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_right_tuple_ids_size());
    total_size += data_size;
  }

  // repeated int64 right_table_ids = 7;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->right_table_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_right_table_ids_size());
    total_size += data_size;
  }

  // optional bool use_index_join = 8;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData JoinNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    JoinNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*JoinNode::GetClassData() const { return &_class_data_; }

void JoinNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<JoinNode *>(to)->MergeFrom(
      static_cast<const JoinNode &>(from));
}


void JoinNode::MergeFrom(const JoinNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.JoinNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  conditions_.MergeFrom(from.conditions_);
  using_clos_.MergeFrom(from.using_clos_);
  left_tuple_ids_.MergeFrom(from.left_tuple_ids_);
  left_table_ids_.MergeFrom(from.left_table_ids_);
  right_tuple_ids_.MergeFrom(from.right_tuple_ids_);
  right_table_ids_.MergeFrom(from.right_table_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      join_type_ = from.join_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      use_index_join_ = from.use_index_join_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void JoinNode::CopyFrom(const JoinNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.JoinNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(conditions_)) return false;
  return true;
}

void JoinNode::InternalSwap(JoinNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  conditions_.InternalSwap(&other->conditions_);
  using_clos_.InternalSwap(&other->using_clos_);
  left_tuple_ids_.InternalSwap(&other->left_tuple_ids_);
  left_table_ids_.InternalSwap(&other->left_table_ids_);
  right_tuple_ids_.InternalSwap(&other->right_tuple_ids_);
  right_table_ids_.InternalSwap(&other->right_table_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(JoinNode, use_index_join_)
      + sizeof(JoinNode::use_index_join_)
      - PROTOBUF_FIELD_OFFSET(JoinNode, join_type_)>(
          reinterpret_cast<char*>(&join_type_),
          reinterpret_cast<char*>(&other->join_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata JoinNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[11]);
}

// ===================================================================

class ApplyNode::_Internal {
 public:
  using HasBits = decltype(std::declval<ApplyNode>()._has_bits_);
  static void set_has_join_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_one_row(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_compare_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_select_field(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

void ApplyNode::clear_conditions() {
  conditions_.Clear();
}
ApplyNode::ApplyNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  conditions_(arena),
  left_tuple_ids_(arena),
  left_table_ids_(arena),
  right_tuple_ids_(arena),
  right_table_ids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.ApplyNode)
}
ApplyNode::ApplyNode(const ApplyNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      conditions_(from.conditions_),
      left_tuple_ids_(from.left_tuple_ids_),
      left_table_ids_(from.left_table_ids_),
      right_tuple_ids_(from.right_tuple_ids_),
      right_table_ids_(from.right_table_ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&join_type_, &from.join_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_select_field_) -
    reinterpret_cast<char*>(&join_type_)) + sizeof(is_select_field_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.ApplyNode)
}

void ApplyNode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&join_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_select_field_) -
    reinterpret_cast<char*>(&join_type_)) + sizeof(is_select_field_));
}

ApplyNode::~ApplyNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.ApplyNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ApplyNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ApplyNode::ArenaDtor(void* object) {
  ApplyNode* _this = reinterpret_cast< ApplyNode* >(object);
  (void)_this;
}
void ApplyNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ApplyNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ApplyNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.ApplyNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  conditions_.Clear();
  left_tuple_ids_.Clear();
  left_table_ids_.Clear();
  right_tuple_ids_.Clear();
  right_table_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&join_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_select_field_) -
        reinterpret_cast<char*>(&join_type_)) + sizeof(is_select_field_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ApplyNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.JoinType join_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::JoinType_IsValid(val))) {
            _internal_set_join_type(static_cast<::baikaldb::pb::JoinType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr conditions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conditions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 left_tuple_ids = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_left_tuple_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_left_tuple_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 left_table_ids = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_left_table_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_left_table_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 right_tuple_ids = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_right_tuple_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_right_tuple_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 right_table_ids = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_right_table_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_right_table_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool max_one_row = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_max_one_row(&has_bits);
          max_one_row_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.CompareType compare_type = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::CompareType_IsValid(val))) {
            _internal_set_compare_type(static_cast<::baikaldb::pb::CompareType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_select_field = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_is_select_field(&has_bits);
          is_select_field_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ApplyNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.ApplyNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.JoinType join_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_join_type(), target);
  }

  // repeated .baikaldb.pb.Expr conditions = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_conditions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_conditions(i), target, stream);
  }

  // repeated int32 left_tuple_ids = 4;
  for (int i = 0, n = this->_internal_left_tuple_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_left_tuple_ids(i), target);
  }

  // repeated int64 left_table_ids = 5;
  for (int i = 0, n = this->_internal_left_table_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_left_table_ids(i), target);
  }

  // repeated int32 right_tuple_ids = 6;
  for (int i = 0, n = this->_internal_right_tuple_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_right_tuple_ids(i), target);
  }

  // repeated int64 right_table_ids = 7;
  for (int i = 0, n = this->_internal_right_table_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(7, this->_internal_right_table_ids(i), target);
  }

  // optional bool max_one_row = 8;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_max_one_row(), target);
  }

  // optional .baikaldb.pb.CompareType compare_type = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      9, this->_internal_compare_type(), target);
  }

  // optional bool is_select_field = 10;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_is_select_field(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.ApplyNode)
  return target;
}

size_t ApplyNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.ApplyNode)
  size_t total_size = 0;

  // required .baikaldb.pb.JoinType join_type = 1;
  if (_internal_has_join_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_join_type());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr conditions = 2;
  total_size += 1UL * this->_internal_conditions_size();
  for (const auto& msg : this->conditions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 left_tuple_ids = 4;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->left_tuple_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_left_tuple_ids_size());
    total_size += data_size;
  }

  // repeated int64 left_table_ids = 5;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->left_table_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_left_table_ids_size());
    total_size += data_size;
  }

  // repeated int32 right_tuple_ids = 6;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->right_tuple_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_right_tuple_ids_size());
    total_size += data_size;
  }

  // repeated int64 right_table_ids = 7;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->right_table_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_right_table_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional .baikaldb.pb.CompareType compare_type = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_compare_type());
    }

    // optional bool max_one_row = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool is_select_field = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ApplyNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ApplyNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ApplyNode::GetClassData() const { return &_class_data_; }

void ApplyNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ApplyNode *>(to)->MergeFrom(
      static_cast<const ApplyNode &>(from));
}


void ApplyNode::MergeFrom(const ApplyNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.ApplyNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  conditions_.MergeFrom(from.conditions_);
  left_tuple_ids_.MergeFrom(from.left_tuple_ids_);
  left_table_ids_.MergeFrom(from.left_table_ids_);
  right_tuple_ids_.MergeFrom(from.right_tuple_ids_);
  right_table_ids_.MergeFrom(from.right_table_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      join_type_ = from.join_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      compare_type_ = from.compare_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_one_row_ = from.max_one_row_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_select_field_ = from.is_select_field_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ApplyNode::CopyFrom(const ApplyNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.ApplyNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplyNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(conditions_)) return false;
  return true;
}

void ApplyNode::InternalSwap(ApplyNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  conditions_.InternalSwap(&other->conditions_);
  left_tuple_ids_.InternalSwap(&other->left_tuple_ids_);
  left_table_ids_.InternalSwap(&other->left_table_ids_);
  right_tuple_ids_.InternalSwap(&other->right_tuple_ids_);
  right_table_ids_.InternalSwap(&other->right_table_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ApplyNode, is_select_field_)
      + sizeof(ApplyNode::is_select_field_)
      - PROTOBUF_FIELD_OFFSET(ApplyNode, join_type_)>(
          reinterpret_cast<char*>(&join_type_),
          reinterpret_cast<char*>(&other->join_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ApplyNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[12]);
}

// ===================================================================

class FetcherNode::_Internal {
 public:
  using HasBits = decltype(std::declval<FetcherNode>()._has_bits_);
  static void set_has_op_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

void FetcherNode::clear_slot_order_exprs() {
  slot_order_exprs_.Clear();
}
FetcherNode::FetcherNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  slot_order_exprs_(arena),
  is_asc_(arena),
  is_null_first_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.FetcherNode)
}
FetcherNode::FetcherNode(const FetcherNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      slot_order_exprs_(from.slot_order_exprs_),
      is_asc_(from.is_asc_),
      is_null_first_(from.is_null_first_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  op_type_ = from.op_type_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.FetcherNode)
}

void FetcherNode::SharedCtor() {
op_type_ = 0;
}

FetcherNode::~FetcherNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.FetcherNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FetcherNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FetcherNode::ArenaDtor(void* object) {
  FetcherNode* _this = reinterpret_cast< FetcherNode* >(object);
  (void)_this;
}
void FetcherNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FetcherNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FetcherNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.FetcherNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  slot_order_exprs_.Clear();
  is_asc_.Clear();
  is_null_first_.Clear();
  op_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FetcherNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.OpType op_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::OpType_IsValid(val))) {
            _internal_set_op_type(static_cast<::baikaldb::pb::OpType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr slot_order_exprs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_slot_order_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bool is_asc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_is_asc(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_is_asc(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool is_null_first = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_is_null_first(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_is_null_first(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FetcherNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.FetcherNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.OpType op_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_op_type(), target);
  }

  // repeated .baikaldb.pb.Expr slot_order_exprs = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_slot_order_exprs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_slot_order_exprs(i), target, stream);
  }

  // repeated bool is_asc = 4;
  for (int i = 0, n = this->_internal_is_asc_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_asc(i), target);
  }

  // repeated bool is_null_first = 5;
  for (int i = 0, n = this->_internal_is_null_first_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_is_null_first(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.FetcherNode)
  return target;
}

size_t FetcherNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.FetcherNode)
  size_t total_size = 0;

  // required .baikaldb.pb.OpType op_type = 1;
  if (_internal_has_op_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_op_type());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr slot_order_exprs = 3;
  total_size += 1UL * this->_internal_slot_order_exprs_size();
  for (const auto& msg : this->slot_order_exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated bool is_asc = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_is_asc_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_is_asc_size());
    total_size += data_size;
  }

  // repeated bool is_null_first = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_is_null_first_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_is_null_first_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FetcherNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FetcherNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FetcherNode::GetClassData() const { return &_class_data_; }

void FetcherNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FetcherNode *>(to)->MergeFrom(
      static_cast<const FetcherNode &>(from));
}


void FetcherNode::MergeFrom(const FetcherNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.FetcherNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  slot_order_exprs_.MergeFrom(from.slot_order_exprs_);
  is_asc_.MergeFrom(from.is_asc_);
  is_null_first_.MergeFrom(from.is_null_first_);
  if (from._internal_has_op_type()) {
    _internal_set_op_type(from._internal_op_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FetcherNode::CopyFrom(const FetcherNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.FetcherNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetcherNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(slot_order_exprs_)) return false;
  return true;
}

void FetcherNode::InternalSwap(FetcherNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  slot_order_exprs_.InternalSwap(&other->slot_order_exprs_);
  is_asc_.InternalSwap(&other->is_asc_);
  is_null_first_.InternalSwap(&other->is_null_first_);
  swap(op_type_, other->op_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FetcherNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[13]);
}

// ===================================================================

class InsertNode::_Internal {
 public:
  using HasBits = decltype(std::declval<InsertNode>()._has_bits_);
  static void set_has_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_need_ignore(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_tuple_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_values_tuple_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_replace(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_row_ttl_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ddl_need_write(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_ddl_index_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_merge(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_watt_stats_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

void InsertNode::clear_update_slots() {
  update_slots_.Clear();
}
void InsertNode::clear_update_exprs() {
  update_exprs_.Clear();
}
void InsertNode::clear_insert_values() {
  insert_values_.Clear();
}
InsertNode::InsertNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  records_(arena),
  update_slots_(arena),
  update_exprs_(arena),
  field_ids_(arena),
  insert_values_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.InsertNode)
}
InsertNode::InsertNode(const InsertNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      records_(from.records_),
      update_slots_(from.update_slots_),
      update_exprs_(from.update_exprs_),
      field_ids_(from.field_ids_),
      insert_values_(from.insert_values_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&table_id_, &from.table_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_merge_) -
    reinterpret_cast<char*>(&table_id_)) + sizeof(is_merge_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.InsertNode)
}

void InsertNode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&table_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_merge_) -
    reinterpret_cast<char*>(&table_id_)) + sizeof(is_merge_));
}

InsertNode::~InsertNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.InsertNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void InsertNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void InsertNode::ArenaDtor(void* object) {
  InsertNode* _this = reinterpret_cast< InsertNode* >(object);
  (void)_this;
}
void InsertNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void InsertNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void InsertNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.InsertNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  records_.Clear();
  update_slots_.Clear();
  update_exprs_.Clear();
  field_ids_.Clear();
  insert_values_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&table_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_replace_) -
        reinterpret_cast<char*>(&table_id_)) + sizeof(is_replace_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&ddl_need_write_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_merge_) -
        reinterpret_cast<char*>(&ddl_need_write_)) + sizeof(is_merge_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InsertNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 table_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_table_id(&has_bits);
          table_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes records = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_records();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool need_ignore = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_need_ignore(&has_bits);
          need_ignore_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.SlotDescriptor update_slots = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_update_slots(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr update_exprs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_update_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 tuple_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_tuple_id(&has_bits);
          tuple_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 values_tuple_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_values_tuple_id(&has_bits);
          values_tuple_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_replace = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_is_replace(&has_bits);
          is_replace_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 field_ids = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_field_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<72>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_field_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr insert_values = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_insert_values(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 row_ttl_duration = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_row_ttl_duration(&has_bits);
          row_ttl_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ddl_need_write = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_ddl_need_write(&has_bits);
          ddl_need_write_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 ddl_index_id = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_ddl_index_id(&has_bits);
          ddl_index_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_merge = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_is_merge(&has_bits);
          is_merge_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 watt_stats_version = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_watt_stats_version(&has_bits);
          watt_stats_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* InsertNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.InsertNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 table_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_table_id(), target);
  }

  // repeated bytes records = 2;
  for (int i = 0, n = this->_internal_records_size(); i < n; i++) {
    const auto& s = this->_internal_records(i);
    target = stream->WriteBytes(2, s, target);
  }

  // optional bool need_ignore = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_need_ignore(), target);
  }

  // repeated .baikaldb.pb.SlotDescriptor update_slots = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_update_slots_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_update_slots(i), target, stream);
  }

  // repeated .baikaldb.pb.Expr update_exprs = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_update_exprs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_update_exprs(i), target, stream);
  }

  // optional int32 tuple_id = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_tuple_id(), target);
  }

  // optional int32 values_tuple_id = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_values_tuple_id(), target);
  }

  // optional bool is_replace = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_is_replace(), target);
  }

  // repeated int32 field_ids = 9;
  for (int i = 0, n = this->_internal_field_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_field_ids(i), target);
  }

  // repeated .baikaldb.pb.Expr insert_values = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_insert_values_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_insert_values(i), target, stream);
  }

  // optional int64 row_ttl_duration = 11;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(11, this->_internal_row_ttl_duration(), target);
  }

  // optional bool ddl_need_write = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_ddl_need_write(), target);
  }

  // optional int64 ddl_index_id = 13;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(13, this->_internal_ddl_index_id(), target);
  }

  // optional bool is_merge = 14;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_is_merge(), target);
  }

  // optional uint64 watt_stats_version = 15;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(15, this->_internal_watt_stats_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.InsertNode)
  return target;
}

size_t InsertNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.InsertNode)
  size_t total_size = 0;

  // required int64 table_id = 1;
  if (_internal_has_table_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_table_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes records = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(records_.size());
  for (int i = 0, n = records_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      records_.Get(i));
  }

  // repeated .baikaldb.pb.SlotDescriptor update_slots = 4;
  total_size += 1UL * this->_internal_update_slots_size();
  for (const auto& msg : this->update_slots_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.Expr update_exprs = 5;
  total_size += 1UL * this->_internal_update_exprs_size();
  for (const auto& msg : this->update_exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 field_ids = 9;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->field_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_field_ids_size());
    total_size += data_size;
  }

  // repeated .baikaldb.pb.Expr insert_values = 10;
  total_size += 1UL * this->_internal_insert_values_size();
  for (const auto& msg : this->insert_values_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional int32 tuple_id = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_tuple_id());
    }

    // optional int32 values_tuple_id = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_values_tuple_id());
    }

    // optional int64 row_ttl_duration = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_row_ttl_duration());
    }

    // optional int64 ddl_index_id = 13;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_ddl_index_id());
    }

    // optional uint64 watt_stats_version = 15;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_watt_stats_version());
    }

    // optional bool need_ignore = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool is_replace = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool ddl_need_write = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool is_merge = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InsertNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    InsertNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InsertNode::GetClassData() const { return &_class_data_; }

void InsertNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<InsertNode *>(to)->MergeFrom(
      static_cast<const InsertNode &>(from));
}


void InsertNode::MergeFrom(const InsertNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.InsertNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  records_.MergeFrom(from.records_);
  update_slots_.MergeFrom(from.update_slots_);
  update_exprs_.MergeFrom(from.update_exprs_);
  field_ids_.MergeFrom(from.field_ids_);
  insert_values_.MergeFrom(from.insert_values_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      table_id_ = from.table_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      tuple_id_ = from.tuple_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      values_tuple_id_ = from.values_tuple_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      row_ttl_duration_ = from.row_ttl_duration_;
    }
    if (cached_has_bits & 0x00000010u) {
      ddl_index_id_ = from.ddl_index_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      watt_stats_version_ = from.watt_stats_version_;
    }
    if (cached_has_bits & 0x00000040u) {
      need_ignore_ = from.need_ignore_;
    }
    if (cached_has_bits & 0x00000080u) {
      is_replace_ = from.is_replace_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      ddl_need_write_ = from.ddl_need_write_;
    }
    if (cached_has_bits & 0x00000200u) {
      is_merge_ = from.is_merge_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InsertNode::CopyFrom(const InsertNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.InsertNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InsertNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(update_slots_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(update_exprs_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(insert_values_)) return false;
  return true;
}

void InsertNode::InternalSwap(InsertNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  records_.InternalSwap(&other->records_);
  update_slots_.InternalSwap(&other->update_slots_);
  update_exprs_.InternalSwap(&other->update_exprs_);
  field_ids_.InternalSwap(&other->field_ids_);
  insert_values_.InternalSwap(&other->insert_values_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InsertNode, is_merge_)
      + sizeof(InsertNode::is_merge_)
      - PROTOBUF_FIELD_OFFSET(InsertNode, table_id_)>(
          reinterpret_cast<char*>(&table_id_),
          reinterpret_cast<char*>(&other->table_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InsertNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[14]);
}

// ===================================================================

class LockPrimaryNode::_Internal {
 public:
  using HasBits = decltype(std::declval<LockPrimaryNode>()._has_bits_);
  static void set_has_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lock_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_affect_primary(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_row_ttl_duration_s(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

void LockPrimaryNode::clear_conjuncts() {
  conjuncts_.Clear();
}
LockPrimaryNode::LockPrimaryNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  put_records_(arena),
  delete_records_(arena),
  affect_index_ids_(arena),
  conjuncts_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.LockPrimaryNode)
}
LockPrimaryNode::LockPrimaryNode(const LockPrimaryNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      put_records_(from.put_records_),
      delete_records_(from.delete_records_),
      affect_index_ids_(from.affect_index_ids_),
      conjuncts_(from.conjuncts_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&table_id_, &from.table_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&affect_primary_) -
    reinterpret_cast<char*>(&table_id_)) + sizeof(affect_primary_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.LockPrimaryNode)
}

void LockPrimaryNode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&table_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&lock_type_) -
    reinterpret_cast<char*>(&table_id_)) + sizeof(lock_type_));
affect_primary_ = true;
}

LockPrimaryNode::~LockPrimaryNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.LockPrimaryNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LockPrimaryNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LockPrimaryNode::ArenaDtor(void* object) {
  LockPrimaryNode* _this = reinterpret_cast< LockPrimaryNode* >(object);
  (void)_this;
}
void LockPrimaryNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LockPrimaryNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LockPrimaryNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.LockPrimaryNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  put_records_.Clear();
  delete_records_.Clear();
  affect_index_ids_.Clear();
  conjuncts_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&table_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lock_type_) -
        reinterpret_cast<char*>(&table_id_)) + sizeof(lock_type_));
    affect_primary_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LockPrimaryNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 table_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_table_id(&has_bits);
          table_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .baikaldb.pb.LockCmdType lock_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::LockCmdType_IsValid(val))) {
            _internal_set_lock_type(static_cast<::baikaldb::pb::LockCmdType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated bytes put_records = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_put_records();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes delete_records = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_delete_records();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool affect_primary = 5 [default = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_affect_primary(&has_bits);
          affect_primary_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 affect_index_ids = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_affect_index_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_affect_index_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 row_ttl_duration_s = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_row_ttl_duration_s(&has_bits);
          row_ttl_duration_s_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr conjuncts = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_conjuncts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LockPrimaryNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.LockPrimaryNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 table_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_table_id(), target);
  }

  // required .baikaldb.pb.LockCmdType lock_type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_lock_type(), target);
  }

  // repeated bytes put_records = 3;
  for (int i = 0, n = this->_internal_put_records_size(); i < n; i++) {
    const auto& s = this->_internal_put_records(i);
    target = stream->WriteBytes(3, s, target);
  }

  // repeated bytes delete_records = 4;
  for (int i = 0, n = this->_internal_delete_records_size(); i < n; i++) {
    const auto& s = this->_internal_delete_records(i);
    target = stream->WriteBytes(4, s, target);
  }

  // optional bool affect_primary = 5 [default = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_affect_primary(), target);
  }

  // repeated int64 affect_index_ids = 6;
  for (int i = 0, n = this->_internal_affect_index_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_affect_index_ids(i), target);
  }

  // optional int64 row_ttl_duration_s = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(7, this->_internal_row_ttl_duration_s(), target);
  }

  // repeated .baikaldb.pb.Expr conjuncts = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_conjuncts_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_conjuncts(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.LockPrimaryNode)
  return target;
}

size_t LockPrimaryNode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.LockPrimaryNode)
  size_t total_size = 0;

  if (_internal_has_table_id()) {
    // required int64 table_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_table_id());
  }

  if (_internal_has_lock_type()) {
    // required .baikaldb.pb.LockCmdType lock_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_lock_type());
  }

  return total_size;
}
size_t LockPrimaryNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.LockPrimaryNode)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required int64 table_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_table_id());

    // required .baikaldb.pb.LockCmdType lock_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_lock_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes put_records = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(put_records_.size());
  for (int i = 0, n = put_records_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      put_records_.Get(i));
  }

  // repeated bytes delete_records = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(delete_records_.size());
  for (int i = 0, n = delete_records_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      delete_records_.Get(i));
  }

  // repeated int64 affect_index_ids = 6;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->affect_index_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_affect_index_ids_size());
    total_size += data_size;
  }

  // repeated .baikaldb.pb.Expr conjuncts = 8;
  total_size += 1UL * this->_internal_conjuncts_size();
  for (const auto& msg : this->conjuncts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int64 row_ttl_duration_s = 7;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_row_ttl_duration_s());
  }

  // optional bool affect_primary = 5 [default = true];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LockPrimaryNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LockPrimaryNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LockPrimaryNode::GetClassData() const { return &_class_data_; }

void LockPrimaryNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LockPrimaryNode *>(to)->MergeFrom(
      static_cast<const LockPrimaryNode &>(from));
}


void LockPrimaryNode::MergeFrom(const LockPrimaryNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.LockPrimaryNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  put_records_.MergeFrom(from.put_records_);
  delete_records_.MergeFrom(from.delete_records_);
  affect_index_ids_.MergeFrom(from.affect_index_ids_);
  conjuncts_.MergeFrom(from.conjuncts_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      table_id_ = from.table_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      row_ttl_duration_s_ = from.row_ttl_duration_s_;
    }
    if (cached_has_bits & 0x00000004u) {
      lock_type_ = from.lock_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      affect_primary_ = from.affect_primary_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LockPrimaryNode::CopyFrom(const LockPrimaryNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.LockPrimaryNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LockPrimaryNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(conjuncts_)) return false;
  return true;
}

void LockPrimaryNode::InternalSwap(LockPrimaryNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  put_records_.InternalSwap(&other->put_records_);
  delete_records_.InternalSwap(&other->delete_records_);
  affect_index_ids_.InternalSwap(&other->affect_index_ids_);
  conjuncts_.InternalSwap(&other->conjuncts_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LockPrimaryNode, lock_type_)
      + sizeof(LockPrimaryNode::lock_type_)
      - PROTOBUF_FIELD_OFFSET(LockPrimaryNode, table_id_)>(
          reinterpret_cast<char*>(&table_id_),
          reinterpret_cast<char*>(&other->table_id_));
  swap(affect_primary_, other->affect_primary_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LockPrimaryNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[15]);
}

// ===================================================================

class LockSecondaryNode::_Internal {
 public:
  using HasBits = decltype(std::declval<LockSecondaryNode>()._has_bits_);
  static void set_has_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_global_index_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_lock_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lock_secondary_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_row_ttl_duration_s(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

LockSecondaryNode::LockSecondaryNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  put_records_(arena),
  delete_records_(arena),
  global_ddl_ttl_timestamp_us_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.LockSecondaryNode)
}
LockSecondaryNode::LockSecondaryNode(const LockSecondaryNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      put_records_(from.put_records_),
      delete_records_(from.delete_records_),
      global_ddl_ttl_timestamp_us_(from.global_ddl_ttl_timestamp_us_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&table_id_, &from.table_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&row_ttl_duration_s_) -
    reinterpret_cast<char*>(&table_id_)) + sizeof(row_ttl_duration_s_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.LockSecondaryNode)
}

void LockSecondaryNode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&table_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&row_ttl_duration_s_) -
    reinterpret_cast<char*>(&table_id_)) + sizeof(row_ttl_duration_s_));
}

LockSecondaryNode::~LockSecondaryNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.LockSecondaryNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LockSecondaryNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LockSecondaryNode::ArenaDtor(void* object) {
  LockSecondaryNode* _this = reinterpret_cast< LockSecondaryNode* >(object);
  (void)_this;
}
void LockSecondaryNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LockSecondaryNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LockSecondaryNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.LockSecondaryNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  put_records_.Clear();
  delete_records_.Clear();
  global_ddl_ttl_timestamp_us_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&table_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&row_ttl_duration_s_) -
        reinterpret_cast<char*>(&table_id_)) + sizeof(row_ttl_duration_s_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LockSecondaryNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 table_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_table_id(&has_bits);
          table_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 global_index_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_global_index_id(&has_bits);
          global_index_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .baikaldb.pb.LockCmdType lock_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::LockCmdType_IsValid(val))) {
            _internal_set_lock_type(static_cast<::baikaldb::pb::LockCmdType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated bytes put_records = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_put_records();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes delete_records = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_delete_records();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.LockSecondaryType lock_secondary_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::LockSecondaryType_IsValid(val))) {
            _internal_set_lock_secondary_type(static_cast<::baikaldb::pb::LockSecondaryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 row_ttl_duration_s = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_row_ttl_duration_s(&has_bits);
          row_ttl_duration_s_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 global_ddl_ttl_timestamp_us = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_global_ddl_ttl_timestamp_us(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_global_ddl_ttl_timestamp_us(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LockSecondaryNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.LockSecondaryNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 table_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_table_id(), target);
  }

  // required int64 global_index_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_global_index_id(), target);
  }

  // required .baikaldb.pb.LockCmdType lock_type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_lock_type(), target);
  }

  // repeated bytes put_records = 4;
  for (int i = 0, n = this->_internal_put_records_size(); i < n; i++) {
    const auto& s = this->_internal_put_records(i);
    target = stream->WriteBytes(4, s, target);
  }

  // repeated bytes delete_records = 5;
  for (int i = 0, n = this->_internal_delete_records_size(); i < n; i++) {
    const auto& s = this->_internal_delete_records(i);
    target = stream->WriteBytes(5, s, target);
  }

  // optional .baikaldb.pb.LockSecondaryType lock_secondary_type = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_lock_secondary_type(), target);
  }

  // optional int64 row_ttl_duration_s = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(7, this->_internal_row_ttl_duration_s(), target);
  }

  // repeated int64 global_ddl_ttl_timestamp_us = 8;
  for (int i = 0, n = this->_internal_global_ddl_ttl_timestamp_us_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(8, this->_internal_global_ddl_ttl_timestamp_us(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.LockSecondaryNode)
  return target;
}

size_t LockSecondaryNode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.LockSecondaryNode)
  size_t total_size = 0;

  if (_internal_has_table_id()) {
    // required int64 table_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_table_id());
  }

  if (_internal_has_global_index_id()) {
    // required int64 global_index_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_global_index_id());
  }

  if (_internal_has_lock_type()) {
    // required .baikaldb.pb.LockCmdType lock_type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_lock_type());
  }

  return total_size;
}
size_t LockSecondaryNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.LockSecondaryNode)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required int64 table_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_table_id());

    // required int64 global_index_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_global_index_id());

    // required .baikaldb.pb.LockCmdType lock_type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_lock_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes put_records = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(put_records_.size());
  for (int i = 0, n = put_records_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      put_records_.Get(i));
  }

  // repeated bytes delete_records = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(delete_records_.size());
  for (int i = 0, n = delete_records_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      delete_records_.Get(i));
  }

  // repeated int64 global_ddl_ttl_timestamp_us = 8;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->global_ddl_ttl_timestamp_us_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_global_ddl_ttl_timestamp_us_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000018u) {
    // optional .baikaldb.pb.LockSecondaryType lock_secondary_type = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_lock_secondary_type());
    }

    // optional int64 row_ttl_duration_s = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_row_ttl_duration_s());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LockSecondaryNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LockSecondaryNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LockSecondaryNode::GetClassData() const { return &_class_data_; }

void LockSecondaryNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LockSecondaryNode *>(to)->MergeFrom(
      static_cast<const LockSecondaryNode &>(from));
}


void LockSecondaryNode::MergeFrom(const LockSecondaryNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.LockSecondaryNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  put_records_.MergeFrom(from.put_records_);
  delete_records_.MergeFrom(from.delete_records_);
  global_ddl_ttl_timestamp_us_.MergeFrom(from.global_ddl_ttl_timestamp_us_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      table_id_ = from.table_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      global_index_id_ = from.global_index_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      lock_type_ = from.lock_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      lock_secondary_type_ = from.lock_secondary_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      row_ttl_duration_s_ = from.row_ttl_duration_s_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LockSecondaryNode::CopyFrom(const LockSecondaryNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.LockSecondaryNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LockSecondaryNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void LockSecondaryNode::InternalSwap(LockSecondaryNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  put_records_.InternalSwap(&other->put_records_);
  delete_records_.InternalSwap(&other->delete_records_);
  global_ddl_ttl_timestamp_us_.InternalSwap(&other->global_ddl_ttl_timestamp_us_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LockSecondaryNode, row_ttl_duration_s_)
      + sizeof(LockSecondaryNode::row_ttl_duration_s_)
      - PROTOBUF_FIELD_OFFSET(LockSecondaryNode, table_id_)>(
          reinterpret_cast<char*>(&table_id_),
          reinterpret_cast<char*>(&other->table_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LockSecondaryNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[16]);
}

// ===================================================================

class DeleteNode::_Internal {
 public:
  using HasBits = decltype(std::declval<DeleteNode>()._has_bits_);
  static void set_has_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

void DeleteNode::clear_primary_slots() {
  primary_slots_.Clear();
}
DeleteNode::DeleteNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  primary_slots_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.DeleteNode)
}
DeleteNode::DeleteNode(const DeleteNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      primary_slots_(from.primary_slots_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  table_id_ = from.table_id_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.DeleteNode)
}

void DeleteNode::SharedCtor() {
table_id_ = int64_t{0};
}

DeleteNode::~DeleteNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.DeleteNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DeleteNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeleteNode::ArenaDtor(void* object) {
  DeleteNode* _this = reinterpret_cast< DeleteNode* >(object);
  (void)_this;
}
void DeleteNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DeleteNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DeleteNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.DeleteNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  primary_slots_.Clear();
  table_id_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DeleteNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 table_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_table_id(&has_bits);
          table_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.SlotDescriptor primary_slots = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_primary_slots(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DeleteNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.DeleteNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 table_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_table_id(), target);
  }

  // repeated .baikaldb.pb.SlotDescriptor primary_slots = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_primary_slots_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_primary_slots(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.DeleteNode)
  return target;
}

size_t DeleteNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.DeleteNode)
  size_t total_size = 0;

  // required int64 table_id = 1;
  if (_internal_has_table_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_table_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.SlotDescriptor primary_slots = 2;
  total_size += 1UL * this->_internal_primary_slots_size();
  for (const auto& msg : this->primary_slots_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DeleteNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DeleteNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DeleteNode::GetClassData() const { return &_class_data_; }

void DeleteNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DeleteNode *>(to)->MergeFrom(
      static_cast<const DeleteNode &>(from));
}


void DeleteNode::MergeFrom(const DeleteNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.DeleteNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  primary_slots_.MergeFrom(from.primary_slots_);
  if (from._internal_has_table_id()) {
    _internal_set_table_id(from._internal_table_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DeleteNode::CopyFrom(const DeleteNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.DeleteNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeleteNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(primary_slots_)) return false;
  return true;
}

void DeleteNode::InternalSwap(DeleteNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  primary_slots_.InternalSwap(&other->primary_slots_);
  swap(table_id_, other->table_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DeleteNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[17]);
}

// ===================================================================

class TruncateNode::_Internal {
 public:
  using HasBits = decltype(std::declval<TruncateNode>()._has_bits_);
  static void set_has_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TruncateNode::TruncateNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.TruncateNode)
}
TruncateNode::TruncateNode(const TruncateNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  table_id_ = from.table_id_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.TruncateNode)
}

void TruncateNode::SharedCtor() {
table_id_ = int64_t{0};
}

TruncateNode::~TruncateNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.TruncateNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TruncateNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TruncateNode::ArenaDtor(void* object) {
  TruncateNode* _this = reinterpret_cast< TruncateNode* >(object);
  (void)_this;
}
void TruncateNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TruncateNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TruncateNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.TruncateNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  table_id_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TruncateNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 table_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_table_id(&has_bits);
          table_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TruncateNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.TruncateNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 table_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_table_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.TruncateNode)
  return target;
}

size_t TruncateNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.TruncateNode)
  size_t total_size = 0;

  // required int64 table_id = 1;
  if (_internal_has_table_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_table_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TruncateNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TruncateNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TruncateNode::GetClassData() const { return &_class_data_; }

void TruncateNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TruncateNode *>(to)->MergeFrom(
      static_cast<const TruncateNode &>(from));
}


void TruncateNode::MergeFrom(const TruncateNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.TruncateNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_table_id()) {
    _internal_set_table_id(from._internal_table_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TruncateNode::CopyFrom(const TruncateNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.TruncateNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TruncateNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TruncateNode::InternalSwap(TruncateNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(table_id_, other->table_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TruncateNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[18]);
}

// ===================================================================

class UpdateNode::_Internal {
 public:
  using HasBits = decltype(std::declval<UpdateNode>()._has_bits_);
  static void set_has_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_row_ttl_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

void UpdateNode::clear_primary_slots() {
  primary_slots_.Clear();
}
void UpdateNode::clear_update_slots() {
  update_slots_.Clear();
}
void UpdateNode::clear_update_exprs() {
  update_exprs_.Clear();
}
UpdateNode::UpdateNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  primary_slots_(arena),
  update_slots_(arena),
  update_exprs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.UpdateNode)
}
UpdateNode::UpdateNode(const UpdateNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      primary_slots_(from.primary_slots_),
      update_slots_(from.update_slots_),
      update_exprs_(from.update_exprs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&table_id_, &from.table_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&row_ttl_duration_) -
    reinterpret_cast<char*>(&table_id_)) + sizeof(row_ttl_duration_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.UpdateNode)
}

void UpdateNode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&table_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&row_ttl_duration_) -
    reinterpret_cast<char*>(&table_id_)) + sizeof(row_ttl_duration_));
}

UpdateNode::~UpdateNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.UpdateNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UpdateNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UpdateNode::ArenaDtor(void* object) {
  UpdateNode* _this = reinterpret_cast< UpdateNode* >(object);
  (void)_this;
}
void UpdateNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UpdateNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UpdateNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.UpdateNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  primary_slots_.Clear();
  update_slots_.Clear();
  update_exprs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&table_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&row_ttl_duration_) -
        reinterpret_cast<char*>(&table_id_)) + sizeof(row_ttl_duration_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 table_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_table_id(&has_bits);
          table_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.SlotDescriptor primary_slots = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_primary_slots(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.SlotDescriptor update_slots = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_update_slots(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr update_exprs = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_update_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 row_ttl_duration = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_row_ttl_duration(&has_bits);
          row_ttl_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UpdateNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.UpdateNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 table_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_table_id(), target);
  }

  // repeated .baikaldb.pb.SlotDescriptor primary_slots = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_primary_slots_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_primary_slots(i), target, stream);
  }

  // repeated .baikaldb.pb.SlotDescriptor update_slots = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_update_slots_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_update_slots(i), target, stream);
  }

  // repeated .baikaldb.pb.Expr update_exprs = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_update_exprs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_update_exprs(i), target, stream);
  }

  // optional int64 row_ttl_duration = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_row_ttl_duration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.UpdateNode)
  return target;
}

size_t UpdateNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.UpdateNode)
  size_t total_size = 0;

  // required int64 table_id = 1;
  if (_internal_has_table_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_table_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.SlotDescriptor primary_slots = 2;
  total_size += 1UL * this->_internal_primary_slots_size();
  for (const auto& msg : this->primary_slots_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.SlotDescriptor update_slots = 3;
  total_size += 1UL * this->_internal_update_slots_size();
  for (const auto& msg : this->update_slots_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.Expr update_exprs = 4;
  total_size += 1UL * this->_internal_update_exprs_size();
  for (const auto& msg : this->update_exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int64 row_ttl_duration = 6;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_row_ttl_duration());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UpdateNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNode::GetClassData() const { return &_class_data_; }

void UpdateNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UpdateNode *>(to)->MergeFrom(
      static_cast<const UpdateNode &>(from));
}


void UpdateNode::MergeFrom(const UpdateNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.UpdateNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  primary_slots_.MergeFrom(from.primary_slots_);
  update_slots_.MergeFrom(from.update_slots_);
  update_exprs_.MergeFrom(from.update_exprs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      table_id_ = from.table_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      row_ttl_duration_ = from.row_ttl_duration_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNode::CopyFrom(const UpdateNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.UpdateNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(primary_slots_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(update_slots_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(update_exprs_)) return false;
  return true;
}

void UpdateNode::InternalSwap(UpdateNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  primary_slots_.InternalSwap(&other->primary_slots_);
  update_slots_.InternalSwap(&other->update_slots_);
  update_exprs_.InternalSwap(&other->update_exprs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateNode, row_ttl_duration_)
      + sizeof(UpdateNode::row_ttl_duration_)
      - PROTOBUF_FIELD_OFFSET(UpdateNode, table_id_)>(
          reinterpret_cast<char*>(&table_id_),
          reinterpret_cast<char*>(&other->table_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[19]);
}

// ===================================================================

class PacketNode::_Internal {
 public:
  using HasBits = decltype(std::declval<PacketNode>()._has_bits_);
  static void set_has_op_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

void PacketNode::clear_projections() {
  projections_.Clear();
}
PacketNode::PacketNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  projections_(arena),
  col_names_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.PacketNode)
}
PacketNode::PacketNode(const PacketNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      projections_(from.projections_),
      col_names_(from.col_names_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  op_type_ = from.op_type_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.PacketNode)
}

void PacketNode::SharedCtor() {
op_type_ = 0;
}

PacketNode::~PacketNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.PacketNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PacketNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PacketNode::ArenaDtor(void* object) {
  PacketNode* _this = reinterpret_cast< PacketNode* >(object);
  (void)_this;
}
void PacketNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PacketNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PacketNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.PacketNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  projections_.Clear();
  col_names_.Clear();
  op_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PacketNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.OpType op_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::OpType_IsValid(val))) {
            _internal_set_op_type(static_cast<::baikaldb::pb::OpType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr projections = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_projections(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string col_names = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_col_names();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.PacketNode.col_names");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PacketNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.PacketNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.OpType op_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_op_type(), target);
  }

  // repeated .baikaldb.pb.Expr projections = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_projections_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_projections(i), target, stream);
  }

  // repeated string col_names = 3;
  for (int i = 0, n = this->_internal_col_names_size(); i < n; i++) {
    const auto& s = this->_internal_col_names(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.PacketNode.col_names");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.PacketNode)
  return target;
}

size_t PacketNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.PacketNode)
  size_t total_size = 0;

  // required .baikaldb.pb.OpType op_type = 1;
  if (_internal_has_op_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_op_type());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr projections = 2;
  total_size += 1UL * this->_internal_projections_size();
  for (const auto& msg : this->projections_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string col_names = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(col_names_.size());
  for (int i = 0, n = col_names_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      col_names_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PacketNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PacketNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PacketNode::GetClassData() const { return &_class_data_; }

void PacketNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PacketNode *>(to)->MergeFrom(
      static_cast<const PacketNode &>(from));
}


void PacketNode::MergeFrom(const PacketNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.PacketNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  projections_.MergeFrom(from.projections_);
  col_names_.MergeFrom(from.col_names_);
  if (from._internal_has_op_type()) {
    _internal_set_op_type(from._internal_op_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PacketNode::CopyFrom(const PacketNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.PacketNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PacketNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(projections_)) return false;
  return true;
}

void PacketNode::InternalSwap(PacketNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  projections_.InternalSwap(&other->projections_);
  col_names_.InternalSwap(&other->col_names_);
  swap(op_type_, other->op_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PacketNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[20]);
}

// ===================================================================

class TransactionNode::_Internal {
 public:
  using HasBits = decltype(std::declval<TransactionNode>()._has_bits_);
  static void set_has_txn_cmd(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_txn_timeout(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_txn_lock_timeout(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000004) ^ 0x00000004) != 0;
  }
};

TransactionNode::TransactionNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.TransactionNode)
}
TransactionNode::TransactionNode(const TransactionNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&txn_timeout_, &from.txn_timeout_,
    static_cast<size_t>(reinterpret_cast<char*>(&txn_cmd_) -
    reinterpret_cast<char*>(&txn_timeout_)) + sizeof(txn_cmd_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.TransactionNode)
}

void TransactionNode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&txn_timeout_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&txn_cmd_) -
    reinterpret_cast<char*>(&txn_timeout_)) + sizeof(txn_cmd_));
}

TransactionNode::~TransactionNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.TransactionNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TransactionNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TransactionNode::ArenaDtor(void* object) {
  TransactionNode* _this = reinterpret_cast< TransactionNode* >(object);
  (void)_this;
}
void TransactionNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TransactionNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TransactionNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.TransactionNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&txn_timeout_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&txn_cmd_) -
        reinterpret_cast<char*>(&txn_timeout_)) + sizeof(txn_cmd_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransactionNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.TxnCmdType txn_cmd = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::TxnCmdType_IsValid(val))) {
            _internal_set_txn_cmd(static_cast<::baikaldb::pb::TxnCmdType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 txn_timeout = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_txn_timeout(&has_bits);
          txn_timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 txn_lock_timeout = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_txn_lock_timeout(&has_bits);
          txn_lock_timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TransactionNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.TransactionNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.TxnCmdType txn_cmd = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_txn_cmd(), target);
  }

  // optional int64 txn_timeout = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_txn_timeout(), target);
  }

  // optional int64 txn_lock_timeout = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_txn_lock_timeout(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.TransactionNode)
  return target;
}

size_t TransactionNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.TransactionNode)
  size_t total_size = 0;

  // required .baikaldb.pb.TxnCmdType txn_cmd = 1;
  if (_internal_has_txn_cmd()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_txn_cmd());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 txn_timeout = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_txn_timeout());
    }

    // optional int64 txn_lock_timeout = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_txn_lock_timeout());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransactionNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TransactionNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransactionNode::GetClassData() const { return &_class_data_; }

void TransactionNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TransactionNode *>(to)->MergeFrom(
      static_cast<const TransactionNode &>(from));
}


void TransactionNode::MergeFrom(const TransactionNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.TransactionNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      txn_timeout_ = from.txn_timeout_;
    }
    if (cached_has_bits & 0x00000002u) {
      txn_lock_timeout_ = from.txn_lock_timeout_;
    }
    if (cached_has_bits & 0x00000004u) {
      txn_cmd_ = from.txn_cmd_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransactionNode::CopyFrom(const TransactionNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.TransactionNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TransactionNode::InternalSwap(TransactionNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TransactionNode, txn_cmd_)
      + sizeof(TransactionNode::txn_cmd_)
      - PROTOBUF_FIELD_OFFSET(TransactionNode, txn_timeout_)>(
          reinterpret_cast<char*>(&txn_timeout_),
          reinterpret_cast<char*>(&other->txn_timeout_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TransactionNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[21]);
}

// ===================================================================

class KillNode::_Internal {
 public:
  using HasBits = decltype(std::declval<KillNode>()._has_bits_);
  static void set_has_db_conn_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_query(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

KillNode::KillNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.KillNode)
}
KillNode::KillNode(const KillNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&db_conn_id_, &from.db_conn_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_query_) -
    reinterpret_cast<char*>(&db_conn_id_)) + sizeof(is_query_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.KillNode)
}

void KillNode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&db_conn_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_query_) -
    reinterpret_cast<char*>(&db_conn_id_)) + sizeof(is_query_));
}

KillNode::~KillNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.KillNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void KillNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KillNode::ArenaDtor(void* object) {
  KillNode* _this = reinterpret_cast< KillNode* >(object);
  (void)_this;
}
void KillNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KillNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KillNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.KillNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&db_conn_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_query_) -
        reinterpret_cast<char*>(&db_conn_id_)) + sizeof(is_query_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KillNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 db_conn_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_db_conn_id(&has_bits);
          db_conn_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_query = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_is_query(&has_bits);
          is_query_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* KillNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.KillNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 db_conn_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_db_conn_id(), target);
  }

  // optional bool is_query = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_is_query(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.KillNode)
  return target;
}

size_t KillNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.KillNode)
  size_t total_size = 0;

  // required uint64 db_conn_id = 1;
  if (_internal_has_db_conn_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_db_conn_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool is_query = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KillNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    KillNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KillNode::GetClassData() const { return &_class_data_; }

void KillNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<KillNode *>(to)->MergeFrom(
      static_cast<const KillNode &>(from));
}


void KillNode::MergeFrom(const KillNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.KillNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      db_conn_id_ = from.db_conn_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_query_ = from.is_query_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KillNode::CopyFrom(const KillNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.KillNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KillNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void KillNode::InternalSwap(KillNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KillNode, is_query_)
      + sizeof(KillNode::is_query_)
      - PROTOBUF_FIELD_OFFSET(KillNode, db_conn_id_)>(
          reinterpret_cast<char*>(&db_conn_id_),
          reinterpret_cast<char*>(&other->db_conn_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KillNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[22]);
}

// ===================================================================

class UnionNode::_Internal {
 public:
  using HasBits = decltype(std::declval<UnionNode>()._has_bits_);
  static void set_has_union_tuple_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

void UnionNode::clear_slot_order_exprs() {
  slot_order_exprs_.Clear();
}
UnionNode::UnionNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  slot_order_exprs_(arena),
  is_asc_(arena),
  is_null_first_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.UnionNode)
}
UnionNode::UnionNode(const UnionNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      slot_order_exprs_(from.slot_order_exprs_),
      is_asc_(from.is_asc_),
      is_null_first_(from.is_null_first_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  union_tuple_id_ = from.union_tuple_id_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.UnionNode)
}

void UnionNode::SharedCtor() {
union_tuple_id_ = 0;
}

UnionNode::~UnionNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.UnionNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UnionNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UnionNode::ArenaDtor(void* object) {
  UnionNode* _this = reinterpret_cast< UnionNode* >(object);
  (void)_this;
}
void UnionNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UnionNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UnionNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.UnionNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  slot_order_exprs_.Clear();
  is_asc_.Clear();
  is_null_first_.Clear();
  union_tuple_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UnionNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 union_tuple_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_union_tuple_id(&has_bits);
          union_tuple_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr slot_order_exprs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_slot_order_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bool is_asc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_is_asc(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_is_asc(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool is_null_first = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_is_null_first(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_is_null_first(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UnionNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.UnionNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 union_tuple_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_union_tuple_id(), target);
  }

  // repeated .baikaldb.pb.Expr slot_order_exprs = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_slot_order_exprs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_slot_order_exprs(i), target, stream);
  }

  // repeated bool is_asc = 3;
  for (int i = 0, n = this->_internal_is_asc_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_is_asc(i), target);
  }

  // repeated bool is_null_first = 4;
  for (int i = 0, n = this->_internal_is_null_first_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_null_first(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.UnionNode)
  return target;
}

size_t UnionNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.UnionNode)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr slot_order_exprs = 2;
  total_size += 1UL * this->_internal_slot_order_exprs_size();
  for (const auto& msg : this->slot_order_exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated bool is_asc = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_is_asc_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_is_asc_size());
    total_size += data_size;
  }

  // repeated bool is_null_first = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_is_null_first_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_is_null_first_size());
    total_size += data_size;
  }

  // optional int32 union_tuple_id = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_union_tuple_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UnionNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UnionNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UnionNode::GetClassData() const { return &_class_data_; }

void UnionNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UnionNode *>(to)->MergeFrom(
      static_cast<const UnionNode &>(from));
}


void UnionNode::MergeFrom(const UnionNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.UnionNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  slot_order_exprs_.MergeFrom(from.slot_order_exprs_);
  is_asc_.MergeFrom(from.is_asc_);
  is_null_first_.MergeFrom(from.is_null_first_);
  if (from._internal_has_union_tuple_id()) {
    _internal_set_union_tuple_id(from._internal_union_tuple_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UnionNode::CopyFrom(const UnionNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.UnionNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnionNode::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(slot_order_exprs_)) return false;
  return true;
}

void UnionNode::InternalSwap(UnionNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  slot_order_exprs_.InternalSwap(&other->slot_order_exprs_);
  is_asc_.InternalSwap(&other->is_asc_);
  is_null_first_.InternalSwap(&other->is_null_first_);
  swap(union_tuple_id_, other->union_tuple_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UnionNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[23]);
}

// ===================================================================

class LoadNode::_Internal {
 public:
  using HasBits = decltype(std::declval<LoadNode>()._has_bits_);
  static void set_has_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_data_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ignore_lines(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_terminated(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enclosed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_escaped(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_line_starting(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_line_terminated(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_opt_enclosed(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_file_size(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_char_set(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000040) ^ 0x00000040) != 0;
  }
};

void LoadNode::clear_set_slots() {
  set_slots_.Clear();
}
void LoadNode::clear_set_exprs() {
  set_exprs_.Clear();
}
LoadNode::LoadNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  set_slots_(arena),
  set_exprs_(arena),
  field_ids_(arena),
  default_field_ids_(arena),
  ingore_field_indexes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.LoadNode)
}
LoadNode::LoadNode(const LoadNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      set_slots_(from.set_slots_),
      set_exprs_(from.set_exprs_),
      field_ids_(from.field_ids_),
      default_field_ids_(from.default_field_ids_),
      ingore_field_indexes_(from.ingore_field_indexes_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_data_path()) {
    data_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data_path(), 
      GetArenaForAllocation());
  }
  terminated_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_terminated()) {
    terminated_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_terminated(), 
      GetArenaForAllocation());
  }
  enclosed_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_enclosed()) {
    enclosed_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_enclosed(), 
      GetArenaForAllocation());
  }
  escaped_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_escaped()) {
    escaped_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_escaped(), 
      GetArenaForAllocation());
  }
  line_starting_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_line_starting()) {
    line_starting_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_line_starting(), 
      GetArenaForAllocation());
  }
  line_terminated_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_line_terminated()) {
    line_terminated_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_line_terminated(), 
      GetArenaForAllocation());
  }
  ::memcpy(&table_id_, &from.table_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&char_set_) -
    reinterpret_cast<char*>(&table_id_)) + sizeof(char_set_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.LoadNode)
}

void LoadNode::SharedCtor() {
data_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
terminated_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
enclosed_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
escaped_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
line_starting_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
line_terminated_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&table_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&char_set_) -
    reinterpret_cast<char*>(&table_id_)) + sizeof(char_set_));
}

LoadNode::~LoadNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.LoadNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LoadNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_path_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  terminated_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  enclosed_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  escaped_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  line_starting_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  line_terminated_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void LoadNode::ArenaDtor(void* object) {
  LoadNode* _this = reinterpret_cast< LoadNode* >(object);
  (void)_this;
}
void LoadNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LoadNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LoadNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.LoadNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  set_slots_.Clear();
  set_exprs_.Clear();
  field_ids_.Clear();
  default_field_ids_.Clear();
  ingore_field_indexes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      data_path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      terminated_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      enclosed_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      escaped_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      line_starting_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      line_terminated_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&table_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ignore_lines_) -
        reinterpret_cast<char*>(&table_id_)) + sizeof(ignore_lines_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&opt_enclosed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&char_set_) -
        reinterpret_cast<char*>(&opt_enclosed_)) + sizeof(char_set_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoadNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 table_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_table_id(&has_bits);
          table_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string data_path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_data_path();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.LoadNode.data_path");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.SlotDescriptor set_slots = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_set_slots(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr set_exprs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_set_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 field_ids = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_field_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_field_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 default_field_ids = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_default_field_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_default_field_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 ingore_field_indexes = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_ingore_field_indexes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_ingore_field_indexes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ignore_lines = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_ignore_lines(&has_bits);
          ignore_lines_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes terminated = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          auto str = _internal_mutable_terminated();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes enclosed = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          auto str = _internal_mutable_enclosed();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes escaped = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          auto str = _internal_mutable_escaped();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes line_starting = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          auto str = _internal_mutable_line_starting();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes line_terminated = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          auto str = _internal_mutable_line_terminated();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool opt_enclosed = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_opt_enclosed(&has_bits);
          opt_enclosed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 file_size = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_file_size(&has_bits);
          file_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.Charset char_set = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 136)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::Charset_IsValid(val))) {
            _internal_set_char_set(static_cast<::baikaldb::pb::Charset>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(17, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LoadNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.LoadNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 table_id = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_table_id(), target);
  }

  // optional string data_path = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_data_path().data(), static_cast<int>(this->_internal_data_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.LoadNode.data_path");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_data_path(), target);
  }

  // repeated .baikaldb.pb.SlotDescriptor set_slots = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_set_slots_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_set_slots(i), target, stream);
  }

  // repeated .baikaldb.pb.Expr set_exprs = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_set_exprs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_set_exprs(i), target, stream);
  }

  // repeated int32 field_ids = 6;
  for (int i = 0, n = this->_internal_field_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_field_ids(i), target);
  }

  // repeated int32 default_field_ids = 7;
  for (int i = 0, n = this->_internal_default_field_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_default_field_ids(i), target);
  }

  // repeated int32 ingore_field_indexes = 8;
  for (int i = 0, n = this->_internal_ingore_field_indexes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_ingore_field_indexes(i), target);
  }

  // optional int32 ignore_lines = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_ignore_lines(), target);
  }

  // optional bytes terminated = 10;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        10, this->_internal_terminated(), target);
  }

  // optional bytes enclosed = 11;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        11, this->_internal_enclosed(), target);
  }

  // optional bytes escaped = 12;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        12, this->_internal_escaped(), target);
  }

  // optional bytes line_starting = 13;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteBytesMaybeAliased(
        13, this->_internal_line_starting(), target);
  }

  // optional bytes line_terminated = 14;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        14, this->_internal_line_terminated(), target);
  }

  // optional bool opt_enclosed = 15;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_opt_enclosed(), target);
  }

  // optional int64 file_size = 16;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(16, this->_internal_file_size(), target);
  }

  // optional .baikaldb.pb.Charset char_set = 17;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      17, this->_internal_char_set(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.LoadNode)
  return target;
}

size_t LoadNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.LoadNode)
  size_t total_size = 0;

  // required int64 table_id = 1;
  if (_internal_has_table_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_table_id());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.SlotDescriptor set_slots = 4;
  total_size += 1UL * this->_internal_set_slots_size();
  for (const auto& msg : this->set_slots_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.Expr set_exprs = 5;
  total_size += 1UL * this->_internal_set_exprs_size();
  for (const auto& msg : this->set_exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 field_ids = 6;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->field_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_field_ids_size());
    total_size += data_size;
  }

  // repeated int32 default_field_ids = 7;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->default_field_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_default_field_ids_size());
    total_size += data_size;
  }

  // repeated int32 ingore_field_indexes = 8;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->ingore_field_indexes_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_ingore_field_indexes_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string data_path = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_data_path());
    }

    // optional bytes terminated = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_terminated());
    }

    // optional bytes enclosed = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_enclosed());
    }

    // optional bytes escaped = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_escaped());
    }

    // optional bytes line_starting = 13;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_line_starting());
    }

    // optional bytes line_terminated = 14;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_line_terminated());
    }

  }
  // optional int32 ignore_lines = 9;
  if (cached_has_bits & 0x00000080u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_ignore_lines());
  }

  if (cached_has_bits & 0x00000700u) {
    // optional bool opt_enclosed = 15;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional int64 file_size = 16;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_file_size());
    }

    // optional .baikaldb.pb.Charset char_set = 17;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_char_set());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LoadNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LoadNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LoadNode::GetClassData() const { return &_class_data_; }

void LoadNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LoadNode *>(to)->MergeFrom(
      static_cast<const LoadNode &>(from));
}


void LoadNode::MergeFrom(const LoadNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.LoadNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  set_slots_.MergeFrom(from.set_slots_);
  set_exprs_.MergeFrom(from.set_exprs_);
  field_ids_.MergeFrom(from.field_ids_);
  default_field_ids_.MergeFrom(from.default_field_ids_);
  ingore_field_indexes_.MergeFrom(from.ingore_field_indexes_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_data_path(from._internal_data_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_terminated(from._internal_terminated());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_enclosed(from._internal_enclosed());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_escaped(from._internal_escaped());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_line_starting(from._internal_line_starting());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_line_terminated(from._internal_line_terminated());
    }
    if (cached_has_bits & 0x00000040u) {
      table_id_ = from.table_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      ignore_lines_ = from.ignore_lines_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      opt_enclosed_ = from.opt_enclosed_;
    }
    if (cached_has_bits & 0x00000200u) {
      file_size_ = from.file_size_;
    }
    if (cached_has_bits & 0x00000400u) {
      char_set_ = from.char_set_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LoadNode::CopyFrom(const LoadNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.LoadNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(set_slots_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(set_exprs_)) return false;
  return true;
}

void LoadNode::InternalSwap(LoadNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  set_slots_.InternalSwap(&other->set_slots_);
  set_exprs_.InternalSwap(&other->set_exprs_);
  field_ids_.InternalSwap(&other->field_ids_);
  default_field_ids_.InternalSwap(&other->default_field_ids_);
  ingore_field_indexes_.InternalSwap(&other->ingore_field_indexes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_path_, lhs_arena,
      &other->data_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &terminated_, lhs_arena,
      &other->terminated_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &enclosed_, lhs_arena,
      &other->enclosed_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &escaped_, lhs_arena,
      &other->escaped_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &line_starting_, lhs_arena,
      &other->line_starting_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &line_terminated_, lhs_arena,
      &other->line_terminated_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoadNode, char_set_)
      + sizeof(LoadNode::char_set_)
      - PROTOBUF_FIELD_OFFSET(LoadNode, table_id_)>(
          reinterpret_cast<char*>(&table_id_),
          reinterpret_cast<char*>(&other->table_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LoadNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[24]);
}

// ===================================================================

class PartitionProperty::_Internal {
 public:
  using HasBits = decltype(std::declval<PartitionProperty>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

void PartitionProperty::clear_need_project_hash_exprs() {
  need_project_hash_exprs_.Clear();
}
PartitionProperty::PartitionProperty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  hash_cols_(arena),
  need_cast_string_cols_(arena),
  need_project_hash_cols_(arena),
  need_project_hash_exprs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.PartitionProperty)
}
PartitionProperty::PartitionProperty(const PartitionProperty& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      hash_cols_(from.hash_cols_),
      need_cast_string_cols_(from.need_cast_string_cols_),
      need_project_hash_cols_(from.need_project_hash_cols_),
      need_project_hash_exprs_(from.need_project_hash_exprs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.PartitionProperty)
}

void PartitionProperty::SharedCtor() {
type_ = 1;
}

PartitionProperty::~PartitionProperty() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.PartitionProperty)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PartitionProperty::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PartitionProperty::ArenaDtor(void* object) {
  PartitionProperty* _this = reinterpret_cast< PartitionProperty* >(object);
  (void)_this;
}
void PartitionProperty::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PartitionProperty::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PartitionProperty::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.PartitionProperty)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  hash_cols_.Clear();
  need_cast_string_cols_.Clear();
  need_project_hash_cols_.Clear();
  need_project_hash_exprs_.Clear();
  type_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PartitionProperty::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.PartitionPropertyType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::PartitionPropertyType_IsValid(val))) {
            _internal_set_type(static_cast<::baikaldb::pb::PartitionPropertyType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated bytes hash_cols = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_hash_cols();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes need_cast_string_cols = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_need_cast_string_cols();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes need_project_hash_cols = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_need_project_hash_cols();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr need_project_hash_exprs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_need_project_hash_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PartitionProperty::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.PartitionProperty)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.PartitionPropertyType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // repeated bytes hash_cols = 2;
  for (int i = 0, n = this->_internal_hash_cols_size(); i < n; i++) {
    const auto& s = this->_internal_hash_cols(i);
    target = stream->WriteBytes(2, s, target);
  }

  // repeated bytes need_cast_string_cols = 3;
  for (int i = 0, n = this->_internal_need_cast_string_cols_size(); i < n; i++) {
    const auto& s = this->_internal_need_cast_string_cols(i);
    target = stream->WriteBytes(3, s, target);
  }

  // repeated bytes need_project_hash_cols = 4;
  for (int i = 0, n = this->_internal_need_project_hash_cols_size(); i < n; i++) {
    const auto& s = this->_internal_need_project_hash_cols(i);
    target = stream->WriteBytes(4, s, target);
  }

  // repeated .baikaldb.pb.Expr need_project_hash_exprs = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_need_project_hash_exprs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_need_project_hash_exprs(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.PartitionProperty)
  return target;
}

size_t PartitionProperty::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.PartitionProperty)
  size_t total_size = 0;

  // required .baikaldb.pb.PartitionPropertyType type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes hash_cols = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(hash_cols_.size());
  for (int i = 0, n = hash_cols_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      hash_cols_.Get(i));
  }

  // repeated bytes need_cast_string_cols = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(need_cast_string_cols_.size());
  for (int i = 0, n = need_cast_string_cols_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      need_cast_string_cols_.Get(i));
  }

  // repeated bytes need_project_hash_cols = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(need_project_hash_cols_.size());
  for (int i = 0, n = need_project_hash_cols_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      need_project_hash_cols_.Get(i));
  }

  // repeated .baikaldb.pb.Expr need_project_hash_exprs = 5;
  total_size += 1UL * this->_internal_need_project_hash_exprs_size();
  for (const auto& msg : this->need_project_hash_exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PartitionProperty::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PartitionProperty::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PartitionProperty::GetClassData() const { return &_class_data_; }

void PartitionProperty::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PartitionProperty *>(to)->MergeFrom(
      static_cast<const PartitionProperty &>(from));
}


void PartitionProperty::MergeFrom(const PartitionProperty& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.PartitionProperty)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  hash_cols_.MergeFrom(from.hash_cols_);
  need_cast_string_cols_.MergeFrom(from.need_cast_string_cols_);
  need_project_hash_cols_.MergeFrom(from.need_project_hash_cols_);
  need_project_hash_exprs_.MergeFrom(from.need_project_hash_exprs_);
  if (from._internal_has_type()) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PartitionProperty::CopyFrom(const PartitionProperty& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.PartitionProperty)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PartitionProperty::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(need_project_hash_exprs_)) return false;
  return true;
}

void PartitionProperty::InternalSwap(PartitionProperty* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  hash_cols_.InternalSwap(&other->hash_cols_);
  need_cast_string_cols_.InternalSwap(&other->need_cast_string_cols_);
  need_project_hash_cols_.InternalSwap(&other->need_project_hash_cols_);
  need_project_hash_exprs_.InternalSwap(&other->need_project_hash_exprs_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PartitionProperty::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[25]);
}

// ===================================================================

class ExchangeDestination::_Internal {
 public:
  using HasBits = decltype(std::declval<ExchangeDestination>()._has_bits_);
  static void set_has_fragment_instance_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

ExchangeDestination::ExchangeDestination(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.ExchangeDestination)
}
ExchangeDestination::ExchangeDestination(const ExchangeDestination& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_address()) {
    address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_address(), 
      GetArenaForAllocation());
  }
  ::memcpy(&fragment_instance_id_, &from.fragment_instance_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&node_id_) -
    reinterpret_cast<char*>(&fragment_instance_id_)) + sizeof(node_id_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.ExchangeDestination)
}

void ExchangeDestination::SharedCtor() {
address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&fragment_instance_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&node_id_) -
    reinterpret_cast<char*>(&fragment_instance_id_)) + sizeof(node_id_));
}

ExchangeDestination::~ExchangeDestination() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.ExchangeDestination)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ExchangeDestination::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ExchangeDestination::ArenaDtor(void* object) {
  ExchangeDestination* _this = reinterpret_cast< ExchangeDestination* >(object);
  (void)_this;
}
void ExchangeDestination::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ExchangeDestination::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ExchangeDestination::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.ExchangeDestination)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    address_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&fragment_instance_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&node_id_) -
        reinterpret_cast<char*>(&fragment_instance_id_)) + sizeof(node_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExchangeDestination::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 fragment_instance_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_fragment_instance_id(&has_bits);
          fragment_instance_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 node_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_node_id(&has_bits);
          node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ExchangeDestination::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.ExchangeDestination)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 fragment_instance_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_fragment_instance_id(), target);
  }

  // required int32 node_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_node_id(), target);
  }

  // optional bytes address = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.ExchangeDestination)
  return target;
}

size_t ExchangeDestination::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.ExchangeDestination)
  size_t total_size = 0;

  if (_internal_has_fragment_instance_id()) {
    // required uint64 fragment_instance_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_fragment_instance_id());
  }

  if (_internal_has_node_id()) {
    // required int32 node_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_node_id());
  }

  return total_size;
}
size_t ExchangeDestination::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.ExchangeDestination)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint64 fragment_instance_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_fragment_instance_id());

    // required int32 node_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_node_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes address = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_address());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExchangeDestination::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ExchangeDestination::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExchangeDestination::GetClassData() const { return &_class_data_; }

void ExchangeDestination::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ExchangeDestination *>(to)->MergeFrom(
      static_cast<const ExchangeDestination &>(from));
}


void ExchangeDestination::MergeFrom(const ExchangeDestination& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.ExchangeDestination)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_address(from._internal_address());
    }
    if (cached_has_bits & 0x00000002u) {
      fragment_instance_id_ = from.fragment_instance_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      node_id_ = from.node_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExchangeDestination::CopyFrom(const ExchangeDestination& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.ExchangeDestination)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExchangeDestination::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ExchangeDestination::InternalSwap(ExchangeDestination* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &address_, lhs_arena,
      &other->address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExchangeDestination, node_id_)
      + sizeof(ExchangeDestination::node_id_)
      - PROTOBUF_FIELD_OFFSET(ExchangeDestination, fragment_instance_id_)>(
          reinterpret_cast<char*>(&fragment_instance_id_),
          reinterpret_cast<char*>(&other->fragment_instance_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExchangeDestination::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[26]);
}

// ===================================================================

class ExchangeSenderNode::_Internal {
 public:
  using HasBits = decltype(std::declval<ExchangeSenderNode>()._has_bits_);
  static void set_has_log_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_fragment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_receiver_fragment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_fragment_instance_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::baikaldb::pb::PartitionProperty& partition_property(const ExchangeSenderNode* msg);
  static void set_has_partition_property(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_schema(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007c) ^ 0x0000007c) != 0;
  }
};

const ::baikaldb::pb::PartitionProperty&
ExchangeSenderNode::_Internal::partition_property(const ExchangeSenderNode* msg) {
  return *msg->partition_property_;
}
ExchangeSenderNode::ExchangeSenderNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  receiver_destinations_(arena),
  fragment_addresses_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.ExchangeSenderNode)
}
ExchangeSenderNode::ExchangeSenderNode(const ExchangeSenderNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      receiver_destinations_(from.receiver_destinations_),
      fragment_addresses_(from.fragment_addresses_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  schema_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_schema()) {
    schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_schema(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_partition_property()) {
    partition_property_ = new ::baikaldb::pb::PartitionProperty(*from.partition_property_);
  } else {
    partition_property_ = nullptr;
  }
  ::memcpy(&log_id_, &from.log_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&node_id_) -
    reinterpret_cast<char*>(&log_id_)) + sizeof(node_id_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.ExchangeSenderNode)
}

void ExchangeSenderNode::SharedCtor() {
schema_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&partition_property_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&node_id_) -
    reinterpret_cast<char*>(&partition_property_)) + sizeof(node_id_));
}

ExchangeSenderNode::~ExchangeSenderNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.ExchangeSenderNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ExchangeSenderNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  schema_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete partition_property_;
}

void ExchangeSenderNode::ArenaDtor(void* object) {
  ExchangeSenderNode* _this = reinterpret_cast< ExchangeSenderNode* >(object);
  (void)_this;
}
void ExchangeSenderNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ExchangeSenderNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ExchangeSenderNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.ExchangeSenderNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  receiver_destinations_.Clear();
  fragment_addresses_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      schema_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(partition_property_ != nullptr);
      partition_property_->Clear();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&log_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&node_id_) -
        reinterpret_cast<char*>(&log_id_)) + sizeof(node_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExchangeSenderNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 log_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_log_id(&has_bits);
          log_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 fragment_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_fragment_id(&has_bits);
          fragment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 receiver_fragment_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_receiver_fragment_id(&has_bits);
          receiver_fragment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 fragment_instance_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_fragment_instance_id(&has_bits);
          fragment_instance_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 node_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_node_id(&has_bits);
          node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.ExchangeDestination receiver_destinations = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_receiver_destinations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.ExchangeDestination fragment_addresses = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fragment_addresses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.PartitionProperty partition_property = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_partition_property(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes schema = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          auto str = _internal_mutable_schema();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ExchangeSenderNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.ExchangeSenderNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 log_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_log_id(), target);
  }

  // required int32 fragment_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_fragment_id(), target);
  }

  // required int32 receiver_fragment_id = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_receiver_fragment_id(), target);
  }

  // required uint64 fragment_instance_id = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_fragment_instance_id(), target);
  }

  // required int32 node_id = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_node_id(), target);
  }

  // repeated .baikaldb.pb.ExchangeDestination receiver_destinations = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_receiver_destinations_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_receiver_destinations(i), target, stream);
  }

  // repeated .baikaldb.pb.ExchangeDestination fragment_addresses = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fragment_addresses_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_fragment_addresses(i), target, stream);
  }

  // optional .baikaldb.pb.PartitionProperty partition_property = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::partition_property(this), target, stream);
  }

  // optional bytes schema = 9;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_schema(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.ExchangeSenderNode)
  return target;
}

size_t ExchangeSenderNode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.ExchangeSenderNode)
  size_t total_size = 0;

  if (_internal_has_log_id()) {
    // required uint64 log_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_log_id());
  }

  if (_internal_has_fragment_id()) {
    // required int32 fragment_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_fragment_id());
  }

  if (_internal_has_receiver_fragment_id()) {
    // required int32 receiver_fragment_id = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_receiver_fragment_id());
  }

  if (_internal_has_fragment_instance_id()) {
    // required uint64 fragment_instance_id = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_fragment_instance_id());
  }

  if (_internal_has_node_id()) {
    // required int32 node_id = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_node_id());
  }

  return total_size;
}
size_t ExchangeSenderNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.ExchangeSenderNode)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000007c) ^ 0x0000007c) == 0) {  // All required fields are present.
    // required uint64 log_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_log_id());

    // required int32 fragment_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_fragment_id());

    // required int32 receiver_fragment_id = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_receiver_fragment_id());

    // required uint64 fragment_instance_id = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_fragment_instance_id());

    // required int32 node_id = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_node_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.ExchangeDestination receiver_destinations = 6;
  total_size += 1UL * this->_internal_receiver_destinations_size();
  for (const auto& msg : this->receiver_destinations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.ExchangeDestination fragment_addresses = 7;
  total_size += 1UL * this->_internal_fragment_addresses_size();
  for (const auto& msg : this->fragment_addresses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes schema = 9;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_schema());
    }

    // optional .baikaldb.pb.PartitionProperty partition_property = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *partition_property_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExchangeSenderNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ExchangeSenderNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExchangeSenderNode::GetClassData() const { return &_class_data_; }

void ExchangeSenderNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ExchangeSenderNode *>(to)->MergeFrom(
      static_cast<const ExchangeSenderNode &>(from));
}


void ExchangeSenderNode::MergeFrom(const ExchangeSenderNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.ExchangeSenderNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  receiver_destinations_.MergeFrom(from.receiver_destinations_);
  fragment_addresses_.MergeFrom(from.fragment_addresses_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_schema(from._internal_schema());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_partition_property()->::baikaldb::pb::PartitionProperty::MergeFrom(from._internal_partition_property());
    }
    if (cached_has_bits & 0x00000004u) {
      log_id_ = from.log_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      fragment_id_ = from.fragment_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      receiver_fragment_id_ = from.receiver_fragment_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      fragment_instance_id_ = from.fragment_instance_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      node_id_ = from.node_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExchangeSenderNode::CopyFrom(const ExchangeSenderNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.ExchangeSenderNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExchangeSenderNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(receiver_destinations_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(fragment_addresses_)) return false;
  if (_internal_has_partition_property()) {
    if (!partition_property_->IsInitialized()) return false;
  }
  return true;
}

void ExchangeSenderNode::InternalSwap(ExchangeSenderNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  receiver_destinations_.InternalSwap(&other->receiver_destinations_);
  fragment_addresses_.InternalSwap(&other->fragment_addresses_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &schema_, lhs_arena,
      &other->schema_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExchangeSenderNode, node_id_)
      + sizeof(ExchangeSenderNode::node_id_)
      - PROTOBUF_FIELD_OFFSET(ExchangeSenderNode, partition_property_)>(
          reinterpret_cast<char*>(&partition_property_),
          reinterpret_cast<char*>(&other->partition_property_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExchangeSenderNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[27]);
}

// ===================================================================

class ExchangeReceiverNode::_Internal {
 public:
  using HasBits = decltype(std::declval<ExchangeReceiverNode>()._has_bits_);
  static void set_has_log_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_fragment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sender_fragment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_fragment_instance_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::baikaldb::pb::PartitionProperty& partition_property(const ExchangeReceiverNode* msg);
  static void set_has_partition_property(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_schema(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000007d) ^ 0x0000007d) != 0;
  }
};

const ::baikaldb::pb::PartitionProperty&
ExchangeReceiverNode::_Internal::partition_property(const ExchangeReceiverNode* msg) {
  return *msg->partition_property_;
}
void ExchangeReceiverNode::clear_regions() {
  regions_.Clear();
}
void ExchangeReceiverNode::clear_slot_order_exprs() {
  slot_order_exprs_.Clear();
}
ExchangeReceiverNode::ExchangeReceiverNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  sender_destinations_(arena),
  regions_(arena),
  slot_order_exprs_(arena),
  is_asc_(arena),
  is_null_first_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.ExchangeReceiverNode)
}
ExchangeReceiverNode::ExchangeReceiverNode(const ExchangeReceiverNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      sender_destinations_(from.sender_destinations_),
      regions_(from.regions_),
      slot_order_exprs_(from.slot_order_exprs_),
      is_asc_(from.is_asc_),
      is_null_first_(from.is_null_first_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  schema_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_schema()) {
    schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_schema(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_partition_property()) {
    partition_property_ = new ::baikaldb::pb::PartitionProperty(*from.partition_property_);
  } else {
    partition_property_ = nullptr;
  }
  ::memcpy(&log_id_, &from.log_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&node_id_) -
    reinterpret_cast<char*>(&log_id_)) + sizeof(node_id_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.ExchangeReceiverNode)
}

void ExchangeReceiverNode::SharedCtor() {
schema_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&partition_property_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&node_id_) -
    reinterpret_cast<char*>(&partition_property_)) + sizeof(node_id_));
}

ExchangeReceiverNode::~ExchangeReceiverNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.ExchangeReceiverNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ExchangeReceiverNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  schema_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete partition_property_;
}

void ExchangeReceiverNode::ArenaDtor(void* object) {
  ExchangeReceiverNode* _this = reinterpret_cast< ExchangeReceiverNode* >(object);
  (void)_this;
}
void ExchangeReceiverNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ExchangeReceiverNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ExchangeReceiverNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.ExchangeReceiverNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sender_destinations_.Clear();
  regions_.Clear();
  slot_order_exprs_.Clear();
  is_asc_.Clear();
  is_null_first_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      schema_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(partition_property_ != nullptr);
      partition_property_->Clear();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&log_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&node_id_) -
        reinterpret_cast<char*>(&log_id_)) + sizeof(node_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExchangeReceiverNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 log_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_log_id(&has_bits);
          log_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 fragment_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_fragment_id(&has_bits);
          fragment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 sender_fragment_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_sender_fragment_id(&has_bits);
          sender_fragment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 fragment_instance_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_fragment_instance_id(&has_bits);
          fragment_instance_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 node_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_node_id(&has_bits);
          node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.ExchangeDestination sender_destinations = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sender_destinations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.RegionInfo regions = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_regions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.PartitionProperty partition_property = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_partition_property(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes schema = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          auto str = _internal_mutable_schema();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr slot_order_exprs = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_slot_order_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bool is_asc = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_is_asc(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<88>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_is_asc(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool is_null_first = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_is_null_first(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<96>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_is_null_first(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ExchangeReceiverNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.ExchangeReceiverNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 log_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_log_id(), target);
  }

  // required int32 fragment_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_fragment_id(), target);
  }

  // required int32 sender_fragment_id = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_sender_fragment_id(), target);
  }

  // required uint64 fragment_instance_id = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_fragment_instance_id(), target);
  }

  // required int32 node_id = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_node_id(), target);
  }

  // repeated .baikaldb.pb.ExchangeDestination sender_destinations = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_sender_destinations_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_sender_destinations(i), target, stream);
  }

  // repeated .baikaldb.pb.RegionInfo regions = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_regions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_regions(i), target, stream);
  }

  // optional .baikaldb.pb.PartitionProperty partition_property = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::partition_property(this), target, stream);
  }

  // required bytes schema = 9;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_schema(), target);
  }

  // repeated .baikaldb.pb.Expr slot_order_exprs = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_slot_order_exprs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_slot_order_exprs(i), target, stream);
  }

  // repeated bool is_asc = 11;
  for (int i = 0, n = this->_internal_is_asc_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_is_asc(i), target);
  }

  // repeated bool is_null_first = 12;
  for (int i = 0, n = this->_internal_is_null_first_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_is_null_first(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.ExchangeReceiverNode)
  return target;
}

size_t ExchangeReceiverNode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.ExchangeReceiverNode)
  size_t total_size = 0;

  if (_internal_has_schema()) {
    // required bytes schema = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_schema());
  }

  if (_internal_has_log_id()) {
    // required uint64 log_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_log_id());
  }

  if (_internal_has_fragment_id()) {
    // required int32 fragment_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_fragment_id());
  }

  if (_internal_has_sender_fragment_id()) {
    // required int32 sender_fragment_id = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_sender_fragment_id());
  }

  if (_internal_has_fragment_instance_id()) {
    // required uint64 fragment_instance_id = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_fragment_instance_id());
  }

  if (_internal_has_node_id()) {
    // required int32 node_id = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_node_id());
  }

  return total_size;
}
size_t ExchangeReceiverNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.ExchangeReceiverNode)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000007d) ^ 0x0000007d) == 0) {  // All required fields are present.
    // required bytes schema = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_schema());

    // required uint64 log_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_log_id());

    // required int32 fragment_id = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_fragment_id());

    // required int32 sender_fragment_id = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_sender_fragment_id());

    // required uint64 fragment_instance_id = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_fragment_instance_id());

    // required int32 node_id = 5;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_node_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.ExchangeDestination sender_destinations = 6;
  total_size += 1UL * this->_internal_sender_destinations_size();
  for (const auto& msg : this->sender_destinations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.RegionInfo regions = 7;
  total_size += 1UL * this->_internal_regions_size();
  for (const auto& msg : this->regions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.Expr slot_order_exprs = 10;
  total_size += 1UL * this->_internal_slot_order_exprs_size();
  for (const auto& msg : this->slot_order_exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated bool is_asc = 11;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_is_asc_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_is_asc_size());
    total_size += data_size;
  }

  // repeated bool is_null_first = 12;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_is_null_first_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_is_null_first_size());
    total_size += data_size;
  }

  // optional .baikaldb.pb.PartitionProperty partition_property = 8;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *partition_property_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ExchangeReceiverNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ExchangeReceiverNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ExchangeReceiverNode::GetClassData() const { return &_class_data_; }

void ExchangeReceiverNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ExchangeReceiverNode *>(to)->MergeFrom(
      static_cast<const ExchangeReceiverNode &>(from));
}


void ExchangeReceiverNode::MergeFrom(const ExchangeReceiverNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.ExchangeReceiverNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  sender_destinations_.MergeFrom(from.sender_destinations_);
  regions_.MergeFrom(from.regions_);
  slot_order_exprs_.MergeFrom(from.slot_order_exprs_);
  is_asc_.MergeFrom(from.is_asc_);
  is_null_first_.MergeFrom(from.is_null_first_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_schema(from._internal_schema());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_partition_property()->::baikaldb::pb::PartitionProperty::MergeFrom(from._internal_partition_property());
    }
    if (cached_has_bits & 0x00000004u) {
      log_id_ = from.log_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      fragment_id_ = from.fragment_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      sender_fragment_id_ = from.sender_fragment_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      fragment_instance_id_ = from.fragment_instance_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      node_id_ = from.node_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ExchangeReceiverNode::CopyFrom(const ExchangeReceiverNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.ExchangeReceiverNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExchangeReceiverNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(sender_destinations_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(regions_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(slot_order_exprs_)) return false;
  if (_internal_has_partition_property()) {
    if (!partition_property_->IsInitialized()) return false;
  }
  return true;
}

void ExchangeReceiverNode::InternalSwap(ExchangeReceiverNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sender_destinations_.InternalSwap(&other->sender_destinations_);
  regions_.InternalSwap(&other->regions_);
  slot_order_exprs_.InternalSwap(&other->slot_order_exprs_);
  is_asc_.InternalSwap(&other->is_asc_);
  is_null_first_.InternalSwap(&other->is_null_first_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &schema_, lhs_arena,
      &other->schema_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExchangeReceiverNode, node_id_)
      + sizeof(ExchangeReceiverNode::node_id_)
      - PROTOBUF_FIELD_OFFSET(ExchangeReceiverNode, partition_property_)>(
          reinterpret_cast<char*>(&partition_property_),
          reinterpret_cast<char*>(&other->partition_property_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExchangeReceiverNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[28]);
}

// ===================================================================

class FrameBound::_Internal {
 public:
  using HasBits = decltype(std::declval<FrameBound>()._has_bits_);
  static void set_has_bound_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_unbounded(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::baikaldb::pb::Expr& expr(const FrameBound* msg);
  static void set_has_expr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::baikaldb::pb::Expr&
FrameBound::_Internal::expr(const FrameBound* msg) {
  return *msg->expr_;
}
void FrameBound::clear_expr() {
  if (expr_ != nullptr) expr_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
FrameBound::FrameBound(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.FrameBound)
}
FrameBound::FrameBound(const FrameBound& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_expr()) {
    expr_ = new ::baikaldb::pb::Expr(*from.expr_);
  } else {
    expr_ = nullptr;
  }
  ::memcpy(&bound_type_, &from.bound_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_unbounded_) -
    reinterpret_cast<char*>(&bound_type_)) + sizeof(is_unbounded_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.FrameBound)
}

void FrameBound::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&expr_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_unbounded_) -
    reinterpret_cast<char*>(&expr_)) + sizeof(is_unbounded_));
}

FrameBound::~FrameBound() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.FrameBound)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FrameBound::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete expr_;
}

void FrameBound::ArenaDtor(void* object) {
  FrameBound* _this = reinterpret_cast< FrameBound* >(object);
  (void)_this;
}
void FrameBound::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FrameBound::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FrameBound::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.FrameBound)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(expr_ != nullptr);
    expr_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&bound_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_unbounded_) -
        reinterpret_cast<char*>(&bound_type_)) + sizeof(is_unbounded_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FrameBound::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .baikaldb.pb.BoundType bound_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::BoundType_IsValid(val))) {
            _internal_set_bound_type(static_cast<::baikaldb::pb::BoundType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_unbounded = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_is_unbounded(&has_bits);
          is_unbounded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.Expr expr = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_expr(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FrameBound::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.FrameBound)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .baikaldb.pb.BoundType bound_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_bound_type(), target);
  }

  // optional bool is_unbounded = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_is_unbounded(), target);
  }

  // optional .baikaldb.pb.Expr expr = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::expr(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.FrameBound)
  return target;
}

size_t FrameBound::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.FrameBound)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .baikaldb.pb.Expr expr = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *expr_);
    }

    // optional .baikaldb.pb.BoundType bound_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_bound_type());
    }

    // optional bool is_unbounded = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FrameBound::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FrameBound::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FrameBound::GetClassData() const { return &_class_data_; }

void FrameBound::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FrameBound *>(to)->MergeFrom(
      static_cast<const FrameBound &>(from));
}


void FrameBound::MergeFrom(const FrameBound& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.FrameBound)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_expr()->::baikaldb::pb::Expr::MergeFrom(from._internal_expr());
    }
    if (cached_has_bits & 0x00000002u) {
      bound_type_ = from.bound_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      is_unbounded_ = from.is_unbounded_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FrameBound::CopyFrom(const FrameBound& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.FrameBound)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameBound::IsInitialized() const {
  if (_internal_has_expr()) {
    if (!expr_->IsInitialized()) return false;
  }
  return true;
}

void FrameBound::InternalSwap(FrameBound* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FrameBound, is_unbounded_)
      + sizeof(FrameBound::is_unbounded_)
      - PROTOBUF_FIELD_OFFSET(FrameBound, expr_)>(
          reinterpret_cast<char*>(&expr_),
          reinterpret_cast<char*>(&other->expr_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FrameBound::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[29]);
}

// ===================================================================

class FrameExtent::_Internal {
 public:
  using HasBits = decltype(std::declval<FrameExtent>()._has_bits_);
  static const ::baikaldb::pb::FrameBound& frame_start(const FrameExtent* msg);
  static void set_has_frame_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::baikaldb::pb::FrameBound& frame_end(const FrameExtent* msg);
  static void set_has_frame_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::baikaldb::pb::FrameBound&
FrameExtent::_Internal::frame_start(const FrameExtent* msg) {
  return *msg->frame_start_;
}
const ::baikaldb::pb::FrameBound&
FrameExtent::_Internal::frame_end(const FrameExtent* msg) {
  return *msg->frame_end_;
}
FrameExtent::FrameExtent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.FrameExtent)
}
FrameExtent::FrameExtent(const FrameExtent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_frame_start()) {
    frame_start_ = new ::baikaldb::pb::FrameBound(*from.frame_start_);
  } else {
    frame_start_ = nullptr;
  }
  if (from._internal_has_frame_end()) {
    frame_end_ = new ::baikaldb::pb::FrameBound(*from.frame_end_);
  } else {
    frame_end_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.FrameExtent)
}

void FrameExtent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&frame_start_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&frame_end_) -
    reinterpret_cast<char*>(&frame_start_)) + sizeof(frame_end_));
}

FrameExtent::~FrameExtent() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.FrameExtent)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FrameExtent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete frame_start_;
  if (this != internal_default_instance()) delete frame_end_;
}

void FrameExtent::ArenaDtor(void* object) {
  FrameExtent* _this = reinterpret_cast< FrameExtent* >(object);
  (void)_this;
}
void FrameExtent::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FrameExtent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FrameExtent::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.FrameExtent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(frame_start_ != nullptr);
      frame_start_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(frame_end_ != nullptr);
      frame_end_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FrameExtent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .baikaldb.pb.FrameBound frame_start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_frame_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.FrameBound frame_end = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_frame_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FrameExtent::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.FrameExtent)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .baikaldb.pb.FrameBound frame_start = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::frame_start(this), target, stream);
  }

  // optional .baikaldb.pb.FrameBound frame_end = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::frame_end(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.FrameExtent)
  return target;
}

size_t FrameExtent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.FrameExtent)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .baikaldb.pb.FrameBound frame_start = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *frame_start_);
    }

    // optional .baikaldb.pb.FrameBound frame_end = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *frame_end_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FrameExtent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FrameExtent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FrameExtent::GetClassData() const { return &_class_data_; }

void FrameExtent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FrameExtent *>(to)->MergeFrom(
      static_cast<const FrameExtent &>(from));
}


void FrameExtent::MergeFrom(const FrameExtent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.FrameExtent)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_frame_start()->::baikaldb::pb::FrameBound::MergeFrom(from._internal_frame_start());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_frame_end()->::baikaldb::pb::FrameBound::MergeFrom(from._internal_frame_end());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FrameExtent::CopyFrom(const FrameExtent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.FrameExtent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameExtent::IsInitialized() const {
  if (_internal_has_frame_start()) {
    if (!frame_start_->IsInitialized()) return false;
  }
  if (_internal_has_frame_end()) {
    if (!frame_end_->IsInitialized()) return false;
  }
  return true;
}

void FrameExtent::InternalSwap(FrameExtent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FrameExtent, frame_end_)
      + sizeof(FrameExtent::frame_end_)
      - PROTOBUF_FIELD_OFFSET(FrameExtent, frame_start_)>(
          reinterpret_cast<char*>(&frame_start_),
          reinterpret_cast<char*>(&other->frame_start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FrameExtent::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[30]);
}

// ===================================================================

class WindowFrame::_Internal {
 public:
  using HasBits = decltype(std::declval<WindowFrame>()._has_bits_);
  static void set_has_frame_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::baikaldb::pb::FrameExtent& frame_extent(const WindowFrame* msg);
  static void set_has_frame_extent(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::baikaldb::pb::FrameExtent&
WindowFrame::_Internal::frame_extent(const WindowFrame* msg) {
  return *msg->frame_extent_;
}
WindowFrame::WindowFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.WindowFrame)
}
WindowFrame::WindowFrame(const WindowFrame& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_frame_extent()) {
    frame_extent_ = new ::baikaldb::pb::FrameExtent(*from.frame_extent_);
  } else {
    frame_extent_ = nullptr;
  }
  frame_type_ = from.frame_type_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.WindowFrame)
}

void WindowFrame::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&frame_extent_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&frame_type_) -
    reinterpret_cast<char*>(&frame_extent_)) + sizeof(frame_type_));
}

WindowFrame::~WindowFrame() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.WindowFrame)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void WindowFrame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete frame_extent_;
}

void WindowFrame::ArenaDtor(void* object) {
  WindowFrame* _this = reinterpret_cast< WindowFrame* >(object);
  (void)_this;
}
void WindowFrame::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WindowFrame::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WindowFrame::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.WindowFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(frame_extent_ != nullptr);
    frame_extent_->Clear();
  }
  frame_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WindowFrame::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .baikaldb.pb.FrameType frame_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::FrameType_IsValid(val))) {
            _internal_set_frame_type(static_cast<::baikaldb::pb::FrameType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.FrameExtent frame_extent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_frame_extent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* WindowFrame::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.WindowFrame)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .baikaldb.pb.FrameType frame_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_frame_type(), target);
  }

  // optional .baikaldb.pb.FrameExtent frame_extent = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::frame_extent(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.WindowFrame)
  return target;
}

size_t WindowFrame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.WindowFrame)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .baikaldb.pb.FrameExtent frame_extent = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *frame_extent_);
    }

    // optional .baikaldb.pb.FrameType frame_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_frame_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WindowFrame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    WindowFrame::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WindowFrame::GetClassData() const { return &_class_data_; }

void WindowFrame::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<WindowFrame *>(to)->MergeFrom(
      static_cast<const WindowFrame &>(from));
}


void WindowFrame::MergeFrom(const WindowFrame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.WindowFrame)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_frame_extent()->::baikaldb::pb::FrameExtent::MergeFrom(from._internal_frame_extent());
    }
    if (cached_has_bits & 0x00000002u) {
      frame_type_ = from.frame_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WindowFrame::CopyFrom(const WindowFrame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.WindowFrame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WindowFrame::IsInitialized() const {
  if (_internal_has_frame_extent()) {
    if (!frame_extent_->IsInitialized()) return false;
  }
  return true;
}

void WindowFrame::InternalSwap(WindowFrame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WindowFrame, frame_type_)
      + sizeof(WindowFrame::frame_type_)
      - PROTOBUF_FIELD_OFFSET(WindowFrame, frame_extent_)>(
          reinterpret_cast<char*>(&frame_extent_),
          reinterpret_cast<char*>(&other->frame_extent_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WindowFrame::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[31]);
}

// ===================================================================

class WindowSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<WindowSpec>()._has_bits_);
  static void set_has_tuple_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::baikaldb::pb::WindowFrame& window_frame(const WindowSpec* msg);
  static void set_has_window_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::baikaldb::pb::WindowFrame&
WindowSpec::_Internal::window_frame(const WindowSpec* msg) {
  return *msg->window_frame_;
}
void WindowSpec::clear_partition_exprs() {
  partition_exprs_.Clear();
}
void WindowSpec::clear_order_exprs() {
  order_exprs_.Clear();
}
WindowSpec::WindowSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  partition_exprs_(arena),
  order_exprs_(arena),
  is_asc_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.WindowSpec)
}
WindowSpec::WindowSpec(const WindowSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      partition_exprs_(from.partition_exprs_),
      order_exprs_(from.order_exprs_),
      is_asc_(from.is_asc_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_window_frame()) {
    window_frame_ = new ::baikaldb::pb::WindowFrame(*from.window_frame_);
  } else {
    window_frame_ = nullptr;
  }
  tuple_id_ = from.tuple_id_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.WindowSpec)
}

void WindowSpec::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&window_frame_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&tuple_id_) -
    reinterpret_cast<char*>(&window_frame_)) + sizeof(tuple_id_));
}

WindowSpec::~WindowSpec() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.WindowSpec)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void WindowSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete window_frame_;
}

void WindowSpec::ArenaDtor(void* object) {
  WindowSpec* _this = reinterpret_cast< WindowSpec* >(object);
  (void)_this;
}
void WindowSpec::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WindowSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WindowSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.WindowSpec)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  partition_exprs_.Clear();
  order_exprs_.Clear();
  is_asc_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(window_frame_ != nullptr);
    window_frame_->Clear();
  }
  tuple_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WindowSpec::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .baikaldb.pb.Expr partition_exprs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_partition_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.Expr order_exprs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_order_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bool is_asc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_is_asc(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(_internal_mutable_is_asc(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tuple_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_tuple_id(&has_bits);
          tuple_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.WindowFrame window_frame = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_window_frame(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* WindowSpec::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.WindowSpec)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr partition_exprs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_partition_exprs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_partition_exprs(i), target, stream);
  }

  // repeated .baikaldb.pb.Expr order_exprs = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_order_exprs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_order_exprs(i), target, stream);
  }

  // repeated bool is_asc = 3;
  for (int i = 0, n = this->_internal_is_asc_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_is_asc(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 tuple_id = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_tuple_id(), target);
  }

  // optional .baikaldb.pb.WindowFrame window_frame = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::window_frame(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.WindowSpec)
  return target;
}

size_t WindowSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.WindowSpec)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr partition_exprs = 1;
  total_size += 1UL * this->_internal_partition_exprs_size();
  for (const auto& msg : this->partition_exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .baikaldb.pb.Expr order_exprs = 2;
  total_size += 1UL * this->_internal_order_exprs_size();
  for (const auto& msg : this->order_exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated bool is_asc = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_is_asc_size());
    size_t data_size = 1UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_is_asc_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .baikaldb.pb.WindowFrame window_frame = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *window_frame_);
    }

    // optional int32 tuple_id = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_tuple_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WindowSpec::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    WindowSpec::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WindowSpec::GetClassData() const { return &_class_data_; }

void WindowSpec::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<WindowSpec *>(to)->MergeFrom(
      static_cast<const WindowSpec &>(from));
}


void WindowSpec::MergeFrom(const WindowSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.WindowSpec)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  partition_exprs_.MergeFrom(from.partition_exprs_);
  order_exprs_.MergeFrom(from.order_exprs_);
  is_asc_.MergeFrom(from.is_asc_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_window_frame()->::baikaldb::pb::WindowFrame::MergeFrom(from._internal_window_frame());
    }
    if (cached_has_bits & 0x00000002u) {
      tuple_id_ = from.tuple_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WindowSpec::CopyFrom(const WindowSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.WindowSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WindowSpec::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(partition_exprs_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(order_exprs_)) return false;
  if (_internal_has_window_frame()) {
    if (!window_frame_->IsInitialized()) return false;
  }
  return true;
}

void WindowSpec::InternalSwap(WindowSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  partition_exprs_.InternalSwap(&other->partition_exprs_);
  order_exprs_.InternalSwap(&other->order_exprs_);
  is_asc_.InternalSwap(&other->is_asc_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WindowSpec, tuple_id_)
      + sizeof(WindowSpec::tuple_id_)
      - PROTOBUF_FIELD_OFFSET(WindowSpec, window_frame_)>(
          reinterpret_cast<char*>(&window_frame_),
          reinterpret_cast<char*>(&other->window_frame_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WindowSpec::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[32]);
}

// ===================================================================

class WindowNode::_Internal {
 public:
  using HasBits = decltype(std::declval<WindowNode>()._has_bits_);
  static const ::baikaldb::pb::WindowSpec& window_spec(const WindowNode* msg);
  static void set_has_window_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::baikaldb::pb::WindowSpec&
WindowNode::_Internal::window_spec(const WindowNode* msg) {
  return *msg->window_spec_;
}
void WindowNode::clear_func_exprs() {
  func_exprs_.Clear();
}
WindowNode::WindowNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  func_exprs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.WindowNode)
}
WindowNode::WindowNode(const WindowNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      func_exprs_(from.func_exprs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_window_spec()) {
    window_spec_ = new ::baikaldb::pb::WindowSpec(*from.window_spec_);
  } else {
    window_spec_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.WindowNode)
}

void WindowNode::SharedCtor() {
window_spec_ = nullptr;
}

WindowNode::~WindowNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.WindowNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void WindowNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete window_spec_;
}

void WindowNode::ArenaDtor(void* object) {
  WindowNode* _this = reinterpret_cast< WindowNode* >(object);
  (void)_this;
}
void WindowNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WindowNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WindowNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.WindowNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  func_exprs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(window_spec_ != nullptr);
    window_spec_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WindowNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .baikaldb.pb.Expr func_exprs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_func_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.WindowSpec window_spec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_window_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* WindowNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.WindowNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr func_exprs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_func_exprs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_func_exprs(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .baikaldb.pb.WindowSpec window_spec = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::window_spec(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.WindowNode)
  return target;
}

size_t WindowNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.WindowNode)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.Expr func_exprs = 1;
  total_size += 1UL * this->_internal_func_exprs_size();
  for (const auto& msg : this->func_exprs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .baikaldb.pb.WindowSpec window_spec = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *window_spec_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WindowNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    WindowNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WindowNode::GetClassData() const { return &_class_data_; }

void WindowNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<WindowNode *>(to)->MergeFrom(
      static_cast<const WindowNode &>(from));
}


void WindowNode::MergeFrom(const WindowNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.WindowNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  func_exprs_.MergeFrom(from.func_exprs_);
  if (from._internal_has_window_spec()) {
    _internal_mutable_window_spec()->::baikaldb::pb::WindowSpec::MergeFrom(from._internal_window_spec());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WindowNode::CopyFrom(const WindowNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.WindowNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WindowNode::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(func_exprs_)) return false;
  if (_internal_has_window_spec()) {
    if (!window_spec_->IsInitialized()) return false;
  }
  return true;
}

void WindowNode::InternalSwap(WindowNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  func_exprs_.InternalSwap(&other->func_exprs_);
  swap(window_spec_, other->window_spec_);
}

::PROTOBUF_NAMESPACE_ID::Metadata WindowNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[33]);
}

// ===================================================================

class DerivePlanNode::_Internal {
 public:
  using HasBits = decltype(std::declval<DerivePlanNode>()._has_bits_);
  static const ::baikaldb::pb::ScanNode& scan_node(const DerivePlanNode* msg);
  static void set_has_scan_node(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::baikaldb::pb::SortNode& sort_node(const DerivePlanNode* msg);
  static void set_has_sort_node(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::baikaldb::pb::AggNode& agg_node(const DerivePlanNode* msg);
  static void set_has_agg_node(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_filter_node(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::baikaldb::pb::JoinNode& join_node(const DerivePlanNode* msg);
  static void set_has_join_node(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::baikaldb::pb::InsertNode& insert_node(const DerivePlanNode* msg);
  static void set_has_insert_node(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::baikaldb::pb::DeleteNode& delete_node(const DerivePlanNode* msg);
  static void set_has_delete_node(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::baikaldb::pb::UpdateNode& update_node(const DerivePlanNode* msg);
  static void set_has_update_node(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::baikaldb::pb::FetcherNode& fetcher_node(const DerivePlanNode* msg);
  static void set_has_fetcher_node(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::baikaldb::pb::LimitNode& limit_node(const DerivePlanNode* msg);
  static void set_has_limit_node(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::baikaldb::pb::PacketNode& packet_node(const DerivePlanNode* msg);
  static void set_has_packet_node(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::baikaldb::pb::TruncateNode& truncate_node(const DerivePlanNode* msg);
  static void set_has_truncate_node(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::baikaldb::pb::TransactionNode& transaction_node(const DerivePlanNode* msg);
  static void set_has_transaction_node(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::baikaldb::pb::KillNode& kill_node(const DerivePlanNode* msg);
  static void set_has_kill_node(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::baikaldb::pb::LockPrimaryNode& lock_primary_node(const DerivePlanNode* msg);
  static void set_has_lock_primary_node(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::baikaldb::pb::LockSecondaryNode& lock_secondary_node(const DerivePlanNode* msg);
  static void set_has_lock_secondary_node(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::baikaldb::pb::UnionNode& union_node(const DerivePlanNode* msg);
  static void set_has_union_node(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static const ::baikaldb::pb::ApplyNode& apply_node(const DerivePlanNode* msg);
  static void set_has_apply_node(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::baikaldb::pb::LoadNode& load_node(const DerivePlanNode* msg);
  static void set_has_load_node(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::baikaldb::pb::FilterNode& raw_filter_node(const DerivePlanNode* msg);
  static void set_has_raw_filter_node(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::baikaldb::pb::ExchangeSenderNode& exchange_sender_node(const DerivePlanNode* msg);
  static void set_has_exchange_sender_node(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static const ::baikaldb::pb::ExchangeReceiverNode& exchange_receiver_node(const DerivePlanNode* msg);
  static void set_has_exchange_receiver_node(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::baikaldb::pb::SelectManagerNode& select_manager_node(const DerivePlanNode* msg);
  static void set_has_select_manager_node(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static const ::baikaldb::pb::DualScanNode& dual_scan_node(const DerivePlanNode* msg);
  static void set_has_dual_scan_node(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static const ::baikaldb::pb::WindowNode& window_node(const DerivePlanNode* msg);
  static void set_has_window_node(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
};

const ::baikaldb::pb::ScanNode&
DerivePlanNode::_Internal::scan_node(const DerivePlanNode* msg) {
  return *msg->scan_node_;
}
const ::baikaldb::pb::SortNode&
DerivePlanNode::_Internal::sort_node(const DerivePlanNode* msg) {
  return *msg->sort_node_;
}
const ::baikaldb::pb::AggNode&
DerivePlanNode::_Internal::agg_node(const DerivePlanNode* msg) {
  return *msg->agg_node_;
}
const ::baikaldb::pb::JoinNode&
DerivePlanNode::_Internal::join_node(const DerivePlanNode* msg) {
  return *msg->join_node_;
}
const ::baikaldb::pb::InsertNode&
DerivePlanNode::_Internal::insert_node(const DerivePlanNode* msg) {
  return *msg->insert_node_;
}
const ::baikaldb::pb::DeleteNode&
DerivePlanNode::_Internal::delete_node(const DerivePlanNode* msg) {
  return *msg->delete_node_;
}
const ::baikaldb::pb::UpdateNode&
DerivePlanNode::_Internal::update_node(const DerivePlanNode* msg) {
  return *msg->update_node_;
}
const ::baikaldb::pb::FetcherNode&
DerivePlanNode::_Internal::fetcher_node(const DerivePlanNode* msg) {
  return *msg->fetcher_node_;
}
const ::baikaldb::pb::LimitNode&
DerivePlanNode::_Internal::limit_node(const DerivePlanNode* msg) {
  return *msg->limit_node_;
}
const ::baikaldb::pb::PacketNode&
DerivePlanNode::_Internal::packet_node(const DerivePlanNode* msg) {
  return *msg->packet_node_;
}
const ::baikaldb::pb::TruncateNode&
DerivePlanNode::_Internal::truncate_node(const DerivePlanNode* msg) {
  return *msg->truncate_node_;
}
const ::baikaldb::pb::TransactionNode&
DerivePlanNode::_Internal::transaction_node(const DerivePlanNode* msg) {
  return *msg->transaction_node_;
}
const ::baikaldb::pb::KillNode&
DerivePlanNode::_Internal::kill_node(const DerivePlanNode* msg) {
  return *msg->kill_node_;
}
const ::baikaldb::pb::LockPrimaryNode&
DerivePlanNode::_Internal::lock_primary_node(const DerivePlanNode* msg) {
  return *msg->lock_primary_node_;
}
const ::baikaldb::pb::LockSecondaryNode&
DerivePlanNode::_Internal::lock_secondary_node(const DerivePlanNode* msg) {
  return *msg->lock_secondary_node_;
}
const ::baikaldb::pb::UnionNode&
DerivePlanNode::_Internal::union_node(const DerivePlanNode* msg) {
  return *msg->union_node_;
}
const ::baikaldb::pb::ApplyNode&
DerivePlanNode::_Internal::apply_node(const DerivePlanNode* msg) {
  return *msg->apply_node_;
}
const ::baikaldb::pb::LoadNode&
DerivePlanNode::_Internal::load_node(const DerivePlanNode* msg) {
  return *msg->load_node_;
}
const ::baikaldb::pb::FilterNode&
DerivePlanNode::_Internal::raw_filter_node(const DerivePlanNode* msg) {
  return *msg->raw_filter_node_;
}
const ::baikaldb::pb::ExchangeSenderNode&
DerivePlanNode::_Internal::exchange_sender_node(const DerivePlanNode* msg) {
  return *msg->exchange_sender_node_;
}
const ::baikaldb::pb::ExchangeReceiverNode&
DerivePlanNode::_Internal::exchange_receiver_node(const DerivePlanNode* msg) {
  return *msg->exchange_receiver_node_;
}
const ::baikaldb::pb::SelectManagerNode&
DerivePlanNode::_Internal::select_manager_node(const DerivePlanNode* msg) {
  return *msg->select_manager_node_;
}
const ::baikaldb::pb::DualScanNode&
DerivePlanNode::_Internal::dual_scan_node(const DerivePlanNode* msg) {
  return *msg->dual_scan_node_;
}
const ::baikaldb::pb::WindowNode&
DerivePlanNode::_Internal::window_node(const DerivePlanNode* msg) {
  return *msg->window_node_;
}
DerivePlanNode::DerivePlanNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.DerivePlanNode)
}
DerivePlanNode::DerivePlanNode(const DerivePlanNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  filter_node_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_filter_node()) {
    filter_node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_filter_node(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_scan_node()) {
    scan_node_ = new ::baikaldb::pb::ScanNode(*from.scan_node_);
  } else {
    scan_node_ = nullptr;
  }
  if (from._internal_has_sort_node()) {
    sort_node_ = new ::baikaldb::pb::SortNode(*from.sort_node_);
  } else {
    sort_node_ = nullptr;
  }
  if (from._internal_has_agg_node()) {
    agg_node_ = new ::baikaldb::pb::AggNode(*from.agg_node_);
  } else {
    agg_node_ = nullptr;
  }
  if (from._internal_has_join_node()) {
    join_node_ = new ::baikaldb::pb::JoinNode(*from.join_node_);
  } else {
    join_node_ = nullptr;
  }
  if (from._internal_has_insert_node()) {
    insert_node_ = new ::baikaldb::pb::InsertNode(*from.insert_node_);
  } else {
    insert_node_ = nullptr;
  }
  if (from._internal_has_delete_node()) {
    delete_node_ = new ::baikaldb::pb::DeleteNode(*from.delete_node_);
  } else {
    delete_node_ = nullptr;
  }
  if (from._internal_has_update_node()) {
    update_node_ = new ::baikaldb::pb::UpdateNode(*from.update_node_);
  } else {
    update_node_ = nullptr;
  }
  if (from._internal_has_fetcher_node()) {
    fetcher_node_ = new ::baikaldb::pb::FetcherNode(*from.fetcher_node_);
  } else {
    fetcher_node_ = nullptr;
  }
  if (from._internal_has_limit_node()) {
    limit_node_ = new ::baikaldb::pb::LimitNode(*from.limit_node_);
  } else {
    limit_node_ = nullptr;
  }
  if (from._internal_has_packet_node()) {
    packet_node_ = new ::baikaldb::pb::PacketNode(*from.packet_node_);
  } else {
    packet_node_ = nullptr;
  }
  if (from._internal_has_truncate_node()) {
    truncate_node_ = new ::baikaldb::pb::TruncateNode(*from.truncate_node_);
  } else {
    truncate_node_ = nullptr;
  }
  if (from._internal_has_transaction_node()) {
    transaction_node_ = new ::baikaldb::pb::TransactionNode(*from.transaction_node_);
  } else {
    transaction_node_ = nullptr;
  }
  if (from._internal_has_kill_node()) {
    kill_node_ = new ::baikaldb::pb::KillNode(*from.kill_node_);
  } else {
    kill_node_ = nullptr;
  }
  if (from._internal_has_lock_primary_node()) {
    lock_primary_node_ = new ::baikaldb::pb::LockPrimaryNode(*from.lock_primary_node_);
  } else {
    lock_primary_node_ = nullptr;
  }
  if (from._internal_has_lock_secondary_node()) {
    lock_secondary_node_ = new ::baikaldb::pb::LockSecondaryNode(*from.lock_secondary_node_);
  } else {
    lock_secondary_node_ = nullptr;
  }
  if (from._internal_has_union_node()) {
    union_node_ = new ::baikaldb::pb::UnionNode(*from.union_node_);
  } else {
    union_node_ = nullptr;
  }
  if (from._internal_has_apply_node()) {
    apply_node_ = new ::baikaldb::pb::ApplyNode(*from.apply_node_);
  } else {
    apply_node_ = nullptr;
  }
  if (from._internal_has_load_node()) {
    load_node_ = new ::baikaldb::pb::LoadNode(*from.load_node_);
  } else {
    load_node_ = nullptr;
  }
  if (from._internal_has_raw_filter_node()) {
    raw_filter_node_ = new ::baikaldb::pb::FilterNode(*from.raw_filter_node_);
  } else {
    raw_filter_node_ = nullptr;
  }
  if (from._internal_has_exchange_sender_node()) {
    exchange_sender_node_ = new ::baikaldb::pb::ExchangeSenderNode(*from.exchange_sender_node_);
  } else {
    exchange_sender_node_ = nullptr;
  }
  if (from._internal_has_exchange_receiver_node()) {
    exchange_receiver_node_ = new ::baikaldb::pb::ExchangeReceiverNode(*from.exchange_receiver_node_);
  } else {
    exchange_receiver_node_ = nullptr;
  }
  if (from._internal_has_select_manager_node()) {
    select_manager_node_ = new ::baikaldb::pb::SelectManagerNode(*from.select_manager_node_);
  } else {
    select_manager_node_ = nullptr;
  }
  if (from._internal_has_dual_scan_node()) {
    dual_scan_node_ = new ::baikaldb::pb::DualScanNode(*from.dual_scan_node_);
  } else {
    dual_scan_node_ = nullptr;
  }
  if (from._internal_has_window_node()) {
    window_node_ = new ::baikaldb::pb::WindowNode(*from.window_node_);
  } else {
    window_node_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.DerivePlanNode)
}

void DerivePlanNode::SharedCtor() {
filter_node_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&scan_node_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&window_node_) -
    reinterpret_cast<char*>(&scan_node_)) + sizeof(window_node_));
}

DerivePlanNode::~DerivePlanNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.DerivePlanNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DerivePlanNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  filter_node_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete scan_node_;
  if (this != internal_default_instance()) delete sort_node_;
  if (this != internal_default_instance()) delete agg_node_;
  if (this != internal_default_instance()) delete join_node_;
  if (this != internal_default_instance()) delete insert_node_;
  if (this != internal_default_instance()) delete delete_node_;
  if (this != internal_default_instance()) delete update_node_;
  if (this != internal_default_instance()) delete fetcher_node_;
  if (this != internal_default_instance()) delete limit_node_;
  if (this != internal_default_instance()) delete packet_node_;
  if (this != internal_default_instance()) delete truncate_node_;
  if (this != internal_default_instance()) delete transaction_node_;
  if (this != internal_default_instance()) delete kill_node_;
  if (this != internal_default_instance()) delete lock_primary_node_;
  if (this != internal_default_instance()) delete lock_secondary_node_;
  if (this != internal_default_instance()) delete union_node_;
  if (this != internal_default_instance()) delete apply_node_;
  if (this != internal_default_instance()) delete load_node_;
  if (this != internal_default_instance()) delete raw_filter_node_;
  if (this != internal_default_instance()) delete exchange_sender_node_;
  if (this != internal_default_instance()) delete exchange_receiver_node_;
  if (this != internal_default_instance()) delete select_manager_node_;
  if (this != internal_default_instance()) delete dual_scan_node_;
  if (this != internal_default_instance()) delete window_node_;
}

void DerivePlanNode::ArenaDtor(void* object) {
  DerivePlanNode* _this = reinterpret_cast< DerivePlanNode* >(object);
  (void)_this;
}
void DerivePlanNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DerivePlanNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DerivePlanNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.DerivePlanNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      filter_node_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(scan_node_ != nullptr);
      scan_node_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(sort_node_ != nullptr);
      sort_node_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(agg_node_ != nullptr);
      agg_node_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(join_node_ != nullptr);
      join_node_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(insert_node_ != nullptr);
      insert_node_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(delete_node_ != nullptr);
      delete_node_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(update_node_ != nullptr);
      update_node_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(fetcher_node_ != nullptr);
      fetcher_node_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(limit_node_ != nullptr);
      limit_node_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(packet_node_ != nullptr);
      packet_node_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(truncate_node_ != nullptr);
      truncate_node_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(transaction_node_ != nullptr);
      transaction_node_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(kill_node_ != nullptr);
      kill_node_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(lock_primary_node_ != nullptr);
      lock_primary_node_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(lock_secondary_node_ != nullptr);
      lock_secondary_node_->Clear();
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(union_node_ != nullptr);
      union_node_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(apply_node_ != nullptr);
      apply_node_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(load_node_ != nullptr);
      load_node_->Clear();
    }
    if (cached_has_bits & 0x00080000u) {
      GOOGLE_DCHECK(raw_filter_node_ != nullptr);
      raw_filter_node_->Clear();
    }
    if (cached_has_bits & 0x00100000u) {
      GOOGLE_DCHECK(exchange_sender_node_ != nullptr);
      exchange_sender_node_->Clear();
    }
    if (cached_has_bits & 0x00200000u) {
      GOOGLE_DCHECK(exchange_receiver_node_ != nullptr);
      exchange_receiver_node_->Clear();
    }
    if (cached_has_bits & 0x00400000u) {
      GOOGLE_DCHECK(select_manager_node_ != nullptr);
      select_manager_node_->Clear();
    }
    if (cached_has_bits & 0x00800000u) {
      GOOGLE_DCHECK(dual_scan_node_ != nullptr);
      dual_scan_node_->Clear();
    }
  }
  if (cached_has_bits & 0x01000000u) {
    GOOGLE_DCHECK(window_node_ != nullptr);
    window_node_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DerivePlanNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .baikaldb.pb.ScanNode scan_node = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_scan_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.SortNode sort_node = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_sort_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.AggNode agg_node = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_agg_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes filter_node = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_filter_node();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.JoinNode join_node = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_join_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.InsertNode insert_node = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_insert_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.DeleteNode delete_node = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_delete_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.UpdateNode update_node = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.FetcherNode fetcher_node = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_fetcher_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.LimitNode limit_node = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_limit_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.PacketNode packet_node = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_packet_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.TruncateNode truncate_node = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_truncate_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.TransactionNode transaction_node = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_transaction_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.KillNode kill_node = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_kill_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.LockPrimaryNode lock_primary_node = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_lock_primary_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.LockSecondaryNode lock_secondary_node = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_lock_secondary_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.UnionNode union_node = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_union_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.ApplyNode apply_node = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_apply_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.LoadNode load_node = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_load_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.FilterNode raw_filter_node = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_raw_filter_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.ExchangeSenderNode exchange_sender_node = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_exchange_sender_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.ExchangeReceiverNode exchange_receiver_node = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_exchange_receiver_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.SelectManagerNode select_manager_node = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_select_manager_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.DualScanNode dual_scan_node = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_dual_scan_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.WindowNode window_node = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_window_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DerivePlanNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.DerivePlanNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .baikaldb.pb.ScanNode scan_node = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::scan_node(this), target, stream);
  }

  // optional .baikaldb.pb.SortNode sort_node = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::sort_node(this), target, stream);
  }

  // optional .baikaldb.pb.AggNode agg_node = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::agg_node(this), target, stream);
  }

  // optional bytes filter_node = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_filter_node(), target);
  }

  // optional .baikaldb.pb.JoinNode join_node = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::join_node(this), target, stream);
  }

  // optional .baikaldb.pb.InsertNode insert_node = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::insert_node(this), target, stream);
  }

  // optional .baikaldb.pb.DeleteNode delete_node = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::delete_node(this), target, stream);
  }

  // optional .baikaldb.pb.UpdateNode update_node = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::update_node(this), target, stream);
  }

  // optional .baikaldb.pb.FetcherNode fetcher_node = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::fetcher_node(this), target, stream);
  }

  // optional .baikaldb.pb.LimitNode limit_node = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::limit_node(this), target, stream);
  }

  // optional .baikaldb.pb.PacketNode packet_node = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::packet_node(this), target, stream);
  }

  // optional .baikaldb.pb.TruncateNode truncate_node = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::truncate_node(this), target, stream);
  }

  // optional .baikaldb.pb.TransactionNode transaction_node = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::transaction_node(this), target, stream);
  }

  // optional .baikaldb.pb.KillNode kill_node = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        14, _Internal::kill_node(this), target, stream);
  }

  // optional .baikaldb.pb.LockPrimaryNode lock_primary_node = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        15, _Internal::lock_primary_node(this), target, stream);
  }

  // optional .baikaldb.pb.LockSecondaryNode lock_secondary_node = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        16, _Internal::lock_secondary_node(this), target, stream);
  }

  // optional .baikaldb.pb.UnionNode union_node = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        17, _Internal::union_node(this), target, stream);
  }

  // optional .baikaldb.pb.ApplyNode apply_node = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        18, _Internal::apply_node(this), target, stream);
  }

  // optional .baikaldb.pb.LoadNode load_node = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        19, _Internal::load_node(this), target, stream);
  }

  // optional .baikaldb.pb.FilterNode raw_filter_node = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::raw_filter_node(this), target, stream);
  }

  // optional .baikaldb.pb.ExchangeSenderNode exchange_sender_node = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        21, _Internal::exchange_sender_node(this), target, stream);
  }

  // optional .baikaldb.pb.ExchangeReceiverNode exchange_receiver_node = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        22, _Internal::exchange_receiver_node(this), target, stream);
  }

  // optional .baikaldb.pb.SelectManagerNode select_manager_node = 23;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        23, _Internal::select_manager_node(this), target, stream);
  }

  // optional .baikaldb.pb.DualScanNode dual_scan_node = 24;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        24, _Internal::dual_scan_node(this), target, stream);
  }

  // optional .baikaldb.pb.WindowNode window_node = 25;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        25, _Internal::window_node(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.DerivePlanNode)
  return target;
}

size_t DerivePlanNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.DerivePlanNode)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes filter_node = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_filter_node());
    }

    // optional .baikaldb.pb.ScanNode scan_node = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *scan_node_);
    }

    // optional .baikaldb.pb.SortNode sort_node = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *sort_node_);
    }

    // optional .baikaldb.pb.AggNode agg_node = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *agg_node_);
    }

    // optional .baikaldb.pb.JoinNode join_node = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *join_node_);
    }

    // optional .baikaldb.pb.InsertNode insert_node = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *insert_node_);
    }

    // optional .baikaldb.pb.DeleteNode delete_node = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *delete_node_);
    }

    // optional .baikaldb.pb.UpdateNode update_node = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *update_node_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .baikaldb.pb.FetcherNode fetcher_node = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *fetcher_node_);
    }

    // optional .baikaldb.pb.LimitNode limit_node = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *limit_node_);
    }

    // optional .baikaldb.pb.PacketNode packet_node = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *packet_node_);
    }

    // optional .baikaldb.pb.TruncateNode truncate_node = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *truncate_node_);
    }

    // optional .baikaldb.pb.TransactionNode transaction_node = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *transaction_node_);
    }

    // optional .baikaldb.pb.KillNode kill_node = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *kill_node_);
    }

    // optional .baikaldb.pb.LockPrimaryNode lock_primary_node = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lock_primary_node_);
    }

    // optional .baikaldb.pb.LockSecondaryNode lock_secondary_node = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lock_secondary_node_);
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional .baikaldb.pb.UnionNode union_node = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *union_node_);
    }

    // optional .baikaldb.pb.ApplyNode apply_node = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *apply_node_);
    }

    // optional .baikaldb.pb.LoadNode load_node = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *load_node_);
    }

    // optional .baikaldb.pb.FilterNode raw_filter_node = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *raw_filter_node_);
    }

    // optional .baikaldb.pb.ExchangeSenderNode exchange_sender_node = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *exchange_sender_node_);
    }

    // optional .baikaldb.pb.ExchangeReceiverNode exchange_receiver_node = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *exchange_receiver_node_);
    }

    // optional .baikaldb.pb.SelectManagerNode select_manager_node = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *select_manager_node_);
    }

    // optional .baikaldb.pb.DualScanNode dual_scan_node = 24;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *dual_scan_node_);
    }

  }
  // optional .baikaldb.pb.WindowNode window_node = 25;
  if (cached_has_bits & 0x01000000u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *window_node_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DerivePlanNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DerivePlanNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DerivePlanNode::GetClassData() const { return &_class_data_; }

void DerivePlanNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DerivePlanNode *>(to)->MergeFrom(
      static_cast<const DerivePlanNode &>(from));
}


void DerivePlanNode::MergeFrom(const DerivePlanNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.DerivePlanNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_filter_node(from._internal_filter_node());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_scan_node()->::baikaldb::pb::ScanNode::MergeFrom(from._internal_scan_node());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_sort_node()->::baikaldb::pb::SortNode::MergeFrom(from._internal_sort_node());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_agg_node()->::baikaldb::pb::AggNode::MergeFrom(from._internal_agg_node());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_join_node()->::baikaldb::pb::JoinNode::MergeFrom(from._internal_join_node());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_insert_node()->::baikaldb::pb::InsertNode::MergeFrom(from._internal_insert_node());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_delete_node()->::baikaldb::pb::DeleteNode::MergeFrom(from._internal_delete_node());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_update_node()->::baikaldb::pb::UpdateNode::MergeFrom(from._internal_update_node());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_fetcher_node()->::baikaldb::pb::FetcherNode::MergeFrom(from._internal_fetcher_node());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_limit_node()->::baikaldb::pb::LimitNode::MergeFrom(from._internal_limit_node());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_packet_node()->::baikaldb::pb::PacketNode::MergeFrom(from._internal_packet_node());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_truncate_node()->::baikaldb::pb::TruncateNode::MergeFrom(from._internal_truncate_node());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_mutable_transaction_node()->::baikaldb::pb::TransactionNode::MergeFrom(from._internal_transaction_node());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_mutable_kill_node()->::baikaldb::pb::KillNode::MergeFrom(from._internal_kill_node());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_mutable_lock_primary_node()->::baikaldb::pb::LockPrimaryNode::MergeFrom(from._internal_lock_primary_node());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_mutable_lock_secondary_node()->::baikaldb::pb::LockSecondaryNode::MergeFrom(from._internal_lock_secondary_node());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _internal_mutable_union_node()->::baikaldb::pb::UnionNode::MergeFrom(from._internal_union_node());
    }
    if (cached_has_bits & 0x00020000u) {
      _internal_mutable_apply_node()->::baikaldb::pb::ApplyNode::MergeFrom(from._internal_apply_node());
    }
    if (cached_has_bits & 0x00040000u) {
      _internal_mutable_load_node()->::baikaldb::pb::LoadNode::MergeFrom(from._internal_load_node());
    }
    if (cached_has_bits & 0x00080000u) {
      _internal_mutable_raw_filter_node()->::baikaldb::pb::FilterNode::MergeFrom(from._internal_raw_filter_node());
    }
    if (cached_has_bits & 0x00100000u) {
      _internal_mutable_exchange_sender_node()->::baikaldb::pb::ExchangeSenderNode::MergeFrom(from._internal_exchange_sender_node());
    }
    if (cached_has_bits & 0x00200000u) {
      _internal_mutable_exchange_receiver_node()->::baikaldb::pb::ExchangeReceiverNode::MergeFrom(from._internal_exchange_receiver_node());
    }
    if (cached_has_bits & 0x00400000u) {
      _internal_mutable_select_manager_node()->::baikaldb::pb::SelectManagerNode::MergeFrom(from._internal_select_manager_node());
    }
    if (cached_has_bits & 0x00800000u) {
      _internal_mutable_dual_scan_node()->::baikaldb::pb::DualScanNode::MergeFrom(from._internal_dual_scan_node());
    }
  }
  if (cached_has_bits & 0x01000000u) {
    _internal_mutable_window_node()->::baikaldb::pb::WindowNode::MergeFrom(from._internal_window_node());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DerivePlanNode::CopyFrom(const DerivePlanNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.DerivePlanNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DerivePlanNode::IsInitialized() const {
  if (_internal_has_scan_node()) {
    if (!scan_node_->IsInitialized()) return false;
  }
  if (_internal_has_sort_node()) {
    if (!sort_node_->IsInitialized()) return false;
  }
  if (_internal_has_agg_node()) {
    if (!agg_node_->IsInitialized()) return false;
  }
  if (_internal_has_join_node()) {
    if (!join_node_->IsInitialized()) return false;
  }
  if (_internal_has_insert_node()) {
    if (!insert_node_->IsInitialized()) return false;
  }
  if (_internal_has_delete_node()) {
    if (!delete_node_->IsInitialized()) return false;
  }
  if (_internal_has_update_node()) {
    if (!update_node_->IsInitialized()) return false;
  }
  if (_internal_has_fetcher_node()) {
    if (!fetcher_node_->IsInitialized()) return false;
  }
  if (_internal_has_limit_node()) {
    if (!limit_node_->IsInitialized()) return false;
  }
  if (_internal_has_packet_node()) {
    if (!packet_node_->IsInitialized()) return false;
  }
  if (_internal_has_truncate_node()) {
    if (!truncate_node_->IsInitialized()) return false;
  }
  if (_internal_has_transaction_node()) {
    if (!transaction_node_->IsInitialized()) return false;
  }
  if (_internal_has_kill_node()) {
    if (!kill_node_->IsInitialized()) return false;
  }
  if (_internal_has_lock_primary_node()) {
    if (!lock_primary_node_->IsInitialized()) return false;
  }
  if (_internal_has_lock_secondary_node()) {
    if (!lock_secondary_node_->IsInitialized()) return false;
  }
  if (_internal_has_union_node()) {
    if (!union_node_->IsInitialized()) return false;
  }
  if (_internal_has_apply_node()) {
    if (!apply_node_->IsInitialized()) return false;
  }
  if (_internal_has_load_node()) {
    if (!load_node_->IsInitialized()) return false;
  }
  if (_internal_has_raw_filter_node()) {
    if (!raw_filter_node_->IsInitialized()) return false;
  }
  if (_internal_has_exchange_sender_node()) {
    if (!exchange_sender_node_->IsInitialized()) return false;
  }
  if (_internal_has_exchange_receiver_node()) {
    if (!exchange_receiver_node_->IsInitialized()) return false;
  }
  if (_internal_has_select_manager_node()) {
    if (!select_manager_node_->IsInitialized()) return false;
  }
  if (_internal_has_dual_scan_node()) {
    if (!dual_scan_node_->IsInitialized()) return false;
  }
  if (_internal_has_window_node()) {
    if (!window_node_->IsInitialized()) return false;
  }
  return true;
}

void DerivePlanNode::InternalSwap(DerivePlanNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &filter_node_, lhs_arena,
      &other->filter_node_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DerivePlanNode, window_node_)
      + sizeof(DerivePlanNode::window_node_)
      - PROTOBUF_FIELD_OFFSET(DerivePlanNode, scan_node_)>(
          reinterpret_cast<char*>(&scan_node_),
          reinterpret_cast<char*>(&other->scan_node_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DerivePlanNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[34]);
}

// ===================================================================

class PlanNode::_Internal {
 public:
  using HasBits = decltype(std::declval<PlanNode>()._has_bits_);
  static void set_has_node_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_num_children(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::baikaldb::pb::DerivePlanNode& derive_node(const PlanNode* msg);
  static void set_has_derive_node(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_explain(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_local_index_binlog(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_get_keypoint(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000044) ^ 0x00000044) != 0;
  }
};

const ::baikaldb::pb::DerivePlanNode&
PlanNode::_Internal::derive_node(const PlanNode* msg) {
  return *msg->derive_node_;
}
PlanNode::PlanNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  partitions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.PlanNode)
}
PlanNode::PlanNode(const PlanNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      partitions_(from.partitions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_derive_node()) {
    derive_node_ = new ::baikaldb::pb::DerivePlanNode(*from.derive_node_);
  } else {
    derive_node_ = nullptr;
  }
  ::memcpy(&limit_, &from.limit_,
    static_cast<size_t>(reinterpret_cast<char*>(&node_type_) -
    reinterpret_cast<char*>(&limit_)) + sizeof(node_type_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.PlanNode)
}

void PlanNode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&derive_node_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_get_keypoint_) -
    reinterpret_cast<char*>(&derive_node_)) + sizeof(is_get_keypoint_));
node_type_ = 1;
}

PlanNode::~PlanNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.PlanNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PlanNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete derive_node_;
}

void PlanNode::ArenaDtor(void* object) {
  PlanNode* _this = reinterpret_cast< PlanNode* >(object);
  (void)_this;
}
void PlanNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PlanNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PlanNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.PlanNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  partitions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(derive_node_ != nullptr);
    derive_node_->Clear();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&limit_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_get_keypoint_) -
        reinterpret_cast<char*>(&limit_)) + sizeof(is_get_keypoint_));
    node_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlanNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .baikaldb.pb.PlanNodeType node_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::PlanNodeType_IsValid(val))) {
            _internal_set_node_type(static_cast<::baikaldb::pb::PlanNodeType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required int32 num_children = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_num_children(&has_bits);
          num_children_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 limit = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_limit(&has_bits);
          limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.DerivePlanNode derive_node = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_derive_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_explain = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_is_explain(&has_bits);
          is_explain_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool local_index_binlog = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_local_index_binlog(&has_bits);
          local_index_binlog_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 partitions = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_partitions(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<72>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_partitions(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_get_keypoint = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_is_get_keypoint(&has_bits);
          is_get_keypoint_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PlanNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.PlanNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .baikaldb.pb.PlanNodeType node_type = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_node_type(), target);
  }

  // required int32 num_children = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_num_children(), target);
  }

  // optional int64 limit = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_limit(), target);
  }

  // optional .baikaldb.pb.DerivePlanNode derive_node = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::derive_node(this), target, stream);
  }

  // optional bool is_explain = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_is_explain(), target);
  }

  // optional bool local_index_binlog = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_local_index_binlog(), target);
  }

  // repeated int64 partitions = 9;
  for (int i = 0, n = this->_internal_partitions_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(9, this->_internal_partitions(i), target);
  }

  // optional bool is_get_keypoint = 10;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_is_get_keypoint(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.PlanNode)
  return target;
}

size_t PlanNode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.PlanNode)
  size_t total_size = 0;

  if (_internal_has_num_children()) {
    // required int32 num_children = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_num_children());
  }

  if (_internal_has_node_type()) {
    // required .baikaldb.pb.PlanNodeType node_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_node_type());
  }

  return total_size;
}
size_t PlanNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.PlanNode)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000044) ^ 0x00000044) == 0) {  // All required fields are present.
    // required int32 num_children = 3;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_num_children());

    // required .baikaldb.pb.PlanNodeType node_type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_node_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 partitions = 9;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int64Size(this->partitions_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_partitions_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .baikaldb.pb.DerivePlanNode derive_node = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *derive_node_);
    }

    // optional int64 limit = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_limit());
    }

  }
  if (cached_has_bits & 0x00000038u) {
    // optional bool is_explain = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool local_index_binlog = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool is_get_keypoint = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlanNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PlanNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlanNode::GetClassData() const { return &_class_data_; }

void PlanNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PlanNode *>(to)->MergeFrom(
      static_cast<const PlanNode &>(from));
}


void PlanNode::MergeFrom(const PlanNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.PlanNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  partitions_.MergeFrom(from.partitions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_derive_node()->::baikaldb::pb::DerivePlanNode::MergeFrom(from._internal_derive_node());
    }
    if (cached_has_bits & 0x00000002u) {
      limit_ = from.limit_;
    }
    if (cached_has_bits & 0x00000004u) {
      num_children_ = from.num_children_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_explain_ = from.is_explain_;
    }
    if (cached_has_bits & 0x00000010u) {
      local_index_binlog_ = from.local_index_binlog_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_get_keypoint_ = from.is_get_keypoint_;
    }
    if (cached_has_bits & 0x00000040u) {
      node_type_ = from.node_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlanNode::CopyFrom(const PlanNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.PlanNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_derive_node()) {
    if (!derive_node_->IsInitialized()) return false;
  }
  return true;
}

void PlanNode::InternalSwap(PlanNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  partitions_.InternalSwap(&other->partitions_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlanNode, is_get_keypoint_)
      + sizeof(PlanNode::is_get_keypoint_)
      - PROTOBUF_FIELD_OFFSET(PlanNode, derive_node_)>(
          reinterpret_cast<char*>(&derive_node_),
          reinterpret_cast<char*>(&other->derive_node_));
  swap(node_type_, other->node_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlanNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[35]);
}

// ===================================================================

class Plan::_Internal {
 public:
};

Plan::Plan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  nodes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.Plan)
}
Plan::Plan(const Plan& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      nodes_(from.nodes_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.Plan)
}

void Plan::SharedCtor() {
}

Plan::~Plan() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.Plan)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Plan::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Plan::ArenaDtor(void* object) {
  Plan* _this = reinterpret_cast< Plan* >(object);
  (void)_this;
}
void Plan::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Plan::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Plan::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.Plan)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nodes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Plan::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .baikaldb.pb.PlanNode nodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Plan::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.Plan)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .baikaldb.pb.PlanNode nodes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_nodes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_nodes(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.Plan)
  return target;
}

size_t Plan::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.Plan)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.PlanNode nodes = 1;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Plan::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Plan::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Plan::GetClassData() const { return &_class_data_; }

void Plan::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Plan *>(to)->MergeFrom(
      static_cast<const Plan &>(from));
}


void Plan::MergeFrom(const Plan& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.Plan)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  nodes_.MergeFrom(from.nodes_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Plan::CopyFrom(const Plan& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.Plan)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Plan::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(nodes_)) return false;
  return true;
}

void Plan::InternalSwap(Plan* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  nodes_.InternalSwap(&other->nodes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Plan::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[36]);
}

// ===================================================================

class LocalTraceNode::_Internal {
 public:
  using HasBits = decltype(std::declval<LocalTraceNode>()._has_bits_);
  static void set_has_time_cost_us(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sort_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_affect_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_scan_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_index_filter_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_get_primary_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_where_filter_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_index_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mpp_property(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

LocalTraceNode::LocalTraceNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  arrow_plan_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.LocalTraceNode)
}
LocalTraceNode::LocalTraceNode(const LocalTraceNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      arrow_plan_(from.arrow_plan_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_description()) {
    description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_description(), 
      GetArenaForAllocation());
  }
  index_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_index_name()) {
    index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_index_name(), 
      GetArenaForAllocation());
  }
  mpp_property_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_mpp_property()) {
    mpp_property_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_mpp_property(), 
      GetArenaForAllocation());
  }
  ::memcpy(&time_cost_us_, &from.time_cost_us_,
    static_cast<size_t>(reinterpret_cast<char*>(&where_filter_rows_) -
    reinterpret_cast<char*>(&time_cost_us_)) + sizeof(where_filter_rows_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.LocalTraceNode)
}

void LocalTraceNode::SharedCtor() {
description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
index_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
mpp_property_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&time_cost_us_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&where_filter_rows_) -
    reinterpret_cast<char*>(&time_cost_us_)) + sizeof(where_filter_rows_));
}

LocalTraceNode::~LocalTraceNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.LocalTraceNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void LocalTraceNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  index_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  mpp_property_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void LocalTraceNode::ArenaDtor(void* object) {
  LocalTraceNode* _this = reinterpret_cast< LocalTraceNode* >(object);
  (void)_this;
}
void LocalTraceNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LocalTraceNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void LocalTraceNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.LocalTraceNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  arrow_plan_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      index_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      mpp_property_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&time_cost_us_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&index_filter_rows_) -
        reinterpret_cast<char*>(&time_cost_us_)) + sizeof(index_filter_rows_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&get_primary_rows_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&where_filter_rows_) -
        reinterpret_cast<char*>(&get_primary_rows_)) + sizeof(where_filter_rows_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LocalTraceNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 time_cost_us = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_time_cost_us(&has_bits);
          time_cost_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 sort_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_sort_time(&has_bits);
          sort_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 affect_rows = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_affect_rows(&has_bits);
          affect_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 scan_rows = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_scan_rows(&has_bits);
          scan_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 index_filter_rows = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_index_filter_rows(&has_bits);
          index_filter_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 get_primary_rows = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_get_primary_rows(&has_bits);
          get_primary_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          auto str = _internal_mutable_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.LocalTraceNode.description");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 where_filter_rows = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_where_filter_rows(&has_bits);
          where_filter_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string index_name = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          auto str = _internal_mutable_index_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.LocalTraceNode.index_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string arrow_plan = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_arrow_plan();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.LocalTraceNode.arrow_plan");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string mpp_property = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          auto str = _internal_mutable_mpp_property();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.LocalTraceNode.mpp_property");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LocalTraceNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.LocalTraceNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 time_cost_us = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_time_cost_us(), target);
  }

  // optional int64 sort_time = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_sort_time(), target);
  }

  // optional int64 affect_rows = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_affect_rows(), target);
  }

  // optional int64 scan_rows = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_scan_rows(), target);
  }

  // optional int64 index_filter_rows = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_index_filter_rows(), target);
  }

  // optional int64 get_primary_rows = 6;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_get_primary_rows(), target);
  }

  // optional string description = 8;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.LocalTraceNode.description");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_description(), target);
  }

  // optional int64 where_filter_rows = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(9, this->_internal_where_filter_rows(), target);
  }

  // optional string index_name = 10;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_index_name().data(), static_cast<int>(this->_internal_index_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.LocalTraceNode.index_name");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_index_name(), target);
  }

  // repeated string arrow_plan = 11;
  for (int i = 0, n = this->_internal_arrow_plan_size(); i < n; i++) {
    const auto& s = this->_internal_arrow_plan(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.LocalTraceNode.arrow_plan");
    target = stream->WriteString(11, s, target);
  }

  // optional string mpp_property = 12;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_mpp_property().data(), static_cast<int>(this->_internal_mpp_property().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.LocalTraceNode.mpp_property");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_mpp_property(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.LocalTraceNode)
  return target;
}

size_t LocalTraceNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.LocalTraceNode)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string arrow_plan = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(arrow_plan_.size());
  for (int i = 0, n = arrow_plan_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      arrow_plan_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string description = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional string index_name = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_index_name());
    }

    // optional string mpp_property = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mpp_property());
    }

    // optional int64 time_cost_us = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_time_cost_us());
    }

    // optional int64 sort_time = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_sort_time());
    }

    // optional int64 affect_rows = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_affect_rows());
    }

    // optional int64 scan_rows = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_scan_rows());
    }

    // optional int64 index_filter_rows = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_index_filter_rows());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int64 get_primary_rows = 6;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_get_primary_rows());
    }

    // optional int64 where_filter_rows = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_where_filter_rows());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LocalTraceNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    LocalTraceNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LocalTraceNode::GetClassData() const { return &_class_data_; }

void LocalTraceNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<LocalTraceNode *>(to)->MergeFrom(
      static_cast<const LocalTraceNode &>(from));
}


void LocalTraceNode::MergeFrom(const LocalTraceNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.LocalTraceNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  arrow_plan_.MergeFrom(from.arrow_plan_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_index_name(from._internal_index_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_mpp_property(from._internal_mpp_property());
    }
    if (cached_has_bits & 0x00000008u) {
      time_cost_us_ = from.time_cost_us_;
    }
    if (cached_has_bits & 0x00000010u) {
      sort_time_ = from.sort_time_;
    }
    if (cached_has_bits & 0x00000020u) {
      affect_rows_ = from.affect_rows_;
    }
    if (cached_has_bits & 0x00000040u) {
      scan_rows_ = from.scan_rows_;
    }
    if (cached_has_bits & 0x00000080u) {
      index_filter_rows_ = from.index_filter_rows_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      get_primary_rows_ = from.get_primary_rows_;
    }
    if (cached_has_bits & 0x00000200u) {
      where_filter_rows_ = from.where_filter_rows_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LocalTraceNode::CopyFrom(const LocalTraceNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.LocalTraceNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocalTraceNode::IsInitialized() const {
  return true;
}

void LocalTraceNode::InternalSwap(LocalTraceNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  arrow_plan_.InternalSwap(&other->arrow_plan_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &index_name_, lhs_arena,
      &other->index_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &mpp_property_, lhs_arena,
      &other->mpp_property_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LocalTraceNode, where_filter_rows_)
      + sizeof(LocalTraceNode::where_filter_rows_)
      - PROTOBUF_FIELD_OFFSET(LocalTraceNode, time_cost_us_)>(
          reinterpret_cast<char*>(&time_cost_us_),
          reinterpret_cast<char*>(&other->time_cost_us_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LocalTraceNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[37]);
}

// ===================================================================

class TraceNode::_Internal {
 public:
  using HasBits = decltype(std::declval<TraceNode>()._has_bits_);
  static void set_has_node_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_instance(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_region_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_total_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_affect_rows(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::baikaldb::pb::LocalTraceNode& open_trace(const TraceNode* msg);
  static void set_has_open_trace(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::baikaldb::pb::LocalTraceNode& get_next_trace(const TraceNode* msg);
  static void set_has_get_next_trace(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::baikaldb::pb::LocalTraceNode& txn_get_trace(const TraceNode* msg);
  static void set_has_txn_get_trace(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::baikaldb::pb::LocalTraceNode& txn_put_trace(const TraceNode* msg);
  static void set_has_txn_put_trace(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::baikaldb::pb::LocalTraceNode& txn_delete_trace(const TraceNode* msg);
  static void set_has_txn_delete_trace(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::baikaldb::pb::LocalTraceNode& txn_commit_trace(const TraceNode* msg);
  static void set_has_txn_commit_trace(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::baikaldb::pb::LocalTraceNode& store_agg(const TraceNode* msg);
  static void set_has_store_agg(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_partition_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

const ::baikaldb::pb::LocalTraceNode&
TraceNode::_Internal::open_trace(const TraceNode* msg) {
  return *msg->open_trace_;
}
const ::baikaldb::pb::LocalTraceNode&
TraceNode::_Internal::get_next_trace(const TraceNode* msg) {
  return *msg->get_next_trace_;
}
const ::baikaldb::pb::LocalTraceNode&
TraceNode::_Internal::txn_get_trace(const TraceNode* msg) {
  return *msg->txn_get_trace_;
}
const ::baikaldb::pb::LocalTraceNode&
TraceNode::_Internal::txn_put_trace(const TraceNode* msg) {
  return *msg->txn_put_trace_;
}
const ::baikaldb::pb::LocalTraceNode&
TraceNode::_Internal::txn_delete_trace(const TraceNode* msg) {
  return *msg->txn_delete_trace_;
}
const ::baikaldb::pb::LocalTraceNode&
TraceNode::_Internal::txn_commit_trace(const TraceNode* msg) {
  return *msg->txn_commit_trace_;
}
const ::baikaldb::pb::LocalTraceNode&
TraceNode::_Internal::store_agg(const TraceNode* msg) {
  return *msg->store_agg_;
}
TraceNode::TraceNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  child_nodes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.TraceNode)
}
TraceNode::TraceNode(const TraceNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      child_nodes_(from.child_nodes_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_description()) {
    description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_description(), 
      GetArenaForAllocation());
  }
  instance_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_instance()) {
    instance_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_instance(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_open_trace()) {
    open_trace_ = new ::baikaldb::pb::LocalTraceNode(*from.open_trace_);
  } else {
    open_trace_ = nullptr;
  }
  if (from._internal_has_get_next_trace()) {
    get_next_trace_ = new ::baikaldb::pb::LocalTraceNode(*from.get_next_trace_);
  } else {
    get_next_trace_ = nullptr;
  }
  if (from._internal_has_txn_get_trace()) {
    txn_get_trace_ = new ::baikaldb::pb::LocalTraceNode(*from.txn_get_trace_);
  } else {
    txn_get_trace_ = nullptr;
  }
  if (from._internal_has_txn_put_trace()) {
    txn_put_trace_ = new ::baikaldb::pb::LocalTraceNode(*from.txn_put_trace_);
  } else {
    txn_put_trace_ = nullptr;
  }
  if (from._internal_has_txn_delete_trace()) {
    txn_delete_trace_ = new ::baikaldb::pb::LocalTraceNode(*from.txn_delete_trace_);
  } else {
    txn_delete_trace_ = nullptr;
  }
  if (from._internal_has_txn_commit_trace()) {
    txn_commit_trace_ = new ::baikaldb::pb::LocalTraceNode(*from.txn_commit_trace_);
  } else {
    txn_commit_trace_ = nullptr;
  }
  if (from._internal_has_store_agg()) {
    store_agg_ = new ::baikaldb::pb::LocalTraceNode(*from.store_agg_);
  } else {
    store_agg_ = nullptr;
  }
  ::memcpy(&region_id_, &from.region_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&node_type_) -
    reinterpret_cast<char*>(&region_id_)) + sizeof(node_type_));
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.TraceNode)
}

void TraceNode::SharedCtor() {
description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
instance_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&open_trace_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&partition_id_) -
    reinterpret_cast<char*>(&open_trace_)) + sizeof(partition_id_));
node_type_ = 1;
}

TraceNode::~TraceNode() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.TraceNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void TraceNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  instance_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete open_trace_;
  if (this != internal_default_instance()) delete get_next_trace_;
  if (this != internal_default_instance()) delete txn_get_trace_;
  if (this != internal_default_instance()) delete txn_put_trace_;
  if (this != internal_default_instance()) delete txn_delete_trace_;
  if (this != internal_default_instance()) delete txn_commit_trace_;
  if (this != internal_default_instance()) delete store_agg_;
}

void TraceNode::ArenaDtor(void* object) {
  TraceNode* _this = reinterpret_cast< TraceNode* >(object);
  (void)_this;
}
void TraceNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TraceNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TraceNode::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.TraceNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  child_nodes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      instance_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(open_trace_ != nullptr);
      open_trace_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(get_next_trace_ != nullptr);
      get_next_trace_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(txn_get_trace_ != nullptr);
      txn_get_trace_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(txn_put_trace_ != nullptr);
      txn_put_trace_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(txn_delete_trace_ != nullptr);
      txn_delete_trace_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(txn_commit_trace_ != nullptr);
      txn_commit_trace_->Clear();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    GOOGLE_DCHECK(store_agg_ != nullptr);
    store_agg_->Clear();
  }
  if (cached_has_bits & 0x00003e00u) {
    ::memset(&region_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&partition_id_) -
        reinterpret_cast<char*>(&region_id_)) + sizeof(partition_id_));
    node_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TraceNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .baikaldb.pb.PlanNodeType node_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::baikaldb::pb::PlanNodeType_IsValid(val))) {
            _internal_set_node_type(static_cast<::baikaldb::pb::PlanNodeType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.TraceNode.description");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string instance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_instance();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "baikaldb.pb.TraceNode.instance");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 region_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_region_id(&has_bits);
          region_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 total_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_total_time(&has_bits);
          total_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 affect_rows = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_affect_rows(&has_bits);
          affect_rows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.LocalTraceNode open_trace = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_open_trace(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.LocalTraceNode get_next_trace = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_next_trace(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.LocalTraceNode txn_get_trace = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_txn_get_trace(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.LocalTraceNode txn_put_trace = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_txn_put_trace(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.LocalTraceNode txn_delete_trace = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_txn_delete_trace(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.LocalTraceNode txn_commit_trace = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_txn_commit_trace(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.LocalTraceNode store_agg = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_store_agg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .baikaldb.pb.TraceNode child_nodes = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_child_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 partition_id = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_partition_id(&has_bits);
          partition_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TraceNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.TraceNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .baikaldb.pb.PlanNodeType node_type = 1;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_node_type(), target);
  }

  // optional string description = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.TraceNode.description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // optional string instance = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_instance().data(), static_cast<int>(this->_internal_instance().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "baikaldb.pb.TraceNode.instance");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_instance(), target);
  }

  // optional int64 region_id = 4;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_region_id(), target);
  }

  // optional int64 total_time = 5;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_total_time(), target);
  }

  // optional int64 affect_rows = 6;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_affect_rows(), target);
  }

  // optional .baikaldb.pb.LocalTraceNode open_trace = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::open_trace(this), target, stream);
  }

  // optional .baikaldb.pb.LocalTraceNode get_next_trace = 8;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::get_next_trace(this), target, stream);
  }

  // optional .baikaldb.pb.LocalTraceNode txn_get_trace = 9;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::txn_get_trace(this), target, stream);
  }

  // optional .baikaldb.pb.LocalTraceNode txn_put_trace = 10;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::txn_put_trace(this), target, stream);
  }

  // optional .baikaldb.pb.LocalTraceNode txn_delete_trace = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::txn_delete_trace(this), target, stream);
  }

  // optional .baikaldb.pb.LocalTraceNode txn_commit_trace = 12;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::txn_commit_trace(this), target, stream);
  }

  // optional .baikaldb.pb.LocalTraceNode store_agg = 13;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::store_agg(this), target, stream);
  }

  // repeated .baikaldb.pb.TraceNode child_nodes = 14;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_child_nodes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, this->_internal_child_nodes(i), target, stream);
  }

  // optional int64 partition_id = 15;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(15, this->_internal_partition_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.TraceNode)
  return target;
}

size_t TraceNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.TraceNode)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .baikaldb.pb.TraceNode child_nodes = 14;
  total_size += 1UL * this->_internal_child_nodes_size();
  for (const auto& msg : this->child_nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string description = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional string instance = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_instance());
    }

    // optional .baikaldb.pb.LocalTraceNode open_trace = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *open_trace_);
    }

    // optional .baikaldb.pb.LocalTraceNode get_next_trace = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *get_next_trace_);
    }

    // optional .baikaldb.pb.LocalTraceNode txn_get_trace = 9;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *txn_get_trace_);
    }

    // optional .baikaldb.pb.LocalTraceNode txn_put_trace = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *txn_put_trace_);
    }

    // optional .baikaldb.pb.LocalTraceNode txn_delete_trace = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *txn_delete_trace_);
    }

    // optional .baikaldb.pb.LocalTraceNode txn_commit_trace = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *txn_commit_trace_);
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional .baikaldb.pb.LocalTraceNode store_agg = 13;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *store_agg_);
    }

    // optional int64 region_id = 4;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_region_id());
    }

    // optional int64 total_time = 5;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_total_time());
    }

    // optional int64 affect_rows = 6;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_affect_rows());
    }

    // optional int64 partition_id = 15;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_partition_id());
    }

    // optional .baikaldb.pb.PlanNodeType node_type = 1;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_node_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TraceNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    TraceNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TraceNode::GetClassData() const { return &_class_data_; }

void TraceNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<TraceNode *>(to)->MergeFrom(
      static_cast<const TraceNode &>(from));
}


void TraceNode::MergeFrom(const TraceNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.TraceNode)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  child_nodes_.MergeFrom(from.child_nodes_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_instance(from._internal_instance());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_open_trace()->::baikaldb::pb::LocalTraceNode::MergeFrom(from._internal_open_trace());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_get_next_trace()->::baikaldb::pb::LocalTraceNode::MergeFrom(from._internal_get_next_trace());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_txn_get_trace()->::baikaldb::pb::LocalTraceNode::MergeFrom(from._internal_txn_get_trace());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_txn_put_trace()->::baikaldb::pb::LocalTraceNode::MergeFrom(from._internal_txn_put_trace());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_txn_delete_trace()->::baikaldb::pb::LocalTraceNode::MergeFrom(from._internal_txn_delete_trace());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_txn_commit_trace()->::baikaldb::pb::LocalTraceNode::MergeFrom(from._internal_txn_commit_trace());
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_store_agg()->::baikaldb::pb::LocalTraceNode::MergeFrom(from._internal_store_agg());
    }
    if (cached_has_bits & 0x00000200u) {
      region_id_ = from.region_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      total_time_ = from.total_time_;
    }
    if (cached_has_bits & 0x00000800u) {
      affect_rows_ = from.affect_rows_;
    }
    if (cached_has_bits & 0x00001000u) {
      partition_id_ = from.partition_id_;
    }
    if (cached_has_bits & 0x00002000u) {
      node_type_ = from.node_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TraceNode::CopyFrom(const TraceNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.TraceNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceNode::IsInitialized() const {
  return true;
}

void TraceNode::InternalSwap(TraceNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  child_nodes_.InternalSwap(&other->child_nodes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &instance_, lhs_arena,
      &other->instance_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TraceNode, partition_id_)
      + sizeof(TraceNode::partition_id_)
      - PROTOBUF_FIELD_OFFSET(TraceNode, open_trace_)>(
          reinterpret_cast<char*>(&open_trace_),
          reinterpret_cast<char*>(&other->open_trace_));
  swap(node_type_, other->node_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TraceNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[38]);
}

// ===================================================================

class FragmentInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<FragmentInfo>()._has_bits_);
  static void set_has_fragment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::baikaldb::pb::Plan& plan(const FragmentInfo* msg);
  static void set_has_plan(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::baikaldb::pb::RuntimeState& runtime_state(const FragmentInfo* msg);
  static void set_has_runtime_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

const ::baikaldb::pb::Plan&
FragmentInfo::_Internal::plan(const FragmentInfo* msg) {
  return *msg->plan_;
}
const ::baikaldb::pb::RuntimeState&
FragmentInfo::_Internal::runtime_state(const FragmentInfo* msg) {
  return *msg->runtime_state_;
}
void FragmentInfo::clear_runtime_state() {
  if (runtime_state_ != nullptr) runtime_state_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
FragmentInfo::FragmentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:baikaldb.pb.FragmentInfo)
}
FragmentInfo::FragmentInfo(const FragmentInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_plan()) {
    plan_ = new ::baikaldb::pb::Plan(*from.plan_);
  } else {
    plan_ = nullptr;
  }
  if (from._internal_has_runtime_state()) {
    runtime_state_ = new ::baikaldb::pb::RuntimeState(*from.runtime_state_);
  } else {
    runtime_state_ = nullptr;
  }
  fragment_id_ = from.fragment_id_;
  // @@protoc_insertion_point(copy_constructor:baikaldb.pb.FragmentInfo)
}

void FragmentInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&plan_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&fragment_id_) -
    reinterpret_cast<char*>(&plan_)) + sizeof(fragment_id_));
}

FragmentInfo::~FragmentInfo() {
  // @@protoc_insertion_point(destructor:baikaldb.pb.FragmentInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FragmentInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete plan_;
  if (this != internal_default_instance()) delete runtime_state_;
}

void FragmentInfo::ArenaDtor(void* object) {
  FragmentInfo* _this = reinterpret_cast< FragmentInfo* >(object);
  (void)_this;
}
void FragmentInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FragmentInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FragmentInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:baikaldb.pb.FragmentInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(plan_ != nullptr);
      plan_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(runtime_state_ != nullptr);
      runtime_state_->Clear();
    }
  }
  fragment_id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FragmentInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 fragment_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_fragment_id(&has_bits);
          fragment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .baikaldb.pb.Plan plan = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_plan(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .baikaldb.pb.RuntimeState runtime_state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_runtime_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FragmentInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:baikaldb.pb.FragmentInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 fragment_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_fragment_id(), target);
  }

  // required .baikaldb.pb.Plan plan = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::plan(this), target, stream);
  }

  // optional .baikaldb.pb.RuntimeState runtime_state = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::runtime_state(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:baikaldb.pb.FragmentInfo)
  return target;
}

size_t FragmentInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:baikaldb.pb.FragmentInfo)
  size_t total_size = 0;

  if (_internal_has_plan()) {
    // required .baikaldb.pb.Plan plan = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *plan_);
  }

  if (_internal_has_fragment_id()) {
    // required int32 fragment_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_fragment_id());
  }

  return total_size;
}
size_t FragmentInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:baikaldb.pb.FragmentInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required .baikaldb.pb.Plan plan = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *plan_);

    // required int32 fragment_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_fragment_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .baikaldb.pb.RuntimeState runtime_state = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *runtime_state_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FragmentInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FragmentInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FragmentInfo::GetClassData() const { return &_class_data_; }

void FragmentInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FragmentInfo *>(to)->MergeFrom(
      static_cast<const FragmentInfo &>(from));
}


void FragmentInfo::MergeFrom(const FragmentInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:baikaldb.pb.FragmentInfo)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_plan()->::baikaldb::pb::Plan::MergeFrom(from._internal_plan());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_runtime_state()->::baikaldb::pb::RuntimeState::MergeFrom(from._internal_runtime_state());
    }
    if (cached_has_bits & 0x00000004u) {
      fragment_id_ = from.fragment_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FragmentInfo::CopyFrom(const FragmentInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:baikaldb.pb.FragmentInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FragmentInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_plan()) {
    if (!plan_->IsInitialized()) return false;
  }
  if (_internal_has_runtime_state()) {
    if (!runtime_state_->IsInitialized()) return false;
  }
  return true;
}

void FragmentInfo::InternalSwap(FragmentInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FragmentInfo, fragment_id_)
      + sizeof(FragmentInfo::fragment_id_)
      - PROTOBUF_FIELD_OFFSET(FragmentInfo, plan_)>(
          reinterpret_cast<char*>(&plan_),
          reinterpret_cast<char*>(&other->plan_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FragmentInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_plan_2eproto_getter, &descriptor_table_plan_2eproto_once,
      file_level_metadata_plan_2eproto[39]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace pb
}  // namespace baikaldb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::baikaldb::pb::SelectManagerNode* Arena::CreateMaybeMessage< ::baikaldb::pb::SelectManagerNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::SelectManagerNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::PossibleIndex_Range* Arena::CreateMaybeMessage< ::baikaldb::pb::PossibleIndex_Range >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::PossibleIndex_Range >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::PossibleIndex_SortIndex* Arena::CreateMaybeMessage< ::baikaldb::pb::PossibleIndex_SortIndex >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::PossibleIndex_SortIndex >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::PossibleIndex* Arena::CreateMaybeMessage< ::baikaldb::pb::PossibleIndex >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::PossibleIndex >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::FulltextIndex* Arena::CreateMaybeMessage< ::baikaldb::pb::FulltextIndex >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::FulltextIndex >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::ScanNode* Arena::CreateMaybeMessage< ::baikaldb::pb::ScanNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::ScanNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::LimitNode* Arena::CreateMaybeMessage< ::baikaldb::pb::LimitNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::LimitNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::SortNode* Arena::CreateMaybeMessage< ::baikaldb::pb::SortNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::SortNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::AggNode* Arena::CreateMaybeMessage< ::baikaldb::pb::AggNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::AggNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::FilterNode* Arena::CreateMaybeMessage< ::baikaldb::pb::FilterNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::FilterNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::DualScanNode* Arena::CreateMaybeMessage< ::baikaldb::pb::DualScanNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::DualScanNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::JoinNode* Arena::CreateMaybeMessage< ::baikaldb::pb::JoinNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::JoinNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::ApplyNode* Arena::CreateMaybeMessage< ::baikaldb::pb::ApplyNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::ApplyNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::FetcherNode* Arena::CreateMaybeMessage< ::baikaldb::pb::FetcherNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::FetcherNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::InsertNode* Arena::CreateMaybeMessage< ::baikaldb::pb::InsertNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::InsertNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::LockPrimaryNode* Arena::CreateMaybeMessage< ::baikaldb::pb::LockPrimaryNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::LockPrimaryNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::LockSecondaryNode* Arena::CreateMaybeMessage< ::baikaldb::pb::LockSecondaryNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::LockSecondaryNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::DeleteNode* Arena::CreateMaybeMessage< ::baikaldb::pb::DeleteNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::DeleteNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::TruncateNode* Arena::CreateMaybeMessage< ::baikaldb::pb::TruncateNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::TruncateNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::UpdateNode* Arena::CreateMaybeMessage< ::baikaldb::pb::UpdateNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::UpdateNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::PacketNode* Arena::CreateMaybeMessage< ::baikaldb::pb::PacketNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::PacketNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::TransactionNode* Arena::CreateMaybeMessage< ::baikaldb::pb::TransactionNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::TransactionNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::KillNode* Arena::CreateMaybeMessage< ::baikaldb::pb::KillNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::KillNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::UnionNode* Arena::CreateMaybeMessage< ::baikaldb::pb::UnionNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::UnionNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::LoadNode* Arena::CreateMaybeMessage< ::baikaldb::pb::LoadNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::LoadNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::PartitionProperty* Arena::CreateMaybeMessage< ::baikaldb::pb::PartitionProperty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::PartitionProperty >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::ExchangeDestination* Arena::CreateMaybeMessage< ::baikaldb::pb::ExchangeDestination >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::ExchangeDestination >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::ExchangeSenderNode* Arena::CreateMaybeMessage< ::baikaldb::pb::ExchangeSenderNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::ExchangeSenderNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::ExchangeReceiverNode* Arena::CreateMaybeMessage< ::baikaldb::pb::ExchangeReceiverNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::ExchangeReceiverNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::FrameBound* Arena::CreateMaybeMessage< ::baikaldb::pb::FrameBound >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::FrameBound >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::FrameExtent* Arena::CreateMaybeMessage< ::baikaldb::pb::FrameExtent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::FrameExtent >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::WindowFrame* Arena::CreateMaybeMessage< ::baikaldb::pb::WindowFrame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::WindowFrame >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::WindowSpec* Arena::CreateMaybeMessage< ::baikaldb::pb::WindowSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::WindowSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::WindowNode* Arena::CreateMaybeMessage< ::baikaldb::pb::WindowNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::WindowNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::DerivePlanNode* Arena::CreateMaybeMessage< ::baikaldb::pb::DerivePlanNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::DerivePlanNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::PlanNode* Arena::CreateMaybeMessage< ::baikaldb::pb::PlanNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::PlanNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::Plan* Arena::CreateMaybeMessage< ::baikaldb::pb::Plan >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::Plan >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::LocalTraceNode* Arena::CreateMaybeMessage< ::baikaldb::pb::LocalTraceNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::LocalTraceNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::TraceNode* Arena::CreateMaybeMessage< ::baikaldb::pb::TraceNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::TraceNode >(arena);
}
template<> PROTOBUF_NOINLINE ::baikaldb::pb::FragmentInfo* Arena::CreateMaybeMessage< ::baikaldb::pb::FragmentInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::baikaldb::pb::FragmentInfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
