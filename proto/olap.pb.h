// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: olap.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_olap_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_olap_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_olap_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_olap_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_olap_2eproto;
namespace baikaldb {
namespace pb {
class BaseExpansionPolicyMessage;
struct BaseExpansionPolicyMessageDefaultTypeInternal;
extern BaseExpansionPolicyMessageDefaultTypeInternal _BaseExpansionPolicyMessage_default_instance_;
class ColumnMessage;
struct ColumnMessageDefaultTypeInternal;
extern ColumnMessageDefaultTypeInternal _ColumnMessage_default_instance_;
class CumulativePolicyMessage;
struct CumulativePolicyMessageDefaultTypeInternal;
extern CumulativePolicyMessageDefaultTypeInternal _CumulativePolicyMessage_default_instance_;
class DeleteDataPolicyMessage;
struct DeleteDataPolicyMessageDefaultTypeInternal;
extern DeleteDataPolicyMessageDefaultTypeInternal _DeleteDataPolicyMessage_default_instance_;
class DelteCondMessage;
struct DelteCondMessageDefaultTypeInternal;
extern DelteCondMessageDefaultTypeInternal _DelteCondMessage_default_instance_;
class FileVersionMessage;
struct FileVersionMessageDefaultTypeInternal;
extern FileVersionMessageDefaultTypeInternal _FileVersionMessage_default_instance_;
class OLAPDataHeaderMessage;
struct OLAPDataHeaderMessageDefaultTypeInternal;
extern OLAPDataHeaderMessageDefaultTypeInternal _OLAPDataHeaderMessage_default_instance_;
class OLAPHeaderMessage;
struct OLAPHeaderMessageDefaultTypeInternal;
extern OLAPHeaderMessageDefaultTypeInternal _OLAPHeaderMessage_default_instance_;
class OLAPIndexHeaderMessage;
struct OLAPIndexHeaderMessageDefaultTypeInternal;
extern OLAPIndexHeaderMessageDefaultTypeInternal _OLAPIndexHeaderMessage_default_instance_;
class OLAPRawDeltaHeaderMessage;
struct OLAPRawDeltaHeaderMessageDefaultTypeInternal;
extern OLAPRawDeltaHeaderMessageDefaultTypeInternal _OLAPRawDeltaHeaderMessage_default_instance_;
class PartitionPolicyMessage;
struct PartitionPolicyMessageDefaultTypeInternal;
extern PartitionPolicyMessageDefaultTypeInternal _PartitionPolicyMessage_default_instance_;
class SchemaChangeStatusMessage;
struct SchemaChangeStatusMessageDefaultTypeInternal;
extern SchemaChangeStatusMessageDefaultTypeInternal _SchemaChangeStatusMessage_default_instance_;
class TierStoragePolicyMessage;
struct TierStoragePolicyMessageDefaultTypeInternal;
extern TierStoragePolicyMessageDefaultTypeInternal _TierStoragePolicyMessage_default_instance_;
}  // namespace pb
}  // namespace baikaldb
PROTOBUF_NAMESPACE_OPEN
template<> ::baikaldb::pb::BaseExpansionPolicyMessage* Arena::CreateMaybeMessage<::baikaldb::pb::BaseExpansionPolicyMessage>(Arena*);
template<> ::baikaldb::pb::ColumnMessage* Arena::CreateMaybeMessage<::baikaldb::pb::ColumnMessage>(Arena*);
template<> ::baikaldb::pb::CumulativePolicyMessage* Arena::CreateMaybeMessage<::baikaldb::pb::CumulativePolicyMessage>(Arena*);
template<> ::baikaldb::pb::DeleteDataPolicyMessage* Arena::CreateMaybeMessage<::baikaldb::pb::DeleteDataPolicyMessage>(Arena*);
template<> ::baikaldb::pb::DelteCondMessage* Arena::CreateMaybeMessage<::baikaldb::pb::DelteCondMessage>(Arena*);
template<> ::baikaldb::pb::FileVersionMessage* Arena::CreateMaybeMessage<::baikaldb::pb::FileVersionMessage>(Arena*);
template<> ::baikaldb::pb::OLAPDataHeaderMessage* Arena::CreateMaybeMessage<::baikaldb::pb::OLAPDataHeaderMessage>(Arena*);
template<> ::baikaldb::pb::OLAPHeaderMessage* Arena::CreateMaybeMessage<::baikaldb::pb::OLAPHeaderMessage>(Arena*);
template<> ::baikaldb::pb::OLAPIndexHeaderMessage* Arena::CreateMaybeMessage<::baikaldb::pb::OLAPIndexHeaderMessage>(Arena*);
template<> ::baikaldb::pb::OLAPRawDeltaHeaderMessage* Arena::CreateMaybeMessage<::baikaldb::pb::OLAPRawDeltaHeaderMessage>(Arena*);
template<> ::baikaldb::pb::PartitionPolicyMessage* Arena::CreateMaybeMessage<::baikaldb::pb::PartitionPolicyMessage>(Arena*);
template<> ::baikaldb::pb::SchemaChangeStatusMessage* Arena::CreateMaybeMessage<::baikaldb::pb::SchemaChangeStatusMessage>(Arena*);
template<> ::baikaldb::pb::TierStoragePolicyMessage* Arena::CreateMaybeMessage<::baikaldb::pb::TierStoragePolicyMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace baikaldb {
namespace pb {

enum OlapPrimitiveType : int {
  olap_uint8_t = 1,
  olap_int8_t = 2,
  olap_uint16_t = 3,
  olap_int16_t = 4,
  olap_uint32_t = 5,
  olap_int32_t = 6,
  olap_uint64_t = 7,
  olap_int64_t = 8,
  olap_float_t = 9,
  olap_double_t = 10,
  olap_discrete_double_t = 11,
  olap_bool_t = 12,
  olap_enum_t = 13,
  olap_date_t = 14,
  olap_string_t = 15
};
bool OlapPrimitiveType_IsValid(int value);
constexpr OlapPrimitiveType OlapPrimitiveType_MIN = olap_uint8_t;
constexpr OlapPrimitiveType OlapPrimitiveType_MAX = olap_string_t;
constexpr int OlapPrimitiveType_ARRAYSIZE = OlapPrimitiveType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OlapPrimitiveType_descriptor();
template<typename T>
inline const std::string& OlapPrimitiveType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OlapPrimitiveType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OlapPrimitiveType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OlapPrimitiveType_descriptor(), enum_t_value);
}
inline bool OlapPrimitiveType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OlapPrimitiveType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OlapPrimitiveType>(
    OlapPrimitiveType_descriptor(), name, value);
}
// ===================================================================

class OLAPRawDeltaHeaderMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.OLAPRawDeltaHeaderMessage) */ {
 public:
  inline OLAPRawDeltaHeaderMessage() : OLAPRawDeltaHeaderMessage(nullptr) {}
  ~OLAPRawDeltaHeaderMessage() override;
  explicit constexpr OLAPRawDeltaHeaderMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OLAPRawDeltaHeaderMessage(const OLAPRawDeltaHeaderMessage& from);
  OLAPRawDeltaHeaderMessage(OLAPRawDeltaHeaderMessage&& from) noexcept
    : OLAPRawDeltaHeaderMessage() {
    *this = ::std::move(from);
  }

  inline OLAPRawDeltaHeaderMessage& operator=(const OLAPRawDeltaHeaderMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OLAPRawDeltaHeaderMessage& operator=(OLAPRawDeltaHeaderMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OLAPRawDeltaHeaderMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OLAPRawDeltaHeaderMessage* internal_default_instance() {
    return reinterpret_cast<const OLAPRawDeltaHeaderMessage*>(
               &_OLAPRawDeltaHeaderMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OLAPRawDeltaHeaderMessage& a, OLAPRawDeltaHeaderMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OLAPRawDeltaHeaderMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OLAPRawDeltaHeaderMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OLAPRawDeltaHeaderMessage* New() const final {
    return new OLAPRawDeltaHeaderMessage();
  }

  OLAPRawDeltaHeaderMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OLAPRawDeltaHeaderMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OLAPRawDeltaHeaderMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OLAPRawDeltaHeaderMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OLAPRawDeltaHeaderMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.OLAPRawDeltaHeaderMessage";
  }
  protected:
  explicit OLAPRawDeltaHeaderMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 1,
    kSchemaHashFieldNumber = 2,
  };
  // required string signature = 1;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // required int32 schema_hash = 2;
  bool has_schema_hash() const;
  private:
  bool _internal_has_schema_hash() const;
  public:
  void clear_schema_hash();
  ::PROTOBUF_NAMESPACE_ID::int32 schema_hash() const;
  void set_schema_hash(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_schema_hash() const;
  void _internal_set_schema_hash(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.OLAPRawDeltaHeaderMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::int32 schema_hash_;
  friend struct ::TableStruct_olap_2eproto;
};
// -------------------------------------------------------------------

class OLAPHeaderMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.OLAPHeaderMessage) */ {
 public:
  inline OLAPHeaderMessage() : OLAPHeaderMessage(nullptr) {}
  ~OLAPHeaderMessage() override;
  explicit constexpr OLAPHeaderMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OLAPHeaderMessage(const OLAPHeaderMessage& from);
  OLAPHeaderMessage(OLAPHeaderMessage&& from) noexcept
    : OLAPHeaderMessage() {
    *this = ::std::move(from);
  }

  inline OLAPHeaderMessage& operator=(const OLAPHeaderMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OLAPHeaderMessage& operator=(OLAPHeaderMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OLAPHeaderMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OLAPHeaderMessage* internal_default_instance() {
    return reinterpret_cast<const OLAPHeaderMessage*>(
               &_OLAPHeaderMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OLAPHeaderMessage& a, OLAPHeaderMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OLAPHeaderMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OLAPHeaderMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OLAPHeaderMessage* New() const final {
    return new OLAPHeaderMessage();
  }

  OLAPHeaderMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OLAPHeaderMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OLAPHeaderMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OLAPHeaderMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OLAPHeaderMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.OLAPHeaderMessage";
  }
  protected:
  explicit OLAPHeaderMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileVersionFieldNumber = 9,
    kColumnFieldNumber = 15,
    kSelectivityFieldNumber = 17,
    kSignatureFieldNumber = 1,
    kDbNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kAbbreviatedNameFieldNumber = 4,
    kIndexNameFieldNumber = 5,
    kBaseExpansionPolicyFieldNumber = 12,
    kCumulativePolicyFieldNumber = 13,
    kSchemaChangeStatusFieldNumber = 19,
    kDeleteDataPolicyFieldNumber = 20,
    kCurPartitionPolicyFieldNumber = 21,
    kTierStoragePolicyFieldNumber = 22,
    kNumRowsPerDataBlockFieldNumber = 6,
    kSchemaHashFieldNumber = 7,
    kSchemaVersionFieldNumber = 8,
    kIsHealthyFieldNumber = 10,
    kCreationTimeFieldNumber = 16,
    kNumShortKeyFieldsFieldNumber = 14,
    kNumRowsFieldNumber = 18,
  };
  // repeated .baikaldb.pb.FileVersionMessage file_version = 9;
  int file_version_size() const;
  private:
  int _internal_file_version_size() const;
  public:
  void clear_file_version();
  ::baikaldb::pb::FileVersionMessage* mutable_file_version(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FileVersionMessage >*
      mutable_file_version();
  private:
  const ::baikaldb::pb::FileVersionMessage& _internal_file_version(int index) const;
  ::baikaldb::pb::FileVersionMessage* _internal_add_file_version();
  public:
  const ::baikaldb::pb::FileVersionMessage& file_version(int index) const;
  ::baikaldb::pb::FileVersionMessage* add_file_version();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FileVersionMessage >&
      file_version() const;

  // repeated .baikaldb.pb.ColumnMessage column = 15;
  int column_size() const;
  private:
  int _internal_column_size() const;
  public:
  void clear_column();
  ::baikaldb::pb::ColumnMessage* mutable_column(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ColumnMessage >*
      mutable_column();
  private:
  const ::baikaldb::pb::ColumnMessage& _internal_column(int index) const;
  ::baikaldb::pb::ColumnMessage* _internal_add_column();
  public:
  const ::baikaldb::pb::ColumnMessage& column(int index) const;
  ::baikaldb::pb::ColumnMessage* add_column();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ColumnMessage >&
      column() const;

  // repeated int32 selectivity = 17;
  int selectivity_size() const;
  private:
  int _internal_selectivity_size() const;
  public:
  void clear_selectivity();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_selectivity(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_selectivity() const;
  void _internal_add_selectivity(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_selectivity();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 selectivity(int index) const;
  void set_selectivity(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_selectivity(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      selectivity() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_selectivity();

  // required string signature = 1;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // required string db_name = 2;
  bool has_db_name() const;
  private:
  bool _internal_has_db_name() const;
  public:
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // required string table_name = 3;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // optional string abbreviated_name = 4;
  bool has_abbreviated_name() const;
  private:
  bool _internal_has_abbreviated_name() const;
  public:
  void clear_abbreviated_name();
  const std::string& abbreviated_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_abbreviated_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_abbreviated_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_abbreviated_name();
  void set_allocated_abbreviated_name(std::string* abbreviated_name);
  private:
  const std::string& _internal_abbreviated_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_abbreviated_name(const std::string& value);
  std::string* _internal_mutable_abbreviated_name();
  public:

  // required string index_name = 5;
  bool has_index_name() const;
  private:
  bool _internal_has_index_name() const;
  public:
  void clear_index_name();
  const std::string& index_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_index_name();
  void set_allocated_index_name(std::string* index_name);
  private:
  const std::string& _internal_index_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index_name(const std::string& value);
  std::string* _internal_mutable_index_name();
  public:

  // required .baikaldb.pb.BaseExpansionPolicyMessage base_expansion_policy = 12;
  bool has_base_expansion_policy() const;
  private:
  bool _internal_has_base_expansion_policy() const;
  public:
  void clear_base_expansion_policy();
  const ::baikaldb::pb::BaseExpansionPolicyMessage& base_expansion_policy() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::BaseExpansionPolicyMessage* release_base_expansion_policy();
  ::baikaldb::pb::BaseExpansionPolicyMessage* mutable_base_expansion_policy();
  void set_allocated_base_expansion_policy(::baikaldb::pb::BaseExpansionPolicyMessage* base_expansion_policy);
  private:
  const ::baikaldb::pb::BaseExpansionPolicyMessage& _internal_base_expansion_policy() const;
  ::baikaldb::pb::BaseExpansionPolicyMessage* _internal_mutable_base_expansion_policy();
  public:
  void unsafe_arena_set_allocated_base_expansion_policy(
      ::baikaldb::pb::BaseExpansionPolicyMessage* base_expansion_policy);
  ::baikaldb::pb::BaseExpansionPolicyMessage* unsafe_arena_release_base_expansion_policy();

  // optional .baikaldb.pb.CumulativePolicyMessage cumulative_policy = 13;
  bool has_cumulative_policy() const;
  private:
  bool _internal_has_cumulative_policy() const;
  public:
  void clear_cumulative_policy();
  const ::baikaldb::pb::CumulativePolicyMessage& cumulative_policy() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::CumulativePolicyMessage* release_cumulative_policy();
  ::baikaldb::pb::CumulativePolicyMessage* mutable_cumulative_policy();
  void set_allocated_cumulative_policy(::baikaldb::pb::CumulativePolicyMessage* cumulative_policy);
  private:
  const ::baikaldb::pb::CumulativePolicyMessage& _internal_cumulative_policy() const;
  ::baikaldb::pb::CumulativePolicyMessage* _internal_mutable_cumulative_policy();
  public:
  void unsafe_arena_set_allocated_cumulative_policy(
      ::baikaldb::pb::CumulativePolicyMessage* cumulative_policy);
  ::baikaldb::pb::CumulativePolicyMessage* unsafe_arena_release_cumulative_policy();

  // optional .baikaldb.pb.SchemaChangeStatusMessage schema_change_status = 19;
  bool has_schema_change_status() const;
  private:
  bool _internal_has_schema_change_status() const;
  public:
  void clear_schema_change_status();
  const ::baikaldb::pb::SchemaChangeStatusMessage& schema_change_status() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::SchemaChangeStatusMessage* release_schema_change_status();
  ::baikaldb::pb::SchemaChangeStatusMessage* mutable_schema_change_status();
  void set_allocated_schema_change_status(::baikaldb::pb::SchemaChangeStatusMessage* schema_change_status);
  private:
  const ::baikaldb::pb::SchemaChangeStatusMessage& _internal_schema_change_status() const;
  ::baikaldb::pb::SchemaChangeStatusMessage* _internal_mutable_schema_change_status();
  public:
  void unsafe_arena_set_allocated_schema_change_status(
      ::baikaldb::pb::SchemaChangeStatusMessage* schema_change_status);
  ::baikaldb::pb::SchemaChangeStatusMessage* unsafe_arena_release_schema_change_status();

  // optional .baikaldb.pb.DeleteDataPolicyMessage delete_data_policy = 20;
  bool has_delete_data_policy() const;
  private:
  bool _internal_has_delete_data_policy() const;
  public:
  void clear_delete_data_policy();
  const ::baikaldb::pb::DeleteDataPolicyMessage& delete_data_policy() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::DeleteDataPolicyMessage* release_delete_data_policy();
  ::baikaldb::pb::DeleteDataPolicyMessage* mutable_delete_data_policy();
  void set_allocated_delete_data_policy(::baikaldb::pb::DeleteDataPolicyMessage* delete_data_policy);
  private:
  const ::baikaldb::pb::DeleteDataPolicyMessage& _internal_delete_data_policy() const;
  ::baikaldb::pb::DeleteDataPolicyMessage* _internal_mutable_delete_data_policy();
  public:
  void unsafe_arena_set_allocated_delete_data_policy(
      ::baikaldb::pb::DeleteDataPolicyMessage* delete_data_policy);
  ::baikaldb::pb::DeleteDataPolicyMessage* unsafe_arena_release_delete_data_policy();

  // optional .baikaldb.pb.PartitionPolicyMessage cur_partition_policy = 21;
  bool has_cur_partition_policy() const;
  private:
  bool _internal_has_cur_partition_policy() const;
  public:
  void clear_cur_partition_policy();
  const ::baikaldb::pb::PartitionPolicyMessage& cur_partition_policy() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::PartitionPolicyMessage* release_cur_partition_policy();
  ::baikaldb::pb::PartitionPolicyMessage* mutable_cur_partition_policy();
  void set_allocated_cur_partition_policy(::baikaldb::pb::PartitionPolicyMessage* cur_partition_policy);
  private:
  const ::baikaldb::pb::PartitionPolicyMessage& _internal_cur_partition_policy() const;
  ::baikaldb::pb::PartitionPolicyMessage* _internal_mutable_cur_partition_policy();
  public:
  void unsafe_arena_set_allocated_cur_partition_policy(
      ::baikaldb::pb::PartitionPolicyMessage* cur_partition_policy);
  ::baikaldb::pb::PartitionPolicyMessage* unsafe_arena_release_cur_partition_policy();

  // optional .baikaldb.pb.TierStoragePolicyMessage tier_storage_policy = 22;
  bool has_tier_storage_policy() const;
  private:
  bool _internal_has_tier_storage_policy() const;
  public:
  void clear_tier_storage_policy();
  const ::baikaldb::pb::TierStoragePolicyMessage& tier_storage_policy() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::TierStoragePolicyMessage* release_tier_storage_policy();
  ::baikaldb::pb::TierStoragePolicyMessage* mutable_tier_storage_policy();
  void set_allocated_tier_storage_policy(::baikaldb::pb::TierStoragePolicyMessage* tier_storage_policy);
  private:
  const ::baikaldb::pb::TierStoragePolicyMessage& _internal_tier_storage_policy() const;
  ::baikaldb::pb::TierStoragePolicyMessage* _internal_mutable_tier_storage_policy();
  public:
  void unsafe_arena_set_allocated_tier_storage_policy(
      ::baikaldb::pb::TierStoragePolicyMessage* tier_storage_policy);
  ::baikaldb::pb::TierStoragePolicyMessage* unsafe_arena_release_tier_storage_policy();

  // required uint32 num_rows_per_data_block = 6;
  bool has_num_rows_per_data_block() const;
  private:
  bool _internal_has_num_rows_per_data_block() const;
  public:
  void clear_num_rows_per_data_block();
  ::PROTOBUF_NAMESPACE_ID::uint32 num_rows_per_data_block() const;
  void set_num_rows_per_data_block(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_rows_per_data_block() const;
  void _internal_set_num_rows_per_data_block(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 schema_hash = 7;
  bool has_schema_hash() const;
  private:
  bool _internal_has_schema_hash() const;
  public:
  void clear_schema_hash();
  ::PROTOBUF_NAMESPACE_ID::uint32 schema_hash() const;
  void set_schema_hash(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_schema_hash() const;
  void _internal_set_schema_hash(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 schema_version = 8;
  bool has_schema_version() const;
  private:
  bool _internal_has_schema_version() const;
  public:
  void clear_schema_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 schema_version() const;
  void set_schema_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_schema_version() const;
  void _internal_set_schema_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required bool is_healthy = 10 [default = false];
  bool has_is_healthy() const;
  private:
  bool _internal_has_is_healthy() const;
  public:
  void clear_is_healthy();
  bool is_healthy() const;
  void set_is_healthy(bool value);
  private:
  bool _internal_is_healthy() const;
  void _internal_set_is_healthy(bool value);
  public:

  // required int64 creation_time = 16;
  bool has_creation_time() const;
  private:
  bool _internal_has_creation_time() const;
  public:
  void clear_creation_time();
  ::PROTOBUF_NAMESPACE_ID::int64 creation_time() const;
  void set_creation_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_creation_time() const;
  void _internal_set_creation_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required uint32 num_short_key_fields = 14;
  bool has_num_short_key_fields() const;
  private:
  bool _internal_has_num_short_key_fields() const;
  public:
  void clear_num_short_key_fields();
  ::PROTOBUF_NAMESPACE_ID::uint32 num_short_key_fields() const;
  void set_num_short_key_fields(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_short_key_fields() const;
  void _internal_set_num_short_key_fields(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint64 num_rows = 18 [default = 1];
  bool has_num_rows() const;
  private:
  bool _internal_has_num_rows() const;
  public:
  void clear_num_rows();
  ::PROTOBUF_NAMESPACE_ID::uint64 num_rows() const;
  void set_num_rows(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_num_rows() const;
  void _internal_set_num_rows(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.OLAPHeaderMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FileVersionMessage > file_version_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ColumnMessage > column_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > selectivity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr abbreviated_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_name_;
  ::baikaldb::pb::BaseExpansionPolicyMessage* base_expansion_policy_;
  ::baikaldb::pb::CumulativePolicyMessage* cumulative_policy_;
  ::baikaldb::pb::SchemaChangeStatusMessage* schema_change_status_;
  ::baikaldb::pb::DeleteDataPolicyMessage* delete_data_policy_;
  ::baikaldb::pb::PartitionPolicyMessage* cur_partition_policy_;
  ::baikaldb::pb::TierStoragePolicyMessage* tier_storage_policy_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_rows_per_data_block_;
  ::PROTOBUF_NAMESPACE_ID::uint32 schema_hash_;
  ::PROTOBUF_NAMESPACE_ID::uint32 schema_version_;
  bool is_healthy_;
  ::PROTOBUF_NAMESPACE_ID::int64 creation_time_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_short_key_fields_;
  ::PROTOBUF_NAMESPACE_ID::uint64 num_rows_;
  friend struct ::TableStruct_olap_2eproto;
};
// -------------------------------------------------------------------

class FileVersionMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.FileVersionMessage) */ {
 public:
  inline FileVersionMessage() : FileVersionMessage(nullptr) {}
  ~FileVersionMessage() override;
  explicit constexpr FileVersionMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileVersionMessage(const FileVersionMessage& from);
  FileVersionMessage(FileVersionMessage&& from) noexcept
    : FileVersionMessage() {
    *this = ::std::move(from);
  }

  inline FileVersionMessage& operator=(const FileVersionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileVersionMessage& operator=(FileVersionMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileVersionMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileVersionMessage* internal_default_instance() {
    return reinterpret_cast<const FileVersionMessage*>(
               &_FileVersionMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FileVersionMessage& a, FileVersionMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(FileVersionMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileVersionMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileVersionMessage* New() const final {
    return new FileVersionMessage();
  }

  FileVersionMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileVersionMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileVersionMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileVersionMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileVersionMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.FileVersionMessage";
  }
  protected:
  explicit FileVersionMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelectivityFieldNumber = 9,
    kDataFilePrefixFieldNumber = 14,
    kNumSegmentsFieldNumber = 1,
    kStartVersionFieldNumber = 2,
    kVersionHashFieldNumber = 4,
    kMaxTimestampFieldNumber = 5,
    kIndexSizeFieldNumber = 6,
    kDataSizeFieldNumber = 7,
    kEndVersionFieldNumber = 3,
    kStartPartkeyFieldNumber = 11,
    kCreationTimeFieldNumber = 8,
    kNumRowsFieldNumber = 10,
    kIsPartitionFieldNumber = 13,
    kHeadReverseFieldNumber = 15,
    kVersionEmptyFieldNumber = 16,
    kEndPartkeyFieldNumber = 12,
  };
  // repeated int32 selectivity = 9;
  int selectivity_size() const;
  private:
  int _internal_selectivity_size() const;
  public:
  void clear_selectivity();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_selectivity(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_selectivity() const;
  void _internal_add_selectivity(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_selectivity();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 selectivity(int index) const;
  void set_selectivity(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_selectivity(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      selectivity() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_selectivity();

  // optional string data_file_prefix = 14;
  bool has_data_file_prefix() const;
  private:
  bool _internal_has_data_file_prefix() const;
  public:
  void clear_data_file_prefix();
  const std::string& data_file_prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_file_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_file_prefix();
  PROTOBUF_MUST_USE_RESULT std::string* release_data_file_prefix();
  void set_allocated_data_file_prefix(std::string* data_file_prefix);
  private:
  const std::string& _internal_data_file_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_file_prefix(const std::string& value);
  std::string* _internal_mutable_data_file_prefix();
  public:

  // required uint32 num_segments = 1 [default = 0];
  bool has_num_segments() const;
  private:
  bool _internal_has_num_segments() const;
  public:
  void clear_num_segments();
  ::PROTOBUF_NAMESPACE_ID::uint32 num_segments() const;
  void set_num_segments(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_segments() const;
  void _internal_set_num_segments(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required int32 start_version = 2;
  bool has_start_version() const;
  private:
  bool _internal_has_start_version() const;
  public:
  void clear_start_version();
  ::PROTOBUF_NAMESPACE_ID::int32 start_version() const;
  void set_start_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start_version() const;
  void _internal_set_start_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int64 version_hash = 4 [default = 0];
  bool has_version_hash() const;
  private:
  bool _internal_has_version_hash() const;
  public:
  void clear_version_hash();
  ::PROTOBUF_NAMESPACE_ID::int64 version_hash() const;
  void set_version_hash(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version_hash() const;
  void _internal_set_version_hash(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 max_timestamp = 5 [default = 0];
  bool has_max_timestamp() const;
  private:
  bool _internal_has_max_timestamp() const;
  public:
  void clear_max_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 max_timestamp() const;
  void set_max_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_max_timestamp() const;
  void _internal_set_max_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 index_size = 6 [default = 0];
  bool has_index_size() const;
  private:
  bool _internal_has_index_size() const;
  public:
  void clear_index_size();
  ::PROTOBUF_NAMESPACE_ID::int64 index_size() const;
  void set_index_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_index_size() const;
  void _internal_set_index_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 data_size = 7 [default = 0];
  bool has_data_size() const;
  private:
  bool _internal_has_data_size() const;
  public:
  void clear_data_size();
  ::PROTOBUF_NAMESPACE_ID::int64 data_size() const;
  void set_data_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_data_size() const;
  void _internal_set_data_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int32 end_version = 3;
  bool has_end_version() const;
  private:
  bool _internal_has_end_version() const;
  public:
  void clear_end_version();
  ::PROTOBUF_NAMESPACE_ID::int32 end_version() const;
  void set_end_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end_version() const;
  void _internal_set_end_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional uint32 start_partkey = 11 [default = 0];
  bool has_start_partkey() const;
  private:
  bool _internal_has_start_partkey() const;
  public:
  void clear_start_partkey();
  ::PROTOBUF_NAMESPACE_ID::uint32 start_partkey() const;
  void set_start_partkey(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_start_partkey() const;
  void _internal_set_start_partkey(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required int64 creation_time = 8 [default = 0];
  bool has_creation_time() const;
  private:
  bool _internal_has_creation_time() const;
  public:
  void clear_creation_time();
  ::PROTOBUF_NAMESPACE_ID::int64 creation_time() const;
  void set_creation_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_creation_time() const;
  void _internal_set_creation_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint64 num_rows = 10 [default = 0];
  bool has_num_rows() const;
  private:
  bool _internal_has_num_rows() const;
  public:
  void clear_num_rows();
  ::PROTOBUF_NAMESPACE_ID::uint64 num_rows() const;
  void set_num_rows(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_num_rows() const;
  void _internal_set_num_rows(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool is_partition = 13 [default = false];
  bool has_is_partition() const;
  private:
  bool _internal_has_is_partition() const;
  public:
  void clear_is_partition();
  bool is_partition() const;
  void set_is_partition(bool value);
  private:
  bool _internal_is_partition() const;
  void _internal_set_is_partition(bool value);
  public:

  // optional bool head_reverse = 15 [default = false];
  bool has_head_reverse() const;
  private:
  bool _internal_has_head_reverse() const;
  public:
  void clear_head_reverse();
  bool head_reverse() const;
  void set_head_reverse(bool value);
  private:
  bool _internal_head_reverse() const;
  void _internal_set_head_reverse(bool value);
  public:

  // optional bool version_empty = 16 [default = false];
  bool has_version_empty() const;
  private:
  bool _internal_has_version_empty() const;
  public:
  void clear_version_empty();
  bool version_empty() const;
  void set_version_empty(bool value);
  private:
  bool _internal_version_empty() const;
  void _internal_set_version_empty(bool value);
  public:

  // optional uint32 end_partkey = 12 [default = 16777215];
  bool has_end_partkey() const;
  private:
  bool _internal_has_end_partkey() const;
  public:
  void clear_end_partkey();
  ::PROTOBUF_NAMESPACE_ID::uint32 end_partkey() const;
  void set_end_partkey(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_end_partkey() const;
  void _internal_set_end_partkey(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.FileVersionMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > selectivity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_file_prefix_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_segments_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_version_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_hash_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int64 index_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 data_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_version_;
  ::PROTOBUF_NAMESPACE_ID::uint32 start_partkey_;
  ::PROTOBUF_NAMESPACE_ID::int64 creation_time_;
  ::PROTOBUF_NAMESPACE_ID::uint64 num_rows_;
  bool is_partition_;
  bool head_reverse_;
  bool version_empty_;
  ::PROTOBUF_NAMESPACE_ID::uint32 end_partkey_;
  friend struct ::TableStruct_olap_2eproto;
};
// -------------------------------------------------------------------

class PartitionPolicyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.PartitionPolicyMessage) */ {
 public:
  inline PartitionPolicyMessage() : PartitionPolicyMessage(nullptr) {}
  ~PartitionPolicyMessage() override;
  explicit constexpr PartitionPolicyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionPolicyMessage(const PartitionPolicyMessage& from);
  PartitionPolicyMessage(PartitionPolicyMessage&& from) noexcept
    : PartitionPolicyMessage() {
    *this = ::std::move(from);
  }

  inline PartitionPolicyMessage& operator=(const PartitionPolicyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionPolicyMessage& operator=(PartitionPolicyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionPolicyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionPolicyMessage* internal_default_instance() {
    return reinterpret_cast<const PartitionPolicyMessage*>(
               &_PartitionPolicyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PartitionPolicyMessage& a, PartitionPolicyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionPolicyMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionPolicyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartitionPolicyMessage* New() const final {
    return new PartitionPolicyMessage();
  }

  PartitionPolicyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartitionPolicyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartitionPolicyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PartitionPolicyMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionPolicyMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.PartitionPolicyMessage";
  }
  protected:
  explicit PartitionPolicyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartGranularityFieldNumber = 1,
    kFirstPartkeyFieldNumber = 2,
  };
  // required uint32 part_granularity = 1 [default = 0];
  bool has_part_granularity() const;
  private:
  bool _internal_has_part_granularity() const;
  public:
  void clear_part_granularity();
  ::PROTOBUF_NAMESPACE_ID::uint32 part_granularity() const;
  void set_part_granularity(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_part_granularity() const;
  void _internal_set_part_granularity(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 first_partkey = 2 [default = 0];
  bool has_first_partkey() const;
  private:
  bool _internal_has_first_partkey() const;
  public:
  void clear_first_partkey();
  ::PROTOBUF_NAMESPACE_ID::uint32 first_partkey() const;
  void set_first_partkey(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_first_partkey() const;
  void _internal_set_first_partkey(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.PartitionPolicyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 part_granularity_;
  ::PROTOBUF_NAMESPACE_ID::uint32 first_partkey_;
  friend struct ::TableStruct_olap_2eproto;
};
// -------------------------------------------------------------------

class BaseExpansionPolicyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.BaseExpansionPolicyMessage) */ {
 public:
  inline BaseExpansionPolicyMessage() : BaseExpansionPolicyMessage(nullptr) {}
  ~BaseExpansionPolicyMessage() override;
  explicit constexpr BaseExpansionPolicyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseExpansionPolicyMessage(const BaseExpansionPolicyMessage& from);
  BaseExpansionPolicyMessage(BaseExpansionPolicyMessage&& from) noexcept
    : BaseExpansionPolicyMessage() {
    *this = ::std::move(from);
  }

  inline BaseExpansionPolicyMessage& operator=(const BaseExpansionPolicyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseExpansionPolicyMessage& operator=(BaseExpansionPolicyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseExpansionPolicyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseExpansionPolicyMessage* internal_default_instance() {
    return reinterpret_cast<const BaseExpansionPolicyMessage*>(
               &_BaseExpansionPolicyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BaseExpansionPolicyMessage& a, BaseExpansionPolicyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseExpansionPolicyMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseExpansionPolicyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BaseExpansionPolicyMessage* New() const final {
    return new BaseExpansionPolicyMessage();
  }

  BaseExpansionPolicyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BaseExpansionPolicyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaseExpansionPolicyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BaseExpansionPolicyMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseExpansionPolicyMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.BaseExpansionPolicyMessage";
  }
  protected:
  explicit BaseExpansionPolicyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionPolicyFieldNumber = 6,
    kMinVersionFieldNumber = 1,
    kMinAgeFieldNumber = 2,
    kMaxVersionFieldNumber = 3,
    kMaxAgeFieldNumber = 4,
    kFlushBeCountFieldNumber = 5,
  };
  // optional .baikaldb.pb.PartitionPolicyMessage partition_policy = 6;
  bool has_partition_policy() const;
  private:
  bool _internal_has_partition_policy() const;
  public:
  void clear_partition_policy();
  const ::baikaldb::pb::PartitionPolicyMessage& partition_policy() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::PartitionPolicyMessage* release_partition_policy();
  ::baikaldb::pb::PartitionPolicyMessage* mutable_partition_policy();
  void set_allocated_partition_policy(::baikaldb::pb::PartitionPolicyMessage* partition_policy);
  private:
  const ::baikaldb::pb::PartitionPolicyMessage& _internal_partition_policy() const;
  ::baikaldb::pb::PartitionPolicyMessage* _internal_mutable_partition_policy();
  public:
  void unsafe_arena_set_allocated_partition_policy(
      ::baikaldb::pb::PartitionPolicyMessage* partition_policy);
  ::baikaldb::pb::PartitionPolicyMessage* unsafe_arena_release_partition_policy();

  // required int32 min_version = 1;
  bool has_min_version() const;
  private:
  bool _internal_has_min_version() const;
  public:
  void clear_min_version();
  ::PROTOBUF_NAMESPACE_ID::int32 min_version() const;
  void set_min_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_min_version() const;
  void _internal_set_min_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 min_age = 2;
  bool has_min_age() const;
  private:
  bool _internal_has_min_age() const;
  public:
  void clear_min_age();
  ::PROTOBUF_NAMESPACE_ID::int32 min_age() const;
  void set_min_age(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_min_age() const;
  void _internal_set_min_age(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 max_version = 3;
  bool has_max_version() const;
  private:
  bool _internal_has_max_version() const;
  public:
  void clear_max_version();
  ::PROTOBUF_NAMESPACE_ID::int32 max_version() const;
  void set_max_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_version() const;
  void _internal_set_max_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 max_age = 4;
  bool has_max_age() const;
  private:
  bool _internal_has_max_age() const;
  public:
  void clear_max_age();
  ::PROTOBUF_NAMESPACE_ID::int32 max_age() const;
  void set_max_age(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_age() const;
  void _internal_set_max_age(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 flush_be_count = 5;
  bool has_flush_be_count() const;
  private:
  bool _internal_has_flush_be_count() const;
  public:
  void clear_flush_be_count();
  ::PROTOBUF_NAMESPACE_ID::int32 flush_be_count() const;
  void set_flush_be_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_flush_be_count() const;
  void _internal_set_flush_be_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.BaseExpansionPolicyMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::baikaldb::pb::PartitionPolicyMessage* partition_policy_;
  ::PROTOBUF_NAMESPACE_ID::int32 min_version_;
  ::PROTOBUF_NAMESPACE_ID::int32 min_age_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_version_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_age_;
  ::PROTOBUF_NAMESPACE_ID::int32 flush_be_count_;
  friend struct ::TableStruct_olap_2eproto;
};
// -------------------------------------------------------------------

class CumulativePolicyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.CumulativePolicyMessage) */ {
 public:
  inline CumulativePolicyMessage() : CumulativePolicyMessage(nullptr) {}
  ~CumulativePolicyMessage() override;
  explicit constexpr CumulativePolicyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CumulativePolicyMessage(const CumulativePolicyMessage& from);
  CumulativePolicyMessage(CumulativePolicyMessage&& from) noexcept
    : CumulativePolicyMessage() {
    *this = ::std::move(from);
  }

  inline CumulativePolicyMessage& operator=(const CumulativePolicyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CumulativePolicyMessage& operator=(CumulativePolicyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CumulativePolicyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CumulativePolicyMessage* internal_default_instance() {
    return reinterpret_cast<const CumulativePolicyMessage*>(
               &_CumulativePolicyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CumulativePolicyMessage& a, CumulativePolicyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CumulativePolicyMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CumulativePolicyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CumulativePolicyMessage* New() const final {
    return new CumulativePolicyMessage();
  }

  CumulativePolicyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CumulativePolicyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CumulativePolicyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CumulativePolicyMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CumulativePolicyMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.CumulativePolicyMessage";
  }
  protected:
  explicit CumulativePolicyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxCumulativeVersionDistanceFieldNumber = 3,
    kTriggerToCreateCumFieldNumber = 1,
    kVersionGapOfSparseCumFieldNumber = 2,
  };
  // optional int32 max_cumulative_version_distance = 3 [default = -1];
  bool has_max_cumulative_version_distance() const;
  private:
  bool _internal_has_max_cumulative_version_distance() const;
  public:
  void clear_max_cumulative_version_distance();
  ::PROTOBUF_NAMESPACE_ID::int32 max_cumulative_version_distance() const;
  void set_max_cumulative_version_distance(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_cumulative_version_distance() const;
  void _internal_set_max_cumulative_version_distance(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional uint32 trigger_to_create_cum = 1 [default = 3];
  bool has_trigger_to_create_cum() const;
  private:
  bool _internal_has_trigger_to_create_cum() const;
  public:
  void clear_trigger_to_create_cum();
  ::PROTOBUF_NAMESPACE_ID::uint32 trigger_to_create_cum() const;
  void set_trigger_to_create_cum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_trigger_to_create_cum() const;
  void _internal_set_trigger_to_create_cum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 version_gap_of_sparse_cum = 2 [default = 5];
  bool has_version_gap_of_sparse_cum() const;
  private:
  bool _internal_has_version_gap_of_sparse_cum() const;
  public:
  void clear_version_gap_of_sparse_cum();
  ::PROTOBUF_NAMESPACE_ID::uint32 version_gap_of_sparse_cum() const;
  void set_version_gap_of_sparse_cum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version_gap_of_sparse_cum() const;
  void _internal_set_version_gap_of_sparse_cum(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.CumulativePolicyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_cumulative_version_distance_;
  ::PROTOBUF_NAMESPACE_ID::uint32 trigger_to_create_cum_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_gap_of_sparse_cum_;
  friend struct ::TableStruct_olap_2eproto;
};
// -------------------------------------------------------------------

class ColumnMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.ColumnMessage) */ {
 public:
  inline ColumnMessage() : ColumnMessage(nullptr) {}
  ~ColumnMessage() override;
  explicit constexpr ColumnMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnMessage(const ColumnMessage& from);
  ColumnMessage(ColumnMessage&& from) noexcept
    : ColumnMessage() {
    *this = ::std::move(from);
  }

  inline ColumnMessage& operator=(const ColumnMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnMessage& operator=(ColumnMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnMessage* internal_default_instance() {
    return reinterpret_cast<const ColumnMessage*>(
               &_ColumnMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ColumnMessage& a, ColumnMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColumnMessage* New() const final {
    return new ColumnMessage();
  }

  ColumnMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColumnMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ColumnMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.ColumnMessage";
  }
  protected:
  explicit ColumnMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kAggregationFieldNumber = 3,
    kDefaultValueFieldNumber = 6,
    kReferencedColumnFieldNumber = 7,
    kLengthFieldNumber = 4,
    kIsKeyFieldNumber = 5,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // required string aggregation = 3;
  bool has_aggregation() const;
  private:
  bool _internal_has_aggregation() const;
  public:
  void clear_aggregation();
  const std::string& aggregation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_aggregation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_aggregation();
  PROTOBUF_MUST_USE_RESULT std::string* release_aggregation();
  void set_allocated_aggregation(std::string* aggregation);
  private:
  const std::string& _internal_aggregation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aggregation(const std::string& value);
  std::string* _internal_mutable_aggregation();
  public:

  // optional string default_value = 6;
  bool has_default_value() const;
  private:
  bool _internal_has_default_value() const;
  public:
  void clear_default_value();
  const std::string& default_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_default_value();
  void set_allocated_default_value(std::string* default_value);
  private:
  const std::string& _internal_default_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_value(const std::string& value);
  std::string* _internal_mutable_default_value();
  public:

  // optional string referenced_column = 7;
  bool has_referenced_column() const;
  private:
  bool _internal_has_referenced_column() const;
  public:
  void clear_referenced_column();
  const std::string& referenced_column() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_referenced_column(ArgT0&& arg0, ArgT... args);
  std::string* mutable_referenced_column();
  PROTOBUF_MUST_USE_RESULT std::string* release_referenced_column();
  void set_allocated_referenced_column(std::string* referenced_column);
  private:
  const std::string& _internal_referenced_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_referenced_column(const std::string& value);
  std::string* _internal_mutable_referenced_column();
  public:

  // required uint32 length = 4;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  ::PROTOBUF_NAMESPACE_ID::uint32 length() const;
  void set_length(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_length() const;
  void _internal_set_length(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required bool is_key = 5;
  bool has_is_key() const;
  private:
  bool _internal_has_is_key() const;
  public:
  void clear_is_key();
  bool is_key() const;
  void set_is_key(bool value);
  private:
  bool _internal_is_key() const;
  void _internal_set_is_key(bool value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.ColumnMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aggregation_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr referenced_column_;
  ::PROTOBUF_NAMESPACE_ID::uint32 length_;
  bool is_key_;
  friend struct ::TableStruct_olap_2eproto;
};
// -------------------------------------------------------------------

class SchemaChangeStatusMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.SchemaChangeStatusMessage) */ {
 public:
  inline SchemaChangeStatusMessage() : SchemaChangeStatusMessage(nullptr) {}
  ~SchemaChangeStatusMessage() override;
  explicit constexpr SchemaChangeStatusMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchemaChangeStatusMessage(const SchemaChangeStatusMessage& from);
  SchemaChangeStatusMessage(SchemaChangeStatusMessage&& from) noexcept
    : SchemaChangeStatusMessage() {
    *this = ::std::move(from);
  }

  inline SchemaChangeStatusMessage& operator=(const SchemaChangeStatusMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaChangeStatusMessage& operator=(SchemaChangeStatusMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaChangeStatusMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaChangeStatusMessage* internal_default_instance() {
    return reinterpret_cast<const SchemaChangeStatusMessage*>(
               &_SchemaChangeStatusMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SchemaChangeStatusMessage& a, SchemaChangeStatusMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaChangeStatusMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaChangeStatusMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SchemaChangeStatusMessage* New() const final {
    return new SchemaChangeStatusMessage();
  }

  SchemaChangeStatusMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SchemaChangeStatusMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchemaChangeStatusMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SchemaChangeStatusMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaChangeStatusMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.SchemaChangeStatusMessage";
  }
  protected:
  explicit SchemaChangeStatusMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionsToBeChangedFieldNumber = 4,
    kRelatedTableNameFieldNumber = 1,
    kRelatedIndexNameFieldNumber = 2,
    kRelatedSchemaHashFieldNumber = 3,
    kSchemaChangeTypeFieldNumber = 5,
  };
  // repeated .baikaldb.pb.FileVersionMessage versions_to_be_changed = 4;
  int versions_to_be_changed_size() const;
  private:
  int _internal_versions_to_be_changed_size() const;
  public:
  void clear_versions_to_be_changed();
  ::baikaldb::pb::FileVersionMessage* mutable_versions_to_be_changed(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FileVersionMessage >*
      mutable_versions_to_be_changed();
  private:
  const ::baikaldb::pb::FileVersionMessage& _internal_versions_to_be_changed(int index) const;
  ::baikaldb::pb::FileVersionMessage* _internal_add_versions_to_be_changed();
  public:
  const ::baikaldb::pb::FileVersionMessage& versions_to_be_changed(int index) const;
  ::baikaldb::pb::FileVersionMessage* add_versions_to_be_changed();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FileVersionMessage >&
      versions_to_be_changed() const;

  // required string related_table_name = 1;
  bool has_related_table_name() const;
  private:
  bool _internal_has_related_table_name() const;
  public:
  void clear_related_table_name();
  const std::string& related_table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_related_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_related_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_related_table_name();
  void set_allocated_related_table_name(std::string* related_table_name);
  private:
  const std::string& _internal_related_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_related_table_name(const std::string& value);
  std::string* _internal_mutable_related_table_name();
  public:

  // required string related_index_name = 2;
  bool has_related_index_name() const;
  private:
  bool _internal_has_related_index_name() const;
  public:
  void clear_related_index_name();
  const std::string& related_index_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_related_index_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_related_index_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_related_index_name();
  void set_allocated_related_index_name(std::string* related_index_name);
  private:
  const std::string& _internal_related_index_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_related_index_name(const std::string& value);
  std::string* _internal_mutable_related_index_name();
  public:

  // required int32 related_schema_hash = 3;
  bool has_related_schema_hash() const;
  private:
  bool _internal_has_related_schema_hash() const;
  public:
  void clear_related_schema_hash();
  ::PROTOBUF_NAMESPACE_ID::int32 related_schema_hash() const;
  void set_related_schema_hash(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_related_schema_hash() const;
  void _internal_set_related_schema_hash(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 schema_change_type = 5;
  bool has_schema_change_type() const;
  private:
  bool _internal_has_schema_change_type() const;
  public:
  void clear_schema_change_type();
  ::PROTOBUF_NAMESPACE_ID::int32 schema_change_type() const;
  void set_schema_change_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_schema_change_type() const;
  void _internal_set_schema_change_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.SchemaChangeStatusMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FileVersionMessage > versions_to_be_changed_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr related_table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr related_index_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 related_schema_hash_;
  ::PROTOBUF_NAMESPACE_ID::int32 schema_change_type_;
  friend struct ::TableStruct_olap_2eproto;
};
// -------------------------------------------------------------------

class DeleteDataPolicyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.DeleteDataPolicyMessage) */ {
 public:
  inline DeleteDataPolicyMessage() : DeleteDataPolicyMessage(nullptr) {}
  ~DeleteDataPolicyMessage() override;
  explicit constexpr DeleteDataPolicyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteDataPolicyMessage(const DeleteDataPolicyMessage& from);
  DeleteDataPolicyMessage(DeleteDataPolicyMessage&& from) noexcept
    : DeleteDataPolicyMessage() {
    *this = ::std::move(from);
  }

  inline DeleteDataPolicyMessage& operator=(const DeleteDataPolicyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteDataPolicyMessage& operator=(DeleteDataPolicyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteDataPolicyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteDataPolicyMessage* internal_default_instance() {
    return reinterpret_cast<const DeleteDataPolicyMessage*>(
               &_DeleteDataPolicyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DeleteDataPolicyMessage& a, DeleteDataPolicyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteDataPolicyMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteDataPolicyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteDataPolicyMessage* New() const final {
    return new DeleteDataPolicyMessage();
  }

  DeleteDataPolicyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteDataPolicyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteDataPolicyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteDataPolicyMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteDataPolicyMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.DeleteDataPolicyMessage";
  }
  protected:
  explicit DeleteDataPolicyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeleteCondsFieldNumber = 3,
    kRangeCondsFieldNumber = 4,
    kExpireCondFieldNumber = 2,
    kOpenFlagFieldNumber = 1,
    kExpireCondOpenFlagFieldNumber = 5,
    kDeleteCondOpenFlagFieldNumber = 6,
    kRangeCondOpenFlagFieldNumber = 7,
    kLatestEditionFieldNumber = 8,
    kBeEditionFieldNumber = 9,
  };
  // repeated .baikaldb.pb.DelteCondMessage delete_conds = 3;
  int delete_conds_size() const;
  private:
  int _internal_delete_conds_size() const;
  public:
  void clear_delete_conds();
  ::baikaldb::pb::DelteCondMessage* mutable_delete_conds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DelteCondMessage >*
      mutable_delete_conds();
  private:
  const ::baikaldb::pb::DelteCondMessage& _internal_delete_conds(int index) const;
  ::baikaldb::pb::DelteCondMessage* _internal_add_delete_conds();
  public:
  const ::baikaldb::pb::DelteCondMessage& delete_conds(int index) const;
  ::baikaldb::pb::DelteCondMessage* add_delete_conds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DelteCondMessage >&
      delete_conds() const;

  // repeated .baikaldb.pb.DelteCondMessage range_conds = 4;
  int range_conds_size() const;
  private:
  int _internal_range_conds_size() const;
  public:
  void clear_range_conds();
  ::baikaldb::pb::DelteCondMessage* mutable_range_conds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DelteCondMessage >*
      mutable_range_conds();
  private:
  const ::baikaldb::pb::DelteCondMessage& _internal_range_conds(int index) const;
  ::baikaldb::pb::DelteCondMessage* _internal_add_range_conds();
  public:
  const ::baikaldb::pb::DelteCondMessage& range_conds(int index) const;
  ::baikaldb::pb::DelteCondMessage* add_range_conds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DelteCondMessage >&
      range_conds() const;

  // optional .baikaldb.pb.DelteCondMessage expire_cond = 2;
  bool has_expire_cond() const;
  private:
  bool _internal_has_expire_cond() const;
  public:
  void clear_expire_cond();
  const ::baikaldb::pb::DelteCondMessage& expire_cond() const;
  PROTOBUF_MUST_USE_RESULT ::baikaldb::pb::DelteCondMessage* release_expire_cond();
  ::baikaldb::pb::DelteCondMessage* mutable_expire_cond();
  void set_allocated_expire_cond(::baikaldb::pb::DelteCondMessage* expire_cond);
  private:
  const ::baikaldb::pb::DelteCondMessage& _internal_expire_cond() const;
  ::baikaldb::pb::DelteCondMessage* _internal_mutable_expire_cond();
  public:
  void unsafe_arena_set_allocated_expire_cond(
      ::baikaldb::pb::DelteCondMessage* expire_cond);
  ::baikaldb::pb::DelteCondMessage* unsafe_arena_release_expire_cond();

  // optional int32 open_flag = 1 [default = 0];
  bool has_open_flag() const;
  private:
  bool _internal_has_open_flag() const;
  public:
  void clear_open_flag();
  ::PROTOBUF_NAMESPACE_ID::int32 open_flag() const;
  void set_open_flag(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_open_flag() const;
  void _internal_set_open_flag(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 expire_cond_open_flag = 5 [default = 0];
  bool has_expire_cond_open_flag() const;
  private:
  bool _internal_has_expire_cond_open_flag() const;
  public:
  void clear_expire_cond_open_flag();
  ::PROTOBUF_NAMESPACE_ID::int32 expire_cond_open_flag() const;
  void set_expire_cond_open_flag(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_expire_cond_open_flag() const;
  void _internal_set_expire_cond_open_flag(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 delete_cond_open_flag = 6 [default = 0];
  bool has_delete_cond_open_flag() const;
  private:
  bool _internal_has_delete_cond_open_flag() const;
  public:
  void clear_delete_cond_open_flag();
  ::PROTOBUF_NAMESPACE_ID::int32 delete_cond_open_flag() const;
  void set_delete_cond_open_flag(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_delete_cond_open_flag() const;
  void _internal_set_delete_cond_open_flag(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 range_cond_open_flag = 7 [default = 0];
  bool has_range_cond_open_flag() const;
  private:
  bool _internal_has_range_cond_open_flag() const;
  public:
  void clear_range_cond_open_flag();
  ::PROTOBUF_NAMESPACE_ID::int32 range_cond_open_flag() const;
  void set_range_cond_open_flag(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_range_cond_open_flag() const;
  void _internal_set_range_cond_open_flag(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 latest_edition = 8 [default = 0];
  bool has_latest_edition() const;
  private:
  bool _internal_has_latest_edition() const;
  public:
  void clear_latest_edition();
  ::PROTOBUF_NAMESPACE_ID::int32 latest_edition() const;
  void set_latest_edition(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_latest_edition() const;
  void _internal_set_latest_edition(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 be_edition = 9 [default = 0];
  bool has_be_edition() const;
  private:
  bool _internal_has_be_edition() const;
  public:
  void clear_be_edition();
  ::PROTOBUF_NAMESPACE_ID::int32 be_edition() const;
  void set_be_edition(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_be_edition() const;
  void _internal_set_be_edition(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.DeleteDataPolicyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DelteCondMessage > delete_conds_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DelteCondMessage > range_conds_;
  ::baikaldb::pb::DelteCondMessage* expire_cond_;
  ::PROTOBUF_NAMESPACE_ID::int32 open_flag_;
  ::PROTOBUF_NAMESPACE_ID::int32 expire_cond_open_flag_;
  ::PROTOBUF_NAMESPACE_ID::int32 delete_cond_open_flag_;
  ::PROTOBUF_NAMESPACE_ID::int32 range_cond_open_flag_;
  ::PROTOBUF_NAMESPACE_ID::int32 latest_edition_;
  ::PROTOBUF_NAMESPACE_ID::int32 be_edition_;
  friend struct ::TableStruct_olap_2eproto;
};
// -------------------------------------------------------------------

class DelteCondMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.DelteCondMessage) */ {
 public:
  inline DelteCondMessage() : DelteCondMessage(nullptr) {}
  ~DelteCondMessage() override;
  explicit constexpr DelteCondMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DelteCondMessage(const DelteCondMessage& from);
  DelteCondMessage(DelteCondMessage&& from) noexcept
    : DelteCondMessage() {
    *this = ::std::move(from);
  }

  inline DelteCondMessage& operator=(const DelteCondMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelteCondMessage& operator=(DelteCondMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelteCondMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelteCondMessage* internal_default_instance() {
    return reinterpret_cast<const DelteCondMessage*>(
               &_DelteCondMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DelteCondMessage& a, DelteCondMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DelteCondMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelteCondMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DelteCondMessage* New() const final {
    return new DelteCondMessage();
  }

  DelteCondMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DelteCondMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DelteCondMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DelteCondMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelteCondMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.DelteCondMessage";
  }
  protected:
  explicit DelteCondMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldNameFieldNumber = 1,
    kRangeFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // required string field_name = 1;
  bool has_field_name() const;
  private:
  bool _internal_has_field_name() const;
  public:
  void clear_field_name();
  const std::string& field_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_field_name();
  void set_allocated_field_name(std::string* field_name);
  private:
  const std::string& _internal_field_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field_name(const std::string& value);
  std::string* _internal_mutable_field_name();
  public:

  // required string range = 2;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const std::string& range() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_range(ArgT0&& arg0, ArgT... args);
  std::string* mutable_range();
  PROTOBUF_MUST_USE_RESULT std::string* release_range();
  void set_allocated_range(std::string* range);
  private:
  const std::string& _internal_range() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_range(const std::string& value);
  std::string* _internal_mutable_range();
  public:

  // required string value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.DelteCondMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr range_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_olap_2eproto;
};
// -------------------------------------------------------------------

class TierStoragePolicyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.TierStoragePolicyMessage) */ {
 public:
  inline TierStoragePolicyMessage() : TierStoragePolicyMessage(nullptr) {}
  ~TierStoragePolicyMessage() override;
  explicit constexpr TierStoragePolicyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TierStoragePolicyMessage(const TierStoragePolicyMessage& from);
  TierStoragePolicyMessage(TierStoragePolicyMessage&& from) noexcept
    : TierStoragePolicyMessage() {
    *this = ::std::move(from);
  }

  inline TierStoragePolicyMessage& operator=(const TierStoragePolicyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TierStoragePolicyMessage& operator=(TierStoragePolicyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TierStoragePolicyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TierStoragePolicyMessage* internal_default_instance() {
    return reinterpret_cast<const TierStoragePolicyMessage*>(
               &_TierStoragePolicyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TierStoragePolicyMessage& a, TierStoragePolicyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TierStoragePolicyMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TierStoragePolicyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TierStoragePolicyMessage* New() const final {
    return new TierStoragePolicyMessage();
  }

  TierStoragePolicyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TierStoragePolicyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TierStoragePolicyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TierStoragePolicyMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TierStoragePolicyMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.TierStoragePolicyMessage";
  }
  protected:
  explicit TierStoragePolicyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowDeltaSsdFieldNumber = 1,
    kSsdDaysFieldNumber = 2,
    kAfsDaysFieldNumber = 3,
  };
  // optional bool allow_delta_ssd = 1 [default = false];
  bool has_allow_delta_ssd() const;
  private:
  bool _internal_has_allow_delta_ssd() const;
  public:
  void clear_allow_delta_ssd();
  bool allow_delta_ssd() const;
  void set_allow_delta_ssd(bool value);
  private:
  bool _internal_allow_delta_ssd() const;
  void _internal_set_allow_delta_ssd(bool value);
  public:

  // optional int32 ssd_days = 2 [default = 0];
  bool has_ssd_days() const;
  private:
  bool _internal_has_ssd_days() const;
  public:
  void clear_ssd_days();
  ::PROTOBUF_NAMESPACE_ID::int32 ssd_days() const;
  void set_ssd_days(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ssd_days() const;
  void _internal_set_ssd_days(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 afs_days = 3 [default = 0];
  bool has_afs_days() const;
  private:
  bool _internal_has_afs_days() const;
  public:
  void clear_afs_days();
  ::PROTOBUF_NAMESPACE_ID::int32 afs_days() const;
  void set_afs_days(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_afs_days() const;
  void _internal_set_afs_days(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.TierStoragePolicyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool allow_delta_ssd_;
  ::PROTOBUF_NAMESPACE_ID::int32 ssd_days_;
  ::PROTOBUF_NAMESPACE_ID::int32 afs_days_;
  friend struct ::TableStruct_olap_2eproto;
};
// -------------------------------------------------------------------

class OLAPDataHeaderMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.OLAPDataHeaderMessage) */ {
 public:
  inline OLAPDataHeaderMessage() : OLAPDataHeaderMessage(nullptr) {}
  ~OLAPDataHeaderMessage() override;
  explicit constexpr OLAPDataHeaderMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OLAPDataHeaderMessage(const OLAPDataHeaderMessage& from);
  OLAPDataHeaderMessage(OLAPDataHeaderMessage&& from) noexcept
    : OLAPDataHeaderMessage() {
    *this = ::std::move(from);
  }

  inline OLAPDataHeaderMessage& operator=(const OLAPDataHeaderMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OLAPDataHeaderMessage& operator=(OLAPDataHeaderMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OLAPDataHeaderMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OLAPDataHeaderMessage* internal_default_instance() {
    return reinterpret_cast<const OLAPDataHeaderMessage*>(
               &_OLAPDataHeaderMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(OLAPDataHeaderMessage& a, OLAPDataHeaderMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OLAPDataHeaderMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OLAPDataHeaderMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OLAPDataHeaderMessage* New() const final {
    return new OLAPDataHeaderMessage();
  }

  OLAPDataHeaderMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OLAPDataHeaderMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OLAPDataHeaderMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OLAPDataHeaderMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OLAPDataHeaderMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.OLAPDataHeaderMessage";
  }
  protected:
  explicit OLAPDataHeaderMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 1,
    kSegmentFieldNumber = 2,
  };
  // required string signature = 1;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // required uint32 segment = 2;
  bool has_segment() const;
  private:
  bool _internal_has_segment() const;
  public:
  void clear_segment();
  ::PROTOBUF_NAMESPACE_ID::uint32 segment() const;
  void set_segment(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_segment() const;
  void _internal_set_segment(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.OLAPDataHeaderMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::uint32 segment_;
  friend struct ::TableStruct_olap_2eproto;
};
// -------------------------------------------------------------------

class OLAPIndexHeaderMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:baikaldb.pb.OLAPIndexHeaderMessage) */ {
 public:
  inline OLAPIndexHeaderMessage() : OLAPIndexHeaderMessage(nullptr) {}
  ~OLAPIndexHeaderMessage() override;
  explicit constexpr OLAPIndexHeaderMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OLAPIndexHeaderMessage(const OLAPIndexHeaderMessage& from);
  OLAPIndexHeaderMessage(OLAPIndexHeaderMessage&& from) noexcept
    : OLAPIndexHeaderMessage() {
    *this = ::std::move(from);
  }

  inline OLAPIndexHeaderMessage& operator=(const OLAPIndexHeaderMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OLAPIndexHeaderMessage& operator=(OLAPIndexHeaderMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OLAPIndexHeaderMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const OLAPIndexHeaderMessage* internal_default_instance() {
    return reinterpret_cast<const OLAPIndexHeaderMessage*>(
               &_OLAPIndexHeaderMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(OLAPIndexHeaderMessage& a, OLAPIndexHeaderMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OLAPIndexHeaderMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OLAPIndexHeaderMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OLAPIndexHeaderMessage* New() const final {
    return new OLAPIndexHeaderMessage();
  }

  OLAPIndexHeaderMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OLAPIndexHeaderMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OLAPIndexHeaderMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OLAPIndexHeaderMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OLAPIndexHeaderMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "baikaldb.pb.OLAPIndexHeaderMessage";
  }
  protected:
  explicit OLAPIndexHeaderMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 1,
    kTableNameFieldNumber = 2,
    kIndexNameFieldNumber = 3,
    kSchemaHashFieldNumber = 4,
    kStartVersionFieldNumber = 5,
    kCumulativeVersionHashFieldNumber = 7,
    kEndVersionFieldNumber = 6,
    kSegmentFieldNumber = 8,
    kNumRowsPerBlockFieldNumber = 9,
    kDataFileSizeFieldNumber = 10,
  };
  // required string signature = 1;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // required string table_name = 2;
  bool has_table_name() const;
  private:
  bool _internal_has_table_name() const;
  public:
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // required string index_name = 3;
  bool has_index_name() const;
  private:
  bool _internal_has_index_name() const;
  public:
  void clear_index_name();
  const std::string& index_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_index_name();
  void set_allocated_index_name(std::string* index_name);
  private:
  const std::string& _internal_index_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index_name(const std::string& value);
  std::string* _internal_mutable_index_name();
  public:

  // required int32 schema_hash = 4;
  bool has_schema_hash() const;
  private:
  bool _internal_has_schema_hash() const;
  public:
  void clear_schema_hash();
  ::PROTOBUF_NAMESPACE_ID::int32 schema_hash() const;
  void set_schema_hash(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_schema_hash() const;
  void _internal_set_schema_hash(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 start_version = 5;
  bool has_start_version() const;
  private:
  bool _internal_has_start_version() const;
  public:
  void clear_start_version();
  ::PROTOBUF_NAMESPACE_ID::int32 start_version() const;
  void set_start_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_start_version() const;
  void _internal_set_start_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int64 cumulative_version_hash = 7;
  bool has_cumulative_version_hash() const;
  private:
  bool _internal_has_cumulative_version_hash() const;
  public:
  void clear_cumulative_version_hash();
  ::PROTOBUF_NAMESPACE_ID::int64 cumulative_version_hash() const;
  void set_cumulative_version_hash(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_cumulative_version_hash() const;
  void _internal_set_cumulative_version_hash(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int32 end_version = 6;
  bool has_end_version() const;
  private:
  bool _internal_has_end_version() const;
  public:
  void clear_end_version();
  ::PROTOBUF_NAMESPACE_ID::int32 end_version() const;
  void set_end_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_end_version() const;
  void _internal_set_end_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required uint32 segment = 8;
  bool has_segment() const;
  private:
  bool _internal_has_segment() const;
  public:
  void clear_segment();
  ::PROTOBUF_NAMESPACE_ID::uint32 segment() const;
  void set_segment(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_segment() const;
  void _internal_set_segment(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 num_rows_per_block = 9;
  bool has_num_rows_per_block() const;
  private:
  bool _internal_has_num_rows_per_block() const;
  public:
  void clear_num_rows_per_block();
  ::PROTOBUF_NAMESPACE_ID::uint32 num_rows_per_block() const;
  void set_num_rows_per_block(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_rows_per_block() const;
  void _internal_set_num_rows_per_block(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 data_file_size = 10;
  bool has_data_file_size() const;
  private:
  bool _internal_has_data_file_size() const;
  public:
  void clear_data_file_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 data_file_size() const;
  void set_data_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_data_file_size() const;
  void _internal_set_data_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:baikaldb.pb.OLAPIndexHeaderMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 schema_hash_;
  ::PROTOBUF_NAMESPACE_ID::int32 start_version_;
  ::PROTOBUF_NAMESPACE_ID::int64 cumulative_version_hash_;
  ::PROTOBUF_NAMESPACE_ID::int32 end_version_;
  ::PROTOBUF_NAMESPACE_ID::uint32 segment_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_rows_per_block_;
  ::PROTOBUF_NAMESPACE_ID::uint32 data_file_size_;
  friend struct ::TableStruct_olap_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OLAPRawDeltaHeaderMessage

// required string signature = 1;
inline bool OLAPRawDeltaHeaderMessage::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OLAPRawDeltaHeaderMessage::has_signature() const {
  return _internal_has_signature();
}
inline void OLAPRawDeltaHeaderMessage::clear_signature() {
  signature_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OLAPRawDeltaHeaderMessage::signature() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPRawDeltaHeaderMessage.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OLAPRawDeltaHeaderMessage::set_signature(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPRawDeltaHeaderMessage.signature)
}
inline std::string* OLAPRawDeltaHeaderMessage::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPRawDeltaHeaderMessage.signature)
  return _s;
}
inline const std::string& OLAPRawDeltaHeaderMessage::_internal_signature() const {
  return signature_.Get();
}
inline void OLAPRawDeltaHeaderMessage::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OLAPRawDeltaHeaderMessage::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OLAPRawDeltaHeaderMessage::release_signature() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OLAPRawDeltaHeaderMessage.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OLAPRawDeltaHeaderMessage::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OLAPRawDeltaHeaderMessage.signature)
}

// required int32 schema_hash = 2;
inline bool OLAPRawDeltaHeaderMessage::_internal_has_schema_hash() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OLAPRawDeltaHeaderMessage::has_schema_hash() const {
  return _internal_has_schema_hash();
}
inline void OLAPRawDeltaHeaderMessage::clear_schema_hash() {
  schema_hash_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OLAPRawDeltaHeaderMessage::_internal_schema_hash() const {
  return schema_hash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OLAPRawDeltaHeaderMessage::schema_hash() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPRawDeltaHeaderMessage.schema_hash)
  return _internal_schema_hash();
}
inline void OLAPRawDeltaHeaderMessage::_internal_set_schema_hash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  schema_hash_ = value;
}
inline void OLAPRawDeltaHeaderMessage::set_schema_hash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_schema_hash(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPRawDeltaHeaderMessage.schema_hash)
}

// -------------------------------------------------------------------

// OLAPHeaderMessage

// required string signature = 1;
inline bool OLAPHeaderMessage::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OLAPHeaderMessage::has_signature() const {
  return _internal_has_signature();
}
inline void OLAPHeaderMessage::clear_signature() {
  signature_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OLAPHeaderMessage::signature() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OLAPHeaderMessage::set_signature(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPHeaderMessage.signature)
}
inline std::string* OLAPHeaderMessage::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPHeaderMessage.signature)
  return _s;
}
inline const std::string& OLAPHeaderMessage::_internal_signature() const {
  return signature_.Get();
}
inline void OLAPHeaderMessage::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OLAPHeaderMessage::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OLAPHeaderMessage::release_signature() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OLAPHeaderMessage.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OLAPHeaderMessage::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OLAPHeaderMessage.signature)
}

// required string db_name = 2;
inline bool OLAPHeaderMessage::_internal_has_db_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OLAPHeaderMessage::has_db_name() const {
  return _internal_has_db_name();
}
inline void OLAPHeaderMessage::clear_db_name() {
  db_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OLAPHeaderMessage::db_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OLAPHeaderMessage::set_db_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 db_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPHeaderMessage.db_name)
}
inline std::string* OLAPHeaderMessage::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPHeaderMessage.db_name)
  return _s;
}
inline const std::string& OLAPHeaderMessage::_internal_db_name() const {
  return db_name_.Get();
}
inline void OLAPHeaderMessage::_internal_set_db_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  db_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OLAPHeaderMessage::_internal_mutable_db_name() {
  _has_bits_[0] |= 0x00000002u;
  return db_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OLAPHeaderMessage::release_db_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OLAPHeaderMessage.db_name)
  if (!_internal_has_db_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return db_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OLAPHeaderMessage::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  db_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), db_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OLAPHeaderMessage.db_name)
}

// required string table_name = 3;
inline bool OLAPHeaderMessage::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OLAPHeaderMessage::has_table_name() const {
  return _internal_has_table_name();
}
inline void OLAPHeaderMessage::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& OLAPHeaderMessage::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OLAPHeaderMessage::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPHeaderMessage.table_name)
}
inline std::string* OLAPHeaderMessage::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPHeaderMessage.table_name)
  return _s;
}
inline const std::string& OLAPHeaderMessage::_internal_table_name() const {
  return table_name_.Get();
}
inline void OLAPHeaderMessage::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OLAPHeaderMessage::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000004u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OLAPHeaderMessage::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OLAPHeaderMessage.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OLAPHeaderMessage::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OLAPHeaderMessage.table_name)
}

// optional string abbreviated_name = 4;
inline bool OLAPHeaderMessage::_internal_has_abbreviated_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OLAPHeaderMessage::has_abbreviated_name() const {
  return _internal_has_abbreviated_name();
}
inline void OLAPHeaderMessage::clear_abbreviated_name() {
  abbreviated_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& OLAPHeaderMessage::abbreviated_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.abbreviated_name)
  return _internal_abbreviated_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OLAPHeaderMessage::set_abbreviated_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 abbreviated_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPHeaderMessage.abbreviated_name)
}
inline std::string* OLAPHeaderMessage::mutable_abbreviated_name() {
  std::string* _s = _internal_mutable_abbreviated_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPHeaderMessage.abbreviated_name)
  return _s;
}
inline const std::string& OLAPHeaderMessage::_internal_abbreviated_name() const {
  return abbreviated_name_.Get();
}
inline void OLAPHeaderMessage::_internal_set_abbreviated_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  abbreviated_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OLAPHeaderMessage::_internal_mutable_abbreviated_name() {
  _has_bits_[0] |= 0x00000008u;
  return abbreviated_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OLAPHeaderMessage::release_abbreviated_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OLAPHeaderMessage.abbreviated_name)
  if (!_internal_has_abbreviated_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return abbreviated_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OLAPHeaderMessage::set_allocated_abbreviated_name(std::string* abbreviated_name) {
  if (abbreviated_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  abbreviated_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), abbreviated_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OLAPHeaderMessage.abbreviated_name)
}

// required string index_name = 5;
inline bool OLAPHeaderMessage::_internal_has_index_name() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool OLAPHeaderMessage::has_index_name() const {
  return _internal_has_index_name();
}
inline void OLAPHeaderMessage::clear_index_name() {
  index_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& OLAPHeaderMessage::index_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.index_name)
  return _internal_index_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OLAPHeaderMessage::set_index_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPHeaderMessage.index_name)
}
inline std::string* OLAPHeaderMessage::mutable_index_name() {
  std::string* _s = _internal_mutable_index_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPHeaderMessage.index_name)
  return _s;
}
inline const std::string& OLAPHeaderMessage::_internal_index_name() const {
  return index_name_.Get();
}
inline void OLAPHeaderMessage::_internal_set_index_name(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OLAPHeaderMessage::_internal_mutable_index_name() {
  _has_bits_[0] |= 0x00000010u;
  return index_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OLAPHeaderMessage::release_index_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OLAPHeaderMessage.index_name)
  if (!_internal_has_index_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return index_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OLAPHeaderMessage::set_allocated_index_name(std::string* index_name) {
  if (index_name != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  index_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OLAPHeaderMessage.index_name)
}

// required uint32 num_rows_per_data_block = 6;
inline bool OLAPHeaderMessage::_internal_has_num_rows_per_data_block() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool OLAPHeaderMessage::has_num_rows_per_data_block() const {
  return _internal_has_num_rows_per_data_block();
}
inline void OLAPHeaderMessage::clear_num_rows_per_data_block() {
  num_rows_per_data_block_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OLAPHeaderMessage::_internal_num_rows_per_data_block() const {
  return num_rows_per_data_block_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OLAPHeaderMessage::num_rows_per_data_block() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.num_rows_per_data_block)
  return _internal_num_rows_per_data_block();
}
inline void OLAPHeaderMessage::_internal_set_num_rows_per_data_block(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  num_rows_per_data_block_ = value;
}
inline void OLAPHeaderMessage::set_num_rows_per_data_block(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num_rows_per_data_block(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPHeaderMessage.num_rows_per_data_block)
}

// required uint32 schema_hash = 7;
inline bool OLAPHeaderMessage::_internal_has_schema_hash() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool OLAPHeaderMessage::has_schema_hash() const {
  return _internal_has_schema_hash();
}
inline void OLAPHeaderMessage::clear_schema_hash() {
  schema_hash_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OLAPHeaderMessage::_internal_schema_hash() const {
  return schema_hash_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OLAPHeaderMessage::schema_hash() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.schema_hash)
  return _internal_schema_hash();
}
inline void OLAPHeaderMessage::_internal_set_schema_hash(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  schema_hash_ = value;
}
inline void OLAPHeaderMessage::set_schema_hash(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_schema_hash(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPHeaderMessage.schema_hash)
}

// optional uint32 schema_version = 8;
inline bool OLAPHeaderMessage::_internal_has_schema_version() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool OLAPHeaderMessage::has_schema_version() const {
  return _internal_has_schema_version();
}
inline void OLAPHeaderMessage::clear_schema_version() {
  schema_version_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OLAPHeaderMessage::_internal_schema_version() const {
  return schema_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OLAPHeaderMessage::schema_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.schema_version)
  return _internal_schema_version();
}
inline void OLAPHeaderMessage::_internal_set_schema_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  schema_version_ = value;
}
inline void OLAPHeaderMessage::set_schema_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_schema_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPHeaderMessage.schema_version)
}

// repeated .baikaldb.pb.FileVersionMessage file_version = 9;
inline int OLAPHeaderMessage::_internal_file_version_size() const {
  return file_version_.size();
}
inline int OLAPHeaderMessage::file_version_size() const {
  return _internal_file_version_size();
}
inline void OLAPHeaderMessage::clear_file_version() {
  file_version_.Clear();
}
inline ::baikaldb::pb::FileVersionMessage* OLAPHeaderMessage::mutable_file_version(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPHeaderMessage.file_version)
  return file_version_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FileVersionMessage >*
OLAPHeaderMessage::mutable_file_version() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.OLAPHeaderMessage.file_version)
  return &file_version_;
}
inline const ::baikaldb::pb::FileVersionMessage& OLAPHeaderMessage::_internal_file_version(int index) const {
  return file_version_.Get(index);
}
inline const ::baikaldb::pb::FileVersionMessage& OLAPHeaderMessage::file_version(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.file_version)
  return _internal_file_version(index);
}
inline ::baikaldb::pb::FileVersionMessage* OLAPHeaderMessage::_internal_add_file_version() {
  return file_version_.Add();
}
inline ::baikaldb::pb::FileVersionMessage* OLAPHeaderMessage::add_file_version() {
  ::baikaldb::pb::FileVersionMessage* _add = _internal_add_file_version();
  // @@protoc_insertion_point(field_add:baikaldb.pb.OLAPHeaderMessage.file_version)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FileVersionMessage >&
OLAPHeaderMessage::file_version() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.OLAPHeaderMessage.file_version)
  return file_version_;
}

// required bool is_healthy = 10 [default = false];
inline bool OLAPHeaderMessage::_internal_has_is_healthy() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool OLAPHeaderMessage::has_is_healthy() const {
  return _internal_has_is_healthy();
}
inline void OLAPHeaderMessage::clear_is_healthy() {
  is_healthy_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool OLAPHeaderMessage::_internal_is_healthy() const {
  return is_healthy_;
}
inline bool OLAPHeaderMessage::is_healthy() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.is_healthy)
  return _internal_is_healthy();
}
inline void OLAPHeaderMessage::_internal_set_is_healthy(bool value) {
  _has_bits_[0] |= 0x00004000u;
  is_healthy_ = value;
}
inline void OLAPHeaderMessage::set_is_healthy(bool value) {
  _internal_set_is_healthy(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPHeaderMessage.is_healthy)
}

// required .baikaldb.pb.BaseExpansionPolicyMessage base_expansion_policy = 12;
inline bool OLAPHeaderMessage::_internal_has_base_expansion_policy() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || base_expansion_policy_ != nullptr);
  return value;
}
inline bool OLAPHeaderMessage::has_base_expansion_policy() const {
  return _internal_has_base_expansion_policy();
}
inline void OLAPHeaderMessage::clear_base_expansion_policy() {
  if (base_expansion_policy_ != nullptr) base_expansion_policy_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::baikaldb::pb::BaseExpansionPolicyMessage& OLAPHeaderMessage::_internal_base_expansion_policy() const {
  const ::baikaldb::pb::BaseExpansionPolicyMessage* p = base_expansion_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::BaseExpansionPolicyMessage&>(
      ::baikaldb::pb::_BaseExpansionPolicyMessage_default_instance_);
}
inline const ::baikaldb::pb::BaseExpansionPolicyMessage& OLAPHeaderMessage::base_expansion_policy() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.base_expansion_policy)
  return _internal_base_expansion_policy();
}
inline void OLAPHeaderMessage::unsafe_arena_set_allocated_base_expansion_policy(
    ::baikaldb::pb::BaseExpansionPolicyMessage* base_expansion_policy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_expansion_policy_);
  }
  base_expansion_policy_ = base_expansion_policy;
  if (base_expansion_policy) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.OLAPHeaderMessage.base_expansion_policy)
}
inline ::baikaldb::pb::BaseExpansionPolicyMessage* OLAPHeaderMessage::release_base_expansion_policy() {
  _has_bits_[0] &= ~0x00000020u;
  ::baikaldb::pb::BaseExpansionPolicyMessage* temp = base_expansion_policy_;
  base_expansion_policy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::BaseExpansionPolicyMessage* OLAPHeaderMessage::unsafe_arena_release_base_expansion_policy() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OLAPHeaderMessage.base_expansion_policy)
  _has_bits_[0] &= ~0x00000020u;
  ::baikaldb::pb::BaseExpansionPolicyMessage* temp = base_expansion_policy_;
  base_expansion_policy_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::BaseExpansionPolicyMessage* OLAPHeaderMessage::_internal_mutable_base_expansion_policy() {
  _has_bits_[0] |= 0x00000020u;
  if (base_expansion_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::BaseExpansionPolicyMessage>(GetArenaForAllocation());
    base_expansion_policy_ = p;
  }
  return base_expansion_policy_;
}
inline ::baikaldb::pb::BaseExpansionPolicyMessage* OLAPHeaderMessage::mutable_base_expansion_policy() {
  ::baikaldb::pb::BaseExpansionPolicyMessage* _msg = _internal_mutable_base_expansion_policy();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPHeaderMessage.base_expansion_policy)
  return _msg;
}
inline void OLAPHeaderMessage::set_allocated_base_expansion_policy(::baikaldb::pb::BaseExpansionPolicyMessage* base_expansion_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete base_expansion_policy_;
  }
  if (base_expansion_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::BaseExpansionPolicyMessage>::GetOwningArena(base_expansion_policy);
    if (message_arena != submessage_arena) {
      base_expansion_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base_expansion_policy, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  base_expansion_policy_ = base_expansion_policy;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OLAPHeaderMessage.base_expansion_policy)
}

// optional .baikaldb.pb.CumulativePolicyMessage cumulative_policy = 13;
inline bool OLAPHeaderMessage::_internal_has_cumulative_policy() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || cumulative_policy_ != nullptr);
  return value;
}
inline bool OLAPHeaderMessage::has_cumulative_policy() const {
  return _internal_has_cumulative_policy();
}
inline void OLAPHeaderMessage::clear_cumulative_policy() {
  if (cumulative_policy_ != nullptr) cumulative_policy_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::baikaldb::pb::CumulativePolicyMessage& OLAPHeaderMessage::_internal_cumulative_policy() const {
  const ::baikaldb::pb::CumulativePolicyMessage* p = cumulative_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::CumulativePolicyMessage&>(
      ::baikaldb::pb::_CumulativePolicyMessage_default_instance_);
}
inline const ::baikaldb::pb::CumulativePolicyMessage& OLAPHeaderMessage::cumulative_policy() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.cumulative_policy)
  return _internal_cumulative_policy();
}
inline void OLAPHeaderMessage::unsafe_arena_set_allocated_cumulative_policy(
    ::baikaldb::pb::CumulativePolicyMessage* cumulative_policy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cumulative_policy_);
  }
  cumulative_policy_ = cumulative_policy;
  if (cumulative_policy) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.OLAPHeaderMessage.cumulative_policy)
}
inline ::baikaldb::pb::CumulativePolicyMessage* OLAPHeaderMessage::release_cumulative_policy() {
  _has_bits_[0] &= ~0x00000040u;
  ::baikaldb::pb::CumulativePolicyMessage* temp = cumulative_policy_;
  cumulative_policy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::CumulativePolicyMessage* OLAPHeaderMessage::unsafe_arena_release_cumulative_policy() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OLAPHeaderMessage.cumulative_policy)
  _has_bits_[0] &= ~0x00000040u;
  ::baikaldb::pb::CumulativePolicyMessage* temp = cumulative_policy_;
  cumulative_policy_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::CumulativePolicyMessage* OLAPHeaderMessage::_internal_mutable_cumulative_policy() {
  _has_bits_[0] |= 0x00000040u;
  if (cumulative_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::CumulativePolicyMessage>(GetArenaForAllocation());
    cumulative_policy_ = p;
  }
  return cumulative_policy_;
}
inline ::baikaldb::pb::CumulativePolicyMessage* OLAPHeaderMessage::mutable_cumulative_policy() {
  ::baikaldb::pb::CumulativePolicyMessage* _msg = _internal_mutable_cumulative_policy();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPHeaderMessage.cumulative_policy)
  return _msg;
}
inline void OLAPHeaderMessage::set_allocated_cumulative_policy(::baikaldb::pb::CumulativePolicyMessage* cumulative_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cumulative_policy_;
  }
  if (cumulative_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::CumulativePolicyMessage>::GetOwningArena(cumulative_policy);
    if (message_arena != submessage_arena) {
      cumulative_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cumulative_policy, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  cumulative_policy_ = cumulative_policy;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OLAPHeaderMessage.cumulative_policy)
}

// required uint32 num_short_key_fields = 14;
inline bool OLAPHeaderMessage::_internal_has_num_short_key_fields() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool OLAPHeaderMessage::has_num_short_key_fields() const {
  return _internal_has_num_short_key_fields();
}
inline void OLAPHeaderMessage::clear_num_short_key_fields() {
  num_short_key_fields_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OLAPHeaderMessage::_internal_num_short_key_fields() const {
  return num_short_key_fields_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OLAPHeaderMessage::num_short_key_fields() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.num_short_key_fields)
  return _internal_num_short_key_fields();
}
inline void OLAPHeaderMessage::_internal_set_num_short_key_fields(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  num_short_key_fields_ = value;
}
inline void OLAPHeaderMessage::set_num_short_key_fields(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num_short_key_fields(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPHeaderMessage.num_short_key_fields)
}

// repeated .baikaldb.pb.ColumnMessage column = 15;
inline int OLAPHeaderMessage::_internal_column_size() const {
  return column_.size();
}
inline int OLAPHeaderMessage::column_size() const {
  return _internal_column_size();
}
inline void OLAPHeaderMessage::clear_column() {
  column_.Clear();
}
inline ::baikaldb::pb::ColumnMessage* OLAPHeaderMessage::mutable_column(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPHeaderMessage.column)
  return column_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ColumnMessage >*
OLAPHeaderMessage::mutable_column() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.OLAPHeaderMessage.column)
  return &column_;
}
inline const ::baikaldb::pb::ColumnMessage& OLAPHeaderMessage::_internal_column(int index) const {
  return column_.Get(index);
}
inline const ::baikaldb::pb::ColumnMessage& OLAPHeaderMessage::column(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.column)
  return _internal_column(index);
}
inline ::baikaldb::pb::ColumnMessage* OLAPHeaderMessage::_internal_add_column() {
  return column_.Add();
}
inline ::baikaldb::pb::ColumnMessage* OLAPHeaderMessage::add_column() {
  ::baikaldb::pb::ColumnMessage* _add = _internal_add_column();
  // @@protoc_insertion_point(field_add:baikaldb.pb.OLAPHeaderMessage.column)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::ColumnMessage >&
OLAPHeaderMessage::column() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.OLAPHeaderMessage.column)
  return column_;
}

// required int64 creation_time = 16;
inline bool OLAPHeaderMessage::_internal_has_creation_time() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool OLAPHeaderMessage::has_creation_time() const {
  return _internal_has_creation_time();
}
inline void OLAPHeaderMessage::clear_creation_time() {
  creation_time_ = int64_t{0};
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OLAPHeaderMessage::_internal_creation_time() const {
  return creation_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OLAPHeaderMessage::creation_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.creation_time)
  return _internal_creation_time();
}
inline void OLAPHeaderMessage::_internal_set_creation_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00008000u;
  creation_time_ = value;
}
inline void OLAPHeaderMessage::set_creation_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_creation_time(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPHeaderMessage.creation_time)
}

// repeated int32 selectivity = 17;
inline int OLAPHeaderMessage::_internal_selectivity_size() const {
  return selectivity_.size();
}
inline int OLAPHeaderMessage::selectivity_size() const {
  return _internal_selectivity_size();
}
inline void OLAPHeaderMessage::clear_selectivity() {
  selectivity_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OLAPHeaderMessage::_internal_selectivity(int index) const {
  return selectivity_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OLAPHeaderMessage::selectivity(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.selectivity)
  return _internal_selectivity(index);
}
inline void OLAPHeaderMessage::set_selectivity(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  selectivity_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPHeaderMessage.selectivity)
}
inline void OLAPHeaderMessage::_internal_add_selectivity(::PROTOBUF_NAMESPACE_ID::int32 value) {
  selectivity_.Add(value);
}
inline void OLAPHeaderMessage::add_selectivity(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_selectivity(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.OLAPHeaderMessage.selectivity)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
OLAPHeaderMessage::_internal_selectivity() const {
  return selectivity_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
OLAPHeaderMessage::selectivity() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.OLAPHeaderMessage.selectivity)
  return _internal_selectivity();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
OLAPHeaderMessage::_internal_mutable_selectivity() {
  return &selectivity_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
OLAPHeaderMessage::mutable_selectivity() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.OLAPHeaderMessage.selectivity)
  return _internal_mutable_selectivity();
}

// required uint64 num_rows = 18 [default = 1];
inline bool OLAPHeaderMessage::_internal_has_num_rows() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool OLAPHeaderMessage::has_num_rows() const {
  return _internal_has_num_rows();
}
inline void OLAPHeaderMessage::clear_num_rows() {
  num_rows_ = uint64_t{1u};
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OLAPHeaderMessage::_internal_num_rows() const {
  return num_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OLAPHeaderMessage::num_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.num_rows)
  return _internal_num_rows();
}
inline void OLAPHeaderMessage::_internal_set_num_rows(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00020000u;
  num_rows_ = value;
}
inline void OLAPHeaderMessage::set_num_rows(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_num_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPHeaderMessage.num_rows)
}

// optional .baikaldb.pb.SchemaChangeStatusMessage schema_change_status = 19;
inline bool OLAPHeaderMessage::_internal_has_schema_change_status() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || schema_change_status_ != nullptr);
  return value;
}
inline bool OLAPHeaderMessage::has_schema_change_status() const {
  return _internal_has_schema_change_status();
}
inline void OLAPHeaderMessage::clear_schema_change_status() {
  if (schema_change_status_ != nullptr) schema_change_status_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::baikaldb::pb::SchemaChangeStatusMessage& OLAPHeaderMessage::_internal_schema_change_status() const {
  const ::baikaldb::pb::SchemaChangeStatusMessage* p = schema_change_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::SchemaChangeStatusMessage&>(
      ::baikaldb::pb::_SchemaChangeStatusMessage_default_instance_);
}
inline const ::baikaldb::pb::SchemaChangeStatusMessage& OLAPHeaderMessage::schema_change_status() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.schema_change_status)
  return _internal_schema_change_status();
}
inline void OLAPHeaderMessage::unsafe_arena_set_allocated_schema_change_status(
    ::baikaldb::pb::SchemaChangeStatusMessage* schema_change_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_change_status_);
  }
  schema_change_status_ = schema_change_status;
  if (schema_change_status) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.OLAPHeaderMessage.schema_change_status)
}
inline ::baikaldb::pb::SchemaChangeStatusMessage* OLAPHeaderMessage::release_schema_change_status() {
  _has_bits_[0] &= ~0x00000080u;
  ::baikaldb::pb::SchemaChangeStatusMessage* temp = schema_change_status_;
  schema_change_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::SchemaChangeStatusMessage* OLAPHeaderMessage::unsafe_arena_release_schema_change_status() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OLAPHeaderMessage.schema_change_status)
  _has_bits_[0] &= ~0x00000080u;
  ::baikaldb::pb::SchemaChangeStatusMessage* temp = schema_change_status_;
  schema_change_status_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::SchemaChangeStatusMessage* OLAPHeaderMessage::_internal_mutable_schema_change_status() {
  _has_bits_[0] |= 0x00000080u;
  if (schema_change_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::SchemaChangeStatusMessage>(GetArenaForAllocation());
    schema_change_status_ = p;
  }
  return schema_change_status_;
}
inline ::baikaldb::pb::SchemaChangeStatusMessage* OLAPHeaderMessage::mutable_schema_change_status() {
  ::baikaldb::pb::SchemaChangeStatusMessage* _msg = _internal_mutable_schema_change_status();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPHeaderMessage.schema_change_status)
  return _msg;
}
inline void OLAPHeaderMessage::set_allocated_schema_change_status(::baikaldb::pb::SchemaChangeStatusMessage* schema_change_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete schema_change_status_;
  }
  if (schema_change_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::SchemaChangeStatusMessage>::GetOwningArena(schema_change_status);
    if (message_arena != submessage_arena) {
      schema_change_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema_change_status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  schema_change_status_ = schema_change_status;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OLAPHeaderMessage.schema_change_status)
}

// optional .baikaldb.pb.DeleteDataPolicyMessage delete_data_policy = 20;
inline bool OLAPHeaderMessage::_internal_has_delete_data_policy() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || delete_data_policy_ != nullptr);
  return value;
}
inline bool OLAPHeaderMessage::has_delete_data_policy() const {
  return _internal_has_delete_data_policy();
}
inline void OLAPHeaderMessage::clear_delete_data_policy() {
  if (delete_data_policy_ != nullptr) delete_data_policy_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::baikaldb::pb::DeleteDataPolicyMessage& OLAPHeaderMessage::_internal_delete_data_policy() const {
  const ::baikaldb::pb::DeleteDataPolicyMessage* p = delete_data_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::DeleteDataPolicyMessage&>(
      ::baikaldb::pb::_DeleteDataPolicyMessage_default_instance_);
}
inline const ::baikaldb::pb::DeleteDataPolicyMessage& OLAPHeaderMessage::delete_data_policy() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.delete_data_policy)
  return _internal_delete_data_policy();
}
inline void OLAPHeaderMessage::unsafe_arena_set_allocated_delete_data_policy(
    ::baikaldb::pb::DeleteDataPolicyMessage* delete_data_policy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(delete_data_policy_);
  }
  delete_data_policy_ = delete_data_policy;
  if (delete_data_policy) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.OLAPHeaderMessage.delete_data_policy)
}
inline ::baikaldb::pb::DeleteDataPolicyMessage* OLAPHeaderMessage::release_delete_data_policy() {
  _has_bits_[0] &= ~0x00000100u;
  ::baikaldb::pb::DeleteDataPolicyMessage* temp = delete_data_policy_;
  delete_data_policy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::DeleteDataPolicyMessage* OLAPHeaderMessage::unsafe_arena_release_delete_data_policy() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OLAPHeaderMessage.delete_data_policy)
  _has_bits_[0] &= ~0x00000100u;
  ::baikaldb::pb::DeleteDataPolicyMessage* temp = delete_data_policy_;
  delete_data_policy_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::DeleteDataPolicyMessage* OLAPHeaderMessage::_internal_mutable_delete_data_policy() {
  _has_bits_[0] |= 0x00000100u;
  if (delete_data_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::DeleteDataPolicyMessage>(GetArenaForAllocation());
    delete_data_policy_ = p;
  }
  return delete_data_policy_;
}
inline ::baikaldb::pb::DeleteDataPolicyMessage* OLAPHeaderMessage::mutable_delete_data_policy() {
  ::baikaldb::pb::DeleteDataPolicyMessage* _msg = _internal_mutable_delete_data_policy();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPHeaderMessage.delete_data_policy)
  return _msg;
}
inline void OLAPHeaderMessage::set_allocated_delete_data_policy(::baikaldb::pb::DeleteDataPolicyMessage* delete_data_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete delete_data_policy_;
  }
  if (delete_data_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::DeleteDataPolicyMessage>::GetOwningArena(delete_data_policy);
    if (message_arena != submessage_arena) {
      delete_data_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delete_data_policy, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  delete_data_policy_ = delete_data_policy;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OLAPHeaderMessage.delete_data_policy)
}

// optional .baikaldb.pb.PartitionPolicyMessage cur_partition_policy = 21;
inline bool OLAPHeaderMessage::_internal_has_cur_partition_policy() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || cur_partition_policy_ != nullptr);
  return value;
}
inline bool OLAPHeaderMessage::has_cur_partition_policy() const {
  return _internal_has_cur_partition_policy();
}
inline void OLAPHeaderMessage::clear_cur_partition_policy() {
  if (cur_partition_policy_ != nullptr) cur_partition_policy_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::baikaldb::pb::PartitionPolicyMessage& OLAPHeaderMessage::_internal_cur_partition_policy() const {
  const ::baikaldb::pb::PartitionPolicyMessage* p = cur_partition_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::PartitionPolicyMessage&>(
      ::baikaldb::pb::_PartitionPolicyMessage_default_instance_);
}
inline const ::baikaldb::pb::PartitionPolicyMessage& OLAPHeaderMessage::cur_partition_policy() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.cur_partition_policy)
  return _internal_cur_partition_policy();
}
inline void OLAPHeaderMessage::unsafe_arena_set_allocated_cur_partition_policy(
    ::baikaldb::pb::PartitionPolicyMessage* cur_partition_policy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cur_partition_policy_);
  }
  cur_partition_policy_ = cur_partition_policy;
  if (cur_partition_policy) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.OLAPHeaderMessage.cur_partition_policy)
}
inline ::baikaldb::pb::PartitionPolicyMessage* OLAPHeaderMessage::release_cur_partition_policy() {
  _has_bits_[0] &= ~0x00000200u;
  ::baikaldb::pb::PartitionPolicyMessage* temp = cur_partition_policy_;
  cur_partition_policy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::PartitionPolicyMessage* OLAPHeaderMessage::unsafe_arena_release_cur_partition_policy() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OLAPHeaderMessage.cur_partition_policy)
  _has_bits_[0] &= ~0x00000200u;
  ::baikaldb::pb::PartitionPolicyMessage* temp = cur_partition_policy_;
  cur_partition_policy_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::PartitionPolicyMessage* OLAPHeaderMessage::_internal_mutable_cur_partition_policy() {
  _has_bits_[0] |= 0x00000200u;
  if (cur_partition_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::PartitionPolicyMessage>(GetArenaForAllocation());
    cur_partition_policy_ = p;
  }
  return cur_partition_policy_;
}
inline ::baikaldb::pb::PartitionPolicyMessage* OLAPHeaderMessage::mutable_cur_partition_policy() {
  ::baikaldb::pb::PartitionPolicyMessage* _msg = _internal_mutable_cur_partition_policy();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPHeaderMessage.cur_partition_policy)
  return _msg;
}
inline void OLAPHeaderMessage::set_allocated_cur_partition_policy(::baikaldb::pb::PartitionPolicyMessage* cur_partition_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cur_partition_policy_;
  }
  if (cur_partition_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::PartitionPolicyMessage>::GetOwningArena(cur_partition_policy);
    if (message_arena != submessage_arena) {
      cur_partition_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cur_partition_policy, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  cur_partition_policy_ = cur_partition_policy;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OLAPHeaderMessage.cur_partition_policy)
}

// optional .baikaldb.pb.TierStoragePolicyMessage tier_storage_policy = 22;
inline bool OLAPHeaderMessage::_internal_has_tier_storage_policy() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || tier_storage_policy_ != nullptr);
  return value;
}
inline bool OLAPHeaderMessage::has_tier_storage_policy() const {
  return _internal_has_tier_storage_policy();
}
inline void OLAPHeaderMessage::clear_tier_storage_policy() {
  if (tier_storage_policy_ != nullptr) tier_storage_policy_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::baikaldb::pb::TierStoragePolicyMessage& OLAPHeaderMessage::_internal_tier_storage_policy() const {
  const ::baikaldb::pb::TierStoragePolicyMessage* p = tier_storage_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::TierStoragePolicyMessage&>(
      ::baikaldb::pb::_TierStoragePolicyMessage_default_instance_);
}
inline const ::baikaldb::pb::TierStoragePolicyMessage& OLAPHeaderMessage::tier_storage_policy() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPHeaderMessage.tier_storage_policy)
  return _internal_tier_storage_policy();
}
inline void OLAPHeaderMessage::unsafe_arena_set_allocated_tier_storage_policy(
    ::baikaldb::pb::TierStoragePolicyMessage* tier_storage_policy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tier_storage_policy_);
  }
  tier_storage_policy_ = tier_storage_policy;
  if (tier_storage_policy) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.OLAPHeaderMessage.tier_storage_policy)
}
inline ::baikaldb::pb::TierStoragePolicyMessage* OLAPHeaderMessage::release_tier_storage_policy() {
  _has_bits_[0] &= ~0x00000400u;
  ::baikaldb::pb::TierStoragePolicyMessage* temp = tier_storage_policy_;
  tier_storage_policy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::TierStoragePolicyMessage* OLAPHeaderMessage::unsafe_arena_release_tier_storage_policy() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OLAPHeaderMessage.tier_storage_policy)
  _has_bits_[0] &= ~0x00000400u;
  ::baikaldb::pb::TierStoragePolicyMessage* temp = tier_storage_policy_;
  tier_storage_policy_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::TierStoragePolicyMessage* OLAPHeaderMessage::_internal_mutable_tier_storage_policy() {
  _has_bits_[0] |= 0x00000400u;
  if (tier_storage_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::TierStoragePolicyMessage>(GetArenaForAllocation());
    tier_storage_policy_ = p;
  }
  return tier_storage_policy_;
}
inline ::baikaldb::pb::TierStoragePolicyMessage* OLAPHeaderMessage::mutable_tier_storage_policy() {
  ::baikaldb::pb::TierStoragePolicyMessage* _msg = _internal_mutable_tier_storage_policy();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPHeaderMessage.tier_storage_policy)
  return _msg;
}
inline void OLAPHeaderMessage::set_allocated_tier_storage_policy(::baikaldb::pb::TierStoragePolicyMessage* tier_storage_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tier_storage_policy_;
  }
  if (tier_storage_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::TierStoragePolicyMessage>::GetOwningArena(tier_storage_policy);
    if (message_arena != submessage_arena) {
      tier_storage_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tier_storage_policy, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  tier_storage_policy_ = tier_storage_policy;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OLAPHeaderMessage.tier_storage_policy)
}

// -------------------------------------------------------------------

// FileVersionMessage

// required uint32 num_segments = 1 [default = 0];
inline bool FileVersionMessage::_internal_has_num_segments() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FileVersionMessage::has_num_segments() const {
  return _internal_has_num_segments();
}
inline void FileVersionMessage::clear_num_segments() {
  num_segments_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FileVersionMessage::_internal_num_segments() const {
  return num_segments_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FileVersionMessage::num_segments() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FileVersionMessage.num_segments)
  return _internal_num_segments();
}
inline void FileVersionMessage::_internal_set_num_segments(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  num_segments_ = value;
}
inline void FileVersionMessage::set_num_segments(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num_segments(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FileVersionMessage.num_segments)
}

// required int32 start_version = 2;
inline bool FileVersionMessage::_internal_has_start_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FileVersionMessage::has_start_version() const {
  return _internal_has_start_version();
}
inline void FileVersionMessage::clear_start_version() {
  start_version_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FileVersionMessage::_internal_start_version() const {
  return start_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FileVersionMessage::start_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FileVersionMessage.start_version)
  return _internal_start_version();
}
inline void FileVersionMessage::_internal_set_start_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  start_version_ = value;
}
inline void FileVersionMessage::set_start_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FileVersionMessage.start_version)
}

// required int32 end_version = 3;
inline bool FileVersionMessage::_internal_has_end_version() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool FileVersionMessage::has_end_version() const {
  return _internal_has_end_version();
}
inline void FileVersionMessage::clear_end_version() {
  end_version_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FileVersionMessage::_internal_end_version() const {
  return end_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FileVersionMessage::end_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FileVersionMessage.end_version)
  return _internal_end_version();
}
inline void FileVersionMessage::_internal_set_end_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  end_version_ = value;
}
inline void FileVersionMessage::set_end_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FileVersionMessage.end_version)
}

// required int64 version_hash = 4 [default = 0];
inline bool FileVersionMessage::_internal_has_version_hash() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FileVersionMessage::has_version_hash() const {
  return _internal_has_version_hash();
}
inline void FileVersionMessage::clear_version_hash() {
  version_hash_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileVersionMessage::_internal_version_hash() const {
  return version_hash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileVersionMessage::version_hash() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FileVersionMessage.version_hash)
  return _internal_version_hash();
}
inline void FileVersionMessage::_internal_set_version_hash(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  version_hash_ = value;
}
inline void FileVersionMessage::set_version_hash(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version_hash(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FileVersionMessage.version_hash)
}

// required int64 max_timestamp = 5 [default = 0];
inline bool FileVersionMessage::_internal_has_max_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FileVersionMessage::has_max_timestamp() const {
  return _internal_has_max_timestamp();
}
inline void FileVersionMessage::clear_max_timestamp() {
  max_timestamp_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileVersionMessage::_internal_max_timestamp() const {
  return max_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileVersionMessage::max_timestamp() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FileVersionMessage.max_timestamp)
  return _internal_max_timestamp();
}
inline void FileVersionMessage::_internal_set_max_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  max_timestamp_ = value;
}
inline void FileVersionMessage::set_max_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_max_timestamp(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FileVersionMessage.max_timestamp)
}

// required int64 index_size = 6 [default = 0];
inline bool FileVersionMessage::_internal_has_index_size() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FileVersionMessage::has_index_size() const {
  return _internal_has_index_size();
}
inline void FileVersionMessage::clear_index_size() {
  index_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileVersionMessage::_internal_index_size() const {
  return index_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileVersionMessage::index_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FileVersionMessage.index_size)
  return _internal_index_size();
}
inline void FileVersionMessage::_internal_set_index_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  index_size_ = value;
}
inline void FileVersionMessage::set_index_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_index_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FileVersionMessage.index_size)
}

// required int64 data_size = 7 [default = 0];
inline bool FileVersionMessage::_internal_has_data_size() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool FileVersionMessage::has_data_size() const {
  return _internal_has_data_size();
}
inline void FileVersionMessage::clear_data_size() {
  data_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileVersionMessage::_internal_data_size() const {
  return data_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileVersionMessage::data_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FileVersionMessage.data_size)
  return _internal_data_size();
}
inline void FileVersionMessage::_internal_set_data_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  data_size_ = value;
}
inline void FileVersionMessage::set_data_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_data_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FileVersionMessage.data_size)
}

// required int64 creation_time = 8 [default = 0];
inline bool FileVersionMessage::_internal_has_creation_time() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool FileVersionMessage::has_creation_time() const {
  return _internal_has_creation_time();
}
inline void FileVersionMessage::clear_creation_time() {
  creation_time_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileVersionMessage::_internal_creation_time() const {
  return creation_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FileVersionMessage::creation_time() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FileVersionMessage.creation_time)
  return _internal_creation_time();
}
inline void FileVersionMessage::_internal_set_creation_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  creation_time_ = value;
}
inline void FileVersionMessage::set_creation_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_creation_time(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FileVersionMessage.creation_time)
}

// repeated int32 selectivity = 9;
inline int FileVersionMessage::_internal_selectivity_size() const {
  return selectivity_.size();
}
inline int FileVersionMessage::selectivity_size() const {
  return _internal_selectivity_size();
}
inline void FileVersionMessage::clear_selectivity() {
  selectivity_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FileVersionMessage::_internal_selectivity(int index) const {
  return selectivity_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FileVersionMessage::selectivity(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FileVersionMessage.selectivity)
  return _internal_selectivity(index);
}
inline void FileVersionMessage::set_selectivity(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  selectivity_.Set(index, value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FileVersionMessage.selectivity)
}
inline void FileVersionMessage::_internal_add_selectivity(::PROTOBUF_NAMESPACE_ID::int32 value) {
  selectivity_.Add(value);
}
inline void FileVersionMessage::add_selectivity(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_selectivity(value);
  // @@protoc_insertion_point(field_add:baikaldb.pb.FileVersionMessage.selectivity)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
FileVersionMessage::_internal_selectivity() const {
  return selectivity_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
FileVersionMessage::selectivity() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.FileVersionMessage.selectivity)
  return _internal_selectivity();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
FileVersionMessage::_internal_mutable_selectivity() {
  return &selectivity_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
FileVersionMessage::mutable_selectivity() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.FileVersionMessage.selectivity)
  return _internal_mutable_selectivity();
}

// optional uint64 num_rows = 10 [default = 0];
inline bool FileVersionMessage::_internal_has_num_rows() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool FileVersionMessage::has_num_rows() const {
  return _internal_has_num_rows();
}
inline void FileVersionMessage::clear_num_rows() {
  num_rows_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FileVersionMessage::_internal_num_rows() const {
  return num_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FileVersionMessage::num_rows() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FileVersionMessage.num_rows)
  return _internal_num_rows();
}
inline void FileVersionMessage::_internal_set_num_rows(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000400u;
  num_rows_ = value;
}
inline void FileVersionMessage::set_num_rows(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_num_rows(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FileVersionMessage.num_rows)
}

// optional uint32 start_partkey = 11 [default = 0];
inline bool FileVersionMessage::_internal_has_start_partkey() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool FileVersionMessage::has_start_partkey() const {
  return _internal_has_start_partkey();
}
inline void FileVersionMessage::clear_start_partkey() {
  start_partkey_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FileVersionMessage::_internal_start_partkey() const {
  return start_partkey_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FileVersionMessage::start_partkey() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FileVersionMessage.start_partkey)
  return _internal_start_partkey();
}
inline void FileVersionMessage::_internal_set_start_partkey(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  start_partkey_ = value;
}
inline void FileVersionMessage::set_start_partkey(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_start_partkey(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FileVersionMessage.start_partkey)
}

// optional uint32 end_partkey = 12 [default = 16777215];
inline bool FileVersionMessage::_internal_has_end_partkey() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool FileVersionMessage::has_end_partkey() const {
  return _internal_has_end_partkey();
}
inline void FileVersionMessage::clear_end_partkey() {
  end_partkey_ = 16777215u;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FileVersionMessage::_internal_end_partkey() const {
  return end_partkey_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FileVersionMessage::end_partkey() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FileVersionMessage.end_partkey)
  return _internal_end_partkey();
}
inline void FileVersionMessage::_internal_set_end_partkey(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00004000u;
  end_partkey_ = value;
}
inline void FileVersionMessage::set_end_partkey(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_end_partkey(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FileVersionMessage.end_partkey)
}

// optional bool is_partition = 13 [default = false];
inline bool FileVersionMessage::_internal_has_is_partition() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool FileVersionMessage::has_is_partition() const {
  return _internal_has_is_partition();
}
inline void FileVersionMessage::clear_is_partition() {
  is_partition_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool FileVersionMessage::_internal_is_partition() const {
  return is_partition_;
}
inline bool FileVersionMessage::is_partition() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FileVersionMessage.is_partition)
  return _internal_is_partition();
}
inline void FileVersionMessage::_internal_set_is_partition(bool value) {
  _has_bits_[0] |= 0x00000800u;
  is_partition_ = value;
}
inline void FileVersionMessage::set_is_partition(bool value) {
  _internal_set_is_partition(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FileVersionMessage.is_partition)
}

// optional string data_file_prefix = 14;
inline bool FileVersionMessage::_internal_has_data_file_prefix() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FileVersionMessage::has_data_file_prefix() const {
  return _internal_has_data_file_prefix();
}
inline void FileVersionMessage::clear_data_file_prefix() {
  data_file_prefix_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FileVersionMessage::data_file_prefix() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FileVersionMessage.data_file_prefix)
  return _internal_data_file_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileVersionMessage::set_data_file_prefix(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 data_file_prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.FileVersionMessage.data_file_prefix)
}
inline std::string* FileVersionMessage::mutable_data_file_prefix() {
  std::string* _s = _internal_mutable_data_file_prefix();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.FileVersionMessage.data_file_prefix)
  return _s;
}
inline const std::string& FileVersionMessage::_internal_data_file_prefix() const {
  return data_file_prefix_.Get();
}
inline void FileVersionMessage::_internal_set_data_file_prefix(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_file_prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileVersionMessage::_internal_mutable_data_file_prefix() {
  _has_bits_[0] |= 0x00000001u;
  return data_file_prefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileVersionMessage::release_data_file_prefix() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.FileVersionMessage.data_file_prefix)
  if (!_internal_has_data_file_prefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_file_prefix_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileVersionMessage::set_allocated_data_file_prefix(std::string* data_file_prefix) {
  if (data_file_prefix != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_file_prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_file_prefix,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.FileVersionMessage.data_file_prefix)
}

// optional bool head_reverse = 15 [default = false];
inline bool FileVersionMessage::_internal_has_head_reverse() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool FileVersionMessage::has_head_reverse() const {
  return _internal_has_head_reverse();
}
inline void FileVersionMessage::clear_head_reverse() {
  head_reverse_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool FileVersionMessage::_internal_head_reverse() const {
  return head_reverse_;
}
inline bool FileVersionMessage::head_reverse() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FileVersionMessage.head_reverse)
  return _internal_head_reverse();
}
inline void FileVersionMessage::_internal_set_head_reverse(bool value) {
  _has_bits_[0] |= 0x00001000u;
  head_reverse_ = value;
}
inline void FileVersionMessage::set_head_reverse(bool value) {
  _internal_set_head_reverse(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FileVersionMessage.head_reverse)
}

// optional bool version_empty = 16 [default = false];
inline bool FileVersionMessage::_internal_has_version_empty() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool FileVersionMessage::has_version_empty() const {
  return _internal_has_version_empty();
}
inline void FileVersionMessage::clear_version_empty() {
  version_empty_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool FileVersionMessage::_internal_version_empty() const {
  return version_empty_;
}
inline bool FileVersionMessage::version_empty() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.FileVersionMessage.version_empty)
  return _internal_version_empty();
}
inline void FileVersionMessage::_internal_set_version_empty(bool value) {
  _has_bits_[0] |= 0x00002000u;
  version_empty_ = value;
}
inline void FileVersionMessage::set_version_empty(bool value) {
  _internal_set_version_empty(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.FileVersionMessage.version_empty)
}

// -------------------------------------------------------------------

// PartitionPolicyMessage

// required uint32 part_granularity = 1 [default = 0];
inline bool PartitionPolicyMessage::_internal_has_part_granularity() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PartitionPolicyMessage::has_part_granularity() const {
  return _internal_has_part_granularity();
}
inline void PartitionPolicyMessage::clear_part_granularity() {
  part_granularity_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PartitionPolicyMessage::_internal_part_granularity() const {
  return part_granularity_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PartitionPolicyMessage::part_granularity() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionPolicyMessage.part_granularity)
  return _internal_part_granularity();
}
inline void PartitionPolicyMessage::_internal_set_part_granularity(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  part_granularity_ = value;
}
inline void PartitionPolicyMessage::set_part_granularity(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_part_granularity(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionPolicyMessage.part_granularity)
}

// optional uint32 first_partkey = 2 [default = 0];
inline bool PartitionPolicyMessage::_internal_has_first_partkey() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PartitionPolicyMessage::has_first_partkey() const {
  return _internal_has_first_partkey();
}
inline void PartitionPolicyMessage::clear_first_partkey() {
  first_partkey_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PartitionPolicyMessage::_internal_first_partkey() const {
  return first_partkey_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PartitionPolicyMessage::first_partkey() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.PartitionPolicyMessage.first_partkey)
  return _internal_first_partkey();
}
inline void PartitionPolicyMessage::_internal_set_first_partkey(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  first_partkey_ = value;
}
inline void PartitionPolicyMessage::set_first_partkey(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_first_partkey(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.PartitionPolicyMessage.first_partkey)
}

// -------------------------------------------------------------------

// BaseExpansionPolicyMessage

// required int32 min_version = 1;
inline bool BaseExpansionPolicyMessage::_internal_has_min_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BaseExpansionPolicyMessage::has_min_version() const {
  return _internal_has_min_version();
}
inline void BaseExpansionPolicyMessage::clear_min_version() {
  min_version_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BaseExpansionPolicyMessage::_internal_min_version() const {
  return min_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BaseExpansionPolicyMessage::min_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaseExpansionPolicyMessage.min_version)
  return _internal_min_version();
}
inline void BaseExpansionPolicyMessage::_internal_set_min_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  min_version_ = value;
}
inline void BaseExpansionPolicyMessage::set_min_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_min_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaseExpansionPolicyMessage.min_version)
}

// required int32 min_age = 2;
inline bool BaseExpansionPolicyMessage::_internal_has_min_age() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BaseExpansionPolicyMessage::has_min_age() const {
  return _internal_has_min_age();
}
inline void BaseExpansionPolicyMessage::clear_min_age() {
  min_age_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BaseExpansionPolicyMessage::_internal_min_age() const {
  return min_age_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BaseExpansionPolicyMessage::min_age() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaseExpansionPolicyMessage.min_age)
  return _internal_min_age();
}
inline void BaseExpansionPolicyMessage::_internal_set_min_age(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  min_age_ = value;
}
inline void BaseExpansionPolicyMessage::set_min_age(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_min_age(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaseExpansionPolicyMessage.min_age)
}

// required int32 max_version = 3;
inline bool BaseExpansionPolicyMessage::_internal_has_max_version() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BaseExpansionPolicyMessage::has_max_version() const {
  return _internal_has_max_version();
}
inline void BaseExpansionPolicyMessage::clear_max_version() {
  max_version_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BaseExpansionPolicyMessage::_internal_max_version() const {
  return max_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BaseExpansionPolicyMessage::max_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaseExpansionPolicyMessage.max_version)
  return _internal_max_version();
}
inline void BaseExpansionPolicyMessage::_internal_set_max_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  max_version_ = value;
}
inline void BaseExpansionPolicyMessage::set_max_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaseExpansionPolicyMessage.max_version)
}

// required int32 max_age = 4;
inline bool BaseExpansionPolicyMessage::_internal_has_max_age() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BaseExpansionPolicyMessage::has_max_age() const {
  return _internal_has_max_age();
}
inline void BaseExpansionPolicyMessage::clear_max_age() {
  max_age_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BaseExpansionPolicyMessage::_internal_max_age() const {
  return max_age_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BaseExpansionPolicyMessage::max_age() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaseExpansionPolicyMessage.max_age)
  return _internal_max_age();
}
inline void BaseExpansionPolicyMessage::_internal_set_max_age(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  max_age_ = value;
}
inline void BaseExpansionPolicyMessage::set_max_age(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_age(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaseExpansionPolicyMessage.max_age)
}

// optional int32 flush_be_count = 5;
inline bool BaseExpansionPolicyMessage::_internal_has_flush_be_count() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BaseExpansionPolicyMessage::has_flush_be_count() const {
  return _internal_has_flush_be_count();
}
inline void BaseExpansionPolicyMessage::clear_flush_be_count() {
  flush_be_count_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BaseExpansionPolicyMessage::_internal_flush_be_count() const {
  return flush_be_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BaseExpansionPolicyMessage::flush_be_count() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaseExpansionPolicyMessage.flush_be_count)
  return _internal_flush_be_count();
}
inline void BaseExpansionPolicyMessage::_internal_set_flush_be_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  flush_be_count_ = value;
}
inline void BaseExpansionPolicyMessage::set_flush_be_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_flush_be_count(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.BaseExpansionPolicyMessage.flush_be_count)
}

// optional .baikaldb.pb.PartitionPolicyMessage partition_policy = 6;
inline bool BaseExpansionPolicyMessage::_internal_has_partition_policy() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || partition_policy_ != nullptr);
  return value;
}
inline bool BaseExpansionPolicyMessage::has_partition_policy() const {
  return _internal_has_partition_policy();
}
inline void BaseExpansionPolicyMessage::clear_partition_policy() {
  if (partition_policy_ != nullptr) partition_policy_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::PartitionPolicyMessage& BaseExpansionPolicyMessage::_internal_partition_policy() const {
  const ::baikaldb::pb::PartitionPolicyMessage* p = partition_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::PartitionPolicyMessage&>(
      ::baikaldb::pb::_PartitionPolicyMessage_default_instance_);
}
inline const ::baikaldb::pb::PartitionPolicyMessage& BaseExpansionPolicyMessage::partition_policy() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.BaseExpansionPolicyMessage.partition_policy)
  return _internal_partition_policy();
}
inline void BaseExpansionPolicyMessage::unsafe_arena_set_allocated_partition_policy(
    ::baikaldb::pb::PartitionPolicyMessage* partition_policy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(partition_policy_);
  }
  partition_policy_ = partition_policy;
  if (partition_policy) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.BaseExpansionPolicyMessage.partition_policy)
}
inline ::baikaldb::pb::PartitionPolicyMessage* BaseExpansionPolicyMessage::release_partition_policy() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::PartitionPolicyMessage* temp = partition_policy_;
  partition_policy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::PartitionPolicyMessage* BaseExpansionPolicyMessage::unsafe_arena_release_partition_policy() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.BaseExpansionPolicyMessage.partition_policy)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::PartitionPolicyMessage* temp = partition_policy_;
  partition_policy_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::PartitionPolicyMessage* BaseExpansionPolicyMessage::_internal_mutable_partition_policy() {
  _has_bits_[0] |= 0x00000001u;
  if (partition_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::PartitionPolicyMessage>(GetArenaForAllocation());
    partition_policy_ = p;
  }
  return partition_policy_;
}
inline ::baikaldb::pb::PartitionPolicyMessage* BaseExpansionPolicyMessage::mutable_partition_policy() {
  ::baikaldb::pb::PartitionPolicyMessage* _msg = _internal_mutable_partition_policy();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.BaseExpansionPolicyMessage.partition_policy)
  return _msg;
}
inline void BaseExpansionPolicyMessage::set_allocated_partition_policy(::baikaldb::pb::PartitionPolicyMessage* partition_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete partition_policy_;
  }
  if (partition_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::PartitionPolicyMessage>::GetOwningArena(partition_policy);
    if (message_arena != submessage_arena) {
      partition_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partition_policy, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  partition_policy_ = partition_policy;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.BaseExpansionPolicyMessage.partition_policy)
}

// -------------------------------------------------------------------

// CumulativePolicyMessage

// optional uint32 trigger_to_create_cum = 1 [default = 3];
inline bool CumulativePolicyMessage::_internal_has_trigger_to_create_cum() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CumulativePolicyMessage::has_trigger_to_create_cum() const {
  return _internal_has_trigger_to_create_cum();
}
inline void CumulativePolicyMessage::clear_trigger_to_create_cum() {
  trigger_to_create_cum_ = 3u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CumulativePolicyMessage::_internal_trigger_to_create_cum() const {
  return trigger_to_create_cum_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CumulativePolicyMessage::trigger_to_create_cum() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CumulativePolicyMessage.trigger_to_create_cum)
  return _internal_trigger_to_create_cum();
}
inline void CumulativePolicyMessage::_internal_set_trigger_to_create_cum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  trigger_to_create_cum_ = value;
}
inline void CumulativePolicyMessage::set_trigger_to_create_cum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_trigger_to_create_cum(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CumulativePolicyMessage.trigger_to_create_cum)
}

// optional uint32 version_gap_of_sparse_cum = 2 [default = 5];
inline bool CumulativePolicyMessage::_internal_has_version_gap_of_sparse_cum() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CumulativePolicyMessage::has_version_gap_of_sparse_cum() const {
  return _internal_has_version_gap_of_sparse_cum();
}
inline void CumulativePolicyMessage::clear_version_gap_of_sparse_cum() {
  version_gap_of_sparse_cum_ = 5u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CumulativePolicyMessage::_internal_version_gap_of_sparse_cum() const {
  return version_gap_of_sparse_cum_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CumulativePolicyMessage::version_gap_of_sparse_cum() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CumulativePolicyMessage.version_gap_of_sparse_cum)
  return _internal_version_gap_of_sparse_cum();
}
inline void CumulativePolicyMessage::_internal_set_version_gap_of_sparse_cum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  version_gap_of_sparse_cum_ = value;
}
inline void CumulativePolicyMessage::set_version_gap_of_sparse_cum(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_version_gap_of_sparse_cum(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CumulativePolicyMessage.version_gap_of_sparse_cum)
}

// optional int32 max_cumulative_version_distance = 3 [default = -1];
inline bool CumulativePolicyMessage::_internal_has_max_cumulative_version_distance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CumulativePolicyMessage::has_max_cumulative_version_distance() const {
  return _internal_has_max_cumulative_version_distance();
}
inline void CumulativePolicyMessage::clear_max_cumulative_version_distance() {
  max_cumulative_version_distance_ = -1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CumulativePolicyMessage::_internal_max_cumulative_version_distance() const {
  return max_cumulative_version_distance_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CumulativePolicyMessage::max_cumulative_version_distance() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.CumulativePolicyMessage.max_cumulative_version_distance)
  return _internal_max_cumulative_version_distance();
}
inline void CumulativePolicyMessage::_internal_set_max_cumulative_version_distance(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  max_cumulative_version_distance_ = value;
}
inline void CumulativePolicyMessage::set_max_cumulative_version_distance(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_cumulative_version_distance(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.CumulativePolicyMessage.max_cumulative_version_distance)
}

// -------------------------------------------------------------------

// ColumnMessage

// required string name = 1;
inline bool ColumnMessage::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ColumnMessage::has_name() const {
  return _internal_has_name();
}
inline void ColumnMessage::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ColumnMessage::name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ColumnMessage.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnMessage::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ColumnMessage.name)
}
inline std::string* ColumnMessage::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ColumnMessage.name)
  return _s;
}
inline const std::string& ColumnMessage::_internal_name() const {
  return name_.Get();
}
inline void ColumnMessage::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ColumnMessage::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ColumnMessage::release_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ColumnMessage.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ColumnMessage::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ColumnMessage.name)
}

// required string type = 2;
inline bool ColumnMessage::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ColumnMessage::has_type() const {
  return _internal_has_type();
}
inline void ColumnMessage::clear_type() {
  type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ColumnMessage::type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ColumnMessage.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnMessage::set_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ColumnMessage.type)
}
inline std::string* ColumnMessage::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ColumnMessage.type)
  return _s;
}
inline const std::string& ColumnMessage::_internal_type() const {
  return type_.Get();
}
inline void ColumnMessage::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ColumnMessage::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000002u;
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ColumnMessage::release_type() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ColumnMessage.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ColumnMessage::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ColumnMessage.type)
}

// required string aggregation = 3;
inline bool ColumnMessage::_internal_has_aggregation() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ColumnMessage::has_aggregation() const {
  return _internal_has_aggregation();
}
inline void ColumnMessage::clear_aggregation() {
  aggregation_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ColumnMessage::aggregation() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ColumnMessage.aggregation)
  return _internal_aggregation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnMessage::set_aggregation(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 aggregation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ColumnMessage.aggregation)
}
inline std::string* ColumnMessage::mutable_aggregation() {
  std::string* _s = _internal_mutable_aggregation();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ColumnMessage.aggregation)
  return _s;
}
inline const std::string& ColumnMessage::_internal_aggregation() const {
  return aggregation_.Get();
}
inline void ColumnMessage::_internal_set_aggregation(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  aggregation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ColumnMessage::_internal_mutable_aggregation() {
  _has_bits_[0] |= 0x00000004u;
  return aggregation_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ColumnMessage::release_aggregation() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ColumnMessage.aggregation)
  if (!_internal_has_aggregation()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return aggregation_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ColumnMessage::set_allocated_aggregation(std::string* aggregation) {
  if (aggregation != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  aggregation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), aggregation,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ColumnMessage.aggregation)
}

// required uint32 length = 4;
inline bool ColumnMessage::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ColumnMessage::has_length() const {
  return _internal_has_length();
}
inline void ColumnMessage::clear_length() {
  length_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ColumnMessage::_internal_length() const {
  return length_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ColumnMessage::length() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ColumnMessage.length)
  return _internal_length();
}
inline void ColumnMessage::_internal_set_length(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  length_ = value;
}
inline void ColumnMessage::set_length(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ColumnMessage.length)
}

// required bool is_key = 5;
inline bool ColumnMessage::_internal_has_is_key() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ColumnMessage::has_is_key() const {
  return _internal_has_is_key();
}
inline void ColumnMessage::clear_is_key() {
  is_key_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ColumnMessage::_internal_is_key() const {
  return is_key_;
}
inline bool ColumnMessage::is_key() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ColumnMessage.is_key)
  return _internal_is_key();
}
inline void ColumnMessage::_internal_set_is_key(bool value) {
  _has_bits_[0] |= 0x00000040u;
  is_key_ = value;
}
inline void ColumnMessage::set_is_key(bool value) {
  _internal_set_is_key(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.ColumnMessage.is_key)
}

// optional string default_value = 6;
inline bool ColumnMessage::_internal_has_default_value() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ColumnMessage::has_default_value() const {
  return _internal_has_default_value();
}
inline void ColumnMessage::clear_default_value() {
  default_value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ColumnMessage::default_value() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ColumnMessage.default_value)
  return _internal_default_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnMessage::set_default_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 default_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ColumnMessage.default_value)
}
inline std::string* ColumnMessage::mutable_default_value() {
  std::string* _s = _internal_mutable_default_value();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ColumnMessage.default_value)
  return _s;
}
inline const std::string& ColumnMessage::_internal_default_value() const {
  return default_value_.Get();
}
inline void ColumnMessage::_internal_set_default_value(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  default_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ColumnMessage::_internal_mutable_default_value() {
  _has_bits_[0] |= 0x00000008u;
  return default_value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ColumnMessage::release_default_value() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ColumnMessage.default_value)
  if (!_internal_has_default_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return default_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ColumnMessage::set_allocated_default_value(std::string* default_value) {
  if (default_value != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  default_value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), default_value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ColumnMessage.default_value)
}

// optional string referenced_column = 7;
inline bool ColumnMessage::_internal_has_referenced_column() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ColumnMessage::has_referenced_column() const {
  return _internal_has_referenced_column();
}
inline void ColumnMessage::clear_referenced_column() {
  referenced_column_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ColumnMessage::referenced_column() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.ColumnMessage.referenced_column)
  return _internal_referenced_column();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnMessage::set_referenced_column(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 referenced_column_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.ColumnMessage.referenced_column)
}
inline std::string* ColumnMessage::mutable_referenced_column() {
  std::string* _s = _internal_mutable_referenced_column();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.ColumnMessage.referenced_column)
  return _s;
}
inline const std::string& ColumnMessage::_internal_referenced_column() const {
  return referenced_column_.Get();
}
inline void ColumnMessage::_internal_set_referenced_column(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  referenced_column_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ColumnMessage::_internal_mutable_referenced_column() {
  _has_bits_[0] |= 0x00000010u;
  return referenced_column_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ColumnMessage::release_referenced_column() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.ColumnMessage.referenced_column)
  if (!_internal_has_referenced_column()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return referenced_column_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ColumnMessage::set_allocated_referenced_column(std::string* referenced_column) {
  if (referenced_column != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  referenced_column_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), referenced_column,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.ColumnMessage.referenced_column)
}

// -------------------------------------------------------------------

// SchemaChangeStatusMessage

// required string related_table_name = 1;
inline bool SchemaChangeStatusMessage::_internal_has_related_table_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SchemaChangeStatusMessage::has_related_table_name() const {
  return _internal_has_related_table_name();
}
inline void SchemaChangeStatusMessage::clear_related_table_name() {
  related_table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchemaChangeStatusMessage::related_table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaChangeStatusMessage.related_table_name)
  return _internal_related_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaChangeStatusMessage::set_related_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 related_table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaChangeStatusMessage.related_table_name)
}
inline std::string* SchemaChangeStatusMessage::mutable_related_table_name() {
  std::string* _s = _internal_mutable_related_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaChangeStatusMessage.related_table_name)
  return _s;
}
inline const std::string& SchemaChangeStatusMessage::_internal_related_table_name() const {
  return related_table_name_.Get();
}
inline void SchemaChangeStatusMessage::_internal_set_related_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  related_table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaChangeStatusMessage::_internal_mutable_related_table_name() {
  _has_bits_[0] |= 0x00000001u;
  return related_table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaChangeStatusMessage::release_related_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaChangeStatusMessage.related_table_name)
  if (!_internal_has_related_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return related_table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaChangeStatusMessage::set_allocated_related_table_name(std::string* related_table_name) {
  if (related_table_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  related_table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), related_table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaChangeStatusMessage.related_table_name)
}

// required string related_index_name = 2;
inline bool SchemaChangeStatusMessage::_internal_has_related_index_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SchemaChangeStatusMessage::has_related_index_name() const {
  return _internal_has_related_index_name();
}
inline void SchemaChangeStatusMessage::clear_related_index_name() {
  related_index_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SchemaChangeStatusMessage::related_index_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaChangeStatusMessage.related_index_name)
  return _internal_related_index_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaChangeStatusMessage::set_related_index_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 related_index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaChangeStatusMessage.related_index_name)
}
inline std::string* SchemaChangeStatusMessage::mutable_related_index_name() {
  std::string* _s = _internal_mutable_related_index_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaChangeStatusMessage.related_index_name)
  return _s;
}
inline const std::string& SchemaChangeStatusMessage::_internal_related_index_name() const {
  return related_index_name_.Get();
}
inline void SchemaChangeStatusMessage::_internal_set_related_index_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  related_index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaChangeStatusMessage::_internal_mutable_related_index_name() {
  _has_bits_[0] |= 0x00000002u;
  return related_index_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaChangeStatusMessage::release_related_index_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.SchemaChangeStatusMessage.related_index_name)
  if (!_internal_has_related_index_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return related_index_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaChangeStatusMessage::set_allocated_related_index_name(std::string* related_index_name) {
  if (related_index_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  related_index_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), related_index_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.SchemaChangeStatusMessage.related_index_name)
}

// required int32 related_schema_hash = 3;
inline bool SchemaChangeStatusMessage::_internal_has_related_schema_hash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SchemaChangeStatusMessage::has_related_schema_hash() const {
  return _internal_has_related_schema_hash();
}
inline void SchemaChangeStatusMessage::clear_related_schema_hash() {
  related_schema_hash_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaChangeStatusMessage::_internal_related_schema_hash() const {
  return related_schema_hash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaChangeStatusMessage::related_schema_hash() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaChangeStatusMessage.related_schema_hash)
  return _internal_related_schema_hash();
}
inline void SchemaChangeStatusMessage::_internal_set_related_schema_hash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  related_schema_hash_ = value;
}
inline void SchemaChangeStatusMessage::set_related_schema_hash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_related_schema_hash(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaChangeStatusMessage.related_schema_hash)
}

// repeated .baikaldb.pb.FileVersionMessage versions_to_be_changed = 4;
inline int SchemaChangeStatusMessage::_internal_versions_to_be_changed_size() const {
  return versions_to_be_changed_.size();
}
inline int SchemaChangeStatusMessage::versions_to_be_changed_size() const {
  return _internal_versions_to_be_changed_size();
}
inline void SchemaChangeStatusMessage::clear_versions_to_be_changed() {
  versions_to_be_changed_.Clear();
}
inline ::baikaldb::pb::FileVersionMessage* SchemaChangeStatusMessage::mutable_versions_to_be_changed(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.SchemaChangeStatusMessage.versions_to_be_changed)
  return versions_to_be_changed_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FileVersionMessage >*
SchemaChangeStatusMessage::mutable_versions_to_be_changed() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.SchemaChangeStatusMessage.versions_to_be_changed)
  return &versions_to_be_changed_;
}
inline const ::baikaldb::pb::FileVersionMessage& SchemaChangeStatusMessage::_internal_versions_to_be_changed(int index) const {
  return versions_to_be_changed_.Get(index);
}
inline const ::baikaldb::pb::FileVersionMessage& SchemaChangeStatusMessage::versions_to_be_changed(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaChangeStatusMessage.versions_to_be_changed)
  return _internal_versions_to_be_changed(index);
}
inline ::baikaldb::pb::FileVersionMessage* SchemaChangeStatusMessage::_internal_add_versions_to_be_changed() {
  return versions_to_be_changed_.Add();
}
inline ::baikaldb::pb::FileVersionMessage* SchemaChangeStatusMessage::add_versions_to_be_changed() {
  ::baikaldb::pb::FileVersionMessage* _add = _internal_add_versions_to_be_changed();
  // @@protoc_insertion_point(field_add:baikaldb.pb.SchemaChangeStatusMessage.versions_to_be_changed)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::FileVersionMessage >&
SchemaChangeStatusMessage::versions_to_be_changed() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.SchemaChangeStatusMessage.versions_to_be_changed)
  return versions_to_be_changed_;
}

// required int32 schema_change_type = 5;
inline bool SchemaChangeStatusMessage::_internal_has_schema_change_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SchemaChangeStatusMessage::has_schema_change_type() const {
  return _internal_has_schema_change_type();
}
inline void SchemaChangeStatusMessage::clear_schema_change_type() {
  schema_change_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaChangeStatusMessage::_internal_schema_change_type() const {
  return schema_change_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SchemaChangeStatusMessage::schema_change_type() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.SchemaChangeStatusMessage.schema_change_type)
  return _internal_schema_change_type();
}
inline void SchemaChangeStatusMessage::_internal_set_schema_change_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  schema_change_type_ = value;
}
inline void SchemaChangeStatusMessage::set_schema_change_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_schema_change_type(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.SchemaChangeStatusMessage.schema_change_type)
}

// -------------------------------------------------------------------

// DeleteDataPolicyMessage

// optional int32 open_flag = 1 [default = 0];
inline bool DeleteDataPolicyMessage::_internal_has_open_flag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeleteDataPolicyMessage::has_open_flag() const {
  return _internal_has_open_flag();
}
inline void DeleteDataPolicyMessage::clear_open_flag() {
  open_flag_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeleteDataPolicyMessage::_internal_open_flag() const {
  return open_flag_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeleteDataPolicyMessage::open_flag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DeleteDataPolicyMessage.open_flag)
  return _internal_open_flag();
}
inline void DeleteDataPolicyMessage::_internal_set_open_flag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  open_flag_ = value;
}
inline void DeleteDataPolicyMessage::set_open_flag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_open_flag(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DeleteDataPolicyMessage.open_flag)
}

// optional .baikaldb.pb.DelteCondMessage expire_cond = 2;
inline bool DeleteDataPolicyMessage::_internal_has_expire_cond() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || expire_cond_ != nullptr);
  return value;
}
inline bool DeleteDataPolicyMessage::has_expire_cond() const {
  return _internal_has_expire_cond();
}
inline void DeleteDataPolicyMessage::clear_expire_cond() {
  if (expire_cond_ != nullptr) expire_cond_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::baikaldb::pb::DelteCondMessage& DeleteDataPolicyMessage::_internal_expire_cond() const {
  const ::baikaldb::pb::DelteCondMessage* p = expire_cond_;
  return p != nullptr ? *p : reinterpret_cast<const ::baikaldb::pb::DelteCondMessage&>(
      ::baikaldb::pb::_DelteCondMessage_default_instance_);
}
inline const ::baikaldb::pb::DelteCondMessage& DeleteDataPolicyMessage::expire_cond() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DeleteDataPolicyMessage.expire_cond)
  return _internal_expire_cond();
}
inline void DeleteDataPolicyMessage::unsafe_arena_set_allocated_expire_cond(
    ::baikaldb::pb::DelteCondMessage* expire_cond) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expire_cond_);
  }
  expire_cond_ = expire_cond;
  if (expire_cond) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:baikaldb.pb.DeleteDataPolicyMessage.expire_cond)
}
inline ::baikaldb::pb::DelteCondMessage* DeleteDataPolicyMessage::release_expire_cond() {
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::DelteCondMessage* temp = expire_cond_;
  expire_cond_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::baikaldb::pb::DelteCondMessage* DeleteDataPolicyMessage::unsafe_arena_release_expire_cond() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DeleteDataPolicyMessage.expire_cond)
  _has_bits_[0] &= ~0x00000001u;
  ::baikaldb::pb::DelteCondMessage* temp = expire_cond_;
  expire_cond_ = nullptr;
  return temp;
}
inline ::baikaldb::pb::DelteCondMessage* DeleteDataPolicyMessage::_internal_mutable_expire_cond() {
  _has_bits_[0] |= 0x00000001u;
  if (expire_cond_ == nullptr) {
    auto* p = CreateMaybeMessage<::baikaldb::pb::DelteCondMessage>(GetArenaForAllocation());
    expire_cond_ = p;
  }
  return expire_cond_;
}
inline ::baikaldb::pb::DelteCondMessage* DeleteDataPolicyMessage::mutable_expire_cond() {
  ::baikaldb::pb::DelteCondMessage* _msg = _internal_mutable_expire_cond();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DeleteDataPolicyMessage.expire_cond)
  return _msg;
}
inline void DeleteDataPolicyMessage::set_allocated_expire_cond(::baikaldb::pb::DelteCondMessage* expire_cond) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete expire_cond_;
  }
  if (expire_cond) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::baikaldb::pb::DelteCondMessage>::GetOwningArena(expire_cond);
    if (message_arena != submessage_arena) {
      expire_cond = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expire_cond, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  expire_cond_ = expire_cond;
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DeleteDataPolicyMessage.expire_cond)
}

// repeated .baikaldb.pb.DelteCondMessage delete_conds = 3;
inline int DeleteDataPolicyMessage::_internal_delete_conds_size() const {
  return delete_conds_.size();
}
inline int DeleteDataPolicyMessage::delete_conds_size() const {
  return _internal_delete_conds_size();
}
inline void DeleteDataPolicyMessage::clear_delete_conds() {
  delete_conds_.Clear();
}
inline ::baikaldb::pb::DelteCondMessage* DeleteDataPolicyMessage::mutable_delete_conds(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DeleteDataPolicyMessage.delete_conds)
  return delete_conds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DelteCondMessage >*
DeleteDataPolicyMessage::mutable_delete_conds() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.DeleteDataPolicyMessage.delete_conds)
  return &delete_conds_;
}
inline const ::baikaldb::pb::DelteCondMessage& DeleteDataPolicyMessage::_internal_delete_conds(int index) const {
  return delete_conds_.Get(index);
}
inline const ::baikaldb::pb::DelteCondMessage& DeleteDataPolicyMessage::delete_conds(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DeleteDataPolicyMessage.delete_conds)
  return _internal_delete_conds(index);
}
inline ::baikaldb::pb::DelteCondMessage* DeleteDataPolicyMessage::_internal_add_delete_conds() {
  return delete_conds_.Add();
}
inline ::baikaldb::pb::DelteCondMessage* DeleteDataPolicyMessage::add_delete_conds() {
  ::baikaldb::pb::DelteCondMessage* _add = _internal_add_delete_conds();
  // @@protoc_insertion_point(field_add:baikaldb.pb.DeleteDataPolicyMessage.delete_conds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DelteCondMessage >&
DeleteDataPolicyMessage::delete_conds() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.DeleteDataPolicyMessage.delete_conds)
  return delete_conds_;
}

// repeated .baikaldb.pb.DelteCondMessage range_conds = 4;
inline int DeleteDataPolicyMessage::_internal_range_conds_size() const {
  return range_conds_.size();
}
inline int DeleteDataPolicyMessage::range_conds_size() const {
  return _internal_range_conds_size();
}
inline void DeleteDataPolicyMessage::clear_range_conds() {
  range_conds_.Clear();
}
inline ::baikaldb::pb::DelteCondMessage* DeleteDataPolicyMessage::mutable_range_conds(int index) {
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DeleteDataPolicyMessage.range_conds)
  return range_conds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DelteCondMessage >*
DeleteDataPolicyMessage::mutable_range_conds() {
  // @@protoc_insertion_point(field_mutable_list:baikaldb.pb.DeleteDataPolicyMessage.range_conds)
  return &range_conds_;
}
inline const ::baikaldb::pb::DelteCondMessage& DeleteDataPolicyMessage::_internal_range_conds(int index) const {
  return range_conds_.Get(index);
}
inline const ::baikaldb::pb::DelteCondMessage& DeleteDataPolicyMessage::range_conds(int index) const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DeleteDataPolicyMessage.range_conds)
  return _internal_range_conds(index);
}
inline ::baikaldb::pb::DelteCondMessage* DeleteDataPolicyMessage::_internal_add_range_conds() {
  return range_conds_.Add();
}
inline ::baikaldb::pb::DelteCondMessage* DeleteDataPolicyMessage::add_range_conds() {
  ::baikaldb::pb::DelteCondMessage* _add = _internal_add_range_conds();
  // @@protoc_insertion_point(field_add:baikaldb.pb.DeleteDataPolicyMessage.range_conds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::baikaldb::pb::DelteCondMessage >&
DeleteDataPolicyMessage::range_conds() const {
  // @@protoc_insertion_point(field_list:baikaldb.pb.DeleteDataPolicyMessage.range_conds)
  return range_conds_;
}

// optional int32 expire_cond_open_flag = 5 [default = 0];
inline bool DeleteDataPolicyMessage::_internal_has_expire_cond_open_flag() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeleteDataPolicyMessage::has_expire_cond_open_flag() const {
  return _internal_has_expire_cond_open_flag();
}
inline void DeleteDataPolicyMessage::clear_expire_cond_open_flag() {
  expire_cond_open_flag_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeleteDataPolicyMessage::_internal_expire_cond_open_flag() const {
  return expire_cond_open_flag_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeleteDataPolicyMessage::expire_cond_open_flag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DeleteDataPolicyMessage.expire_cond_open_flag)
  return _internal_expire_cond_open_flag();
}
inline void DeleteDataPolicyMessage::_internal_set_expire_cond_open_flag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  expire_cond_open_flag_ = value;
}
inline void DeleteDataPolicyMessage::set_expire_cond_open_flag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_expire_cond_open_flag(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DeleteDataPolicyMessage.expire_cond_open_flag)
}

// optional int32 delete_cond_open_flag = 6 [default = 0];
inline bool DeleteDataPolicyMessage::_internal_has_delete_cond_open_flag() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeleteDataPolicyMessage::has_delete_cond_open_flag() const {
  return _internal_has_delete_cond_open_flag();
}
inline void DeleteDataPolicyMessage::clear_delete_cond_open_flag() {
  delete_cond_open_flag_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeleteDataPolicyMessage::_internal_delete_cond_open_flag() const {
  return delete_cond_open_flag_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeleteDataPolicyMessage::delete_cond_open_flag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DeleteDataPolicyMessage.delete_cond_open_flag)
  return _internal_delete_cond_open_flag();
}
inline void DeleteDataPolicyMessage::_internal_set_delete_cond_open_flag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  delete_cond_open_flag_ = value;
}
inline void DeleteDataPolicyMessage::set_delete_cond_open_flag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_delete_cond_open_flag(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DeleteDataPolicyMessage.delete_cond_open_flag)
}

// optional int32 range_cond_open_flag = 7 [default = 0];
inline bool DeleteDataPolicyMessage::_internal_has_range_cond_open_flag() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DeleteDataPolicyMessage::has_range_cond_open_flag() const {
  return _internal_has_range_cond_open_flag();
}
inline void DeleteDataPolicyMessage::clear_range_cond_open_flag() {
  range_cond_open_flag_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeleteDataPolicyMessage::_internal_range_cond_open_flag() const {
  return range_cond_open_flag_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeleteDataPolicyMessage::range_cond_open_flag() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DeleteDataPolicyMessage.range_cond_open_flag)
  return _internal_range_cond_open_flag();
}
inline void DeleteDataPolicyMessage::_internal_set_range_cond_open_flag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  range_cond_open_flag_ = value;
}
inline void DeleteDataPolicyMessage::set_range_cond_open_flag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_range_cond_open_flag(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DeleteDataPolicyMessage.range_cond_open_flag)
}

// optional int32 latest_edition = 8 [default = 0];
inline bool DeleteDataPolicyMessage::_internal_has_latest_edition() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DeleteDataPolicyMessage::has_latest_edition() const {
  return _internal_has_latest_edition();
}
inline void DeleteDataPolicyMessage::clear_latest_edition() {
  latest_edition_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeleteDataPolicyMessage::_internal_latest_edition() const {
  return latest_edition_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeleteDataPolicyMessage::latest_edition() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DeleteDataPolicyMessage.latest_edition)
  return _internal_latest_edition();
}
inline void DeleteDataPolicyMessage::_internal_set_latest_edition(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  latest_edition_ = value;
}
inline void DeleteDataPolicyMessage::set_latest_edition(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_latest_edition(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DeleteDataPolicyMessage.latest_edition)
}

// optional int32 be_edition = 9 [default = 0];
inline bool DeleteDataPolicyMessage::_internal_has_be_edition() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DeleteDataPolicyMessage::has_be_edition() const {
  return _internal_has_be_edition();
}
inline void DeleteDataPolicyMessage::clear_be_edition() {
  be_edition_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeleteDataPolicyMessage::_internal_be_edition() const {
  return be_edition_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeleteDataPolicyMessage::be_edition() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DeleteDataPolicyMessage.be_edition)
  return _internal_be_edition();
}
inline void DeleteDataPolicyMessage::_internal_set_be_edition(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  be_edition_ = value;
}
inline void DeleteDataPolicyMessage::set_be_edition(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_be_edition(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.DeleteDataPolicyMessage.be_edition)
}

// -------------------------------------------------------------------

// DelteCondMessage

// required string field_name = 1;
inline bool DelteCondMessage::_internal_has_field_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DelteCondMessage::has_field_name() const {
  return _internal_has_field_name();
}
inline void DelteCondMessage::clear_field_name() {
  field_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DelteCondMessage::field_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DelteCondMessage.field_name)
  return _internal_field_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelteCondMessage::set_field_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 field_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DelteCondMessage.field_name)
}
inline std::string* DelteCondMessage::mutable_field_name() {
  std::string* _s = _internal_mutable_field_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DelteCondMessage.field_name)
  return _s;
}
inline const std::string& DelteCondMessage::_internal_field_name() const {
  return field_name_.Get();
}
inline void DelteCondMessage::_internal_set_field_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  field_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DelteCondMessage::_internal_mutable_field_name() {
  _has_bits_[0] |= 0x00000001u;
  return field_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DelteCondMessage::release_field_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DelteCondMessage.field_name)
  if (!_internal_has_field_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return field_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DelteCondMessage::set_allocated_field_name(std::string* field_name) {
  if (field_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  field_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), field_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DelteCondMessage.field_name)
}

// required string range = 2;
inline bool DelteCondMessage::_internal_has_range() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DelteCondMessage::has_range() const {
  return _internal_has_range();
}
inline void DelteCondMessage::clear_range() {
  range_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DelteCondMessage::range() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DelteCondMessage.range)
  return _internal_range();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelteCondMessage::set_range(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 range_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DelteCondMessage.range)
}
inline std::string* DelteCondMessage::mutable_range() {
  std::string* _s = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DelteCondMessage.range)
  return _s;
}
inline const std::string& DelteCondMessage::_internal_range() const {
  return range_.Get();
}
inline void DelteCondMessage::_internal_set_range(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  range_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DelteCondMessage::_internal_mutable_range() {
  _has_bits_[0] |= 0x00000002u;
  return range_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DelteCondMessage::release_range() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DelteCondMessage.range)
  if (!_internal_has_range()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return range_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DelteCondMessage::set_allocated_range(std::string* range) {
  if (range != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  range_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), range,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DelteCondMessage.range)
}

// required string value = 3;
inline bool DelteCondMessage::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DelteCondMessage::has_value() const {
  return _internal_has_value();
}
inline void DelteCondMessage::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DelteCondMessage::value() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.DelteCondMessage.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DelteCondMessage::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.DelteCondMessage.value)
}
inline std::string* DelteCondMessage::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.DelteCondMessage.value)
  return _s;
}
inline const std::string& DelteCondMessage::_internal_value() const {
  return value_.Get();
}
inline void DelteCondMessage::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DelteCondMessage::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000004u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DelteCondMessage::release_value() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.DelteCondMessage.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DelteCondMessage::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.DelteCondMessage.value)
}

// -------------------------------------------------------------------

// TierStoragePolicyMessage

// optional bool allow_delta_ssd = 1 [default = false];
inline bool TierStoragePolicyMessage::_internal_has_allow_delta_ssd() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TierStoragePolicyMessage::has_allow_delta_ssd() const {
  return _internal_has_allow_delta_ssd();
}
inline void TierStoragePolicyMessage::clear_allow_delta_ssd() {
  allow_delta_ssd_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool TierStoragePolicyMessage::_internal_allow_delta_ssd() const {
  return allow_delta_ssd_;
}
inline bool TierStoragePolicyMessage::allow_delta_ssd() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TierStoragePolicyMessage.allow_delta_ssd)
  return _internal_allow_delta_ssd();
}
inline void TierStoragePolicyMessage::_internal_set_allow_delta_ssd(bool value) {
  _has_bits_[0] |= 0x00000001u;
  allow_delta_ssd_ = value;
}
inline void TierStoragePolicyMessage::set_allow_delta_ssd(bool value) {
  _internal_set_allow_delta_ssd(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TierStoragePolicyMessage.allow_delta_ssd)
}

// optional int32 ssd_days = 2 [default = 0];
inline bool TierStoragePolicyMessage::_internal_has_ssd_days() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TierStoragePolicyMessage::has_ssd_days() const {
  return _internal_has_ssd_days();
}
inline void TierStoragePolicyMessage::clear_ssd_days() {
  ssd_days_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TierStoragePolicyMessage::_internal_ssd_days() const {
  return ssd_days_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TierStoragePolicyMessage::ssd_days() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TierStoragePolicyMessage.ssd_days)
  return _internal_ssd_days();
}
inline void TierStoragePolicyMessage::_internal_set_ssd_days(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  ssd_days_ = value;
}
inline void TierStoragePolicyMessage::set_ssd_days(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ssd_days(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TierStoragePolicyMessage.ssd_days)
}

// optional int32 afs_days = 3 [default = 0];
inline bool TierStoragePolicyMessage::_internal_has_afs_days() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TierStoragePolicyMessage::has_afs_days() const {
  return _internal_has_afs_days();
}
inline void TierStoragePolicyMessage::clear_afs_days() {
  afs_days_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TierStoragePolicyMessage::_internal_afs_days() const {
  return afs_days_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TierStoragePolicyMessage::afs_days() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.TierStoragePolicyMessage.afs_days)
  return _internal_afs_days();
}
inline void TierStoragePolicyMessage::_internal_set_afs_days(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  afs_days_ = value;
}
inline void TierStoragePolicyMessage::set_afs_days(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_afs_days(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.TierStoragePolicyMessage.afs_days)
}

// -------------------------------------------------------------------

// OLAPDataHeaderMessage

// required string signature = 1;
inline bool OLAPDataHeaderMessage::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OLAPDataHeaderMessage::has_signature() const {
  return _internal_has_signature();
}
inline void OLAPDataHeaderMessage::clear_signature() {
  signature_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OLAPDataHeaderMessage::signature() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPDataHeaderMessage.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OLAPDataHeaderMessage::set_signature(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPDataHeaderMessage.signature)
}
inline std::string* OLAPDataHeaderMessage::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPDataHeaderMessage.signature)
  return _s;
}
inline const std::string& OLAPDataHeaderMessage::_internal_signature() const {
  return signature_.Get();
}
inline void OLAPDataHeaderMessage::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OLAPDataHeaderMessage::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OLAPDataHeaderMessage::release_signature() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OLAPDataHeaderMessage.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OLAPDataHeaderMessage::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OLAPDataHeaderMessage.signature)
}

// required uint32 segment = 2;
inline bool OLAPDataHeaderMessage::_internal_has_segment() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OLAPDataHeaderMessage::has_segment() const {
  return _internal_has_segment();
}
inline void OLAPDataHeaderMessage::clear_segment() {
  segment_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OLAPDataHeaderMessage::_internal_segment() const {
  return segment_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OLAPDataHeaderMessage::segment() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPDataHeaderMessage.segment)
  return _internal_segment();
}
inline void OLAPDataHeaderMessage::_internal_set_segment(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  segment_ = value;
}
inline void OLAPDataHeaderMessage::set_segment(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_segment(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPDataHeaderMessage.segment)
}

// -------------------------------------------------------------------

// OLAPIndexHeaderMessage

// required string signature = 1;
inline bool OLAPIndexHeaderMessage::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OLAPIndexHeaderMessage::has_signature() const {
  return _internal_has_signature();
}
inline void OLAPIndexHeaderMessage::clear_signature() {
  signature_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OLAPIndexHeaderMessage::signature() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPIndexHeaderMessage.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OLAPIndexHeaderMessage::set_signature(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPIndexHeaderMessage.signature)
}
inline std::string* OLAPIndexHeaderMessage::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPIndexHeaderMessage.signature)
  return _s;
}
inline const std::string& OLAPIndexHeaderMessage::_internal_signature() const {
  return signature_.Get();
}
inline void OLAPIndexHeaderMessage::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OLAPIndexHeaderMessage::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OLAPIndexHeaderMessage::release_signature() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OLAPIndexHeaderMessage.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OLAPIndexHeaderMessage::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OLAPIndexHeaderMessage.signature)
}

// required string table_name = 2;
inline bool OLAPIndexHeaderMessage::_internal_has_table_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OLAPIndexHeaderMessage::has_table_name() const {
  return _internal_has_table_name();
}
inline void OLAPIndexHeaderMessage::clear_table_name() {
  table_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OLAPIndexHeaderMessage::table_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPIndexHeaderMessage.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OLAPIndexHeaderMessage::set_table_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPIndexHeaderMessage.table_name)
}
inline std::string* OLAPIndexHeaderMessage::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPIndexHeaderMessage.table_name)
  return _s;
}
inline const std::string& OLAPIndexHeaderMessage::_internal_table_name() const {
  return table_name_.Get();
}
inline void OLAPIndexHeaderMessage::_internal_set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  table_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OLAPIndexHeaderMessage::_internal_mutable_table_name() {
  _has_bits_[0] |= 0x00000002u;
  return table_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OLAPIndexHeaderMessage::release_table_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OLAPIndexHeaderMessage.table_name)
  if (!_internal_has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return table_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OLAPIndexHeaderMessage::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  table_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OLAPIndexHeaderMessage.table_name)
}

// required string index_name = 3;
inline bool OLAPIndexHeaderMessage::_internal_has_index_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OLAPIndexHeaderMessage::has_index_name() const {
  return _internal_has_index_name();
}
inline void OLAPIndexHeaderMessage::clear_index_name() {
  index_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& OLAPIndexHeaderMessage::index_name() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPIndexHeaderMessage.index_name)
  return _internal_index_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OLAPIndexHeaderMessage::set_index_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPIndexHeaderMessage.index_name)
}
inline std::string* OLAPIndexHeaderMessage::mutable_index_name() {
  std::string* _s = _internal_mutable_index_name();
  // @@protoc_insertion_point(field_mutable:baikaldb.pb.OLAPIndexHeaderMessage.index_name)
  return _s;
}
inline const std::string& OLAPIndexHeaderMessage::_internal_index_name() const {
  return index_name_.Get();
}
inline void OLAPIndexHeaderMessage::_internal_set_index_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OLAPIndexHeaderMessage::_internal_mutable_index_name() {
  _has_bits_[0] |= 0x00000004u;
  return index_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OLAPIndexHeaderMessage::release_index_name() {
  // @@protoc_insertion_point(field_release:baikaldb.pb.OLAPIndexHeaderMessage.index_name)
  if (!_internal_has_index_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return index_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OLAPIndexHeaderMessage::set_allocated_index_name(std::string* index_name) {
  if (index_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  index_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:baikaldb.pb.OLAPIndexHeaderMessage.index_name)
}

// required int32 schema_hash = 4;
inline bool OLAPIndexHeaderMessage::_internal_has_schema_hash() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OLAPIndexHeaderMessage::has_schema_hash() const {
  return _internal_has_schema_hash();
}
inline void OLAPIndexHeaderMessage::clear_schema_hash() {
  schema_hash_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OLAPIndexHeaderMessage::_internal_schema_hash() const {
  return schema_hash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OLAPIndexHeaderMessage::schema_hash() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPIndexHeaderMessage.schema_hash)
  return _internal_schema_hash();
}
inline void OLAPIndexHeaderMessage::_internal_set_schema_hash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  schema_hash_ = value;
}
inline void OLAPIndexHeaderMessage::set_schema_hash(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_schema_hash(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPIndexHeaderMessage.schema_hash)
}

// required int32 start_version = 5;
inline bool OLAPIndexHeaderMessage::_internal_has_start_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool OLAPIndexHeaderMessage::has_start_version() const {
  return _internal_has_start_version();
}
inline void OLAPIndexHeaderMessage::clear_start_version() {
  start_version_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OLAPIndexHeaderMessage::_internal_start_version() const {
  return start_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OLAPIndexHeaderMessage::start_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPIndexHeaderMessage.start_version)
  return _internal_start_version();
}
inline void OLAPIndexHeaderMessage::_internal_set_start_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  start_version_ = value;
}
inline void OLAPIndexHeaderMessage::set_start_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_start_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPIndexHeaderMessage.start_version)
}

// required int32 end_version = 6;
inline bool OLAPIndexHeaderMessage::_internal_has_end_version() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool OLAPIndexHeaderMessage::has_end_version() const {
  return _internal_has_end_version();
}
inline void OLAPIndexHeaderMessage::clear_end_version() {
  end_version_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OLAPIndexHeaderMessage::_internal_end_version() const {
  return end_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OLAPIndexHeaderMessage::end_version() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPIndexHeaderMessage.end_version)
  return _internal_end_version();
}
inline void OLAPIndexHeaderMessage::_internal_set_end_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  end_version_ = value;
}
inline void OLAPIndexHeaderMessage::set_end_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_end_version(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPIndexHeaderMessage.end_version)
}

// required int64 cumulative_version_hash = 7;
inline bool OLAPIndexHeaderMessage::_internal_has_cumulative_version_hash() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool OLAPIndexHeaderMessage::has_cumulative_version_hash() const {
  return _internal_has_cumulative_version_hash();
}
inline void OLAPIndexHeaderMessage::clear_cumulative_version_hash() {
  cumulative_version_hash_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OLAPIndexHeaderMessage::_internal_cumulative_version_hash() const {
  return cumulative_version_hash_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OLAPIndexHeaderMessage::cumulative_version_hash() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPIndexHeaderMessage.cumulative_version_hash)
  return _internal_cumulative_version_hash();
}
inline void OLAPIndexHeaderMessage::_internal_set_cumulative_version_hash(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  cumulative_version_hash_ = value;
}
inline void OLAPIndexHeaderMessage::set_cumulative_version_hash(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_cumulative_version_hash(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPIndexHeaderMessage.cumulative_version_hash)
}

// required uint32 segment = 8;
inline bool OLAPIndexHeaderMessage::_internal_has_segment() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool OLAPIndexHeaderMessage::has_segment() const {
  return _internal_has_segment();
}
inline void OLAPIndexHeaderMessage::clear_segment() {
  segment_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OLAPIndexHeaderMessage::_internal_segment() const {
  return segment_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OLAPIndexHeaderMessage::segment() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPIndexHeaderMessage.segment)
  return _internal_segment();
}
inline void OLAPIndexHeaderMessage::_internal_set_segment(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  segment_ = value;
}
inline void OLAPIndexHeaderMessage::set_segment(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_segment(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPIndexHeaderMessage.segment)
}

// required uint32 num_rows_per_block = 9;
inline bool OLAPIndexHeaderMessage::_internal_has_num_rows_per_block() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool OLAPIndexHeaderMessage::has_num_rows_per_block() const {
  return _internal_has_num_rows_per_block();
}
inline void OLAPIndexHeaderMessage::clear_num_rows_per_block() {
  num_rows_per_block_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OLAPIndexHeaderMessage::_internal_num_rows_per_block() const {
  return num_rows_per_block_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OLAPIndexHeaderMessage::num_rows_per_block() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPIndexHeaderMessage.num_rows_per_block)
  return _internal_num_rows_per_block();
}
inline void OLAPIndexHeaderMessage::_internal_set_num_rows_per_block(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  num_rows_per_block_ = value;
}
inline void OLAPIndexHeaderMessage::set_num_rows_per_block(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num_rows_per_block(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPIndexHeaderMessage.num_rows_per_block)
}

// optional uint32 data_file_size = 10;
inline bool OLAPIndexHeaderMessage::_internal_has_data_file_size() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool OLAPIndexHeaderMessage::has_data_file_size() const {
  return _internal_has_data_file_size();
}
inline void OLAPIndexHeaderMessage::clear_data_file_size() {
  data_file_size_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OLAPIndexHeaderMessage::_internal_data_file_size() const {
  return data_file_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OLAPIndexHeaderMessage::data_file_size() const {
  // @@protoc_insertion_point(field_get:baikaldb.pb.OLAPIndexHeaderMessage.data_file_size)
  return _internal_data_file_size();
}
inline void OLAPIndexHeaderMessage::_internal_set_data_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  data_file_size_ = value;
}
inline void OLAPIndexHeaderMessage::set_data_file_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_data_file_size(value);
  // @@protoc_insertion_point(field_set:baikaldb.pb.OLAPIndexHeaderMessage.data_file_size)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace baikaldb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::baikaldb::pb::OlapPrimitiveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::baikaldb::pb::OlapPrimitiveType>() {
  return ::baikaldb::pb::OlapPrimitiveType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_olap_2eproto
