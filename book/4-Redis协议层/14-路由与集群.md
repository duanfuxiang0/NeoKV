# 路由与集群

## 概览

- CRC16 与 Slot 计算：兼容 Redis Cluster 的哈希方案
- Hash Tag：让多 key 命令成为可能
- SlotTable：O(1) 的 slot 到 Region 映射
- RedisKeyPattern：命令参数中 key 的位置定义
- CROSSSLOT 校验与 MOVED 重定向
- CLUSTER 命令：SLOTS / NODES / INFO / KEYSLOT / MYID

上一章我们看到，每个读写命令的第一步都是 `check_route()`——根据 key 找到对应的 Region。这一章深入路由机制的内部实现：slot 是怎么算的？key 是怎么从命令参数中提取的？SlotTable 是怎么做到 O(1) 查找的？以及 NeoKV 如何通过实现 CLUSTER 命令让标准 Redis 客户端（Jedis、redis-py、go-redis）直接连接。

## CRC16 与 16384 个 Slot

NeoKV 完整兼容 Redis Cluster 的哈希方案——16384 个 slot，CRC16-CCITT 算法，`slot = crc16(key) & 0x3FFF`。

`redis_crc16()` 的实现（`src/redis/redis_service.cpp`）使用 CRC16-CCITT 多项式 0x1021，初始值 0，逐字节计算。这与 Redis 源码中的实现完全一致——同一个 key，在 Redis 和 NeoKV 中计算出的 slot 号相同。这个一致性是兼容 Redis Cluster 客户端的基础。

`redis_slot()` 在计算 CRC16 之前，先调用 `extract_hash_tag()` 处理 Hash Tag。如果 key 中没有 `{...}` 语法，就用整个 key 计算 slot；如果有，只用花括号内的部分。

## Hash Tag：多 key 命令的前提

在分布式 KV 系统中，每个 key 只属于一个 slot，每个 slot 只属于一个 Region。这意味着像 `MSET name Alice age 30` 这样的多 key 命令，如果 `name` 和 `age` 落在不同的 slot，就无法在一次操作中完成——因为它们可能分布在不同的 Region，甚至不同的物理节点。

Redis Cluster 通过 Hash Tag 解决这个问题。规则很简单：如果 key 中包含 `{tag}`（第一个 `{` 和第一个非空 `}`），就只用 tag 部分计算 slot。

```cpp
std::string extract_hash_tag(const std::string& key) {
    auto left = key.find('{');
    if (left == std::string::npos) return key;
    auto right = key.find('}', left + 1);
    if (right != std::string::npos && right > left + 1)
        return key.substr(left + 1, right - left - 1);
    return key;
}
```

于是 `{user}:name`、`{user}:age`、`{user}:email` 都只用 `"user"` 计算 slot，保证它们落在同一个 slot。`MSET {user}:name Alice {user}:age 30` 就可以正常工作了。

这段提取逻辑有两个边界情况值得注意。如果 key 中有 `{` 但没有 `}`，视为没有 Hash Tag，用整个 key。如果花括号内为空（`{}`），同样视为没有 Hash Tag。这与 Redis 的行为完全一致。

NeoKV 中 `extract_hash_tag()` 出现在两个位置——`redis_service.cpp` 中作为独立函数，`RedisRouter` 中作为静态方法——实现逻辑相同。

## SlotTable：O(1) 的路由查找

路由的核心数据结构是 `SlotTable`（`include/redis/redis_router.h`）——一个 16384 项的定长数组。每个 slot 对应一个 `Entry`，包含 Region 的智能指针和 region_id：

```cpp
struct SlotTable {
    struct Entry {
        SmartRegion region;
        int64_t region_id = 0;
    };
    std::array<Entry, 16384> slots {};
};
```

查找过程是纯数组下标访问：计算 slot → `table->slots[slot]` → 返回 Region。O(1)，无锁。

但"无锁"需要一些解释。`SlotTable` 本身是不可变的（immutable）——一旦创建，就不会被修改。当 Region 发生变更（Split、Merge、新增、删除）时，`rebuild_slot_table()` 创建一个全新的 `SlotTable`，然后通过 `std::mutex` 保护的 `shared_ptr` 替换旧的。读路径通过在锁保护下拷贝 `shared_ptr`（而不是在锁内执行整个查找），让锁的持有时间降到最低。

```cpp
SmartRegion RedisRouter::find_region_by_slot(uint16_t slot, int64_t* out_region_id) {
    SlotTablePtr table;
    {
        std::lock_guard<std::mutex> lock(_slot_table_mutex);
        table = _slot_table;  // shared_ptr 拷贝，纳秒级
    }
    // 后续的数组访问在锁外完成
    if (table && slot < SLOT_TABLE_SIZE) {
        const auto& entry = table->slots[slot];
        if (entry.region != nullptr) {
            // 验证 Region 仍然有效
            auto current = Store::get_instance()->get_region(entry.region_id);
            if (current != nullptr && current == entry.region) {
                return entry.region;
            }
        }
    }
    return find_region_by_slot_slow(slot, out_region_id);
}
```

注意快速路径中还有一个**有效性验证**——从 SlotTable 拿到 Region 后，再去 Store 的 region map 中确认这个 Region 还存在。这是为了处理 SlotTable 刚被创建但 Region 已被删除的竞态。如果验证失败，走慢路径 `find_region_by_slot_slow()`，它会线性扫描所有 Region 找到覆盖该 slot 的那个，同时触发 SlotTable 重建。

**`rebuild_slot_table()`** 遍历 Store 中所有 Region，从 RegionInfo 的 start_key/end_key 解码出 slot 范围，填充新 table 的对应条目。它还有一个过滤条件：如果 `_redis_table_id > 0`，只处理匹配该 table_id 的 Region——这确保 Redis 路由不会被其他类型的 Region（比如 SQL 表的 Region）干扰。

SlotTable 的重建时机包括：Store 启动加载 Region 后、`Store::set_region()` 或 `Store::erase_region()` 时（Region 新增/删除/Split）、以及慢路径查找时自动触发。

## RedisKeyPattern：知道每个命令的 key 在哪

不同的 Redis 命令，key 参数的位置不同。GET 的 key 在 `args[1]`，MSET 的 key 在 `args[1]`、`args[3]`、`args[5]`...（步长 2，因为 key 和 value 交替），SINTER 的 key 从 `args[1]` 到末尾。路由需要从命令参数中提取所有 key 来计算 slot，所以必须知道每个命令的 key 位置规则。

NeoKV 通过 `RedisKeyPattern` 结构体（`include/redis/redis_router.h`）描述这个规则：

```cpp
struct RedisKeyPattern {
    int first_key_index;  // 第一个 key 的位置（1-based，0 表示无 key）
    int last_key_index;   // 最后一个 key 的位置（-1 表示到末尾）
    int key_step;         // key 之间的步长
};
```

`kKeyPatterns`（`src/redis/redis_router.cpp`）是一个 `std::unordered_map`，为每个命令定义 pattern。单 key 命令如 `get`/`set`/`hset`/`zadd` 的 pattern 都是 `{1, 1, 1}`——key 在 args[1]，只有一个。多 key 命令如 `mget`/`del`/`sinter` 是 `{1, -1, 1}`——从 args[1] 到末尾，步长 1。MSET 特殊，pattern 是 `{1, -1, 2}`——步长为 2，因为参数是 `key1 val1 key2 val2...` 交替排列。`smove` 的 pattern 是 `{1, 2, 1}`——两个 key 分别在 args[1] 和 args[2]。无 key 命令如 `ping`/`echo`/`cluster` 的 pattern 是 `{0, 0, 0}`。

`extract_keys()` 根据 pattern 从命令参数中提取所有 key：找到命令对应的 pattern，将 `last_key_index` 的 -1 解析为实际的最后一个参数位置，然后按步长遍历。提取出的 key 列表传给 `check_same_slot()` 做 CROSSSLOT 校验。

## CROSSSLOT 校验

`check_same_slot()` 的逻辑很直接：计算第一个 key 的 slot，然后逐个检查后续 key 的 slot 是否相同。如果不同，返回 -1 表示 CROSSSLOT。

```cpp
int32_t RedisRouter::check_same_slot(const std::vector<std::string>& keys) {
    if (keys.empty()) return 0;
    uint16_t first_slot = calc_slot(keys[0]);
    for (size_t i = 1; i < keys.size(); ++i) {
        if (calc_slot(keys[i]) != first_slot) {
            return -1;
        }
    }
    return static_cast<int32_t>(first_slot);
}
```

CROSSSLOT 错误在 `RedisRouter::route()` 中被检测到，错误消息是标准的 `"CROSSSLOT Keys in request don't hash to the same slot"`——与 Redis Cluster 完全一致。Redis 客户端库通常会识别这个错误并提示用户使用 Hash Tag。

## MOVED 重定向

当写命令到达非 Leader 节点，或读命令到达非 Leader 节点且未启用 ReadIndex 时，NeoKV 返回 MOVED 重定向。MOVED 响应格式为 `-MOVED <slot> <leader_ip>:<leader_redis_port>`，与 Redis Cluster 协议完全兼容。

```cpp
static void set_moved_error(uint16_t slot, const std::string& leader_store_addr,
                            brpc::RedisReply* output) {
    std::string leader_redis_addr = store_addr_to_redis_addr(leader_store_addr);
    std::string moved = "MOVED " + std::to_string(slot) + " " + leader_redis_addr;
    output->SetError(moved.c_str());
}
```

这里有一个地址转换的细节。NeoKV 内部使用的是 Store 的 Raft 地址（`ip:raft_port`），但 MOVED 需要返回 Redis 端口。`store_addr_to_redis_addr()` 从 Store 地址提取 IP，然后拼接 `FLAGS_redis_advertise_port`（或 `FLAGS_redis_port`）。如果配置了 `redis_advertise_ip`，则使用配置的地址——这在 NAT 或容器环境中很重要，因为内部 IP 和外部可达 IP 可能不同。

MOVED 重定向是 Redis Cluster 客户端的核心机制。当客户端收到 MOVED 响应后，会更新本地的 slot 映射缓存，后续请求直接发到正确的节点。NeoKV 通过兼容这个协议，让 Jedis、redis-py、go-redis 等标准 Redis Cluster 客户端可以直接连接，不需要任何适配。

## CLUSTER 命令

为了让 Redis Cluster 客户端能完成初始化和拓扑发现，NeoKV 实现了 CLUSTER 命令的核心子命令（`ClusterCommandHandler`，`src/redis/redis_service.cpp`）。

**CLUSTER KEYSLOT** 最简单——直接调用 `redis_slot(key)` 返回 slot 号。它主要用于调试，让用户确认某个 key 会落在哪个 slot。

**CLUSTER INFO** 返回集群状态的多行字符串。NeoKV 收集所有 Region 的 slot 分配信息，判断是否 16384 个 slot 全部被覆盖（`cluster_state: ok` 或 `fail`），统计已分配的 slot 数、已知节点数和 Leader 数。格式与 Redis Cluster 完全一致。

**CLUSTER SLOTS** 返回 slot 范围到节点的映射。NeoKV 遍历所有 Region，将连续的 slot 范围合并，为每个范围返回 Leader 和 Replica 的地址信息。输出是 Redis 的嵌套数组格式：`[[start_slot, end_slot, [leader_ip, leader_port, node_id], [replica_ip, replica_port, node_id], ...], ...]`。这是大多数 Redis Cluster 客户端在初始化时调用的第一个命令。

**CLUSTER NODES** 返回 Redis Cluster 格式的节点列表。每一行包含 node_id、地址、角色（master/slave）、slot 范围等。格式如 `node-id 10.0.0.1:16379@26379 myself,master - 0 0 1 connected 0-5460`。

**CLUSTER MYID** 返回当前节点的 ID。NeoKV 没有使用随机 UUID 作为 node_id（Redis 那样做），而是基于节点的 Redis advertise address 做哈希生成一个 40 字符的十六进制字符串。这意味着同一个节点重启后 node_id 不变——只要地址不变。

```cpp
std::string generate_node_id_for_addr(const std::string& addr) {
    uint64_t hash = std::hash<std::string>{}(addr);
    char buf[41];
    snprintf(buf, sizeof(buf), "%016lx%016lx%08x",
             static_cast<unsigned long>(hash),
             static_cast<unsigned long>(hash ^ 0xDEADBEEFCAFEBABEULL),
             static_cast<uint32_t>(hash >> 32));
    return std::string(buf, 40);
}
```

这个 node_id 生成方式的优势是确定性——不需要持久化 node_id，重启后自动恢复。劣势是如果节点的 IP 或端口变了，node_id 也会变。对于 NeoKV 的使用场景（固定部署拓扑），这不是问题。

## 检验你的理解

- Hash Tag `{tag}` 让多 key 命令成为可能。但如果所有 key 都使用相同的 Hash Tag（比如 `{app}:*`），会有什么问题？
- SlotTable 在快速路径中还验证了 Region 的有效性。如果跳过这个验证，在什么场景下会出错？
- `RedisKeyPattern` 中 MSET 的步长是 2。如果某个新命令的参数格式是 `CMD key1 key2 value`（两个 key 后跟一个 value），pattern 应该怎么写？
- MOVED 重定向依赖 Leader 地址的准确性。如果 Leader 刚切换，旧 Leader 可能返回指向自己的 MOVED。客户端会怎么处理这种情况？
- NeoKV 的 node_id 基于地址哈希生成。如果两个节点的地址恰好哈希冲突（概率极低但非零），Redis 客户端会有什么行为异常？

---

> 下一章：[15-过期与 TTL](./15-过期与TTL.md) — 我们将了解 NeoKV 的两层过期机制：被动过期如何保证读取正确性，主动清理如何回收空间，以及为什么 TTL Cleaner 可以安全地绕过 Raft。
